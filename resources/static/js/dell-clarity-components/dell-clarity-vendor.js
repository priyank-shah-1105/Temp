/*
 *  Â© 2017 Dell Inc.
 *  ALL RIGHTS RESERVED.
 *  dell-clarity-components 1.0.0
 */
(function(global, factory) {
    if (typeof module === "object" && typeof module.exports === "object") {
        module.exports = global.document ? factory(global, true) : function(w) {
            if (!w.document) {
                throw new Error("jQuery requires a window with a document");
            }
            return factory(w);
        };
    } else {
        factory(global);
    }
})(typeof window !== "undefined" ? window : this, function(window, noGlobal) {
    var arr = [];
    var document = window.document;
    var slice = arr.slice;
    var concat = arr.concat;
    var push = arr.push;
    var indexOf = arr.indexOf;
    var class2type = {};
    var toString = class2type.toString;
    var hasOwn = class2type.hasOwnProperty;
    var support = {};
    var version = "2.2.4", jQuery = function(selector, context) {
        return new jQuery.fn.init(selector, context);
    }, rtrim = /^[\s\uFEFF\xA0]+|[\s\uFEFF\xA0]+$/g, rmsPrefix = /^-ms-/, rdashAlpha = /-([\da-z])/gi, fcamelCase = function(all, letter) {
        return letter.toUpperCase();
    };
    jQuery.fn = jQuery.prototype = {
        jquery: version,
        constructor: jQuery,
        selector: "",
        length: 0,
        toArray: function() {
            return slice.call(this);
        },
        get: function(num) {
            return num != null ? num < 0 ? this[num + this.length] : this[num] : slice.call(this);
        },
        pushStack: function(elems) {
            var ret = jQuery.merge(this.constructor(), elems);
            ret.prevObject = this;
            ret.context = this.context;
            return ret;
        },
        each: function(callback) {
            return jQuery.each(this, callback);
        },
        map: function(callback) {
            return this.pushStack(jQuery.map(this, function(elem, i) {
                return callback.call(elem, i, elem);
            }));
        },
        slice: function() {
            return this.pushStack(slice.apply(this, arguments));
        },
        first: function() {
            return this.eq(0);
        },
        last: function() {
            return this.eq(-1);
        },
        eq: function(i) {
            var len = this.length, j = +i + (i < 0 ? len : 0);
            return this.pushStack(j >= 0 && j < len ? [ this[j] ] : []);
        },
        end: function() {
            return this.prevObject || this.constructor();
        },
        push: push,
        sort: arr.sort,
        splice: arr.splice
    };
    jQuery.extend = jQuery.fn.extend = function() {
        var options, name, src, copy, copyIsArray, clone, target = arguments[0] || {}, i = 1, length = arguments.length, deep = false;
        if (typeof target === "boolean") {
            deep = target;
            target = arguments[i] || {};
            i++;
        }
        if (typeof target !== "object" && !jQuery.isFunction(target)) {
            target = {};
        }
        if (i === length) {
            target = this;
            i--;
        }
        for (;i < length; i++) {
            if ((options = arguments[i]) != null) {
                for (name in options) {
                    src = target[name];
                    copy = options[name];
                    if (target === copy) {
                        continue;
                    }
                    if (deep && copy && (jQuery.isPlainObject(copy) || (copyIsArray = jQuery.isArray(copy)))) {
                        if (copyIsArray) {
                            copyIsArray = false;
                            clone = src && jQuery.isArray(src) ? src : [];
                        } else {
                            clone = src && jQuery.isPlainObject(src) ? src : {};
                        }
                        target[name] = jQuery.extend(deep, clone, copy);
                    } else if (copy !== undefined) {
                        target[name] = copy;
                    }
                }
            }
        }
        return target;
    };
    jQuery.extend({
        expando: "jQuery" + (version + Math.random()).replace(/\D/g, ""),
        isReady: true,
        error: function(msg) {
            throw new Error(msg);
        },
        noop: function() {},
        isFunction: function(obj) {
            return jQuery.type(obj) === "function";
        },
        isArray: Array.isArray,
        isWindow: function(obj) {
            return obj != null && obj === obj.window;
        },
        isNumeric: function(obj) {
            var realStringObj = obj && obj.toString();
            return !jQuery.isArray(obj) && realStringObj - parseFloat(realStringObj) + 1 >= 0;
        },
        isPlainObject: function(obj) {
            var key;
            if (jQuery.type(obj) !== "object" || obj.nodeType || jQuery.isWindow(obj)) {
                return false;
            }
            if (obj.constructor && !hasOwn.call(obj, "constructor") && !hasOwn.call(obj.constructor.prototype || {}, "isPrototypeOf")) {
                return false;
            }
            for (key in obj) {}
            return key === undefined || hasOwn.call(obj, key);
        },
        isEmptyObject: function(obj) {
            var name;
            for (name in obj) {
                return false;
            }
            return true;
        },
        type: function(obj) {
            if (obj == null) {
                return obj + "";
            }
            return typeof obj === "object" || typeof obj === "function" ? class2type[toString.call(obj)] || "object" : typeof obj;
        },
        globalEval: function(code) {
            var script, indirect = eval;
            code = jQuery.trim(code);
            if (code) {
                if (code.indexOf("use strict") === 1) {
                    script = document.createElement("script");
                    script.text = code;
                    document.head.appendChild(script).parentNode.removeChild(script);
                } else {
                    indirect(code);
                }
            }
        },
        camelCase: function(string) {
            return string.replace(rmsPrefix, "ms-").replace(rdashAlpha, fcamelCase);
        },
        nodeName: function(elem, name) {
            return elem.nodeName && elem.nodeName.toLowerCase() === name.toLowerCase();
        },
        each: function(obj, callback) {
            var length, i = 0;
            if (isArrayLike(obj)) {
                length = obj.length;
                for (;i < length; i++) {
                    if (callback.call(obj[i], i, obj[i]) === false) {
                        break;
                    }
                }
            } else {
                for (i in obj) {
                    if (callback.call(obj[i], i, obj[i]) === false) {
                        break;
                    }
                }
            }
            return obj;
        },
        trim: function(text) {
            return text == null ? "" : (text + "").replace(rtrim, "");
        },
        makeArray: function(arr, results) {
            var ret = results || [];
            if (arr != null) {
                if (isArrayLike(Object(arr))) {
                    jQuery.merge(ret, typeof arr === "string" ? [ arr ] : arr);
                } else {
                    push.call(ret, arr);
                }
            }
            return ret;
        },
        inArray: function(elem, arr, i) {
            return arr == null ? -1 : indexOf.call(arr, elem, i);
        },
        merge: function(first, second) {
            var len = +second.length, j = 0, i = first.length;
            for (;j < len; j++) {
                first[i++] = second[j];
            }
            first.length = i;
            return first;
        },
        grep: function(elems, callback, invert) {
            var callbackInverse, matches = [], i = 0, length = elems.length, callbackExpect = !invert;
            for (;i < length; i++) {
                callbackInverse = !callback(elems[i], i);
                if (callbackInverse !== callbackExpect) {
                    matches.push(elems[i]);
                }
            }
            return matches;
        },
        map: function(elems, callback, arg) {
            var length, value, i = 0, ret = [];
            if (isArrayLike(elems)) {
                length = elems.length;
                for (;i < length; i++) {
                    value = callback(elems[i], i, arg);
                    if (value != null) {
                        ret.push(value);
                    }
                }
            } else {
                for (i in elems) {
                    value = callback(elems[i], i, arg);
                    if (value != null) {
                        ret.push(value);
                    }
                }
            }
            return concat.apply([], ret);
        },
        guid: 1,
        proxy: function(fn, context) {
            var tmp, args, proxy;
            if (typeof context === "string") {
                tmp = fn[context];
                context = fn;
                fn = tmp;
            }
            if (!jQuery.isFunction(fn)) {
                return undefined;
            }
            args = slice.call(arguments, 2);
            proxy = function() {
                return fn.apply(context || this, args.concat(slice.call(arguments)));
            };
            proxy.guid = fn.guid = fn.guid || jQuery.guid++;
            return proxy;
        },
        now: Date.now,
        support: support
    });
    if (typeof Symbol === "function") {
        jQuery.fn[Symbol.iterator] = arr[Symbol.iterator];
    }
    jQuery.each("Boolean Number String Function Array Date RegExp Object Error Symbol".split(" "), function(i, name) {
        class2type["[object " + name + "]"] = name.toLowerCase();
    });
    function isArrayLike(obj) {
        var length = !!obj && "length" in obj && obj.length, type = jQuery.type(obj);
        if (type === "function" || jQuery.isWindow(obj)) {
            return false;
        }
        return type === "array" || length === 0 || typeof length === "number" && length > 0 && length - 1 in obj;
    }
    var Sizzle = function(window) {
        var i, support, Expr, getText, isXML, tokenize, compile, select, outermostContext, sortInput, hasDuplicate, setDocument, document, docElem, documentIsHTML, rbuggyQSA, rbuggyMatches, matches, contains, expando = "sizzle" + 1 * new Date(), preferredDoc = window.document, dirruns = 0, done = 0, classCache = createCache(), tokenCache = createCache(), compilerCache = createCache(), sortOrder = function(a, b) {
            if (a === b) {
                hasDuplicate = true;
            }
            return 0;
        }, MAX_NEGATIVE = 1 << 31, hasOwn = {}.hasOwnProperty, arr = [], pop = arr.pop, push_native = arr.push, push = arr.push, slice = arr.slice, indexOf = function(list, elem) {
            var i = 0, len = list.length;
            for (;i < len; i++) {
                if (list[i] === elem) {
                    return i;
                }
            }
            return -1;
        }, booleans = "checked|selected|async|autofocus|autoplay|controls|defer|disabled|hidden|ismap|loop|multiple|open|readonly|required|scoped", whitespace = "[\\x20\\t\\r\\n\\f]", identifier = "(?:\\\\.|[\\w-]|[^\\x00-\\xa0])+", attributes = "\\[" + whitespace + "*(" + identifier + ")(?:" + whitespace + "*([*^$|!~]?=)" + whitespace + "*(?:'((?:\\\\.|[^\\\\'])*)'|\"((?:\\\\.|[^\\\\\"])*)\"|(" + identifier + "))|)" + whitespace + "*\\]", pseudos = ":(" + identifier + ")(?:\\((" + "('((?:\\\\.|[^\\\\'])*)'|\"((?:\\\\.|[^\\\\\"])*)\")|" + "((?:\\\\.|[^\\\\()[\\]]|" + attributes + ")*)|" + ".*" + ")\\)|)", rwhitespace = new RegExp(whitespace + "+", "g"), rtrim = new RegExp("^" + whitespace + "+|((?:^|[^\\\\])(?:\\\\.)*)" + whitespace + "+$", "g"), rcomma = new RegExp("^" + whitespace + "*," + whitespace + "*"), rcombinators = new RegExp("^" + whitespace + "*([>+~]|" + whitespace + ")" + whitespace + "*"), rattributeQuotes = new RegExp("=" + whitespace + "*([^\\]'\"]*?)" + whitespace + "*\\]", "g"), rpseudo = new RegExp(pseudos), ridentifier = new RegExp("^" + identifier + "$"), matchExpr = {
            ID: new RegExp("^#(" + identifier + ")"),
            CLASS: new RegExp("^\\.(" + identifier + ")"),
            TAG: new RegExp("^(" + identifier + "|[*])"),
            ATTR: new RegExp("^" + attributes),
            PSEUDO: new RegExp("^" + pseudos),
            CHILD: new RegExp("^:(only|first|last|nth|nth-last)-(child|of-type)(?:\\(" + whitespace + "*(even|odd|(([+-]|)(\\d*)n|)" + whitespace + "*(?:([+-]|)" + whitespace + "*(\\d+)|))" + whitespace + "*\\)|)", "i"),
            bool: new RegExp("^(?:" + booleans + ")$", "i"),
            needsContext: new RegExp("^" + whitespace + "*[>+~]|:(even|odd|eq|gt|lt|nth|first|last)(?:\\(" + whitespace + "*((?:-\\d)?\\d*)" + whitespace + "*\\)|)(?=[^-]|$)", "i")
        }, rinputs = /^(?:input|select|textarea|button)$/i, rheader = /^h\d$/i, rnative = /^[^{]+\{\s*\[native \w/, rquickExpr = /^(?:#([\w-]+)|(\w+)|\.([\w-]+))$/, rsibling = /[+~]/, rescape = /'|\\/g, runescape = new RegExp("\\\\([\\da-f]{1,6}" + whitespace + "?|(" + whitespace + ")|.)", "ig"), funescape = function(_, escaped, escapedWhitespace) {
            var high = "0x" + escaped - 65536;
            return high !== high || escapedWhitespace ? escaped : high < 0 ? String.fromCharCode(high + 65536) : String.fromCharCode(high >> 10 | 55296, high & 1023 | 56320);
        }, unloadHandler = function() {
            setDocument();
        };
        try {
            push.apply(arr = slice.call(preferredDoc.childNodes), preferredDoc.childNodes);
            arr[preferredDoc.childNodes.length].nodeType;
        } catch (e) {
            push = {
                apply: arr.length ? function(target, els) {
                    push_native.apply(target, slice.call(els));
                } : function(target, els) {
                    var j = target.length, i = 0;
                    while (target[j++] = els[i++]) {}
                    target.length = j - 1;
                }
            };
        }
        function Sizzle(selector, context, results, seed) {
            var m, i, elem, nid, nidselect, match, groups, newSelector, newContext = context && context.ownerDocument, nodeType = context ? context.nodeType : 9;
            results = results || [];
            if (typeof selector !== "string" || !selector || nodeType !== 1 && nodeType !== 9 && nodeType !== 11) {
                return results;
            }
            if (!seed) {
                if ((context ? context.ownerDocument || context : preferredDoc) !== document) {
                    setDocument(context);
                }
                context = context || document;
                if (documentIsHTML) {
                    if (nodeType !== 11 && (match = rquickExpr.exec(selector))) {
                        if (m = match[1]) {
                            if (nodeType === 9) {
                                if (elem = context.getElementById(m)) {
                                    if (elem.id === m) {
                                        results.push(elem);
                                        return results;
                                    }
                                } else {
                                    return results;
                                }
                            } else {
                                if (newContext && (elem = newContext.getElementById(m)) && contains(context, elem) && elem.id === m) {
                                    results.push(elem);
                                    return results;
                                }
                            }
                        } else if (match[2]) {
                            push.apply(results, context.getElementsByTagName(selector));
                            return results;
                        } else if ((m = match[3]) && support.getElementsByClassName && context.getElementsByClassName) {
                            push.apply(results, context.getElementsByClassName(m));
                            return results;
                        }
                    }
                    if (support.qsa && !compilerCache[selector + " "] && (!rbuggyQSA || !rbuggyQSA.test(selector))) {
                        if (nodeType !== 1) {
                            newContext = context;
                            newSelector = selector;
                        } else if (context.nodeName.toLowerCase() !== "object") {
                            if (nid = context.getAttribute("id")) {
                                nid = nid.replace(rescape, "\\$&");
                            } else {
                                context.setAttribute("id", nid = expando);
                            }
                            groups = tokenize(selector);
                            i = groups.length;
                            nidselect = ridentifier.test(nid) ? "#" + nid : "[id='" + nid + "']";
                            while (i--) {
                                groups[i] = nidselect + " " + toSelector(groups[i]);
                            }
                            newSelector = groups.join(",");
                            newContext = rsibling.test(selector) && testContext(context.parentNode) || context;
                        }
                        if (newSelector) {
                            try {
                                push.apply(results, newContext.querySelectorAll(newSelector));
                                return results;
                            } catch (qsaError) {} finally {
                                if (nid === expando) {
                                    context.removeAttribute("id");
                                }
                            }
                        }
                    }
                }
            }
            return select(selector.replace(rtrim, "$1"), context, results, seed);
        }
        function createCache() {
            var keys = [];
            function cache(key, value) {
                if (keys.push(key + " ") > Expr.cacheLength) {
                    delete cache[keys.shift()];
                }
                return cache[key + " "] = value;
            }
            return cache;
        }
        function markFunction(fn) {
            fn[expando] = true;
            return fn;
        }
        function assert(fn) {
            var div = document.createElement("div");
            try {
                return !!fn(div);
            } catch (e) {
                return false;
            } finally {
                if (div.parentNode) {
                    div.parentNode.removeChild(div);
                }
                div = null;
            }
        }
        function addHandle(attrs, handler) {
            var arr = attrs.split("|"), i = arr.length;
            while (i--) {
                Expr.attrHandle[arr[i]] = handler;
            }
        }
        function siblingCheck(a, b) {
            var cur = b && a, diff = cur && a.nodeType === 1 && b.nodeType === 1 && (~b.sourceIndex || MAX_NEGATIVE) - (~a.sourceIndex || MAX_NEGATIVE);
            if (diff) {
                return diff;
            }
            if (cur) {
                while (cur = cur.nextSibling) {
                    if (cur === b) {
                        return -1;
                    }
                }
            }
            return a ? 1 : -1;
        }
        function createInputPseudo(type) {
            return function(elem) {
                var name = elem.nodeName.toLowerCase();
                return name === "input" && elem.type === type;
            };
        }
        function createButtonPseudo(type) {
            return function(elem) {
                var name = elem.nodeName.toLowerCase();
                return (name === "input" || name === "button") && elem.type === type;
            };
        }
        function createPositionalPseudo(fn) {
            return markFunction(function(argument) {
                argument = +argument;
                return markFunction(function(seed, matches) {
                    var j, matchIndexes = fn([], seed.length, argument), i = matchIndexes.length;
                    while (i--) {
                        if (seed[j = matchIndexes[i]]) {
                            seed[j] = !(matches[j] = seed[j]);
                        }
                    }
                });
            });
        }
        function testContext(context) {
            return context && typeof context.getElementsByTagName !== "undefined" && context;
        }
        support = Sizzle.support = {};
        isXML = Sizzle.isXML = function(elem) {
            var documentElement = elem && (elem.ownerDocument || elem).documentElement;
            return documentElement ? documentElement.nodeName !== "HTML" : false;
        };
        setDocument = Sizzle.setDocument = function(node) {
            var hasCompare, parent, doc = node ? node.ownerDocument || node : preferredDoc;
            if (doc === document || doc.nodeType !== 9 || !doc.documentElement) {
                return document;
            }
            document = doc;
            docElem = document.documentElement;
            documentIsHTML = !isXML(document);
            if ((parent = document.defaultView) && parent.top !== parent) {
                if (parent.addEventListener) {
                    parent.addEventListener("unload", unloadHandler, false);
                } else if (parent.attachEvent) {
                    parent.attachEvent("onunload", unloadHandler);
                }
            }
            support.attributes = assert(function(div) {
                div.className = "i";
                return !div.getAttribute("className");
            });
            support.getElementsByTagName = assert(function(div) {
                div.appendChild(document.createComment(""));
                return !div.getElementsByTagName("*").length;
            });
            support.getElementsByClassName = rnative.test(document.getElementsByClassName);
            support.getById = assert(function(div) {
                docElem.appendChild(div).id = expando;
                return !document.getElementsByName || !document.getElementsByName(expando).length;
            });
            if (support.getById) {
                Expr.find["ID"] = function(id, context) {
                    if (typeof context.getElementById !== "undefined" && documentIsHTML) {
                        var m = context.getElementById(id);
                        return m ? [ m ] : [];
                    }
                };
                Expr.filter["ID"] = function(id) {
                    var attrId = id.replace(runescape, funescape);
                    return function(elem) {
                        return elem.getAttribute("id") === attrId;
                    };
                };
            } else {
                delete Expr.find["ID"];
                Expr.filter["ID"] = function(id) {
                    var attrId = id.replace(runescape, funescape);
                    return function(elem) {
                        var node = typeof elem.getAttributeNode !== "undefined" && elem.getAttributeNode("id");
                        return node && node.value === attrId;
                    };
                };
            }
            Expr.find["TAG"] = support.getElementsByTagName ? function(tag, context) {
                if (typeof context.getElementsByTagName !== "undefined") {
                    return context.getElementsByTagName(tag);
                } else if (support.qsa) {
                    return context.querySelectorAll(tag);
                }
            } : function(tag, context) {
                var elem, tmp = [], i = 0, results = context.getElementsByTagName(tag);
                if (tag === "*") {
                    while (elem = results[i++]) {
                        if (elem.nodeType === 1) {
                            tmp.push(elem);
                        }
                    }
                    return tmp;
                }
                return results;
            };
            Expr.find["CLASS"] = support.getElementsByClassName && function(className, context) {
                if (typeof context.getElementsByClassName !== "undefined" && documentIsHTML) {
                    return context.getElementsByClassName(className);
                }
            };
            rbuggyMatches = [];
            rbuggyQSA = [];
            if (support.qsa = rnative.test(document.querySelectorAll)) {
                assert(function(div) {
                    docElem.appendChild(div).innerHTML = "<a id='" + expando + "'></a>" + "<select id='" + expando + "-\r\\' msallowcapture=''>" + "<option selected=''></option></select>";
                    if (div.querySelectorAll("[msallowcapture^='']").length) {
                        rbuggyQSA.push("[*^$]=" + whitespace + "*(?:''|\"\")");
                    }
                    if (!div.querySelectorAll("[selected]").length) {
                        rbuggyQSA.push("\\[" + whitespace + "*(?:value|" + booleans + ")");
                    }
                    if (!div.querySelectorAll("[id~=" + expando + "-]").length) {
                        rbuggyQSA.push("~=");
                    }
                    if (!div.querySelectorAll(":checked").length) {
                        rbuggyQSA.push(":checked");
                    }
                    if (!div.querySelectorAll("a#" + expando + "+*").length) {
                        rbuggyQSA.push(".#.+[+~]");
                    }
                });
                assert(function(div) {
                    var input = document.createElement("input");
                    input.setAttribute("type", "hidden");
                    div.appendChild(input).setAttribute("name", "D");
                    if (div.querySelectorAll("[name=d]").length) {
                        rbuggyQSA.push("name" + whitespace + "*[*^$|!~]?=");
                    }
                    if (!div.querySelectorAll(":enabled").length) {
                        rbuggyQSA.push(":enabled", ":disabled");
                    }
                    div.querySelectorAll("*,:x");
                    rbuggyQSA.push(",.*:");
                });
            }
            if (support.matchesSelector = rnative.test(matches = docElem.matches || docElem.webkitMatchesSelector || docElem.mozMatchesSelector || docElem.oMatchesSelector || docElem.msMatchesSelector)) {
                assert(function(div) {
                    support.disconnectedMatch = matches.call(div, "div");
                    matches.call(div, "[s!='']:x");
                    rbuggyMatches.push("!=", pseudos);
                });
            }
            rbuggyQSA = rbuggyQSA.length && new RegExp(rbuggyQSA.join("|"));
            rbuggyMatches = rbuggyMatches.length && new RegExp(rbuggyMatches.join("|"));
            hasCompare = rnative.test(docElem.compareDocumentPosition);
            contains = hasCompare || rnative.test(docElem.contains) ? function(a, b) {
                var adown = a.nodeType === 9 ? a.documentElement : a, bup = b && b.parentNode;
                return a === bup || !!(bup && bup.nodeType === 1 && (adown.contains ? adown.contains(bup) : a.compareDocumentPosition && a.compareDocumentPosition(bup) & 16));
            } : function(a, b) {
                if (b) {
                    while (b = b.parentNode) {
                        if (b === a) {
                            return true;
                        }
                    }
                }
                return false;
            };
            sortOrder = hasCompare ? function(a, b) {
                if (a === b) {
                    hasDuplicate = true;
                    return 0;
                }
                var compare = !a.compareDocumentPosition - !b.compareDocumentPosition;
                if (compare) {
                    return compare;
                }
                compare = (a.ownerDocument || a) === (b.ownerDocument || b) ? a.compareDocumentPosition(b) : 1;
                if (compare & 1 || !support.sortDetached && b.compareDocumentPosition(a) === compare) {
                    if (a === document || a.ownerDocument === preferredDoc && contains(preferredDoc, a)) {
                        return -1;
                    }
                    if (b === document || b.ownerDocument === preferredDoc && contains(preferredDoc, b)) {
                        return 1;
                    }
                    return sortInput ? indexOf(sortInput, a) - indexOf(sortInput, b) : 0;
                }
                return compare & 4 ? -1 : 1;
            } : function(a, b) {
                if (a === b) {
                    hasDuplicate = true;
                    return 0;
                }
                var cur, i = 0, aup = a.parentNode, bup = b.parentNode, ap = [ a ], bp = [ b ];
                if (!aup || !bup) {
                    return a === document ? -1 : b === document ? 1 : aup ? -1 : bup ? 1 : sortInput ? indexOf(sortInput, a) - indexOf(sortInput, b) : 0;
                } else if (aup === bup) {
                    return siblingCheck(a, b);
                }
                cur = a;
                while (cur = cur.parentNode) {
                    ap.unshift(cur);
                }
                cur = b;
                while (cur = cur.parentNode) {
                    bp.unshift(cur);
                }
                while (ap[i] === bp[i]) {
                    i++;
                }
                return i ? siblingCheck(ap[i], bp[i]) : ap[i] === preferredDoc ? -1 : bp[i] === preferredDoc ? 1 : 0;
            };
            return document;
        };
        Sizzle.matches = function(expr, elements) {
            return Sizzle(expr, null, null, elements);
        };
        Sizzle.matchesSelector = function(elem, expr) {
            if ((elem.ownerDocument || elem) !== document) {
                setDocument(elem);
            }
            expr = expr.replace(rattributeQuotes, "='$1']");
            if (support.matchesSelector && documentIsHTML && !compilerCache[expr + " "] && (!rbuggyMatches || !rbuggyMatches.test(expr)) && (!rbuggyQSA || !rbuggyQSA.test(expr))) {
                try {
                    var ret = matches.call(elem, expr);
                    if (ret || support.disconnectedMatch || elem.document && elem.document.nodeType !== 11) {
                        return ret;
                    }
                } catch (e) {}
            }
            return Sizzle(expr, document, null, [ elem ]).length > 0;
        };
        Sizzle.contains = function(context, elem) {
            if ((context.ownerDocument || context) !== document) {
                setDocument(context);
            }
            return contains(context, elem);
        };
        Sizzle.attr = function(elem, name) {
            if ((elem.ownerDocument || elem) !== document) {
                setDocument(elem);
            }
            var fn = Expr.attrHandle[name.toLowerCase()], val = fn && hasOwn.call(Expr.attrHandle, name.toLowerCase()) ? fn(elem, name, !documentIsHTML) : undefined;
            return val !== undefined ? val : support.attributes || !documentIsHTML ? elem.getAttribute(name) : (val = elem.getAttributeNode(name)) && val.specified ? val.value : null;
        };
        Sizzle.error = function(msg) {
            throw new Error("Syntax error, unrecognized expression: " + msg);
        };
        Sizzle.uniqueSort = function(results) {
            var elem, duplicates = [], j = 0, i = 0;
            hasDuplicate = !support.detectDuplicates;
            sortInput = !support.sortStable && results.slice(0);
            results.sort(sortOrder);
            if (hasDuplicate) {
                while (elem = results[i++]) {
                    if (elem === results[i]) {
                        j = duplicates.push(i);
                    }
                }
                while (j--) {
                    results.splice(duplicates[j], 1);
                }
            }
            sortInput = null;
            return results;
        };
        getText = Sizzle.getText = function(elem) {
            var node, ret = "", i = 0, nodeType = elem.nodeType;
            if (!nodeType) {
                while (node = elem[i++]) {
                    ret += getText(node);
                }
            } else if (nodeType === 1 || nodeType === 9 || nodeType === 11) {
                if (typeof elem.textContent === "string") {
                    return elem.textContent;
                } else {
                    for (elem = elem.firstChild; elem; elem = elem.nextSibling) {
                        ret += getText(elem);
                    }
                }
            } else if (nodeType === 3 || nodeType === 4) {
                return elem.nodeValue;
            }
            return ret;
        };
        Expr = Sizzle.selectors = {
            cacheLength: 50,
            createPseudo: markFunction,
            match: matchExpr,
            attrHandle: {},
            find: {},
            relative: {
                ">": {
                    dir: "parentNode",
                    first: true
                },
                " ": {
                    dir: "parentNode"
                },
                "+": {
                    dir: "previousSibling",
                    first: true
                },
                "~": {
                    dir: "previousSibling"
                }
            },
            preFilter: {
                ATTR: function(match) {
                    match[1] = match[1].replace(runescape, funescape);
                    match[3] = (match[3] || match[4] || match[5] || "").replace(runescape, funescape);
                    if (match[2] === "~=") {
                        match[3] = " " + match[3] + " ";
                    }
                    return match.slice(0, 4);
                },
                CHILD: function(match) {
                    match[1] = match[1].toLowerCase();
                    if (match[1].slice(0, 3) === "nth") {
                        if (!match[3]) {
                            Sizzle.error(match[0]);
                        }
                        match[4] = +(match[4] ? match[5] + (match[6] || 1) : 2 * (match[3] === "even" || match[3] === "odd"));
                        match[5] = +(match[7] + match[8] || match[3] === "odd");
                    } else if (match[3]) {
                        Sizzle.error(match[0]);
                    }
                    return match;
                },
                PSEUDO: function(match) {
                    var excess, unquoted = !match[6] && match[2];
                    if (matchExpr["CHILD"].test(match[0])) {
                        return null;
                    }
                    if (match[3]) {
                        match[2] = match[4] || match[5] || "";
                    } else if (unquoted && rpseudo.test(unquoted) && (excess = tokenize(unquoted, true)) && (excess = unquoted.indexOf(")", unquoted.length - excess) - unquoted.length)) {
                        match[0] = match[0].slice(0, excess);
                        match[2] = unquoted.slice(0, excess);
                    }
                    return match.slice(0, 3);
                }
            },
            filter: {
                TAG: function(nodeNameSelector) {
                    var nodeName = nodeNameSelector.replace(runescape, funescape).toLowerCase();
                    return nodeNameSelector === "*" ? function() {
                        return true;
                    } : function(elem) {
                        return elem.nodeName && elem.nodeName.toLowerCase() === nodeName;
                    };
                },
                CLASS: function(className) {
                    var pattern = classCache[className + " "];
                    return pattern || (pattern = new RegExp("(^|" + whitespace + ")" + className + "(" + whitespace + "|$)")) && classCache(className, function(elem) {
                        return pattern.test(typeof elem.className === "string" && elem.className || typeof elem.getAttribute !== "undefined" && elem.getAttribute("class") || "");
                    });
                },
                ATTR: function(name, operator, check) {
                    return function(elem) {
                        var result = Sizzle.attr(elem, name);
                        if (result == null) {
                            return operator === "!=";
                        }
                        if (!operator) {
                            return true;
                        }
                        result += "";
                        return operator === "=" ? result === check : operator === "!=" ? result !== check : operator === "^=" ? check && result.indexOf(check) === 0 : operator === "*=" ? check && result.indexOf(check) > -1 : operator === "$=" ? check && result.slice(-check.length) === check : operator === "~=" ? (" " + result.replace(rwhitespace, " ") + " ").indexOf(check) > -1 : operator === "|=" ? result === check || result.slice(0, check.length + 1) === check + "-" : false;
                    };
                },
                CHILD: function(type, what, argument, first, last) {
                    var simple = type.slice(0, 3) !== "nth", forward = type.slice(-4) !== "last", ofType = what === "of-type";
                    return first === 1 && last === 0 ? function(elem) {
                        return !!elem.parentNode;
                    } : function(elem, context, xml) {
                        var cache, uniqueCache, outerCache, node, nodeIndex, start, dir = simple !== forward ? "nextSibling" : "previousSibling", parent = elem.parentNode, name = ofType && elem.nodeName.toLowerCase(), useCache = !xml && !ofType, diff = false;
                        if (parent) {
                            if (simple) {
                                while (dir) {
                                    node = elem;
                                    while (node = node[dir]) {
                                        if (ofType ? node.nodeName.toLowerCase() === name : node.nodeType === 1) {
                                            return false;
                                        }
                                    }
                                    start = dir = type === "only" && !start && "nextSibling";
                                }
                                return true;
                            }
                            start = [ forward ? parent.firstChild : parent.lastChild ];
                            if (forward && useCache) {
                                node = parent;
                                outerCache = node[expando] || (node[expando] = {});
                                uniqueCache = outerCache[node.uniqueID] || (outerCache[node.uniqueID] = {});
                                cache = uniqueCache[type] || [];
                                nodeIndex = cache[0] === dirruns && cache[1];
                                diff = nodeIndex && cache[2];
                                node = nodeIndex && parent.childNodes[nodeIndex];
                                while (node = ++nodeIndex && node && node[dir] || (diff = nodeIndex = 0) || start.pop()) {
                                    if (node.nodeType === 1 && ++diff && node === elem) {
                                        uniqueCache[type] = [ dirruns, nodeIndex, diff ];
                                        break;
                                    }
                                }
                            } else {
                                if (useCache) {
                                    node = elem;
                                    outerCache = node[expando] || (node[expando] = {});
                                    uniqueCache = outerCache[node.uniqueID] || (outerCache[node.uniqueID] = {});
                                    cache = uniqueCache[type] || [];
                                    nodeIndex = cache[0] === dirruns && cache[1];
                                    diff = nodeIndex;
                                }
                                if (diff === false) {
                                    while (node = ++nodeIndex && node && node[dir] || (diff = nodeIndex = 0) || start.pop()) {
                                        if ((ofType ? node.nodeName.toLowerCase() === name : node.nodeType === 1) && ++diff) {
                                            if (useCache) {
                                                outerCache = node[expando] || (node[expando] = {});
                                                uniqueCache = outerCache[node.uniqueID] || (outerCache[node.uniqueID] = {});
                                                uniqueCache[type] = [ dirruns, diff ];
                                            }
                                            if (node === elem) {
                                                break;
                                            }
                                        }
                                    }
                                }
                            }
                            diff -= last;
                            return diff === first || diff % first === 0 && diff / first >= 0;
                        }
                    };
                },
                PSEUDO: function(pseudo, argument) {
                    var args, fn = Expr.pseudos[pseudo] || Expr.setFilters[pseudo.toLowerCase()] || Sizzle.error("unsupported pseudo: " + pseudo);
                    if (fn[expando]) {
                        return fn(argument);
                    }
                    if (fn.length > 1) {
                        args = [ pseudo, pseudo, "", argument ];
                        return Expr.setFilters.hasOwnProperty(pseudo.toLowerCase()) ? markFunction(function(seed, matches) {
                            var idx, matched = fn(seed, argument), i = matched.length;
                            while (i--) {
                                idx = indexOf(seed, matched[i]);
                                seed[idx] = !(matches[idx] = matched[i]);
                            }
                        }) : function(elem) {
                            return fn(elem, 0, args);
                        };
                    }
                    return fn;
                }
            },
            pseudos: {
                not: markFunction(function(selector) {
                    var input = [], results = [], matcher = compile(selector.replace(rtrim, "$1"));
                    return matcher[expando] ? markFunction(function(seed, matches, context, xml) {
                        var elem, unmatched = matcher(seed, null, xml, []), i = seed.length;
                        while (i--) {
                            if (elem = unmatched[i]) {
                                seed[i] = !(matches[i] = elem);
                            }
                        }
                    }) : function(elem, context, xml) {
                        input[0] = elem;
                        matcher(input, null, xml, results);
                        input[0] = null;
                        return !results.pop();
                    };
                }),
                has: markFunction(function(selector) {
                    return function(elem) {
                        return Sizzle(selector, elem).length > 0;
                    };
                }),
                contains: markFunction(function(text) {
                    text = text.replace(runescape, funescape);
                    return function(elem) {
                        return (elem.textContent || elem.innerText || getText(elem)).indexOf(text) > -1;
                    };
                }),
                lang: markFunction(function(lang) {
                    if (!ridentifier.test(lang || "")) {
                        Sizzle.error("unsupported lang: " + lang);
                    }
                    lang = lang.replace(runescape, funescape).toLowerCase();
                    return function(elem) {
                        var elemLang;
                        do {
                            if (elemLang = documentIsHTML ? elem.lang : elem.getAttribute("xml:lang") || elem.getAttribute("lang")) {
                                elemLang = elemLang.toLowerCase();
                                return elemLang === lang || elemLang.indexOf(lang + "-") === 0;
                            }
                        } while ((elem = elem.parentNode) && elem.nodeType === 1);
                        return false;
                    };
                }),
                target: function(elem) {
                    var hash = window.location && window.location.hash;
                    return hash && hash.slice(1) === elem.id;
                },
                root: function(elem) {
                    return elem === docElem;
                },
                focus: function(elem) {
                    return elem === document.activeElement && (!document.hasFocus || document.hasFocus()) && !!(elem.type || elem.href || ~elem.tabIndex);
                },
                enabled: function(elem) {
                    return elem.disabled === false;
                },
                disabled: function(elem) {
                    return elem.disabled === true;
                },
                checked: function(elem) {
                    var nodeName = elem.nodeName.toLowerCase();
                    return nodeName === "input" && !!elem.checked || nodeName === "option" && !!elem.selected;
                },
                selected: function(elem) {
                    if (elem.parentNode) {
                        elem.parentNode.selectedIndex;
                    }
                    return elem.selected === true;
                },
                empty: function(elem) {
                    for (elem = elem.firstChild; elem; elem = elem.nextSibling) {
                        if (elem.nodeType < 6) {
                            return false;
                        }
                    }
                    return true;
                },
                parent: function(elem) {
                    return !Expr.pseudos["empty"](elem);
                },
                header: function(elem) {
                    return rheader.test(elem.nodeName);
                },
                input: function(elem) {
                    return rinputs.test(elem.nodeName);
                },
                button: function(elem) {
                    var name = elem.nodeName.toLowerCase();
                    return name === "input" && elem.type === "button" || name === "button";
                },
                text: function(elem) {
                    var attr;
                    return elem.nodeName.toLowerCase() === "input" && elem.type === "text" && ((attr = elem.getAttribute("type")) == null || attr.toLowerCase() === "text");
                },
                first: createPositionalPseudo(function() {
                    return [ 0 ];
                }),
                last: createPositionalPseudo(function(matchIndexes, length) {
                    return [ length - 1 ];
                }),
                eq: createPositionalPseudo(function(matchIndexes, length, argument) {
                    return [ argument < 0 ? argument + length : argument ];
                }),
                even: createPositionalPseudo(function(matchIndexes, length) {
                    var i = 0;
                    for (;i < length; i += 2) {
                        matchIndexes.push(i);
                    }
                    return matchIndexes;
                }),
                odd: createPositionalPseudo(function(matchIndexes, length) {
                    var i = 1;
                    for (;i < length; i += 2) {
                        matchIndexes.push(i);
                    }
                    return matchIndexes;
                }),
                lt: createPositionalPseudo(function(matchIndexes, length, argument) {
                    var i = argument < 0 ? argument + length : argument;
                    for (;--i >= 0; ) {
                        matchIndexes.push(i);
                    }
                    return matchIndexes;
                }),
                gt: createPositionalPseudo(function(matchIndexes, length, argument) {
                    var i = argument < 0 ? argument + length : argument;
                    for (;++i < length; ) {
                        matchIndexes.push(i);
                    }
                    return matchIndexes;
                })
            }
        };
        Expr.pseudos["nth"] = Expr.pseudos["eq"];
        for (i in {
            radio: true,
            checkbox: true,
            file: true,
            password: true,
            image: true
        }) {
            Expr.pseudos[i] = createInputPseudo(i);
        }
        for (i in {
            submit: true,
            reset: true
        }) {
            Expr.pseudos[i] = createButtonPseudo(i);
        }
        function setFilters() {}
        setFilters.prototype = Expr.filters = Expr.pseudos;
        Expr.setFilters = new setFilters();
        tokenize = Sizzle.tokenize = function(selector, parseOnly) {
            var matched, match, tokens, type, soFar, groups, preFilters, cached = tokenCache[selector + " "];
            if (cached) {
                return parseOnly ? 0 : cached.slice(0);
            }
            soFar = selector;
            groups = [];
            preFilters = Expr.preFilter;
            while (soFar) {
                if (!matched || (match = rcomma.exec(soFar))) {
                    if (match) {
                        soFar = soFar.slice(match[0].length) || soFar;
                    }
                    groups.push(tokens = []);
                }
                matched = false;
                if (match = rcombinators.exec(soFar)) {
                    matched = match.shift();
                    tokens.push({
                        value: matched,
                        type: match[0].replace(rtrim, " ")
                    });
                    soFar = soFar.slice(matched.length);
                }
                for (type in Expr.filter) {
                    if ((match = matchExpr[type].exec(soFar)) && (!preFilters[type] || (match = preFilters[type](match)))) {
                        matched = match.shift();
                        tokens.push({
                            value: matched,
                            type: type,
                            matches: match
                        });
                        soFar = soFar.slice(matched.length);
                    }
                }
                if (!matched) {
                    break;
                }
            }
            return parseOnly ? soFar.length : soFar ? Sizzle.error(selector) : tokenCache(selector, groups).slice(0);
        };
        function toSelector(tokens) {
            var i = 0, len = tokens.length, selector = "";
            for (;i < len; i++) {
                selector += tokens[i].value;
            }
            return selector;
        }
        function addCombinator(matcher, combinator, base) {
            var dir = combinator.dir, checkNonElements = base && dir === "parentNode", doneName = done++;
            return combinator.first ? function(elem, context, xml) {
                while (elem = elem[dir]) {
                    if (elem.nodeType === 1 || checkNonElements) {
                        return matcher(elem, context, xml);
                    }
                }
            } : function(elem, context, xml) {
                var oldCache, uniqueCache, outerCache, newCache = [ dirruns, doneName ];
                if (xml) {
                    while (elem = elem[dir]) {
                        if (elem.nodeType === 1 || checkNonElements) {
                            if (matcher(elem, context, xml)) {
                                return true;
                            }
                        }
                    }
                } else {
                    while (elem = elem[dir]) {
                        if (elem.nodeType === 1 || checkNonElements) {
                            outerCache = elem[expando] || (elem[expando] = {});
                            uniqueCache = outerCache[elem.uniqueID] || (outerCache[elem.uniqueID] = {});
                            if ((oldCache = uniqueCache[dir]) && oldCache[0] === dirruns && oldCache[1] === doneName) {
                                return newCache[2] = oldCache[2];
                            } else {
                                uniqueCache[dir] = newCache;
                                if (newCache[2] = matcher(elem, context, xml)) {
                                    return true;
                                }
                            }
                        }
                    }
                }
            };
        }
        function elementMatcher(matchers) {
            return matchers.length > 1 ? function(elem, context, xml) {
                var i = matchers.length;
                while (i--) {
                    if (!matchers[i](elem, context, xml)) {
                        return false;
                    }
                }
                return true;
            } : matchers[0];
        }
        function multipleContexts(selector, contexts, results) {
            var i = 0, len = contexts.length;
            for (;i < len; i++) {
                Sizzle(selector, contexts[i], results);
            }
            return results;
        }
        function condense(unmatched, map, filter, context, xml) {
            var elem, newUnmatched = [], i = 0, len = unmatched.length, mapped = map != null;
            for (;i < len; i++) {
                if (elem = unmatched[i]) {
                    if (!filter || filter(elem, context, xml)) {
                        newUnmatched.push(elem);
                        if (mapped) {
                            map.push(i);
                        }
                    }
                }
            }
            return newUnmatched;
        }
        function setMatcher(preFilter, selector, matcher, postFilter, postFinder, postSelector) {
            if (postFilter && !postFilter[expando]) {
                postFilter = setMatcher(postFilter);
            }
            if (postFinder && !postFinder[expando]) {
                postFinder = setMatcher(postFinder, postSelector);
            }
            return markFunction(function(seed, results, context, xml) {
                var temp, i, elem, preMap = [], postMap = [], preexisting = results.length, elems = seed || multipleContexts(selector || "*", context.nodeType ? [ context ] : context, []), matcherIn = preFilter && (seed || !selector) ? condense(elems, preMap, preFilter, context, xml) : elems, matcherOut = matcher ? postFinder || (seed ? preFilter : preexisting || postFilter) ? [] : results : matcherIn;
                if (matcher) {
                    matcher(matcherIn, matcherOut, context, xml);
                }
                if (postFilter) {
                    temp = condense(matcherOut, postMap);
                    postFilter(temp, [], context, xml);
                    i = temp.length;
                    while (i--) {
                        if (elem = temp[i]) {
                            matcherOut[postMap[i]] = !(matcherIn[postMap[i]] = elem);
                        }
                    }
                }
                if (seed) {
                    if (postFinder || preFilter) {
                        if (postFinder) {
                            temp = [];
                            i = matcherOut.length;
                            while (i--) {
                                if (elem = matcherOut[i]) {
                                    temp.push(matcherIn[i] = elem);
                                }
                            }
                            postFinder(null, matcherOut = [], temp, xml);
                        }
                        i = matcherOut.length;
                        while (i--) {
                            if ((elem = matcherOut[i]) && (temp = postFinder ? indexOf(seed, elem) : preMap[i]) > -1) {
                                seed[temp] = !(results[temp] = elem);
                            }
                        }
                    }
                } else {
                    matcherOut = condense(matcherOut === results ? matcherOut.splice(preexisting, matcherOut.length) : matcherOut);
                    if (postFinder) {
                        postFinder(null, results, matcherOut, xml);
                    } else {
                        push.apply(results, matcherOut);
                    }
                }
            });
        }
        function matcherFromTokens(tokens) {
            var checkContext, matcher, j, len = tokens.length, leadingRelative = Expr.relative[tokens[0].type], implicitRelative = leadingRelative || Expr.relative[" "], i = leadingRelative ? 1 : 0, matchContext = addCombinator(function(elem) {
                return elem === checkContext;
            }, implicitRelative, true), matchAnyContext = addCombinator(function(elem) {
                return indexOf(checkContext, elem) > -1;
            }, implicitRelative, true), matchers = [ function(elem, context, xml) {
                var ret = !leadingRelative && (xml || context !== outermostContext) || ((checkContext = context).nodeType ? matchContext(elem, context, xml) : matchAnyContext(elem, context, xml));
                checkContext = null;
                return ret;
            } ];
            for (;i < len; i++) {
                if (matcher = Expr.relative[tokens[i].type]) {
                    matchers = [ addCombinator(elementMatcher(matchers), matcher) ];
                } else {
                    matcher = Expr.filter[tokens[i].type].apply(null, tokens[i].matches);
                    if (matcher[expando]) {
                        j = ++i;
                        for (;j < len; j++) {
                            if (Expr.relative[tokens[j].type]) {
                                break;
                            }
                        }
                        return setMatcher(i > 1 && elementMatcher(matchers), i > 1 && toSelector(tokens.slice(0, i - 1).concat({
                            value: tokens[i - 2].type === " " ? "*" : ""
                        })).replace(rtrim, "$1"), matcher, i < j && matcherFromTokens(tokens.slice(i, j)), j < len && matcherFromTokens(tokens = tokens.slice(j)), j < len && toSelector(tokens));
                    }
                    matchers.push(matcher);
                }
            }
            return elementMatcher(matchers);
        }
        function matcherFromGroupMatchers(elementMatchers, setMatchers) {
            var bySet = setMatchers.length > 0, byElement = elementMatchers.length > 0, superMatcher = function(seed, context, xml, results, outermost) {
                var elem, j, matcher, matchedCount = 0, i = "0", unmatched = seed && [], setMatched = [], contextBackup = outermostContext, elems = seed || byElement && Expr.find["TAG"]("*", outermost), dirrunsUnique = dirruns += contextBackup == null ? 1 : Math.random() || .1, len = elems.length;
                if (outermost) {
                    outermostContext = context === document || context || outermost;
                }
                for (;i !== len && (elem = elems[i]) != null; i++) {
                    if (byElement && elem) {
                        j = 0;
                        if (!context && elem.ownerDocument !== document) {
                            setDocument(elem);
                            xml = !documentIsHTML;
                        }
                        while (matcher = elementMatchers[j++]) {
                            if (matcher(elem, context || document, xml)) {
                                results.push(elem);
                                break;
                            }
                        }
                        if (outermost) {
                            dirruns = dirrunsUnique;
                        }
                    }
                    if (bySet) {
                        if (elem = !matcher && elem) {
                            matchedCount--;
                        }
                        if (seed) {
                            unmatched.push(elem);
                        }
                    }
                }
                matchedCount += i;
                if (bySet && i !== matchedCount) {
                    j = 0;
                    while (matcher = setMatchers[j++]) {
                        matcher(unmatched, setMatched, context, xml);
                    }
                    if (seed) {
                        if (matchedCount > 0) {
                            while (i--) {
                                if (!(unmatched[i] || setMatched[i])) {
                                    setMatched[i] = pop.call(results);
                                }
                            }
                        }
                        setMatched = condense(setMatched);
                    }
                    push.apply(results, setMatched);
                    if (outermost && !seed && setMatched.length > 0 && matchedCount + setMatchers.length > 1) {
                        Sizzle.uniqueSort(results);
                    }
                }
                if (outermost) {
                    dirruns = dirrunsUnique;
                    outermostContext = contextBackup;
                }
                return unmatched;
            };
            return bySet ? markFunction(superMatcher) : superMatcher;
        }
        compile = Sizzle.compile = function(selector, match) {
            var i, setMatchers = [], elementMatchers = [], cached = compilerCache[selector + " "];
            if (!cached) {
                if (!match) {
                    match = tokenize(selector);
                }
                i = match.length;
                while (i--) {
                    cached = matcherFromTokens(match[i]);
                    if (cached[expando]) {
                        setMatchers.push(cached);
                    } else {
                        elementMatchers.push(cached);
                    }
                }
                cached = compilerCache(selector, matcherFromGroupMatchers(elementMatchers, setMatchers));
                cached.selector = selector;
            }
            return cached;
        };
        select = Sizzle.select = function(selector, context, results, seed) {
            var i, tokens, token, type, find, compiled = typeof selector === "function" && selector, match = !seed && tokenize(selector = compiled.selector || selector);
            results = results || [];
            if (match.length === 1) {
                tokens = match[0] = match[0].slice(0);
                if (tokens.length > 2 && (token = tokens[0]).type === "ID" && support.getById && context.nodeType === 9 && documentIsHTML && Expr.relative[tokens[1].type]) {
                    context = (Expr.find["ID"](token.matches[0].replace(runescape, funescape), context) || [])[0];
                    if (!context) {
                        return results;
                    } else if (compiled) {
                        context = context.parentNode;
                    }
                    selector = selector.slice(tokens.shift().value.length);
                }
                i = matchExpr["needsContext"].test(selector) ? 0 : tokens.length;
                while (i--) {
                    token = tokens[i];
                    if (Expr.relative[type = token.type]) {
                        break;
                    }
                    if (find = Expr.find[type]) {
                        if (seed = find(token.matches[0].replace(runescape, funescape), rsibling.test(tokens[0].type) && testContext(context.parentNode) || context)) {
                            tokens.splice(i, 1);
                            selector = seed.length && toSelector(tokens);
                            if (!selector) {
                                push.apply(results, seed);
                                return results;
                            }
                            break;
                        }
                    }
                }
            }
            (compiled || compile(selector, match))(seed, context, !documentIsHTML, results, !context || rsibling.test(selector) && testContext(context.parentNode) || context);
            return results;
        };
        support.sortStable = expando.split("").sort(sortOrder).join("") === expando;
        support.detectDuplicates = !!hasDuplicate;
        setDocument();
        support.sortDetached = assert(function(div1) {
            return div1.compareDocumentPosition(document.createElement("div")) & 1;
        });
        if (!assert(function(div) {
            div.innerHTML = "<a href='#'></a>";
            return div.firstChild.getAttribute("href") === "#";
        })) {
            addHandle("type|href|height|width", function(elem, name, isXML) {
                if (!isXML) {
                    return elem.getAttribute(name, name.toLowerCase() === "type" ? 1 : 2);
                }
            });
        }
        if (!support.attributes || !assert(function(div) {
            div.innerHTML = "<input/>";
            div.firstChild.setAttribute("value", "");
            return div.firstChild.getAttribute("value") === "";
        })) {
            addHandle("value", function(elem, name, isXML) {
                if (!isXML && elem.nodeName.toLowerCase() === "input") {
                    return elem.defaultValue;
                }
            });
        }
        if (!assert(function(div) {
            return div.getAttribute("disabled") == null;
        })) {
            addHandle(booleans, function(elem, name, isXML) {
                var val;
                if (!isXML) {
                    return elem[name] === true ? name.toLowerCase() : (val = elem.getAttributeNode(name)) && val.specified ? val.value : null;
                }
            });
        }
        return Sizzle;
    }(window);
    jQuery.find = Sizzle;
    jQuery.expr = Sizzle.selectors;
    jQuery.expr[":"] = jQuery.expr.pseudos;
    jQuery.uniqueSort = jQuery.unique = Sizzle.uniqueSort;
    jQuery.text = Sizzle.getText;
    jQuery.isXMLDoc = Sizzle.isXML;
    jQuery.contains = Sizzle.contains;
    var dir = function(elem, dir, until) {
        var matched = [], truncate = until !== undefined;
        while ((elem = elem[dir]) && elem.nodeType !== 9) {
            if (elem.nodeType === 1) {
                if (truncate && jQuery(elem).is(until)) {
                    break;
                }
                matched.push(elem);
            }
        }
        return matched;
    };
    var siblings = function(n, elem) {
        var matched = [];
        for (;n; n = n.nextSibling) {
            if (n.nodeType === 1 && n !== elem) {
                matched.push(n);
            }
        }
        return matched;
    };
    var rneedsContext = jQuery.expr.match.needsContext;
    var rsingleTag = /^<([\w-]+)\s*\/?>(?:<\/\1>|)$/;
    var risSimple = /^.[^:#\[\.,]*$/;
    function winnow(elements, qualifier, not) {
        if (jQuery.isFunction(qualifier)) {
            return jQuery.grep(elements, function(elem, i) {
                return !!qualifier.call(elem, i, elem) !== not;
            });
        }
        if (qualifier.nodeType) {
            return jQuery.grep(elements, function(elem) {
                return elem === qualifier !== not;
            });
        }
        if (typeof qualifier === "string") {
            if (risSimple.test(qualifier)) {
                return jQuery.filter(qualifier, elements, not);
            }
            qualifier = jQuery.filter(qualifier, elements);
        }
        return jQuery.grep(elements, function(elem) {
            return indexOf.call(qualifier, elem) > -1 !== not;
        });
    }
    jQuery.filter = function(expr, elems, not) {
        var elem = elems[0];
        if (not) {
            expr = ":not(" + expr + ")";
        }
        return elems.length === 1 && elem.nodeType === 1 ? jQuery.find.matchesSelector(elem, expr) ? [ elem ] : [] : jQuery.find.matches(expr, jQuery.grep(elems, function(elem) {
            return elem.nodeType === 1;
        }));
    };
    jQuery.fn.extend({
        find: function(selector) {
            var i, len = this.length, ret = [], self = this;
            if (typeof selector !== "string") {
                return this.pushStack(jQuery(selector).filter(function() {
                    for (i = 0; i < len; i++) {
                        if (jQuery.contains(self[i], this)) {
                            return true;
                        }
                    }
                }));
            }
            for (i = 0; i < len; i++) {
                jQuery.find(selector, self[i], ret);
            }
            ret = this.pushStack(len > 1 ? jQuery.unique(ret) : ret);
            ret.selector = this.selector ? this.selector + " " + selector : selector;
            return ret;
        },
        filter: function(selector) {
            return this.pushStack(winnow(this, selector || [], false));
        },
        not: function(selector) {
            return this.pushStack(winnow(this, selector || [], true));
        },
        is: function(selector) {
            return !!winnow(this, typeof selector === "string" && rneedsContext.test(selector) ? jQuery(selector) : selector || [], false).length;
        }
    });
    var rootjQuery, rquickExpr = /^(?:\s*(<[\w\W]+>)[^>]*|#([\w-]*))$/, init = jQuery.fn.init = function(selector, context, root) {
        var match, elem;
        if (!selector) {
            return this;
        }
        root = root || rootjQuery;
        if (typeof selector === "string") {
            if (selector[0] === "<" && selector[selector.length - 1] === ">" && selector.length >= 3) {
                match = [ null, selector, null ];
            } else {
                match = rquickExpr.exec(selector);
            }
            if (match && (match[1] || !context)) {
                if (match[1]) {
                    context = context instanceof jQuery ? context[0] : context;
                    jQuery.merge(this, jQuery.parseHTML(match[1], context && context.nodeType ? context.ownerDocument || context : document, true));
                    if (rsingleTag.test(match[1]) && jQuery.isPlainObject(context)) {
                        for (match in context) {
                            if (jQuery.isFunction(this[match])) {
                                this[match](context[match]);
                            } else {
                                this.attr(match, context[match]);
                            }
                        }
                    }
                    return this;
                } else {
                    elem = document.getElementById(match[2]);
                    if (elem && elem.parentNode) {
                        this.length = 1;
                        this[0] = elem;
                    }
                    this.context = document;
                    this.selector = selector;
                    return this;
                }
            } else if (!context || context.jquery) {
                return (context || root).find(selector);
            } else {
                return this.constructor(context).find(selector);
            }
        } else if (selector.nodeType) {
            this.context = this[0] = selector;
            this.length = 1;
            return this;
        } else if (jQuery.isFunction(selector)) {
            return root.ready !== undefined ? root.ready(selector) : selector(jQuery);
        }
        if (selector.selector !== undefined) {
            this.selector = selector.selector;
            this.context = selector.context;
        }
        return jQuery.makeArray(selector, this);
    };
    init.prototype = jQuery.fn;
    rootjQuery = jQuery(document);
    var rparentsprev = /^(?:parents|prev(?:Until|All))/, guaranteedUnique = {
        children: true,
        contents: true,
        next: true,
        prev: true
    };
    jQuery.fn.extend({
        has: function(target) {
            var targets = jQuery(target, this), l = targets.length;
            return this.filter(function() {
                var i = 0;
                for (;i < l; i++) {
                    if (jQuery.contains(this, targets[i])) {
                        return true;
                    }
                }
            });
        },
        closest: function(selectors, context) {
            var cur, i = 0, l = this.length, matched = [], pos = rneedsContext.test(selectors) || typeof selectors !== "string" ? jQuery(selectors, context || this.context) : 0;
            for (;i < l; i++) {
                for (cur = this[i]; cur && cur !== context; cur = cur.parentNode) {
                    if (cur.nodeType < 11 && (pos ? pos.index(cur) > -1 : cur.nodeType === 1 && jQuery.find.matchesSelector(cur, selectors))) {
                        matched.push(cur);
                        break;
                    }
                }
            }
            return this.pushStack(matched.length > 1 ? jQuery.uniqueSort(matched) : matched);
        },
        index: function(elem) {
            if (!elem) {
                return this[0] && this[0].parentNode ? this.first().prevAll().length : -1;
            }
            if (typeof elem === "string") {
                return indexOf.call(jQuery(elem), this[0]);
            }
            return indexOf.call(this, elem.jquery ? elem[0] : elem);
        },
        add: function(selector, context) {
            return this.pushStack(jQuery.uniqueSort(jQuery.merge(this.get(), jQuery(selector, context))));
        },
        addBack: function(selector) {
            return this.add(selector == null ? this.prevObject : this.prevObject.filter(selector));
        }
    });
    function sibling(cur, dir) {
        while ((cur = cur[dir]) && cur.nodeType !== 1) {}
        return cur;
    }
    jQuery.each({
        parent: function(elem) {
            var parent = elem.parentNode;
            return parent && parent.nodeType !== 11 ? parent : null;
        },
        parents: function(elem) {
            return dir(elem, "parentNode");
        },
        parentsUntil: function(elem, i, until) {
            return dir(elem, "parentNode", until);
        },
        next: function(elem) {
            return sibling(elem, "nextSibling");
        },
        prev: function(elem) {
            return sibling(elem, "previousSibling");
        },
        nextAll: function(elem) {
            return dir(elem, "nextSibling");
        },
        prevAll: function(elem) {
            return dir(elem, "previousSibling");
        },
        nextUntil: function(elem, i, until) {
            return dir(elem, "nextSibling", until);
        },
        prevUntil: function(elem, i, until) {
            return dir(elem, "previousSibling", until);
        },
        siblings: function(elem) {
            return siblings((elem.parentNode || {}).firstChild, elem);
        },
        children: function(elem) {
            return siblings(elem.firstChild);
        },
        contents: function(elem) {
            return elem.contentDocument || jQuery.merge([], elem.childNodes);
        }
    }, function(name, fn) {
        jQuery.fn[name] = function(until, selector) {
            var matched = jQuery.map(this, fn, until);
            if (name.slice(-5) !== "Until") {
                selector = until;
            }
            if (selector && typeof selector === "string") {
                matched = jQuery.filter(selector, matched);
            }
            if (this.length > 1) {
                if (!guaranteedUnique[name]) {
                    jQuery.uniqueSort(matched);
                }
                if (rparentsprev.test(name)) {
                    matched.reverse();
                }
            }
            return this.pushStack(matched);
        };
    });
    var rnotwhite = /\S+/g;
    function createOptions(options) {
        var object = {};
        jQuery.each(options.match(rnotwhite) || [], function(_, flag) {
            object[flag] = true;
        });
        return object;
    }
    jQuery.Callbacks = function(options) {
        options = typeof options === "string" ? createOptions(options) : jQuery.extend({}, options);
        var firing, memory, fired, locked, list = [], queue = [], firingIndex = -1, fire = function() {
            locked = options.once;
            fired = firing = true;
            for (;queue.length; firingIndex = -1) {
                memory = queue.shift();
                while (++firingIndex < list.length) {
                    if (list[firingIndex].apply(memory[0], memory[1]) === false && options.stopOnFalse) {
                        firingIndex = list.length;
                        memory = false;
                    }
                }
            }
            if (!options.memory) {
                memory = false;
            }
            firing = false;
            if (locked) {
                if (memory) {
                    list = [];
                } else {
                    list = "";
                }
            }
        }, self = {
            add: function() {
                if (list) {
                    if (memory && !firing) {
                        firingIndex = list.length - 1;
                        queue.push(memory);
                    }
                    (function add(args) {
                        jQuery.each(args, function(_, arg) {
                            if (jQuery.isFunction(arg)) {
                                if (!options.unique || !self.has(arg)) {
                                    list.push(arg);
                                }
                            } else if (arg && arg.length && jQuery.type(arg) !== "string") {
                                add(arg);
                            }
                        });
                    })(arguments);
                    if (memory && !firing) {
                        fire();
                    }
                }
                return this;
            },
            remove: function() {
                jQuery.each(arguments, function(_, arg) {
                    var index;
                    while ((index = jQuery.inArray(arg, list, index)) > -1) {
                        list.splice(index, 1);
                        if (index <= firingIndex) {
                            firingIndex--;
                        }
                    }
                });
                return this;
            },
            has: function(fn) {
                return fn ? jQuery.inArray(fn, list) > -1 : list.length > 0;
            },
            empty: function() {
                if (list) {
                    list = [];
                }
                return this;
            },
            disable: function() {
                locked = queue = [];
                list = memory = "";
                return this;
            },
            disabled: function() {
                return !list;
            },
            lock: function() {
                locked = queue = [];
                if (!memory) {
                    list = memory = "";
                }
                return this;
            },
            locked: function() {
                return !!locked;
            },
            fireWith: function(context, args) {
                if (!locked) {
                    args = args || [];
                    args = [ context, args.slice ? args.slice() : args ];
                    queue.push(args);
                    if (!firing) {
                        fire();
                    }
                }
                return this;
            },
            fire: function() {
                self.fireWith(this, arguments);
                return this;
            },
            fired: function() {
                return !!fired;
            }
        };
        return self;
    };
    jQuery.extend({
        Deferred: function(func) {
            var tuples = [ [ "resolve", "done", jQuery.Callbacks("once memory"), "resolved" ], [ "reject", "fail", jQuery.Callbacks("once memory"), "rejected" ], [ "notify", "progress", jQuery.Callbacks("memory") ] ], state = "pending", promise = {
                state: function() {
                    return state;
                },
                always: function() {
                    deferred.done(arguments).fail(arguments);
                    return this;
                },
                then: function() {
                    var fns = arguments;
                    return jQuery.Deferred(function(newDefer) {
                        jQuery.each(tuples, function(i, tuple) {
                            var fn = jQuery.isFunction(fns[i]) && fns[i];
                            deferred[tuple[1]](function() {
                                var returned = fn && fn.apply(this, arguments);
                                if (returned && jQuery.isFunction(returned.promise)) {
                                    returned.promise().progress(newDefer.notify).done(newDefer.resolve).fail(newDefer.reject);
                                } else {
                                    newDefer[tuple[0] + "With"](this === promise ? newDefer.promise() : this, fn ? [ returned ] : arguments);
                                }
                            });
                        });
                        fns = null;
                    }).promise();
                },
                promise: function(obj) {
                    return obj != null ? jQuery.extend(obj, promise) : promise;
                }
            }, deferred = {};
            promise.pipe = promise.then;
            jQuery.each(tuples, function(i, tuple) {
                var list = tuple[2], stateString = tuple[3];
                promise[tuple[1]] = list.add;
                if (stateString) {
                    list.add(function() {
                        state = stateString;
                    }, tuples[i ^ 1][2].disable, tuples[2][2].lock);
                }
                deferred[tuple[0]] = function() {
                    deferred[tuple[0] + "With"](this === deferred ? promise : this, arguments);
                    return this;
                };
                deferred[tuple[0] + "With"] = list.fireWith;
            });
            promise.promise(deferred);
            if (func) {
                func.call(deferred, deferred);
            }
            return deferred;
        },
        when: function(subordinate) {
            var i = 0, resolveValues = slice.call(arguments), length = resolveValues.length, remaining = length !== 1 || subordinate && jQuery.isFunction(subordinate.promise) ? length : 0, deferred = remaining === 1 ? subordinate : jQuery.Deferred(), updateFunc = function(i, contexts, values) {
                return function(value) {
                    contexts[i] = this;
                    values[i] = arguments.length > 1 ? slice.call(arguments) : value;
                    if (values === progressValues) {
                        deferred.notifyWith(contexts, values);
                    } else if (!--remaining) {
                        deferred.resolveWith(contexts, values);
                    }
                };
            }, progressValues, progressContexts, resolveContexts;
            if (length > 1) {
                progressValues = new Array(length);
                progressContexts = new Array(length);
                resolveContexts = new Array(length);
                for (;i < length; i++) {
                    if (resolveValues[i] && jQuery.isFunction(resolveValues[i].promise)) {
                        resolveValues[i].promise().progress(updateFunc(i, progressContexts, progressValues)).done(updateFunc(i, resolveContexts, resolveValues)).fail(deferred.reject);
                    } else {
                        --remaining;
                    }
                }
            }
            if (!remaining) {
                deferred.resolveWith(resolveContexts, resolveValues);
            }
            return deferred.promise();
        }
    });
    var readyList;
    jQuery.fn.ready = function(fn) {
        jQuery.ready.promise().done(fn);
        return this;
    };
    jQuery.extend({
        isReady: false,
        readyWait: 1,
        holdReady: function(hold) {
            if (hold) {
                jQuery.readyWait++;
            } else {
                jQuery.ready(true);
            }
        },
        ready: function(wait) {
            if (wait === true ? --jQuery.readyWait : jQuery.isReady) {
                return;
            }
            jQuery.isReady = true;
            if (wait !== true && --jQuery.readyWait > 0) {
                return;
            }
            readyList.resolveWith(document, [ jQuery ]);
            if (jQuery.fn.triggerHandler) {
                jQuery(document).triggerHandler("ready");
                jQuery(document).off("ready");
            }
        }
    });
    function completed() {
        document.removeEventListener("DOMContentLoaded", completed);
        window.removeEventListener("load", completed);
        jQuery.ready();
    }
    jQuery.ready.promise = function(obj) {
        if (!readyList) {
            readyList = jQuery.Deferred();
            if (document.readyState === "complete" || document.readyState !== "loading" && !document.documentElement.doScroll) {
                window.setTimeout(jQuery.ready);
            } else {
                document.addEventListener("DOMContentLoaded", completed);
                window.addEventListener("load", completed);
            }
        }
        return readyList.promise(obj);
    };
    jQuery.ready.promise();
    var access = function(elems, fn, key, value, chainable, emptyGet, raw) {
        var i = 0, len = elems.length, bulk = key == null;
        if (jQuery.type(key) === "object") {
            chainable = true;
            for (i in key) {
                access(elems, fn, i, key[i], true, emptyGet, raw);
            }
        } else if (value !== undefined) {
            chainable = true;
            if (!jQuery.isFunction(value)) {
                raw = true;
            }
            if (bulk) {
                if (raw) {
                    fn.call(elems, value);
                    fn = null;
                } else {
                    bulk = fn;
                    fn = function(elem, key, value) {
                        return bulk.call(jQuery(elem), value);
                    };
                }
            }
            if (fn) {
                for (;i < len; i++) {
                    fn(elems[i], key, raw ? value : value.call(elems[i], i, fn(elems[i], key)));
                }
            }
        }
        return chainable ? elems : bulk ? fn.call(elems) : len ? fn(elems[0], key) : emptyGet;
    };
    var acceptData = function(owner) {
        return owner.nodeType === 1 || owner.nodeType === 9 || !+owner.nodeType;
    };
    function Data() {
        this.expando = jQuery.expando + Data.uid++;
    }
    Data.uid = 1;
    Data.prototype = {
        register: function(owner, initial) {
            var value = initial || {};
            if (owner.nodeType) {
                owner[this.expando] = value;
            } else {
                Object.defineProperty(owner, this.expando, {
                    value: value,
                    writable: true,
                    configurable: true
                });
            }
            return owner[this.expando];
        },
        cache: function(owner) {
            if (!acceptData(owner)) {
                return {};
            }
            var value = owner[this.expando];
            if (!value) {
                value = {};
                if (acceptData(owner)) {
                    if (owner.nodeType) {
                        owner[this.expando] = value;
                    } else {
                        Object.defineProperty(owner, this.expando, {
                            value: value,
                            configurable: true
                        });
                    }
                }
            }
            return value;
        },
        set: function(owner, data, value) {
            var prop, cache = this.cache(owner);
            if (typeof data === "string") {
                cache[data] = value;
            } else {
                for (prop in data) {
                    cache[prop] = data[prop];
                }
            }
            return cache;
        },
        get: function(owner, key) {
            return key === undefined ? this.cache(owner) : owner[this.expando] && owner[this.expando][key];
        },
        access: function(owner, key, value) {
            var stored;
            if (key === undefined || key && typeof key === "string" && value === undefined) {
                stored = this.get(owner, key);
                return stored !== undefined ? stored : this.get(owner, jQuery.camelCase(key));
            }
            this.set(owner, key, value);
            return value !== undefined ? value : key;
        },
        remove: function(owner, key) {
            var i, name, camel, cache = owner[this.expando];
            if (cache === undefined) {
                return;
            }
            if (key === undefined) {
                this.register(owner);
            } else {
                if (jQuery.isArray(key)) {
                    name = key.concat(key.map(jQuery.camelCase));
                } else {
                    camel = jQuery.camelCase(key);
                    if (key in cache) {
                        name = [ key, camel ];
                    } else {
                        name = camel;
                        name = name in cache ? [ name ] : name.match(rnotwhite) || [];
                    }
                }
                i = name.length;
                while (i--) {
                    delete cache[name[i]];
                }
            }
            if (key === undefined || jQuery.isEmptyObject(cache)) {
                if (owner.nodeType) {
                    owner[this.expando] = undefined;
                } else {
                    delete owner[this.expando];
                }
            }
        },
        hasData: function(owner) {
            var cache = owner[this.expando];
            return cache !== undefined && !jQuery.isEmptyObject(cache);
        }
    };
    var dataPriv = new Data();
    var dataUser = new Data();
    var rbrace = /^(?:\{[\w\W]*\}|\[[\w\W]*\])$/, rmultiDash = /[A-Z]/g;
    function dataAttr(elem, key, data) {
        var name;
        if (data === undefined && elem.nodeType === 1) {
            name = "data-" + key.replace(rmultiDash, "-$&").toLowerCase();
            data = elem.getAttribute(name);
            if (typeof data === "string") {
                try {
                    data = data === "true" ? true : data === "false" ? false : data === "null" ? null : +data + "" === data ? +data : rbrace.test(data) ? jQuery.parseJSON(data) : data;
                } catch (e) {}
                dataUser.set(elem, key, data);
            } else {
                data = undefined;
            }
        }
        return data;
    }
    jQuery.extend({
        hasData: function(elem) {
            return dataUser.hasData(elem) || dataPriv.hasData(elem);
        },
        data: function(elem, name, data) {
            return dataUser.access(elem, name, data);
        },
        removeData: function(elem, name) {
            dataUser.remove(elem, name);
        },
        _data: function(elem, name, data) {
            return dataPriv.access(elem, name, data);
        },
        _removeData: function(elem, name) {
            dataPriv.remove(elem, name);
        }
    });
    jQuery.fn.extend({
        data: function(key, value) {
            var i, name, data, elem = this[0], attrs = elem && elem.attributes;
            if (key === undefined) {
                if (this.length) {
                    data = dataUser.get(elem);
                    if (elem.nodeType === 1 && !dataPriv.get(elem, "hasDataAttrs")) {
                        i = attrs.length;
                        while (i--) {
                            if (attrs[i]) {
                                name = attrs[i].name;
                                if (name.indexOf("data-") === 0) {
                                    name = jQuery.camelCase(name.slice(5));
                                    dataAttr(elem, name, data[name]);
                                }
                            }
                        }
                        dataPriv.set(elem, "hasDataAttrs", true);
                    }
                }
                return data;
            }
            if (typeof key === "object") {
                return this.each(function() {
                    dataUser.set(this, key);
                });
            }
            return access(this, function(value) {
                var data, camelKey;
                if (elem && value === undefined) {
                    data = dataUser.get(elem, key) || dataUser.get(elem, key.replace(rmultiDash, "-$&").toLowerCase());
                    if (data !== undefined) {
                        return data;
                    }
                    camelKey = jQuery.camelCase(key);
                    data = dataUser.get(elem, camelKey);
                    if (data !== undefined) {
                        return data;
                    }
                    data = dataAttr(elem, camelKey, undefined);
                    if (data !== undefined) {
                        return data;
                    }
                    return;
                }
                camelKey = jQuery.camelCase(key);
                this.each(function() {
                    var data = dataUser.get(this, camelKey);
                    dataUser.set(this, camelKey, value);
                    if (key.indexOf("-") > -1 && data !== undefined) {
                        dataUser.set(this, key, value);
                    }
                });
            }, null, value, arguments.length > 1, null, true);
        },
        removeData: function(key) {
            return this.each(function() {
                dataUser.remove(this, key);
            });
        }
    });
    jQuery.extend({
        queue: function(elem, type, data) {
            var queue;
            if (elem) {
                type = (type || "fx") + "queue";
                queue = dataPriv.get(elem, type);
                if (data) {
                    if (!queue || jQuery.isArray(data)) {
                        queue = dataPriv.access(elem, type, jQuery.makeArray(data));
                    } else {
                        queue.push(data);
                    }
                }
                return queue || [];
            }
        },
        dequeue: function(elem, type) {
            type = type || "fx";
            var queue = jQuery.queue(elem, type), startLength = queue.length, fn = queue.shift(), hooks = jQuery._queueHooks(elem, type), next = function() {
                jQuery.dequeue(elem, type);
            };
            if (fn === "inprogress") {
                fn = queue.shift();
                startLength--;
            }
            if (fn) {
                if (type === "fx") {
                    queue.unshift("inprogress");
                }
                delete hooks.stop;
                fn.call(elem, next, hooks);
            }
            if (!startLength && hooks) {
                hooks.empty.fire();
            }
        },
        _queueHooks: function(elem, type) {
            var key = type + "queueHooks";
            return dataPriv.get(elem, key) || dataPriv.access(elem, key, {
                empty: jQuery.Callbacks("once memory").add(function() {
                    dataPriv.remove(elem, [ type + "queue", key ]);
                })
            });
        }
    });
    jQuery.fn.extend({
        queue: function(type, data) {
            var setter = 2;
            if (typeof type !== "string") {
                data = type;
                type = "fx";
                setter--;
            }
            if (arguments.length < setter) {
                return jQuery.queue(this[0], type);
            }
            return data === undefined ? this : this.each(function() {
                var queue = jQuery.queue(this, type, data);
                jQuery._queueHooks(this, type);
                if (type === "fx" && queue[0] !== "inprogress") {
                    jQuery.dequeue(this, type);
                }
            });
        },
        dequeue: function(type) {
            return this.each(function() {
                jQuery.dequeue(this, type);
            });
        },
        clearQueue: function(type) {
            return this.queue(type || "fx", []);
        },
        promise: function(type, obj) {
            var tmp, count = 1, defer = jQuery.Deferred(), elements = this, i = this.length, resolve = function() {
                if (!--count) {
                    defer.resolveWith(elements, [ elements ]);
                }
            };
            if (typeof type !== "string") {
                obj = type;
                type = undefined;
            }
            type = type || "fx";
            while (i--) {
                tmp = dataPriv.get(elements[i], type + "queueHooks");
                if (tmp && tmp.empty) {
                    count++;
                    tmp.empty.add(resolve);
                }
            }
            resolve();
            return defer.promise(obj);
        }
    });
    var pnum = /[+-]?(?:\d*\.|)\d+(?:[eE][+-]?\d+|)/.source;
    var rcssNum = new RegExp("^(?:([+-])=|)(" + pnum + ")([a-z%]*)$", "i");
    var cssExpand = [ "Top", "Right", "Bottom", "Left" ];
    var isHidden = function(elem, el) {
        elem = el || elem;
        return jQuery.css(elem, "display") === "none" || !jQuery.contains(elem.ownerDocument, elem);
    };
    function adjustCSS(elem, prop, valueParts, tween) {
        var adjusted, scale = 1, maxIterations = 20, currentValue = tween ? function() {
            return tween.cur();
        } : function() {
            return jQuery.css(elem, prop, "");
        }, initial = currentValue(), unit = valueParts && valueParts[3] || (jQuery.cssNumber[prop] ? "" : "px"), initialInUnit = (jQuery.cssNumber[prop] || unit !== "px" && +initial) && rcssNum.exec(jQuery.css(elem, prop));
        if (initialInUnit && initialInUnit[3] !== unit) {
            unit = unit || initialInUnit[3];
            valueParts = valueParts || [];
            initialInUnit = +initial || 1;
            do {
                scale = scale || ".5";
                initialInUnit = initialInUnit / scale;
                jQuery.style(elem, prop, initialInUnit + unit);
            } while (scale !== (scale = currentValue() / initial) && scale !== 1 && --maxIterations);
        }
        if (valueParts) {
            initialInUnit = +initialInUnit || +initial || 0;
            adjusted = valueParts[1] ? initialInUnit + (valueParts[1] + 1) * valueParts[2] : +valueParts[2];
            if (tween) {
                tween.unit = unit;
                tween.start = initialInUnit;
                tween.end = adjusted;
            }
        }
        return adjusted;
    }
    var rcheckableType = /^(?:checkbox|radio)$/i;
    var rtagName = /<([\w:-]+)/;
    var rscriptType = /^$|\/(?:java|ecma)script/i;
    var wrapMap = {
        option: [ 1, "<select multiple='multiple'>", "</select>" ],
        thead: [ 1, "<table>", "</table>" ],
        col: [ 2, "<table><colgroup>", "</colgroup></table>" ],
        tr: [ 2, "<table><tbody>", "</tbody></table>" ],
        td: [ 3, "<table><tbody><tr>", "</tr></tbody></table>" ],
        _default: [ 0, "", "" ]
    };
    wrapMap.optgroup = wrapMap.option;
    wrapMap.tbody = wrapMap.tfoot = wrapMap.colgroup = wrapMap.caption = wrapMap.thead;
    wrapMap.th = wrapMap.td;
    function getAll(context, tag) {
        var ret = typeof context.getElementsByTagName !== "undefined" ? context.getElementsByTagName(tag || "*") : typeof context.querySelectorAll !== "undefined" ? context.querySelectorAll(tag || "*") : [];
        return tag === undefined || tag && jQuery.nodeName(context, tag) ? jQuery.merge([ context ], ret) : ret;
    }
    function setGlobalEval(elems, refElements) {
        var i = 0, l = elems.length;
        for (;i < l; i++) {
            dataPriv.set(elems[i], "globalEval", !refElements || dataPriv.get(refElements[i], "globalEval"));
        }
    }
    var rhtml = /<|&#?\w+;/;
    function buildFragment(elems, context, scripts, selection, ignored) {
        var elem, tmp, tag, wrap, contains, j, fragment = context.createDocumentFragment(), nodes = [], i = 0, l = elems.length;
        for (;i < l; i++) {
            elem = elems[i];
            if (elem || elem === 0) {
                if (jQuery.type(elem) === "object") {
                    jQuery.merge(nodes, elem.nodeType ? [ elem ] : elem);
                } else if (!rhtml.test(elem)) {
                    nodes.push(context.createTextNode(elem));
                } else {
                    tmp = tmp || fragment.appendChild(context.createElement("div"));
                    tag = (rtagName.exec(elem) || [ "", "" ])[1].toLowerCase();
                    wrap = wrapMap[tag] || wrapMap._default;
                    tmp.innerHTML = wrap[1] + jQuery.htmlPrefilter(elem) + wrap[2];
                    j = wrap[0];
                    while (j--) {
                        tmp = tmp.lastChild;
                    }
                    jQuery.merge(nodes, tmp.childNodes);
                    tmp = fragment.firstChild;
                    tmp.textContent = "";
                }
            }
        }
        fragment.textContent = "";
        i = 0;
        while (elem = nodes[i++]) {
            if (selection && jQuery.inArray(elem, selection) > -1) {
                if (ignored) {
                    ignored.push(elem);
                }
                continue;
            }
            contains = jQuery.contains(elem.ownerDocument, elem);
            tmp = getAll(fragment.appendChild(elem), "script");
            if (contains) {
                setGlobalEval(tmp);
            }
            if (scripts) {
                j = 0;
                while (elem = tmp[j++]) {
                    if (rscriptType.test(elem.type || "")) {
                        scripts.push(elem);
                    }
                }
            }
        }
        return fragment;
    }
    (function() {
        var fragment = document.createDocumentFragment(), div = fragment.appendChild(document.createElement("div")), input = document.createElement("input");
        input.setAttribute("type", "radio");
        input.setAttribute("checked", "checked");
        input.setAttribute("name", "t");
        div.appendChild(input);
        support.checkClone = div.cloneNode(true).cloneNode(true).lastChild.checked;
        div.innerHTML = "<textarea>x</textarea>";
        support.noCloneChecked = !!div.cloneNode(true).lastChild.defaultValue;
    })();
    var rkeyEvent = /^key/, rmouseEvent = /^(?:mouse|pointer|contextmenu|drag|drop)|click/, rtypenamespace = /^([^.]*)(?:\.(.+)|)/;
    function returnTrue() {
        return true;
    }
    function returnFalse() {
        return false;
    }
    function safeActiveElement() {
        try {
            return document.activeElement;
        } catch (err) {}
    }
    function on(elem, types, selector, data, fn, one) {
        var origFn, type;
        if (typeof types === "object") {
            if (typeof selector !== "string") {
                data = data || selector;
                selector = undefined;
            }
            for (type in types) {
                on(elem, type, selector, data, types[type], one);
            }
            return elem;
        }
        if (data == null && fn == null) {
            fn = selector;
            data = selector = undefined;
        } else if (fn == null) {
            if (typeof selector === "string") {
                fn = data;
                data = undefined;
            } else {
                fn = data;
                data = selector;
                selector = undefined;
            }
        }
        if (fn === false) {
            fn = returnFalse;
        } else if (!fn) {
            return elem;
        }
        if (one === 1) {
            origFn = fn;
            fn = function(event) {
                jQuery().off(event);
                return origFn.apply(this, arguments);
            };
            fn.guid = origFn.guid || (origFn.guid = jQuery.guid++);
        }
        return elem.each(function() {
            jQuery.event.add(this, types, fn, data, selector);
        });
    }
    jQuery.event = {
        global: {},
        add: function(elem, types, handler, data, selector) {
            var handleObjIn, eventHandle, tmp, events, t, handleObj, special, handlers, type, namespaces, origType, elemData = dataPriv.get(elem);
            if (!elemData) {
                return;
            }
            if (handler.handler) {
                handleObjIn = handler;
                handler = handleObjIn.handler;
                selector = handleObjIn.selector;
            }
            if (!handler.guid) {
                handler.guid = jQuery.guid++;
            }
            if (!(events = elemData.events)) {
                events = elemData.events = {};
            }
            if (!(eventHandle = elemData.handle)) {
                eventHandle = elemData.handle = function(e) {
                    return typeof jQuery !== "undefined" && jQuery.event.triggered !== e.type ? jQuery.event.dispatch.apply(elem, arguments) : undefined;
                };
            }
            types = (types || "").match(rnotwhite) || [ "" ];
            t = types.length;
            while (t--) {
                tmp = rtypenamespace.exec(types[t]) || [];
                type = origType = tmp[1];
                namespaces = (tmp[2] || "").split(".").sort();
                if (!type) {
                    continue;
                }
                special = jQuery.event.special[type] || {};
                type = (selector ? special.delegateType : special.bindType) || type;
                special = jQuery.event.special[type] || {};
                handleObj = jQuery.extend({
                    type: type,
                    origType: origType,
                    data: data,
                    handler: handler,
                    guid: handler.guid,
                    selector: selector,
                    needsContext: selector && jQuery.expr.match.needsContext.test(selector),
                    namespace: namespaces.join(".")
                }, handleObjIn);
                if (!(handlers = events[type])) {
                    handlers = events[type] = [];
                    handlers.delegateCount = 0;
                    if (!special.setup || special.setup.call(elem, data, namespaces, eventHandle) === false) {
                        if (elem.addEventListener) {
                            elem.addEventListener(type, eventHandle);
                        }
                    }
                }
                if (special.add) {
                    special.add.call(elem, handleObj);
                    if (!handleObj.handler.guid) {
                        handleObj.handler.guid = handler.guid;
                    }
                }
                if (selector) {
                    handlers.splice(handlers.delegateCount++, 0, handleObj);
                } else {
                    handlers.push(handleObj);
                }
                jQuery.event.global[type] = true;
            }
        },
        remove: function(elem, types, handler, selector, mappedTypes) {
            var j, origCount, tmp, events, t, handleObj, special, handlers, type, namespaces, origType, elemData = dataPriv.hasData(elem) && dataPriv.get(elem);
            if (!elemData || !(events = elemData.events)) {
                return;
            }
            types = (types || "").match(rnotwhite) || [ "" ];
            t = types.length;
            while (t--) {
                tmp = rtypenamespace.exec(types[t]) || [];
                type = origType = tmp[1];
                namespaces = (tmp[2] || "").split(".").sort();
                if (!type) {
                    for (type in events) {
                        jQuery.event.remove(elem, type + types[t], handler, selector, true);
                    }
                    continue;
                }
                special = jQuery.event.special[type] || {};
                type = (selector ? special.delegateType : special.bindType) || type;
                handlers = events[type] || [];
                tmp = tmp[2] && new RegExp("(^|\\.)" + namespaces.join("\\.(?:.*\\.|)") + "(\\.|$)");
                origCount = j = handlers.length;
                while (j--) {
                    handleObj = handlers[j];
                    if ((mappedTypes || origType === handleObj.origType) && (!handler || handler.guid === handleObj.guid) && (!tmp || tmp.test(handleObj.namespace)) && (!selector || selector === handleObj.selector || selector === "**" && handleObj.selector)) {
                        handlers.splice(j, 1);
                        if (handleObj.selector) {
                            handlers.delegateCount--;
                        }
                        if (special.remove) {
                            special.remove.call(elem, handleObj);
                        }
                    }
                }
                if (origCount && !handlers.length) {
                    if (!special.teardown || special.teardown.call(elem, namespaces, elemData.handle) === false) {
                        jQuery.removeEvent(elem, type, elemData.handle);
                    }
                    delete events[type];
                }
            }
            if (jQuery.isEmptyObject(events)) {
                dataPriv.remove(elem, "handle events");
            }
        },
        dispatch: function(event) {
            event = jQuery.event.fix(event);
            var i, j, ret, matched, handleObj, handlerQueue = [], args = slice.call(arguments), handlers = (dataPriv.get(this, "events") || {})[event.type] || [], special = jQuery.event.special[event.type] || {};
            args[0] = event;
            event.delegateTarget = this;
            if (special.preDispatch && special.preDispatch.call(this, event) === false) {
                return;
            }
            handlerQueue = jQuery.event.handlers.call(this, event, handlers);
            i = 0;
            while ((matched = handlerQueue[i++]) && !event.isPropagationStopped()) {
                event.currentTarget = matched.elem;
                j = 0;
                while ((handleObj = matched.handlers[j++]) && !event.isImmediatePropagationStopped()) {
                    if (!event.rnamespace || event.rnamespace.test(handleObj.namespace)) {
                        event.handleObj = handleObj;
                        event.data = handleObj.data;
                        ret = ((jQuery.event.special[handleObj.origType] || {}).handle || handleObj.handler).apply(matched.elem, args);
                        if (ret !== undefined) {
                            if ((event.result = ret) === false) {
                                event.preventDefault();
                                event.stopPropagation();
                            }
                        }
                    }
                }
            }
            if (special.postDispatch) {
                special.postDispatch.call(this, event);
            }
            return event.result;
        },
        handlers: function(event, handlers) {
            var i, matches, sel, handleObj, handlerQueue = [], delegateCount = handlers.delegateCount, cur = event.target;
            if (delegateCount && cur.nodeType && (event.type !== "click" || isNaN(event.button) || event.button < 1)) {
                for (;cur !== this; cur = cur.parentNode || this) {
                    if (cur.nodeType === 1 && (cur.disabled !== true || event.type !== "click")) {
                        matches = [];
                        for (i = 0; i < delegateCount; i++) {
                            handleObj = handlers[i];
                            sel = handleObj.selector + " ";
                            if (matches[sel] === undefined) {
                                matches[sel] = handleObj.needsContext ? jQuery(sel, this).index(cur) > -1 : jQuery.find(sel, this, null, [ cur ]).length;
                            }
                            if (matches[sel]) {
                                matches.push(handleObj);
                            }
                        }
                        if (matches.length) {
                            handlerQueue.push({
                                elem: cur,
                                handlers: matches
                            });
                        }
                    }
                }
            }
            if (delegateCount < handlers.length) {
                handlerQueue.push({
                    elem: this,
                    handlers: handlers.slice(delegateCount)
                });
            }
            return handlerQueue;
        },
        props: ("altKey bubbles cancelable ctrlKey currentTarget detail eventPhase " + "metaKey relatedTarget shiftKey target timeStamp view which").split(" "),
        fixHooks: {},
        keyHooks: {
            props: "char charCode key keyCode".split(" "),
            filter: function(event, original) {
                if (event.which == null) {
                    event.which = original.charCode != null ? original.charCode : original.keyCode;
                }
                return event;
            }
        },
        mouseHooks: {
            props: ("button buttons clientX clientY offsetX offsetY pageX pageY " + "screenX screenY toElement").split(" "),
            filter: function(event, original) {
                var eventDoc, doc, body, button = original.button;
                if (event.pageX == null && original.clientX != null) {
                    eventDoc = event.target.ownerDocument || document;
                    doc = eventDoc.documentElement;
                    body = eventDoc.body;
                    event.pageX = original.clientX + (doc && doc.scrollLeft || body && body.scrollLeft || 0) - (doc && doc.clientLeft || body && body.clientLeft || 0);
                    event.pageY = original.clientY + (doc && doc.scrollTop || body && body.scrollTop || 0) - (doc && doc.clientTop || body && body.clientTop || 0);
                }
                if (!event.which && button !== undefined) {
                    event.which = button & 1 ? 1 : button & 2 ? 3 : button & 4 ? 2 : 0;
                }
                return event;
            }
        },
        fix: function(event) {
            if (event[jQuery.expando]) {
                return event;
            }
            var i, prop, copy, type = event.type, originalEvent = event, fixHook = this.fixHooks[type];
            if (!fixHook) {
                this.fixHooks[type] = fixHook = rmouseEvent.test(type) ? this.mouseHooks : rkeyEvent.test(type) ? this.keyHooks : {};
            }
            copy = fixHook.props ? this.props.concat(fixHook.props) : this.props;
            event = new jQuery.Event(originalEvent);
            i = copy.length;
            while (i--) {
                prop = copy[i];
                event[prop] = originalEvent[prop];
            }
            if (!event.target) {
                event.target = document;
            }
            if (event.target.nodeType === 3) {
                event.target = event.target.parentNode;
            }
            return fixHook.filter ? fixHook.filter(event, originalEvent) : event;
        },
        special: {
            load: {
                noBubble: true
            },
            focus: {
                trigger: function() {
                    if (this !== safeActiveElement() && this.focus) {
                        this.focus();
                        return false;
                    }
                },
                delegateType: "focusin"
            },
            blur: {
                trigger: function() {
                    if (this === safeActiveElement() && this.blur) {
                        this.blur();
                        return false;
                    }
                },
                delegateType: "focusout"
            },
            click: {
                trigger: function() {
                    if (this.type === "checkbox" && this.click && jQuery.nodeName(this, "input")) {
                        this.click();
                        return false;
                    }
                },
                _default: function(event) {
                    return jQuery.nodeName(event.target, "a");
                }
            },
            beforeunload: {
                postDispatch: function(event) {
                    if (event.result !== undefined && event.originalEvent) {
                        event.originalEvent.returnValue = event.result;
                    }
                }
            }
        }
    };
    jQuery.removeEvent = function(elem, type, handle) {
        if (elem.removeEventListener) {
            elem.removeEventListener(type, handle);
        }
    };
    jQuery.Event = function(src, props) {
        if (!(this instanceof jQuery.Event)) {
            return new jQuery.Event(src, props);
        }
        if (src && src.type) {
            this.originalEvent = src;
            this.type = src.type;
            this.isDefaultPrevented = src.defaultPrevented || src.defaultPrevented === undefined && src.returnValue === false ? returnTrue : returnFalse;
        } else {
            this.type = src;
        }
        if (props) {
            jQuery.extend(this, props);
        }
        this.timeStamp = src && src.timeStamp || jQuery.now();
        this[jQuery.expando] = true;
    };
    jQuery.Event.prototype = {
        constructor: jQuery.Event,
        isDefaultPrevented: returnFalse,
        isPropagationStopped: returnFalse,
        isImmediatePropagationStopped: returnFalse,
        isSimulated: false,
        preventDefault: function() {
            var e = this.originalEvent;
            this.isDefaultPrevented = returnTrue;
            if (e && !this.isSimulated) {
                e.preventDefault();
            }
        },
        stopPropagation: function() {
            var e = this.originalEvent;
            this.isPropagationStopped = returnTrue;
            if (e && !this.isSimulated) {
                e.stopPropagation();
            }
        },
        stopImmediatePropagation: function() {
            var e = this.originalEvent;
            this.isImmediatePropagationStopped = returnTrue;
            if (e && !this.isSimulated) {
                e.stopImmediatePropagation();
            }
            this.stopPropagation();
        }
    };
    jQuery.each({
        mouseenter: "mouseover",
        mouseleave: "mouseout",
        pointerenter: "pointerover",
        pointerleave: "pointerout"
    }, function(orig, fix) {
        jQuery.event.special[orig] = {
            delegateType: fix,
            bindType: fix,
            handle: function(event) {
                var ret, target = this, related = event.relatedTarget, handleObj = event.handleObj;
                if (!related || related !== target && !jQuery.contains(target, related)) {
                    event.type = handleObj.origType;
                    ret = handleObj.handler.apply(this, arguments);
                    event.type = fix;
                }
                return ret;
            }
        };
    });
    jQuery.fn.extend({
        on: function(types, selector, data, fn) {
            return on(this, types, selector, data, fn);
        },
        one: function(types, selector, data, fn) {
            return on(this, types, selector, data, fn, 1);
        },
        off: function(types, selector, fn) {
            var handleObj, type;
            if (types && types.preventDefault && types.handleObj) {
                handleObj = types.handleObj;
                jQuery(types.delegateTarget).off(handleObj.namespace ? handleObj.origType + "." + handleObj.namespace : handleObj.origType, handleObj.selector, handleObj.handler);
                return this;
            }
            if (typeof types === "object") {
                for (type in types) {
                    this.off(type, selector, types[type]);
                }
                return this;
            }
            if (selector === false || typeof selector === "function") {
                fn = selector;
                selector = undefined;
            }
            if (fn === false) {
                fn = returnFalse;
            }
            return this.each(function() {
                jQuery.event.remove(this, types, fn, selector);
            });
        }
    });
    var rxhtmlTag = /<(?!area|br|col|embed|hr|img|input|link|meta|param)(([\w:-]+)[^>]*)\/>/gi, rnoInnerhtml = /<script|<style|<link/i, rchecked = /checked\s*(?:[^=]|=\s*.checked.)/i, rscriptTypeMasked = /^true\/(.*)/, rcleanScript = /^\s*<!(?:\[CDATA\[|--)|(?:\]\]|--)>\s*$/g;
    function manipulationTarget(elem, content) {
        return jQuery.nodeName(elem, "table") && jQuery.nodeName(content.nodeType !== 11 ? content : content.firstChild, "tr") ? elem.getElementsByTagName("tbody")[0] || elem.appendChild(elem.ownerDocument.createElement("tbody")) : elem;
    }
    function disableScript(elem) {
        elem.type = (elem.getAttribute("type") !== null) + "/" + elem.type;
        return elem;
    }
    function restoreScript(elem) {
        var match = rscriptTypeMasked.exec(elem.type);
        if (match) {
            elem.type = match[1];
        } else {
            elem.removeAttribute("type");
        }
        return elem;
    }
    function cloneCopyEvent(src, dest) {
        var i, l, type, pdataOld, pdataCur, udataOld, udataCur, events;
        if (dest.nodeType !== 1) {
            return;
        }
        if (dataPriv.hasData(src)) {
            pdataOld = dataPriv.access(src);
            pdataCur = dataPriv.set(dest, pdataOld);
            events = pdataOld.events;
            if (events) {
                delete pdataCur.handle;
                pdataCur.events = {};
                for (type in events) {
                    for (i = 0, l = events[type].length; i < l; i++) {
                        jQuery.event.add(dest, type, events[type][i]);
                    }
                }
            }
        }
        if (dataUser.hasData(src)) {
            udataOld = dataUser.access(src);
            udataCur = jQuery.extend({}, udataOld);
            dataUser.set(dest, udataCur);
        }
    }
    function fixInput(src, dest) {
        var nodeName = dest.nodeName.toLowerCase();
        if (nodeName === "input" && rcheckableType.test(src.type)) {
            dest.checked = src.checked;
        } else if (nodeName === "input" || nodeName === "textarea") {
            dest.defaultValue = src.defaultValue;
        }
    }
    function domManip(collection, args, callback, ignored) {
        args = concat.apply([], args);
        var fragment, first, scripts, hasScripts, node, doc, i = 0, l = collection.length, iNoClone = l - 1, value = args[0], isFunction = jQuery.isFunction(value);
        if (isFunction || l > 1 && typeof value === "string" && !support.checkClone && rchecked.test(value)) {
            return collection.each(function(index) {
                var self = collection.eq(index);
                if (isFunction) {
                    args[0] = value.call(this, index, self.html());
                }
                domManip(self, args, callback, ignored);
            });
        }
        if (l) {
            fragment = buildFragment(args, collection[0].ownerDocument, false, collection, ignored);
            first = fragment.firstChild;
            if (fragment.childNodes.length === 1) {
                fragment = first;
            }
            if (first || ignored) {
                scripts = jQuery.map(getAll(fragment, "script"), disableScript);
                hasScripts = scripts.length;
                for (;i < l; i++) {
                    node = fragment;
                    if (i !== iNoClone) {
                        node = jQuery.clone(node, true, true);
                        if (hasScripts) {
                            jQuery.merge(scripts, getAll(node, "script"));
                        }
                    }
                    callback.call(collection[i], node, i);
                }
                if (hasScripts) {
                    doc = scripts[scripts.length - 1].ownerDocument;
                    jQuery.map(scripts, restoreScript);
                    for (i = 0; i < hasScripts; i++) {
                        node = scripts[i];
                        if (rscriptType.test(node.type || "") && !dataPriv.access(node, "globalEval") && jQuery.contains(doc, node)) {
                            if (node.src) {
                                if (jQuery._evalUrl) {
                                    jQuery._evalUrl(node.src);
                                }
                            } else {
                                jQuery.globalEval(node.textContent.replace(rcleanScript, ""));
                            }
                        }
                    }
                }
            }
        }
        return collection;
    }
    function remove(elem, selector, keepData) {
        var node, nodes = selector ? jQuery.filter(selector, elem) : elem, i = 0;
        for (;(node = nodes[i]) != null; i++) {
            if (!keepData && node.nodeType === 1) {
                jQuery.cleanData(getAll(node));
            }
            if (node.parentNode) {
                if (keepData && jQuery.contains(node.ownerDocument, node)) {
                    setGlobalEval(getAll(node, "script"));
                }
                node.parentNode.removeChild(node);
            }
        }
        return elem;
    }
    jQuery.extend({
        htmlPrefilter: function(html) {
            return html.replace(rxhtmlTag, "<$1></$2>");
        },
        clone: function(elem, dataAndEvents, deepDataAndEvents) {
            var i, l, srcElements, destElements, clone = elem.cloneNode(true), inPage = jQuery.contains(elem.ownerDocument, elem);
            if (!support.noCloneChecked && (elem.nodeType === 1 || elem.nodeType === 11) && !jQuery.isXMLDoc(elem)) {
                destElements = getAll(clone);
                srcElements = getAll(elem);
                for (i = 0, l = srcElements.length; i < l; i++) {
                    fixInput(srcElements[i], destElements[i]);
                }
            }
            if (dataAndEvents) {
                if (deepDataAndEvents) {
                    srcElements = srcElements || getAll(elem);
                    destElements = destElements || getAll(clone);
                    for (i = 0, l = srcElements.length; i < l; i++) {
                        cloneCopyEvent(srcElements[i], destElements[i]);
                    }
                } else {
                    cloneCopyEvent(elem, clone);
                }
            }
            destElements = getAll(clone, "script");
            if (destElements.length > 0) {
                setGlobalEval(destElements, !inPage && getAll(elem, "script"));
            }
            return clone;
        },
        cleanData: function(elems) {
            var data, elem, type, special = jQuery.event.special, i = 0;
            for (;(elem = elems[i]) !== undefined; i++) {
                if (acceptData(elem)) {
                    if (data = elem[dataPriv.expando]) {
                        if (data.events) {
                            for (type in data.events) {
                                if (special[type]) {
                                    jQuery.event.remove(elem, type);
                                } else {
                                    jQuery.removeEvent(elem, type, data.handle);
                                }
                            }
                        }
                        elem[dataPriv.expando] = undefined;
                    }
                    if (elem[dataUser.expando]) {
                        elem[dataUser.expando] = undefined;
                    }
                }
            }
        }
    });
    jQuery.fn.extend({
        domManip: domManip,
        detach: function(selector) {
            return remove(this, selector, true);
        },
        remove: function(selector) {
            return remove(this, selector);
        },
        text: function(value) {
            return access(this, function(value) {
                return value === undefined ? jQuery.text(this) : this.empty().each(function() {
                    if (this.nodeType === 1 || this.nodeType === 11 || this.nodeType === 9) {
                        this.textContent = value;
                    }
                });
            }, null, value, arguments.length);
        },
        append: function() {
            return domManip(this, arguments, function(elem) {
                if (this.nodeType === 1 || this.nodeType === 11 || this.nodeType === 9) {
                    var target = manipulationTarget(this, elem);
                    target.appendChild(elem);
                }
            });
        },
        prepend: function() {
            return domManip(this, arguments, function(elem) {
                if (this.nodeType === 1 || this.nodeType === 11 || this.nodeType === 9) {
                    var target = manipulationTarget(this, elem);
                    target.insertBefore(elem, target.firstChild);
                }
            });
        },
        before: function() {
            return domManip(this, arguments, function(elem) {
                if (this.parentNode) {
                    this.parentNode.insertBefore(elem, this);
                }
            });
        },
        after: function() {
            return domManip(this, arguments, function(elem) {
                if (this.parentNode) {
                    this.parentNode.insertBefore(elem, this.nextSibling);
                }
            });
        },
        empty: function() {
            var elem, i = 0;
            for (;(elem = this[i]) != null; i++) {
                if (elem.nodeType === 1) {
                    jQuery.cleanData(getAll(elem, false));
                    elem.textContent = "";
                }
            }
            return this;
        },
        clone: function(dataAndEvents, deepDataAndEvents) {
            dataAndEvents = dataAndEvents == null ? false : dataAndEvents;
            deepDataAndEvents = deepDataAndEvents == null ? dataAndEvents : deepDataAndEvents;
            return this.map(function() {
                return jQuery.clone(this, dataAndEvents, deepDataAndEvents);
            });
        },
        html: function(value) {
            return access(this, function(value) {
                var elem = this[0] || {}, i = 0, l = this.length;
                if (value === undefined && elem.nodeType === 1) {
                    return elem.innerHTML;
                }
                if (typeof value === "string" && !rnoInnerhtml.test(value) && !wrapMap[(rtagName.exec(value) || [ "", "" ])[1].toLowerCase()]) {
                    value = jQuery.htmlPrefilter(value);
                    try {
                        for (;i < l; i++) {
                            elem = this[i] || {};
                            if (elem.nodeType === 1) {
                                jQuery.cleanData(getAll(elem, false));
                                elem.innerHTML = value;
                            }
                        }
                        elem = 0;
                    } catch (e) {}
                }
                if (elem) {
                    this.empty().append(value);
                }
            }, null, value, arguments.length);
        },
        replaceWith: function() {
            var ignored = [];
            return domManip(this, arguments, function(elem) {
                var parent = this.parentNode;
                if (jQuery.inArray(this, ignored) < 0) {
                    jQuery.cleanData(getAll(this));
                    if (parent) {
                        parent.replaceChild(elem, this);
                    }
                }
            }, ignored);
        }
    });
    jQuery.each({
        appendTo: "append",
        prependTo: "prepend",
        insertBefore: "before",
        insertAfter: "after",
        replaceAll: "replaceWith"
    }, function(name, original) {
        jQuery.fn[name] = function(selector) {
            var elems, ret = [], insert = jQuery(selector), last = insert.length - 1, i = 0;
            for (;i <= last; i++) {
                elems = i === last ? this : this.clone(true);
                jQuery(insert[i])[original](elems);
                push.apply(ret, elems.get());
            }
            return this.pushStack(ret);
        };
    });
    var iframe, elemdisplay = {
        HTML: "block",
        BODY: "block"
    };
    function actualDisplay(name, doc) {
        var elem = jQuery(doc.createElement(name)).appendTo(doc.body), display = jQuery.css(elem[0], "display");
        elem.detach();
        return display;
    }
    function defaultDisplay(nodeName) {
        var doc = document, display = elemdisplay[nodeName];
        if (!display) {
            display = actualDisplay(nodeName, doc);
            if (display === "none" || !display) {
                iframe = (iframe || jQuery("<iframe frameborder='0' width='0' height='0'/>")).appendTo(doc.documentElement);
                doc = iframe[0].contentDocument;
                doc.write();
                doc.close();
                display = actualDisplay(nodeName, doc);
                iframe.detach();
            }
            elemdisplay[nodeName] = display;
        }
        return display;
    }
    var rmargin = /^margin/;
    var rnumnonpx = new RegExp("^(" + pnum + ")(?!px)[a-z%]+$", "i");
    var getStyles = function(elem) {
        var view = elem.ownerDocument.defaultView;
        if (!view || !view.opener) {
            view = window;
        }
        return view.getComputedStyle(elem);
    };
    var swap = function(elem, options, callback, args) {
        var ret, name, old = {};
        for (name in options) {
            old[name] = elem.style[name];
            elem.style[name] = options[name];
        }
        ret = callback.apply(elem, args || []);
        for (name in options) {
            elem.style[name] = old[name];
        }
        return ret;
    };
    var documentElement = document.documentElement;
    (function() {
        var pixelPositionVal, boxSizingReliableVal, pixelMarginRightVal, reliableMarginLeftVal, container = document.createElement("div"), div = document.createElement("div");
        if (!div.style) {
            return;
        }
        div.style.backgroundClip = "content-box";
        div.cloneNode(true).style.backgroundClip = "";
        support.clearCloneStyle = div.style.backgroundClip === "content-box";
        container.style.cssText = "border:0;width:8px;height:0;top:0;left:-9999px;" + "padding:0;margin-top:1px;position:absolute";
        container.appendChild(div);
        function computeStyleTests() {
            div.style.cssText = "-webkit-box-sizing:border-box;-moz-box-sizing:border-box;box-sizing:border-box;" + "position:relative;display:block;" + "margin:auto;border:1px;padding:1px;" + "top:1%;width:50%";
            div.innerHTML = "";
            documentElement.appendChild(container);
            var divStyle = window.getComputedStyle(div);
            pixelPositionVal = divStyle.top !== "1%";
            reliableMarginLeftVal = divStyle.marginLeft === "2px";
            boxSizingReliableVal = divStyle.width === "4px";
            div.style.marginRight = "50%";
            pixelMarginRightVal = divStyle.marginRight === "4px";
            documentElement.removeChild(container);
        }
        jQuery.extend(support, {
            pixelPosition: function() {
                computeStyleTests();
                return pixelPositionVal;
            },
            boxSizingReliable: function() {
                if (boxSizingReliableVal == null) {
                    computeStyleTests();
                }
                return boxSizingReliableVal;
            },
            pixelMarginRight: function() {
                if (boxSizingReliableVal == null) {
                    computeStyleTests();
                }
                return pixelMarginRightVal;
            },
            reliableMarginLeft: function() {
                if (boxSizingReliableVal == null) {
                    computeStyleTests();
                }
                return reliableMarginLeftVal;
            },
            reliableMarginRight: function() {
                var ret, marginDiv = div.appendChild(document.createElement("div"));
                marginDiv.style.cssText = div.style.cssText = "-webkit-box-sizing:content-box;box-sizing:content-box;" + "display:block;margin:0;border:0;padding:0";
                marginDiv.style.marginRight = marginDiv.style.width = "0";
                div.style.width = "1px";
                documentElement.appendChild(container);
                ret = !parseFloat(window.getComputedStyle(marginDiv).marginRight);
                documentElement.removeChild(container);
                div.removeChild(marginDiv);
                return ret;
            }
        });
    })();
    function curCSS(elem, name, computed) {
        var width, minWidth, maxWidth, ret, style = elem.style;
        computed = computed || getStyles(elem);
        ret = computed ? computed.getPropertyValue(name) || computed[name] : undefined;
        if ((ret === "" || ret === undefined) && !jQuery.contains(elem.ownerDocument, elem)) {
            ret = jQuery.style(elem, name);
        }
        if (computed) {
            if (!support.pixelMarginRight() && rnumnonpx.test(ret) && rmargin.test(name)) {
                width = style.width;
                minWidth = style.minWidth;
                maxWidth = style.maxWidth;
                style.minWidth = style.maxWidth = style.width = ret;
                ret = computed.width;
                style.width = width;
                style.minWidth = minWidth;
                style.maxWidth = maxWidth;
            }
        }
        return ret !== undefined ? ret + "" : ret;
    }
    function addGetHookIf(conditionFn, hookFn) {
        return {
            get: function() {
                if (conditionFn()) {
                    delete this.get;
                    return;
                }
                return (this.get = hookFn).apply(this, arguments);
            }
        };
    }
    var rdisplayswap = /^(none|table(?!-c[ea]).+)/, cssShow = {
        position: "absolute",
        visibility: "hidden",
        display: "block"
    }, cssNormalTransform = {
        letterSpacing: "0",
        fontWeight: "400"
    }, cssPrefixes = [ "Webkit", "O", "Moz", "ms" ], emptyStyle = document.createElement("div").style;
    function vendorPropName(name) {
        if (name in emptyStyle) {
            return name;
        }
        var capName = name[0].toUpperCase() + name.slice(1), i = cssPrefixes.length;
        while (i--) {
            name = cssPrefixes[i] + capName;
            if (name in emptyStyle) {
                return name;
            }
        }
    }
    function setPositiveNumber(elem, value, subtract) {
        var matches = rcssNum.exec(value);
        return matches ? Math.max(0, matches[2] - (subtract || 0)) + (matches[3] || "px") : value;
    }
    function augmentWidthOrHeight(elem, name, extra, isBorderBox, styles) {
        var i = extra === (isBorderBox ? "border" : "content") ? 4 : name === "width" ? 1 : 0, val = 0;
        for (;i < 4; i += 2) {
            if (extra === "margin") {
                val += jQuery.css(elem, extra + cssExpand[i], true, styles);
            }
            if (isBorderBox) {
                if (extra === "content") {
                    val -= jQuery.css(elem, "padding" + cssExpand[i], true, styles);
                }
                if (extra !== "margin") {
                    val -= jQuery.css(elem, "border" + cssExpand[i] + "Width", true, styles);
                }
            } else {
                val += jQuery.css(elem, "padding" + cssExpand[i], true, styles);
                if (extra !== "padding") {
                    val += jQuery.css(elem, "border" + cssExpand[i] + "Width", true, styles);
                }
            }
        }
        return val;
    }
    function getWidthOrHeight(elem, name, extra) {
        var valueIsBorderBox = true, val = name === "width" ? elem.offsetWidth : elem.offsetHeight, styles = getStyles(elem), isBorderBox = jQuery.css(elem, "boxSizing", false, styles) === "border-box";
        if (val <= 0 || val == null) {
            val = curCSS(elem, name, styles);
            if (val < 0 || val == null) {
                val = elem.style[name];
            }
            if (rnumnonpx.test(val)) {
                return val;
            }
            valueIsBorderBox = isBorderBox && (support.boxSizingReliable() || val === elem.style[name]);
            val = parseFloat(val) || 0;
        }
        return val + augmentWidthOrHeight(elem, name, extra || (isBorderBox ? "border" : "content"), valueIsBorderBox, styles) + "px";
    }
    function showHide(elements, show) {
        var display, elem, hidden, values = [], index = 0, length = elements.length;
        for (;index < length; index++) {
            elem = elements[index];
            if (!elem.style) {
                continue;
            }
            values[index] = dataPriv.get(elem, "olddisplay");
            display = elem.style.display;
            if (show) {
                if (!values[index] && display === "none") {
                    elem.style.display = "";
                }
                if (elem.style.display === "" && isHidden(elem)) {
                    values[index] = dataPriv.access(elem, "olddisplay", defaultDisplay(elem.nodeName));
                }
            } else {
                hidden = isHidden(elem);
                if (display !== "none" || !hidden) {
                    dataPriv.set(elem, "olddisplay", hidden ? display : jQuery.css(elem, "display"));
                }
            }
        }
        for (index = 0; index < length; index++) {
            elem = elements[index];
            if (!elem.style) {
                continue;
            }
            if (!show || elem.style.display === "none" || elem.style.display === "") {
                elem.style.display = show ? values[index] || "" : "none";
            }
        }
        return elements;
    }
    jQuery.extend({
        cssHooks: {
            opacity: {
                get: function(elem, computed) {
                    if (computed) {
                        var ret = curCSS(elem, "opacity");
                        return ret === "" ? "1" : ret;
                    }
                }
            }
        },
        cssNumber: {
            animationIterationCount: true,
            columnCount: true,
            fillOpacity: true,
            flexGrow: true,
            flexShrink: true,
            fontWeight: true,
            lineHeight: true,
            opacity: true,
            order: true,
            orphans: true,
            widows: true,
            zIndex: true,
            zoom: true
        },
        cssProps: {
            "float": "cssFloat"
        },
        style: function(elem, name, value, extra) {
            if (!elem || elem.nodeType === 3 || elem.nodeType === 8 || !elem.style) {
                return;
            }
            var ret, type, hooks, origName = jQuery.camelCase(name), style = elem.style;
            name = jQuery.cssProps[origName] || (jQuery.cssProps[origName] = vendorPropName(origName) || origName);
            hooks = jQuery.cssHooks[name] || jQuery.cssHooks[origName];
            if (value !== undefined) {
                type = typeof value;
                if (type === "string" && (ret = rcssNum.exec(value)) && ret[1]) {
                    value = adjustCSS(elem, name, ret);
                    type = "number";
                }
                if (value == null || value !== value) {
                    return;
                }
                if (type === "number") {
                    value += ret && ret[3] || (jQuery.cssNumber[origName] ? "" : "px");
                }
                if (!support.clearCloneStyle && value === "" && name.indexOf("background") === 0) {
                    style[name] = "inherit";
                }
                if (!hooks || !("set" in hooks) || (value = hooks.set(elem, value, extra)) !== undefined) {
                    style[name] = value;
                }
            } else {
                if (hooks && "get" in hooks && (ret = hooks.get(elem, false, extra)) !== undefined) {
                    return ret;
                }
                return style[name];
            }
        },
        css: function(elem, name, extra, styles) {
            var val, num, hooks, origName = jQuery.camelCase(name);
            name = jQuery.cssProps[origName] || (jQuery.cssProps[origName] = vendorPropName(origName) || origName);
            hooks = jQuery.cssHooks[name] || jQuery.cssHooks[origName];
            if (hooks && "get" in hooks) {
                val = hooks.get(elem, true, extra);
            }
            if (val === undefined) {
                val = curCSS(elem, name, styles);
            }
            if (val === "normal" && name in cssNormalTransform) {
                val = cssNormalTransform[name];
            }
            if (extra === "" || extra) {
                num = parseFloat(val);
                return extra === true || isFinite(num) ? num || 0 : val;
            }
            return val;
        }
    });
    jQuery.each([ "height", "width" ], function(i, name) {
        jQuery.cssHooks[name] = {
            get: function(elem, computed, extra) {
                if (computed) {
                    return rdisplayswap.test(jQuery.css(elem, "display")) && elem.offsetWidth === 0 ? swap(elem, cssShow, function() {
                        return getWidthOrHeight(elem, name, extra);
                    }) : getWidthOrHeight(elem, name, extra);
                }
            },
            set: function(elem, value, extra) {
                var matches, styles = extra && getStyles(elem), subtract = extra && augmentWidthOrHeight(elem, name, extra, jQuery.css(elem, "boxSizing", false, styles) === "border-box", styles);
                if (subtract && (matches = rcssNum.exec(value)) && (matches[3] || "px") !== "px") {
                    elem.style[name] = value;
                    value = jQuery.css(elem, name);
                }
                return setPositiveNumber(elem, value, subtract);
            }
        };
    });
    jQuery.cssHooks.marginLeft = addGetHookIf(support.reliableMarginLeft, function(elem, computed) {
        if (computed) {
            return (parseFloat(curCSS(elem, "marginLeft")) || elem.getBoundingClientRect().left - swap(elem, {
                marginLeft: 0
            }, function() {
                return elem.getBoundingClientRect().left;
            })) + "px";
        }
    });
    jQuery.cssHooks.marginRight = addGetHookIf(support.reliableMarginRight, function(elem, computed) {
        if (computed) {
            return swap(elem, {
                display: "inline-block"
            }, curCSS, [ elem, "marginRight" ]);
        }
    });
    jQuery.each({
        margin: "",
        padding: "",
        border: "Width"
    }, function(prefix, suffix) {
        jQuery.cssHooks[prefix + suffix] = {
            expand: function(value) {
                var i = 0, expanded = {}, parts = typeof value === "string" ? value.split(" ") : [ value ];
                for (;i < 4; i++) {
                    expanded[prefix + cssExpand[i] + suffix] = parts[i] || parts[i - 2] || parts[0];
                }
                return expanded;
            }
        };
        if (!rmargin.test(prefix)) {
            jQuery.cssHooks[prefix + suffix].set = setPositiveNumber;
        }
    });
    jQuery.fn.extend({
        css: function(name, value) {
            return access(this, function(elem, name, value) {
                var styles, len, map = {}, i = 0;
                if (jQuery.isArray(name)) {
                    styles = getStyles(elem);
                    len = name.length;
                    for (;i < len; i++) {
                        map[name[i]] = jQuery.css(elem, name[i], false, styles);
                    }
                    return map;
                }
                return value !== undefined ? jQuery.style(elem, name, value) : jQuery.css(elem, name);
            }, name, value, arguments.length > 1);
        },
        show: function() {
            return showHide(this, true);
        },
        hide: function() {
            return showHide(this);
        },
        toggle: function(state) {
            if (typeof state === "boolean") {
                return state ? this.show() : this.hide();
            }
            return this.each(function() {
                if (isHidden(this)) {
                    jQuery(this).show();
                } else {
                    jQuery(this).hide();
                }
            });
        }
    });
    function Tween(elem, options, prop, end, easing) {
        return new Tween.prototype.init(elem, options, prop, end, easing);
    }
    jQuery.Tween = Tween;
    Tween.prototype = {
        constructor: Tween,
        init: function(elem, options, prop, end, easing, unit) {
            this.elem = elem;
            this.prop = prop;
            this.easing = easing || jQuery.easing._default;
            this.options = options;
            this.start = this.now = this.cur();
            this.end = end;
            this.unit = unit || (jQuery.cssNumber[prop] ? "" : "px");
        },
        cur: function() {
            var hooks = Tween.propHooks[this.prop];
            return hooks && hooks.get ? hooks.get(this) : Tween.propHooks._default.get(this);
        },
        run: function(percent) {
            var eased, hooks = Tween.propHooks[this.prop];
            if (this.options.duration) {
                this.pos = eased = jQuery.easing[this.easing](percent, this.options.duration * percent, 0, 1, this.options.duration);
            } else {
                this.pos = eased = percent;
            }
            this.now = (this.end - this.start) * eased + this.start;
            if (this.options.step) {
                this.options.step.call(this.elem, this.now, this);
            }
            if (hooks && hooks.set) {
                hooks.set(this);
            } else {
                Tween.propHooks._default.set(this);
            }
            return this;
        }
    };
    Tween.prototype.init.prototype = Tween.prototype;
    Tween.propHooks = {
        _default: {
            get: function(tween) {
                var result;
                if (tween.elem.nodeType !== 1 || tween.elem[tween.prop] != null && tween.elem.style[tween.prop] == null) {
                    return tween.elem[tween.prop];
                }
                result = jQuery.css(tween.elem, tween.prop, "");
                return !result || result === "auto" ? 0 : result;
            },
            set: function(tween) {
                if (jQuery.fx.step[tween.prop]) {
                    jQuery.fx.step[tween.prop](tween);
                } else if (tween.elem.nodeType === 1 && (tween.elem.style[jQuery.cssProps[tween.prop]] != null || jQuery.cssHooks[tween.prop])) {
                    jQuery.style(tween.elem, tween.prop, tween.now + tween.unit);
                } else {
                    tween.elem[tween.prop] = tween.now;
                }
            }
        }
    };
    Tween.propHooks.scrollTop = Tween.propHooks.scrollLeft = {
        set: function(tween) {
            if (tween.elem.nodeType && tween.elem.parentNode) {
                tween.elem[tween.prop] = tween.now;
            }
        }
    };
    jQuery.easing = {
        linear: function(p) {
            return p;
        },
        swing: function(p) {
            return .5 - Math.cos(p * Math.PI) / 2;
        },
        _default: "swing"
    };
    jQuery.fx = Tween.prototype.init;
    jQuery.fx.step = {};
    var fxNow, timerId, rfxtypes = /^(?:toggle|show|hide)$/, rrun = /queueHooks$/;
    function createFxNow() {
        window.setTimeout(function() {
            fxNow = undefined;
        });
        return fxNow = jQuery.now();
    }
    function genFx(type, includeWidth) {
        var which, i = 0, attrs = {
            height: type
        };
        includeWidth = includeWidth ? 1 : 0;
        for (;i < 4; i += 2 - includeWidth) {
            which = cssExpand[i];
            attrs["margin" + which] = attrs["padding" + which] = type;
        }
        if (includeWidth) {
            attrs.opacity = attrs.width = type;
        }
        return attrs;
    }
    function createTween(value, prop, animation) {
        var tween, collection = (Animation.tweeners[prop] || []).concat(Animation.tweeners["*"]), index = 0, length = collection.length;
        for (;index < length; index++) {
            if (tween = collection[index].call(animation, prop, value)) {
                return tween;
            }
        }
    }
    function defaultPrefilter(elem, props, opts) {
        var prop, value, toggle, tween, hooks, oldfire, display, checkDisplay, anim = this, orig = {}, style = elem.style, hidden = elem.nodeType && isHidden(elem), dataShow = dataPriv.get(elem, "fxshow");
        if (!opts.queue) {
            hooks = jQuery._queueHooks(elem, "fx");
            if (hooks.unqueued == null) {
                hooks.unqueued = 0;
                oldfire = hooks.empty.fire;
                hooks.empty.fire = function() {
                    if (!hooks.unqueued) {
                        oldfire();
                    }
                };
            }
            hooks.unqueued++;
            anim.always(function() {
                anim.always(function() {
                    hooks.unqueued--;
                    if (!jQuery.queue(elem, "fx").length) {
                        hooks.empty.fire();
                    }
                });
            });
        }
        if (elem.nodeType === 1 && ("height" in props || "width" in props)) {
            opts.overflow = [ style.overflow, style.overflowX, style.overflowY ];
            display = jQuery.css(elem, "display");
            checkDisplay = display === "none" ? dataPriv.get(elem, "olddisplay") || defaultDisplay(elem.nodeName) : display;
            if (checkDisplay === "inline" && jQuery.css(elem, "float") === "none") {
                style.display = "inline-block";
            }
        }
        if (opts.overflow) {
            style.overflow = "hidden";
            anim.always(function() {
                style.overflow = opts.overflow[0];
                style.overflowX = opts.overflow[1];
                style.overflowY = opts.overflow[2];
            });
        }
        for (prop in props) {
            value = props[prop];
            if (rfxtypes.exec(value)) {
                delete props[prop];
                toggle = toggle || value === "toggle";
                if (value === (hidden ? "hide" : "show")) {
                    if (value === "show" && dataShow && dataShow[prop] !== undefined) {
                        hidden = true;
                    } else {
                        continue;
                    }
                }
                orig[prop] = dataShow && dataShow[prop] || jQuery.style(elem, prop);
            } else {
                display = undefined;
            }
        }
        if (!jQuery.isEmptyObject(orig)) {
            if (dataShow) {
                if ("hidden" in dataShow) {
                    hidden = dataShow.hidden;
                }
            } else {
                dataShow = dataPriv.access(elem, "fxshow", {});
            }
            if (toggle) {
                dataShow.hidden = !hidden;
            }
            if (hidden) {
                jQuery(elem).show();
            } else {
                anim.done(function() {
                    jQuery(elem).hide();
                });
            }
            anim.done(function() {
                var prop;
                dataPriv.remove(elem, "fxshow");
                for (prop in orig) {
                    jQuery.style(elem, prop, orig[prop]);
                }
            });
            for (prop in orig) {
                tween = createTween(hidden ? dataShow[prop] : 0, prop, anim);
                if (!(prop in dataShow)) {
                    dataShow[prop] = tween.start;
                    if (hidden) {
                        tween.end = tween.start;
                        tween.start = prop === "width" || prop === "height" ? 1 : 0;
                    }
                }
            }
        } else if ((display === "none" ? defaultDisplay(elem.nodeName) : display) === "inline") {
            style.display = display;
        }
    }
    function propFilter(props, specialEasing) {
        var index, name, easing, value, hooks;
        for (index in props) {
            name = jQuery.camelCase(index);
            easing = specialEasing[name];
            value = props[index];
            if (jQuery.isArray(value)) {
                easing = value[1];
                value = props[index] = value[0];
            }
            if (index !== name) {
                props[name] = value;
                delete props[index];
            }
            hooks = jQuery.cssHooks[name];
            if (hooks && "expand" in hooks) {
                value = hooks.expand(value);
                delete props[name];
                for (index in value) {
                    if (!(index in props)) {
                        props[index] = value[index];
                        specialEasing[index] = easing;
                    }
                }
            } else {
                specialEasing[name] = easing;
            }
        }
    }
    function Animation(elem, properties, options) {
        var result, stopped, index = 0, length = Animation.prefilters.length, deferred = jQuery.Deferred().always(function() {
            delete tick.elem;
        }), tick = function() {
            if (stopped) {
                return false;
            }
            var currentTime = fxNow || createFxNow(), remaining = Math.max(0, animation.startTime + animation.duration - currentTime), temp = remaining / animation.duration || 0, percent = 1 - temp, index = 0, length = animation.tweens.length;
            for (;index < length; index++) {
                animation.tweens[index].run(percent);
            }
            deferred.notifyWith(elem, [ animation, percent, remaining ]);
            if (percent < 1 && length) {
                return remaining;
            } else {
                deferred.resolveWith(elem, [ animation ]);
                return false;
            }
        }, animation = deferred.promise({
            elem: elem,
            props: jQuery.extend({}, properties),
            opts: jQuery.extend(true, {
                specialEasing: {},
                easing: jQuery.easing._default
            }, options),
            originalProperties: properties,
            originalOptions: options,
            startTime: fxNow || createFxNow(),
            duration: options.duration,
            tweens: [],
            createTween: function(prop, end) {
                var tween = jQuery.Tween(elem, animation.opts, prop, end, animation.opts.specialEasing[prop] || animation.opts.easing);
                animation.tweens.push(tween);
                return tween;
            },
            stop: function(gotoEnd) {
                var index = 0, length = gotoEnd ? animation.tweens.length : 0;
                if (stopped) {
                    return this;
                }
                stopped = true;
                for (;index < length; index++) {
                    animation.tweens[index].run(1);
                }
                if (gotoEnd) {
                    deferred.notifyWith(elem, [ animation, 1, 0 ]);
                    deferred.resolveWith(elem, [ animation, gotoEnd ]);
                } else {
                    deferred.rejectWith(elem, [ animation, gotoEnd ]);
                }
                return this;
            }
        }), props = animation.props;
        propFilter(props, animation.opts.specialEasing);
        for (;index < length; index++) {
            result = Animation.prefilters[index].call(animation, elem, props, animation.opts);
            if (result) {
                if (jQuery.isFunction(result.stop)) {
                    jQuery._queueHooks(animation.elem, animation.opts.queue).stop = jQuery.proxy(result.stop, result);
                }
                return result;
            }
        }
        jQuery.map(props, createTween, animation);
        if (jQuery.isFunction(animation.opts.start)) {
            animation.opts.start.call(elem, animation);
        }
        jQuery.fx.timer(jQuery.extend(tick, {
            elem: elem,
            anim: animation,
            queue: animation.opts.queue
        }));
        return animation.progress(animation.opts.progress).done(animation.opts.done, animation.opts.complete).fail(animation.opts.fail).always(animation.opts.always);
    }
    jQuery.Animation = jQuery.extend(Animation, {
        tweeners: {
            "*": [ function(prop, value) {
                var tween = this.createTween(prop, value);
                adjustCSS(tween.elem, prop, rcssNum.exec(value), tween);
                return tween;
            } ]
        },
        tweener: function(props, callback) {
            if (jQuery.isFunction(props)) {
                callback = props;
                props = [ "*" ];
            } else {
                props = props.match(rnotwhite);
            }
            var prop, index = 0, length = props.length;
            for (;index < length; index++) {
                prop = props[index];
                Animation.tweeners[prop] = Animation.tweeners[prop] || [];
                Animation.tweeners[prop].unshift(callback);
            }
        },
        prefilters: [ defaultPrefilter ],
        prefilter: function(callback, prepend) {
            if (prepend) {
                Animation.prefilters.unshift(callback);
            } else {
                Animation.prefilters.push(callback);
            }
        }
    });
    jQuery.speed = function(speed, easing, fn) {
        var opt = speed && typeof speed === "object" ? jQuery.extend({}, speed) : {
            complete: fn || !fn && easing || jQuery.isFunction(speed) && speed,
            duration: speed,
            easing: fn && easing || easing && !jQuery.isFunction(easing) && easing
        };
        opt.duration = jQuery.fx.off ? 0 : typeof opt.duration === "number" ? opt.duration : opt.duration in jQuery.fx.speeds ? jQuery.fx.speeds[opt.duration] : jQuery.fx.speeds._default;
        if (opt.queue == null || opt.queue === true) {
            opt.queue = "fx";
        }
        opt.old = opt.complete;
        opt.complete = function() {
            if (jQuery.isFunction(opt.old)) {
                opt.old.call(this);
            }
            if (opt.queue) {
                jQuery.dequeue(this, opt.queue);
            }
        };
        return opt;
    };
    jQuery.fn.extend({
        fadeTo: function(speed, to, easing, callback) {
            return this.filter(isHidden).css("opacity", 0).show().end().animate({
                opacity: to
            }, speed, easing, callback);
        },
        animate: function(prop, speed, easing, callback) {
            var empty = jQuery.isEmptyObject(prop), optall = jQuery.speed(speed, easing, callback), doAnimation = function() {
                var anim = Animation(this, jQuery.extend({}, prop), optall);
                if (empty || dataPriv.get(this, "finish")) {
                    anim.stop(true);
                }
            };
            doAnimation.finish = doAnimation;
            return empty || optall.queue === false ? this.each(doAnimation) : this.queue(optall.queue, doAnimation);
        },
        stop: function(type, clearQueue, gotoEnd) {
            var stopQueue = function(hooks) {
                var stop = hooks.stop;
                delete hooks.stop;
                stop(gotoEnd);
            };
            if (typeof type !== "string") {
                gotoEnd = clearQueue;
                clearQueue = type;
                type = undefined;
            }
            if (clearQueue && type !== false) {
                this.queue(type || "fx", []);
            }
            return this.each(function() {
                var dequeue = true, index = type != null && type + "queueHooks", timers = jQuery.timers, data = dataPriv.get(this);
                if (index) {
                    if (data[index] && data[index].stop) {
                        stopQueue(data[index]);
                    }
                } else {
                    for (index in data) {
                        if (data[index] && data[index].stop && rrun.test(index)) {
                            stopQueue(data[index]);
                        }
                    }
                }
                for (index = timers.length; index--; ) {
                    if (timers[index].elem === this && (type == null || timers[index].queue === type)) {
                        timers[index].anim.stop(gotoEnd);
                        dequeue = false;
                        timers.splice(index, 1);
                    }
                }
                if (dequeue || !gotoEnd) {
                    jQuery.dequeue(this, type);
                }
            });
        },
        finish: function(type) {
            if (type !== false) {
                type = type || "fx";
            }
            return this.each(function() {
                var index, data = dataPriv.get(this), queue = data[type + "queue"], hooks = data[type + "queueHooks"], timers = jQuery.timers, length = queue ? queue.length : 0;
                data.finish = true;
                jQuery.queue(this, type, []);
                if (hooks && hooks.stop) {
                    hooks.stop.call(this, true);
                }
                for (index = timers.length; index--; ) {
                    if (timers[index].elem === this && timers[index].queue === type) {
                        timers[index].anim.stop(true);
                        timers.splice(index, 1);
                    }
                }
                for (index = 0; index < length; index++) {
                    if (queue[index] && queue[index].finish) {
                        queue[index].finish.call(this);
                    }
                }
                delete data.finish;
            });
        }
    });
    jQuery.each([ "toggle", "show", "hide" ], function(i, name) {
        var cssFn = jQuery.fn[name];
        jQuery.fn[name] = function(speed, easing, callback) {
            return speed == null || typeof speed === "boolean" ? cssFn.apply(this, arguments) : this.animate(genFx(name, true), speed, easing, callback);
        };
    });
    jQuery.each({
        slideDown: genFx("show"),
        slideUp: genFx("hide"),
        slideToggle: genFx("toggle"),
        fadeIn: {
            opacity: "show"
        },
        fadeOut: {
            opacity: "hide"
        },
        fadeToggle: {
            opacity: "toggle"
        }
    }, function(name, props) {
        jQuery.fn[name] = function(speed, easing, callback) {
            return this.animate(props, speed, easing, callback);
        };
    });
    jQuery.timers = [];
    jQuery.fx.tick = function() {
        var timer, i = 0, timers = jQuery.timers;
        fxNow = jQuery.now();
        for (;i < timers.length; i++) {
            timer = timers[i];
            if (!timer() && timers[i] === timer) {
                timers.splice(i--, 1);
            }
        }
        if (!timers.length) {
            jQuery.fx.stop();
        }
        fxNow = undefined;
    };
    jQuery.fx.timer = function(timer) {
        jQuery.timers.push(timer);
        if (timer()) {
            jQuery.fx.start();
        } else {
            jQuery.timers.pop();
        }
    };
    jQuery.fx.interval = 13;
    jQuery.fx.start = function() {
        if (!timerId) {
            timerId = window.setInterval(jQuery.fx.tick, jQuery.fx.interval);
        }
    };
    jQuery.fx.stop = function() {
        window.clearInterval(timerId);
        timerId = null;
    };
    jQuery.fx.speeds = {
        slow: 600,
        fast: 200,
        _default: 400
    };
    jQuery.fn.delay = function(time, type) {
        time = jQuery.fx ? jQuery.fx.speeds[time] || time : time;
        type = type || "fx";
        return this.queue(type, function(next, hooks) {
            var timeout = window.setTimeout(next, time);
            hooks.stop = function() {
                window.clearTimeout(timeout);
            };
        });
    };
    (function() {
        var input = document.createElement("input"), select = document.createElement("select"), opt = select.appendChild(document.createElement("option"));
        input.type = "checkbox";
        support.checkOn = input.value !== "";
        support.optSelected = opt.selected;
        select.disabled = true;
        support.optDisabled = !opt.disabled;
        input = document.createElement("input");
        input.value = "t";
        input.type = "radio";
        support.radioValue = input.value === "t";
    })();
    var boolHook, attrHandle = jQuery.expr.attrHandle;
    jQuery.fn.extend({
        attr: function(name, value) {
            return access(this, jQuery.attr, name, value, arguments.length > 1);
        },
        removeAttr: function(name) {
            return this.each(function() {
                jQuery.removeAttr(this, name);
            });
        }
    });
    jQuery.extend({
        attr: function(elem, name, value) {
            var ret, hooks, nType = elem.nodeType;
            if (nType === 3 || nType === 8 || nType === 2) {
                return;
            }
            if (typeof elem.getAttribute === "undefined") {
                return jQuery.prop(elem, name, value);
            }
            if (nType !== 1 || !jQuery.isXMLDoc(elem)) {
                name = name.toLowerCase();
                hooks = jQuery.attrHooks[name] || (jQuery.expr.match.bool.test(name) ? boolHook : undefined);
            }
            if (value !== undefined) {
                if (value === null) {
                    jQuery.removeAttr(elem, name);
                    return;
                }
                if (hooks && "set" in hooks && (ret = hooks.set(elem, value, name)) !== undefined) {
                    return ret;
                }
                elem.setAttribute(name, value + "");
                return value;
            }
            if (hooks && "get" in hooks && (ret = hooks.get(elem, name)) !== null) {
                return ret;
            }
            ret = jQuery.find.attr(elem, name);
            return ret == null ? undefined : ret;
        },
        attrHooks: {
            type: {
                set: function(elem, value) {
                    if (!support.radioValue && value === "radio" && jQuery.nodeName(elem, "input")) {
                        var val = elem.value;
                        elem.setAttribute("type", value);
                        if (val) {
                            elem.value = val;
                        }
                        return value;
                    }
                }
            }
        },
        removeAttr: function(elem, value) {
            var name, propName, i = 0, attrNames = value && value.match(rnotwhite);
            if (attrNames && elem.nodeType === 1) {
                while (name = attrNames[i++]) {
                    propName = jQuery.propFix[name] || name;
                    if (jQuery.expr.match.bool.test(name)) {
                        elem[propName] = false;
                    }
                    elem.removeAttribute(name);
                }
            }
        }
    });
    boolHook = {
        set: function(elem, value, name) {
            if (value === false) {
                jQuery.removeAttr(elem, name);
            } else {
                elem.setAttribute(name, name);
            }
            return name;
        }
    };
    jQuery.each(jQuery.expr.match.bool.source.match(/\w+/g), function(i, name) {
        var getter = attrHandle[name] || jQuery.find.attr;
        attrHandle[name] = function(elem, name, isXML) {
            var ret, handle;
            if (!isXML) {
                handle = attrHandle[name];
                attrHandle[name] = ret;
                ret = getter(elem, name, isXML) != null ? name.toLowerCase() : null;
                attrHandle[name] = handle;
            }
            return ret;
        };
    });
    var rfocusable = /^(?:input|select|textarea|button)$/i, rclickable = /^(?:a|area)$/i;
    jQuery.fn.extend({
        prop: function(name, value) {
            return access(this, jQuery.prop, name, value, arguments.length > 1);
        },
        removeProp: function(name) {
            return this.each(function() {
                delete this[jQuery.propFix[name] || name];
            });
        }
    });
    jQuery.extend({
        prop: function(elem, name, value) {
            var ret, hooks, nType = elem.nodeType;
            if (nType === 3 || nType === 8 || nType === 2) {
                return;
            }
            if (nType !== 1 || !jQuery.isXMLDoc(elem)) {
                name = jQuery.propFix[name] || name;
                hooks = jQuery.propHooks[name];
            }
            if (value !== undefined) {
                if (hooks && "set" in hooks && (ret = hooks.set(elem, value, name)) !== undefined) {
                    return ret;
                }
                return elem[name] = value;
            }
            if (hooks && "get" in hooks && (ret = hooks.get(elem, name)) !== null) {
                return ret;
            }
            return elem[name];
        },
        propHooks: {
            tabIndex: {
                get: function(elem) {
                    var tabindex = jQuery.find.attr(elem, "tabindex");
                    return tabindex ? parseInt(tabindex, 10) : rfocusable.test(elem.nodeName) || rclickable.test(elem.nodeName) && elem.href ? 0 : -1;
                }
            }
        },
        propFix: {
            "for": "htmlFor",
            "class": "className"
        }
    });
    if (!support.optSelected) {
        jQuery.propHooks.selected = {
            get: function(elem) {
                var parent = elem.parentNode;
                if (parent && parent.parentNode) {
                    parent.parentNode.selectedIndex;
                }
                return null;
            },
            set: function(elem) {
                var parent = elem.parentNode;
                if (parent) {
                    parent.selectedIndex;
                    if (parent.parentNode) {
                        parent.parentNode.selectedIndex;
                    }
                }
            }
        };
    }
    jQuery.each([ "tabIndex", "readOnly", "maxLength", "cellSpacing", "cellPadding", "rowSpan", "colSpan", "useMap", "frameBorder", "contentEditable" ], function() {
        jQuery.propFix[this.toLowerCase()] = this;
    });
    var rclass = /[\t\r\n\f]/g;
    function getClass(elem) {
        return elem.getAttribute && elem.getAttribute("class") || "";
    }
    jQuery.fn.extend({
        addClass: function(value) {
            var classes, elem, cur, curValue, clazz, j, finalValue, i = 0;
            if (jQuery.isFunction(value)) {
                return this.each(function(j) {
                    jQuery(this).addClass(value.call(this, j, getClass(this)));
                });
            }
            if (typeof value === "string" && value) {
                classes = value.match(rnotwhite) || [];
                while (elem = this[i++]) {
                    curValue = getClass(elem);
                    cur = elem.nodeType === 1 && (" " + curValue + " ").replace(rclass, " ");
                    if (cur) {
                        j = 0;
                        while (clazz = classes[j++]) {
                            if (cur.indexOf(" " + clazz + " ") < 0) {
                                cur += clazz + " ";
                            }
                        }
                        finalValue = jQuery.trim(cur);
                        if (curValue !== finalValue) {
                            elem.setAttribute("class", finalValue);
                        }
                    }
                }
            }
            return this;
        },
        removeClass: function(value) {
            var classes, elem, cur, curValue, clazz, j, finalValue, i = 0;
            if (jQuery.isFunction(value)) {
                return this.each(function(j) {
                    jQuery(this).removeClass(value.call(this, j, getClass(this)));
                });
            }
            if (!arguments.length) {
                return this.attr("class", "");
            }
            if (typeof value === "string" && value) {
                classes = value.match(rnotwhite) || [];
                while (elem = this[i++]) {
                    curValue = getClass(elem);
                    cur = elem.nodeType === 1 && (" " + curValue + " ").replace(rclass, " ");
                    if (cur) {
                        j = 0;
                        while (clazz = classes[j++]) {
                            while (cur.indexOf(" " + clazz + " ") > -1) {
                                cur = cur.replace(" " + clazz + " ", " ");
                            }
                        }
                        finalValue = jQuery.trim(cur);
                        if (curValue !== finalValue) {
                            elem.setAttribute("class", finalValue);
                        }
                    }
                }
            }
            return this;
        },
        toggleClass: function(value, stateVal) {
            var type = typeof value;
            if (typeof stateVal === "boolean" && type === "string") {
                return stateVal ? this.addClass(value) : this.removeClass(value);
            }
            if (jQuery.isFunction(value)) {
                return this.each(function(i) {
                    jQuery(this).toggleClass(value.call(this, i, getClass(this), stateVal), stateVal);
                });
            }
            return this.each(function() {
                var className, i, self, classNames;
                if (type === "string") {
                    i = 0;
                    self = jQuery(this);
                    classNames = value.match(rnotwhite) || [];
                    while (className = classNames[i++]) {
                        if (self.hasClass(className)) {
                            self.removeClass(className);
                        } else {
                            self.addClass(className);
                        }
                    }
                } else if (value === undefined || type === "boolean") {
                    className = getClass(this);
                    if (className) {
                        dataPriv.set(this, "__className__", className);
                    }
                    if (this.setAttribute) {
                        this.setAttribute("class", className || value === false ? "" : dataPriv.get(this, "__className__") || "");
                    }
                }
            });
        },
        hasClass: function(selector) {
            var className, elem, i = 0;
            className = " " + selector + " ";
            while (elem = this[i++]) {
                if (elem.nodeType === 1 && (" " + getClass(elem) + " ").replace(rclass, " ").indexOf(className) > -1) {
                    return true;
                }
            }
            return false;
        }
    });
    var rreturn = /\r/g, rspaces = /[\x20\t\r\n\f]+/g;
    jQuery.fn.extend({
        val: function(value) {
            var hooks, ret, isFunction, elem = this[0];
            if (!arguments.length) {
                if (elem) {
                    hooks = jQuery.valHooks[elem.type] || jQuery.valHooks[elem.nodeName.toLowerCase()];
                    if (hooks && "get" in hooks && (ret = hooks.get(elem, "value")) !== undefined) {
                        return ret;
                    }
                    ret = elem.value;
                    return typeof ret === "string" ? ret.replace(rreturn, "") : ret == null ? "" : ret;
                }
                return;
            }
            isFunction = jQuery.isFunction(value);
            return this.each(function(i) {
                var val;
                if (this.nodeType !== 1) {
                    return;
                }
                if (isFunction) {
                    val = value.call(this, i, jQuery(this).val());
                } else {
                    val = value;
                }
                if (val == null) {
                    val = "";
                } else if (typeof val === "number") {
                    val += "";
                } else if (jQuery.isArray(val)) {
                    val = jQuery.map(val, function(value) {
                        return value == null ? "" : value + "";
                    });
                }
                hooks = jQuery.valHooks[this.type] || jQuery.valHooks[this.nodeName.toLowerCase()];
                if (!hooks || !("set" in hooks) || hooks.set(this, val, "value") === undefined) {
                    this.value = val;
                }
            });
        }
    });
    jQuery.extend({
        valHooks: {
            option: {
                get: function(elem) {
                    var val = jQuery.find.attr(elem, "value");
                    return val != null ? val : jQuery.trim(jQuery.text(elem)).replace(rspaces, " ");
                }
            },
            select: {
                get: function(elem) {
                    var value, option, options = elem.options, index = elem.selectedIndex, one = elem.type === "select-one" || index < 0, values = one ? null : [], max = one ? index + 1 : options.length, i = index < 0 ? max : one ? index : 0;
                    for (;i < max; i++) {
                        option = options[i];
                        if ((option.selected || i === index) && (support.optDisabled ? !option.disabled : option.getAttribute("disabled") === null) && (!option.parentNode.disabled || !jQuery.nodeName(option.parentNode, "optgroup"))) {
                            value = jQuery(option).val();
                            if (one) {
                                return value;
                            }
                            values.push(value);
                        }
                    }
                    return values;
                },
                set: function(elem, value) {
                    var optionSet, option, options = elem.options, values = jQuery.makeArray(value), i = options.length;
                    while (i--) {
                        option = options[i];
                        if (option.selected = jQuery.inArray(jQuery.valHooks.option.get(option), values) > -1) {
                            optionSet = true;
                        }
                    }
                    if (!optionSet) {
                        elem.selectedIndex = -1;
                    }
                    return values;
                }
            }
        }
    });
    jQuery.each([ "radio", "checkbox" ], function() {
        jQuery.valHooks[this] = {
            set: function(elem, value) {
                if (jQuery.isArray(value)) {
                    return elem.checked = jQuery.inArray(jQuery(elem).val(), value) > -1;
                }
            }
        };
        if (!support.checkOn) {
            jQuery.valHooks[this].get = function(elem) {
                return elem.getAttribute("value") === null ? "on" : elem.value;
            };
        }
    });
    var rfocusMorph = /^(?:focusinfocus|focusoutblur)$/;
    jQuery.extend(jQuery.event, {
        trigger: function(event, data, elem, onlyHandlers) {
            var i, cur, tmp, bubbleType, ontype, handle, special, eventPath = [ elem || document ], type = hasOwn.call(event, "type") ? event.type : event, namespaces = hasOwn.call(event, "namespace") ? event.namespace.split(".") : [];
            cur = tmp = elem = elem || document;
            if (elem.nodeType === 3 || elem.nodeType === 8) {
                return;
            }
            if (rfocusMorph.test(type + jQuery.event.triggered)) {
                return;
            }
            if (type.indexOf(".") > -1) {
                namespaces = type.split(".");
                type = namespaces.shift();
                namespaces.sort();
            }
            ontype = type.indexOf(":") < 0 && "on" + type;
            event = event[jQuery.expando] ? event : new jQuery.Event(type, typeof event === "object" && event);
            event.isTrigger = onlyHandlers ? 2 : 3;
            event.namespace = namespaces.join(".");
            event.rnamespace = event.namespace ? new RegExp("(^|\\.)" + namespaces.join("\\.(?:.*\\.|)") + "(\\.|$)") : null;
            event.result = undefined;
            if (!event.target) {
                event.target = elem;
            }
            data = data == null ? [ event ] : jQuery.makeArray(data, [ event ]);
            special = jQuery.event.special[type] || {};
            if (!onlyHandlers && special.trigger && special.trigger.apply(elem, data) === false) {
                return;
            }
            if (!onlyHandlers && !special.noBubble && !jQuery.isWindow(elem)) {
                bubbleType = special.delegateType || type;
                if (!rfocusMorph.test(bubbleType + type)) {
                    cur = cur.parentNode;
                }
                for (;cur; cur = cur.parentNode) {
                    eventPath.push(cur);
                    tmp = cur;
                }
                if (tmp === (elem.ownerDocument || document)) {
                    eventPath.push(tmp.defaultView || tmp.parentWindow || window);
                }
            }
            i = 0;
            while ((cur = eventPath[i++]) && !event.isPropagationStopped()) {
                event.type = i > 1 ? bubbleType : special.bindType || type;
                handle = (dataPriv.get(cur, "events") || {})[event.type] && dataPriv.get(cur, "handle");
                if (handle) {
                    handle.apply(cur, data);
                }
                handle = ontype && cur[ontype];
                if (handle && handle.apply && acceptData(cur)) {
                    event.result = handle.apply(cur, data);
                    if (event.result === false) {
                        event.preventDefault();
                    }
                }
            }
            event.type = type;
            if (!onlyHandlers && !event.isDefaultPrevented()) {
                if ((!special._default || special._default.apply(eventPath.pop(), data) === false) && acceptData(elem)) {
                    if (ontype && jQuery.isFunction(elem[type]) && !jQuery.isWindow(elem)) {
                        tmp = elem[ontype];
                        if (tmp) {
                            elem[ontype] = null;
                        }
                        jQuery.event.triggered = type;
                        elem[type]();
                        jQuery.event.triggered = undefined;
                        if (tmp) {
                            elem[ontype] = tmp;
                        }
                    }
                }
            }
            return event.result;
        },
        simulate: function(type, elem, event) {
            var e = jQuery.extend(new jQuery.Event(), event, {
                type: type,
                isSimulated: true
            });
            jQuery.event.trigger(e, null, elem);
        }
    });
    jQuery.fn.extend({
        trigger: function(type, data) {
            return this.each(function() {
                jQuery.event.trigger(type, data, this);
            });
        },
        triggerHandler: function(type, data) {
            var elem = this[0];
            if (elem) {
                return jQuery.event.trigger(type, data, elem, true);
            }
        }
    });
    jQuery.each(("blur focus focusin focusout load resize scroll unload click dblclick " + "mousedown mouseup mousemove mouseover mouseout mouseenter mouseleave " + "change select submit keydown keypress keyup error contextmenu").split(" "), function(i, name) {
        jQuery.fn[name] = function(data, fn) {
            return arguments.length > 0 ? this.on(name, null, data, fn) : this.trigger(name);
        };
    });
    jQuery.fn.extend({
        hover: function(fnOver, fnOut) {
            return this.mouseenter(fnOver).mouseleave(fnOut || fnOver);
        }
    });
    support.focusin = "onfocusin" in window;
    if (!support.focusin) {
        jQuery.each({
            focus: "focusin",
            blur: "focusout"
        }, function(orig, fix) {
            var handler = function(event) {
                jQuery.event.simulate(fix, event.target, jQuery.event.fix(event));
            };
            jQuery.event.special[fix] = {
                setup: function() {
                    var doc = this.ownerDocument || this, attaches = dataPriv.access(doc, fix);
                    if (!attaches) {
                        doc.addEventListener(orig, handler, true);
                    }
                    dataPriv.access(doc, fix, (attaches || 0) + 1);
                },
                teardown: function() {
                    var doc = this.ownerDocument || this, attaches = dataPriv.access(doc, fix) - 1;
                    if (!attaches) {
                        doc.removeEventListener(orig, handler, true);
                        dataPriv.remove(doc, fix);
                    } else {
                        dataPriv.access(doc, fix, attaches);
                    }
                }
            };
        });
    }
    var location = window.location;
    var nonce = jQuery.now();
    var rquery = /\?/;
    jQuery.parseJSON = function(data) {
        return JSON.parse(data + "");
    };
    jQuery.parseXML = function(data) {
        var xml;
        if (!data || typeof data !== "string") {
            return null;
        }
        try {
            xml = new window.DOMParser().parseFromString(data, "text/xml");
        } catch (e) {
            xml = undefined;
        }
        if (!xml || xml.getElementsByTagName("parsererror").length) {
            jQuery.error("Invalid XML: " + data);
        }
        return xml;
    };
    var rhash = /#.*$/, rts = /([?&])_=[^&]*/, rheaders = /^(.*?):[ \t]*([^\r\n]*)$/gm, rlocalProtocol = /^(?:about|app|app-storage|.+-extension|file|res|widget):$/, rnoContent = /^(?:GET|HEAD)$/, rprotocol = /^\/\//, prefilters = {}, transports = {}, allTypes = "*/".concat("*"), originAnchor = document.createElement("a");
    originAnchor.href = location.href;
    function addToPrefiltersOrTransports(structure) {
        return function(dataTypeExpression, func) {
            if (typeof dataTypeExpression !== "string") {
                func = dataTypeExpression;
                dataTypeExpression = "*";
            }
            var dataType, i = 0, dataTypes = dataTypeExpression.toLowerCase().match(rnotwhite) || [];
            if (jQuery.isFunction(func)) {
                while (dataType = dataTypes[i++]) {
                    if (dataType[0] === "+") {
                        dataType = dataType.slice(1) || "*";
                        (structure[dataType] = structure[dataType] || []).unshift(func);
                    } else {
                        (structure[dataType] = structure[dataType] || []).push(func);
                    }
                }
            }
        };
    }
    function inspectPrefiltersOrTransports(structure, options, originalOptions, jqXHR) {
        var inspected = {}, seekingTransport = structure === transports;
        function inspect(dataType) {
            var selected;
            inspected[dataType] = true;
            jQuery.each(structure[dataType] || [], function(_, prefilterOrFactory) {
                var dataTypeOrTransport = prefilterOrFactory(options, originalOptions, jqXHR);
                if (typeof dataTypeOrTransport === "string" && !seekingTransport && !inspected[dataTypeOrTransport]) {
                    options.dataTypes.unshift(dataTypeOrTransport);
                    inspect(dataTypeOrTransport);
                    return false;
                } else if (seekingTransport) {
                    return !(selected = dataTypeOrTransport);
                }
            });
            return selected;
        }
        return inspect(options.dataTypes[0]) || !inspected["*"] && inspect("*");
    }
    function ajaxExtend(target, src) {
        var key, deep, flatOptions = jQuery.ajaxSettings.flatOptions || {};
        for (key in src) {
            if (src[key] !== undefined) {
                (flatOptions[key] ? target : deep || (deep = {}))[key] = src[key];
            }
        }
        if (deep) {
            jQuery.extend(true, target, deep);
        }
        return target;
    }
    function ajaxHandleResponses(s, jqXHR, responses) {
        var ct, type, finalDataType, firstDataType, contents = s.contents, dataTypes = s.dataTypes;
        while (dataTypes[0] === "*") {
            dataTypes.shift();
            if (ct === undefined) {
                ct = s.mimeType || jqXHR.getResponseHeader("Content-Type");
            }
        }
        if (ct) {
            for (type in contents) {
                if (contents[type] && contents[type].test(ct)) {
                    dataTypes.unshift(type);
                    break;
                }
            }
        }
        if (dataTypes[0] in responses) {
            finalDataType = dataTypes[0];
        } else {
            for (type in responses) {
                if (!dataTypes[0] || s.converters[type + " " + dataTypes[0]]) {
                    finalDataType = type;
                    break;
                }
                if (!firstDataType) {
                    firstDataType = type;
                }
            }
            finalDataType = finalDataType || firstDataType;
        }
        if (finalDataType) {
            if (finalDataType !== dataTypes[0]) {
                dataTypes.unshift(finalDataType);
            }
            return responses[finalDataType];
        }
    }
    function ajaxConvert(s, response, jqXHR, isSuccess) {
        var conv2, current, conv, tmp, prev, converters = {}, dataTypes = s.dataTypes.slice();
        if (dataTypes[1]) {
            for (conv in s.converters) {
                converters[conv.toLowerCase()] = s.converters[conv];
            }
        }
        current = dataTypes.shift();
        while (current) {
            if (s.responseFields[current]) {
                jqXHR[s.responseFields[current]] = response;
            }
            if (!prev && isSuccess && s.dataFilter) {
                response = s.dataFilter(response, s.dataType);
            }
            prev = current;
            current = dataTypes.shift();
            if (current) {
                if (current === "*") {
                    current = prev;
                } else if (prev !== "*" && prev !== current) {
                    conv = converters[prev + " " + current] || converters["* " + current];
                    if (!conv) {
                        for (conv2 in converters) {
                            tmp = conv2.split(" ");
                            if (tmp[1] === current) {
                                conv = converters[prev + " " + tmp[0]] || converters["* " + tmp[0]];
                                if (conv) {
                                    if (conv === true) {
                                        conv = converters[conv2];
                                    } else if (converters[conv2] !== true) {
                                        current = tmp[0];
                                        dataTypes.unshift(tmp[1]);
                                    }
                                    break;
                                }
                            }
                        }
                    }
                    if (conv !== true) {
                        if (conv && s.throws) {
                            response = conv(response);
                        } else {
                            try {
                                response = conv(response);
                            } catch (e) {
                                return {
                                    state: "parsererror",
                                    error: conv ? e : "No conversion from " + prev + " to " + current
                                };
                            }
                        }
                    }
                }
            }
        }
        return {
            state: "success",
            data: response
        };
    }
    jQuery.extend({
        active: 0,
        lastModified: {},
        etag: {},
        ajaxSettings: {
            url: location.href,
            type: "GET",
            isLocal: rlocalProtocol.test(location.protocol),
            global: true,
            processData: true,
            async: true,
            contentType: "application/x-www-form-urlencoded; charset=UTF-8",
            accepts: {
                "*": allTypes,
                text: "text/plain",
                html: "text/html",
                xml: "application/xml, text/xml",
                json: "application/json, text/javascript"
            },
            contents: {
                xml: /\bxml\b/,
                html: /\bhtml/,
                json: /\bjson\b/
            },
            responseFields: {
                xml: "responseXML",
                text: "responseText",
                json: "responseJSON"
            },
            converters: {
                "* text": String,
                "text html": true,
                "text json": jQuery.parseJSON,
                "text xml": jQuery.parseXML
            },
            flatOptions: {
                url: true,
                context: true
            }
        },
        ajaxSetup: function(target, settings) {
            return settings ? ajaxExtend(ajaxExtend(target, jQuery.ajaxSettings), settings) : ajaxExtend(jQuery.ajaxSettings, target);
        },
        ajaxPrefilter: addToPrefiltersOrTransports(prefilters),
        ajaxTransport: addToPrefiltersOrTransports(transports),
        ajax: function(url, options) {
            if (typeof url === "object") {
                options = url;
                url = undefined;
            }
            options = options || {};
            var transport, cacheURL, responseHeadersString, responseHeaders, timeoutTimer, urlAnchor, fireGlobals, i, s = jQuery.ajaxSetup({}, options), callbackContext = s.context || s, globalEventContext = s.context && (callbackContext.nodeType || callbackContext.jquery) ? jQuery(callbackContext) : jQuery.event, deferred = jQuery.Deferred(), completeDeferred = jQuery.Callbacks("once memory"), statusCode = s.statusCode || {}, requestHeaders = {}, requestHeadersNames = {}, state = 0, strAbort = "canceled", jqXHR = {
                readyState: 0,
                getResponseHeader: function(key) {
                    var match;
                    if (state === 2) {
                        if (!responseHeaders) {
                            responseHeaders = {};
                            while (match = rheaders.exec(responseHeadersString)) {
                                responseHeaders[match[1].toLowerCase()] = match[2];
                            }
                        }
                        match = responseHeaders[key.toLowerCase()];
                    }
                    return match == null ? null : match;
                },
                getAllResponseHeaders: function() {
                    return state === 2 ? responseHeadersString : null;
                },
                setRequestHeader: function(name, value) {
                    var lname = name.toLowerCase();
                    if (!state) {
                        name = requestHeadersNames[lname] = requestHeadersNames[lname] || name;
                        requestHeaders[name] = value;
                    }
                    return this;
                },
                overrideMimeType: function(type) {
                    if (!state) {
                        s.mimeType = type;
                    }
                    return this;
                },
                statusCode: function(map) {
                    var code;
                    if (map) {
                        if (state < 2) {
                            for (code in map) {
                                statusCode[code] = [ statusCode[code], map[code] ];
                            }
                        } else {
                            jqXHR.always(map[jqXHR.status]);
                        }
                    }
                    return this;
                },
                abort: function(statusText) {
                    var finalText = statusText || strAbort;
                    if (transport) {
                        transport.abort(finalText);
                    }
                    done(0, finalText);
                    return this;
                }
            };
            deferred.promise(jqXHR).complete = completeDeferred.add;
            jqXHR.success = jqXHR.done;
            jqXHR.error = jqXHR.fail;
            s.url = ((url || s.url || location.href) + "").replace(rhash, "").replace(rprotocol, location.protocol + "//");
            s.type = options.method || options.type || s.method || s.type;
            s.dataTypes = jQuery.trim(s.dataType || "*").toLowerCase().match(rnotwhite) || [ "" ];
            if (s.crossDomain == null) {
                urlAnchor = document.createElement("a");
                try {
                    urlAnchor.href = s.url;
                    urlAnchor.href = urlAnchor.href;
                    s.crossDomain = originAnchor.protocol + "//" + originAnchor.host !== urlAnchor.protocol + "//" + urlAnchor.host;
                } catch (e) {
                    s.crossDomain = true;
                }
            }
            if (s.data && s.processData && typeof s.data !== "string") {
                s.data = jQuery.param(s.data, s.traditional);
            }
            inspectPrefiltersOrTransports(prefilters, s, options, jqXHR);
            if (state === 2) {
                return jqXHR;
            }
            fireGlobals = jQuery.event && s.global;
            if (fireGlobals && jQuery.active++ === 0) {
                jQuery.event.trigger("ajaxStart");
            }
            s.type = s.type.toUpperCase();
            s.hasContent = !rnoContent.test(s.type);
            cacheURL = s.url;
            if (!s.hasContent) {
                if (s.data) {
                    cacheURL = s.url += (rquery.test(cacheURL) ? "&" : "?") + s.data;
                    delete s.data;
                }
                if (s.cache === false) {
                    s.url = rts.test(cacheURL) ? cacheURL.replace(rts, "$1_=" + nonce++) : cacheURL + (rquery.test(cacheURL) ? "&" : "?") + "_=" + nonce++;
                }
            }
            if (s.ifModified) {
                if (jQuery.lastModified[cacheURL]) {
                    jqXHR.setRequestHeader("If-Modified-Since", jQuery.lastModified[cacheURL]);
                }
                if (jQuery.etag[cacheURL]) {
                    jqXHR.setRequestHeader("If-None-Match", jQuery.etag[cacheURL]);
                }
            }
            if (s.data && s.hasContent && s.contentType !== false || options.contentType) {
                jqXHR.setRequestHeader("Content-Type", s.contentType);
            }
            jqXHR.setRequestHeader("Accept", s.dataTypes[0] && s.accepts[s.dataTypes[0]] ? s.accepts[s.dataTypes[0]] + (s.dataTypes[0] !== "*" ? ", " + allTypes + "; q=0.01" : "") : s.accepts["*"]);
            for (i in s.headers) {
                jqXHR.setRequestHeader(i, s.headers[i]);
            }
            if (s.beforeSend && (s.beforeSend.call(callbackContext, jqXHR, s) === false || state === 2)) {
                return jqXHR.abort();
            }
            strAbort = "abort";
            for (i in {
                success: 1,
                error: 1,
                complete: 1
            }) {
                jqXHR[i](s[i]);
            }
            transport = inspectPrefiltersOrTransports(transports, s, options, jqXHR);
            if (!transport) {
                done(-1, "No Transport");
            } else {
                jqXHR.readyState = 1;
                if (fireGlobals) {
                    globalEventContext.trigger("ajaxSend", [ jqXHR, s ]);
                }
                if (state === 2) {
                    return jqXHR;
                }
                if (s.async && s.timeout > 0) {
                    timeoutTimer = window.setTimeout(function() {
                        jqXHR.abort("timeout");
                    }, s.timeout);
                }
                try {
                    state = 1;
                    transport.send(requestHeaders, done);
                } catch (e) {
                    if (state < 2) {
                        done(-1, e);
                    } else {
                        throw e;
                    }
                }
            }
            function done(status, nativeStatusText, responses, headers) {
                var isSuccess, success, error, response, modified, statusText = nativeStatusText;
                if (state === 2) {
                    return;
                }
                state = 2;
                if (timeoutTimer) {
                    window.clearTimeout(timeoutTimer);
                }
                transport = undefined;
                responseHeadersString = headers || "";
                jqXHR.readyState = status > 0 ? 4 : 0;
                isSuccess = status >= 200 && status < 300 || status === 304;
                if (responses) {
                    response = ajaxHandleResponses(s, jqXHR, responses);
                }
                response = ajaxConvert(s, response, jqXHR, isSuccess);
                if (isSuccess) {
                    if (s.ifModified) {
                        modified = jqXHR.getResponseHeader("Last-Modified");
                        if (modified) {
                            jQuery.lastModified[cacheURL] = modified;
                        }
                        modified = jqXHR.getResponseHeader("etag");
                        if (modified) {
                            jQuery.etag[cacheURL] = modified;
                        }
                    }
                    if (status === 204 || s.type === "HEAD") {
                        statusText = "nocontent";
                    } else if (status === 304) {
                        statusText = "notmodified";
                    } else {
                        statusText = response.state;
                        success = response.data;
                        error = response.error;
                        isSuccess = !error;
                    }
                } else {
                    error = statusText;
                    if (status || !statusText) {
                        statusText = "error";
                        if (status < 0) {
                            status = 0;
                        }
                    }
                }
                jqXHR.status = status;
                jqXHR.statusText = (nativeStatusText || statusText) + "";
                if (isSuccess) {
                    deferred.resolveWith(callbackContext, [ success, statusText, jqXHR ]);
                } else {
                    deferred.rejectWith(callbackContext, [ jqXHR, statusText, error ]);
                }
                jqXHR.statusCode(statusCode);
                statusCode = undefined;
                if (fireGlobals) {
                    globalEventContext.trigger(isSuccess ? "ajaxSuccess" : "ajaxError", [ jqXHR, s, isSuccess ? success : error ]);
                }
                completeDeferred.fireWith(callbackContext, [ jqXHR, statusText ]);
                if (fireGlobals) {
                    globalEventContext.trigger("ajaxComplete", [ jqXHR, s ]);
                    if (!--jQuery.active) {
                        jQuery.event.trigger("ajaxStop");
                    }
                }
            }
            return jqXHR;
        },
        getJSON: function(url, data, callback) {
            return jQuery.get(url, data, callback, "json");
        },
        getScript: function(url, callback) {
            return jQuery.get(url, undefined, callback, "script");
        }
    });
    jQuery.each([ "get", "post" ], function(i, method) {
        jQuery[method] = function(url, data, callback, type) {
            if (jQuery.isFunction(data)) {
                type = type || callback;
                callback = data;
                data = undefined;
            }
            return jQuery.ajax(jQuery.extend({
                url: url,
                type: method,
                dataType: type,
                data: data,
                success: callback
            }, jQuery.isPlainObject(url) && url));
        };
    });
    jQuery._evalUrl = function(url) {
        return jQuery.ajax({
            url: url,
            type: "GET",
            dataType: "script",
            async: false,
            global: false,
            "throws": true
        });
    };
    jQuery.fn.extend({
        wrapAll: function(html) {
            var wrap;
            if (jQuery.isFunction(html)) {
                return this.each(function(i) {
                    jQuery(this).wrapAll(html.call(this, i));
                });
            }
            if (this[0]) {
                wrap = jQuery(html, this[0].ownerDocument).eq(0).clone(true);
                if (this[0].parentNode) {
                    wrap.insertBefore(this[0]);
                }
                wrap.map(function() {
                    var elem = this;
                    while (elem.firstElementChild) {
                        elem = elem.firstElementChild;
                    }
                    return elem;
                }).append(this);
            }
            return this;
        },
        wrapInner: function(html) {
            if (jQuery.isFunction(html)) {
                return this.each(function(i) {
                    jQuery(this).wrapInner(html.call(this, i));
                });
            }
            return this.each(function() {
                var self = jQuery(this), contents = self.contents();
                if (contents.length) {
                    contents.wrapAll(html);
                } else {
                    self.append(html);
                }
            });
        },
        wrap: function(html) {
            var isFunction = jQuery.isFunction(html);
            return this.each(function(i) {
                jQuery(this).wrapAll(isFunction ? html.call(this, i) : html);
            });
        },
        unwrap: function() {
            return this.parent().each(function() {
                if (!jQuery.nodeName(this, "body")) {
                    jQuery(this).replaceWith(this.childNodes);
                }
            }).end();
        }
    });
    jQuery.expr.filters.hidden = function(elem) {
        return !jQuery.expr.filters.visible(elem);
    };
    jQuery.expr.filters.visible = function(elem) {
        return elem.offsetWidth > 0 || elem.offsetHeight > 0 || elem.getClientRects().length > 0;
    };
    var r20 = /%20/g, rbracket = /\[\]$/, rCRLF = /\r?\n/g, rsubmitterTypes = /^(?:submit|button|image|reset|file)$/i, rsubmittable = /^(?:input|select|textarea|keygen)/i;
    function buildParams(prefix, obj, traditional, add) {
        var name;
        if (jQuery.isArray(obj)) {
            jQuery.each(obj, function(i, v) {
                if (traditional || rbracket.test(prefix)) {
                    add(prefix, v);
                } else {
                    buildParams(prefix + "[" + (typeof v === "object" && v != null ? i : "") + "]", v, traditional, add);
                }
            });
        } else if (!traditional && jQuery.type(obj) === "object") {
            for (name in obj) {
                buildParams(prefix + "[" + name + "]", obj[name], traditional, add);
            }
        } else {
            add(prefix, obj);
        }
    }
    jQuery.param = function(a, traditional) {
        var prefix, s = [], add = function(key, value) {
            value = jQuery.isFunction(value) ? value() : value == null ? "" : value;
            s[s.length] = encodeURIComponent(key) + "=" + encodeURIComponent(value);
        };
        if (traditional === undefined) {
            traditional = jQuery.ajaxSettings && jQuery.ajaxSettings.traditional;
        }
        if (jQuery.isArray(a) || a.jquery && !jQuery.isPlainObject(a)) {
            jQuery.each(a, function() {
                add(this.name, this.value);
            });
        } else {
            for (prefix in a) {
                buildParams(prefix, a[prefix], traditional, add);
            }
        }
        return s.join("&").replace(r20, "+");
    };
    jQuery.fn.extend({
        serialize: function() {
            return jQuery.param(this.serializeArray());
        },
        serializeArray: function() {
            return this.map(function() {
                var elements = jQuery.prop(this, "elements");
                return elements ? jQuery.makeArray(elements) : this;
            }).filter(function() {
                var type = this.type;
                return this.name && !jQuery(this).is(":disabled") && rsubmittable.test(this.nodeName) && !rsubmitterTypes.test(type) && (this.checked || !rcheckableType.test(type));
            }).map(function(i, elem) {
                var val = jQuery(this).val();
                return val == null ? null : jQuery.isArray(val) ? jQuery.map(val, function(val) {
                    return {
                        name: elem.name,
                        value: val.replace(rCRLF, "\r\n")
                    };
                }) : {
                    name: elem.name,
                    value: val.replace(rCRLF, "\r\n")
                };
            }).get();
        }
    });
    jQuery.ajaxSettings.xhr = function() {
        try {
            return new window.XMLHttpRequest();
        } catch (e) {}
    };
    var xhrSuccessStatus = {
        0: 200,
        1223: 204
    }, xhrSupported = jQuery.ajaxSettings.xhr();
    support.cors = !!xhrSupported && "withCredentials" in xhrSupported;
    support.ajax = xhrSupported = !!xhrSupported;
    jQuery.ajaxTransport(function(options) {
        var callback, errorCallback;
        if (support.cors || xhrSupported && !options.crossDomain) {
            return {
                send: function(headers, complete) {
                    var i, xhr = options.xhr();
                    xhr.open(options.type, options.url, options.async, options.username, options.password);
                    if (options.xhrFields) {
                        for (i in options.xhrFields) {
                            xhr[i] = options.xhrFields[i];
                        }
                    }
                    if (options.mimeType && xhr.overrideMimeType) {
                        xhr.overrideMimeType(options.mimeType);
                    }
                    if (!options.crossDomain && !headers["X-Requested-With"]) {
                        headers["X-Requested-With"] = "XMLHttpRequest";
                    }
                    for (i in headers) {
                        xhr.setRequestHeader(i, headers[i]);
                    }
                    callback = function(type) {
                        return function() {
                            if (callback) {
                                callback = errorCallback = xhr.onload = xhr.onerror = xhr.onabort = xhr.onreadystatechange = null;
                                if (type === "abort") {
                                    xhr.abort();
                                } else if (type === "error") {
                                    if (typeof xhr.status !== "number") {
                                        complete(0, "error");
                                    } else {
                                        complete(xhr.status, xhr.statusText);
                                    }
                                } else {
                                    complete(xhrSuccessStatus[xhr.status] || xhr.status, xhr.statusText, (xhr.responseType || "text") !== "text" || typeof xhr.responseText !== "string" ? {
                                        binary: xhr.response
                                    } : {
                                        text: xhr.responseText
                                    }, xhr.getAllResponseHeaders());
                                }
                            }
                        };
                    };
                    xhr.onload = callback();
                    errorCallback = xhr.onerror = callback("error");
                    if (xhr.onabort !== undefined) {
                        xhr.onabort = errorCallback;
                    } else {
                        xhr.onreadystatechange = function() {
                            if (xhr.readyState === 4) {
                                window.setTimeout(function() {
                                    if (callback) {
                                        errorCallback();
                                    }
                                });
                            }
                        };
                    }
                    callback = callback("abort");
                    try {
                        xhr.send(options.hasContent && options.data || null);
                    } catch (e) {
                        if (callback) {
                            throw e;
                        }
                    }
                },
                abort: function() {
                    if (callback) {
                        callback();
                    }
                }
            };
        }
    });
    jQuery.ajaxSetup({
        accepts: {
            script: "text/javascript, application/javascript, " + "application/ecmascript, application/x-ecmascript"
        },
        contents: {
            script: /\b(?:java|ecma)script\b/
        },
        converters: {
            "text script": function(text) {
                jQuery.globalEval(text);
                return text;
            }
        }
    });
    jQuery.ajaxPrefilter("script", function(s) {
        if (s.cache === undefined) {
            s.cache = false;
        }
        if (s.crossDomain) {
            s.type = "GET";
        }
    });
    jQuery.ajaxTransport("script", function(s) {
        if (s.crossDomain) {
            var script, callback;
            return {
                send: function(_, complete) {
                    script = jQuery("<script>").prop({
                        charset: s.scriptCharset,
                        src: s.url
                    }).on("load error", callback = function(evt) {
                        script.remove();
                        callback = null;
                        if (evt) {
                            complete(evt.type === "error" ? 404 : 200, evt.type);
                        }
                    });
                    document.head.appendChild(script[0]);
                },
                abort: function() {
                    if (callback) {
                        callback();
                    }
                }
            };
        }
    });
    var oldCallbacks = [], rjsonp = /(=)\?(?=&|$)|\?\?/;
    jQuery.ajaxSetup({
        jsonp: "callback",
        jsonpCallback: function() {
            var callback = oldCallbacks.pop() || jQuery.expando + "_" + nonce++;
            this[callback] = true;
            return callback;
        }
    });
    jQuery.ajaxPrefilter("json jsonp", function(s, originalSettings, jqXHR) {
        var callbackName, overwritten, responseContainer, jsonProp = s.jsonp !== false && (rjsonp.test(s.url) ? "url" : typeof s.data === "string" && (s.contentType || "").indexOf("application/x-www-form-urlencoded") === 0 && rjsonp.test(s.data) && "data");
        if (jsonProp || s.dataTypes[0] === "jsonp") {
            callbackName = s.jsonpCallback = jQuery.isFunction(s.jsonpCallback) ? s.jsonpCallback() : s.jsonpCallback;
            if (jsonProp) {
                s[jsonProp] = s[jsonProp].replace(rjsonp, "$1" + callbackName);
            } else if (s.jsonp !== false) {
                s.url += (rquery.test(s.url) ? "&" : "?") + s.jsonp + "=" + callbackName;
            }
            s.converters["script json"] = function() {
                if (!responseContainer) {
                    jQuery.error(callbackName + " was not called");
                }
                return responseContainer[0];
            };
            s.dataTypes[0] = "json";
            overwritten = window[callbackName];
            window[callbackName] = function() {
                responseContainer = arguments;
            };
            jqXHR.always(function() {
                if (overwritten === undefined) {
                    jQuery(window).removeProp(callbackName);
                } else {
                    window[callbackName] = overwritten;
                }
                if (s[callbackName]) {
                    s.jsonpCallback = originalSettings.jsonpCallback;
                    oldCallbacks.push(callbackName);
                }
                if (responseContainer && jQuery.isFunction(overwritten)) {
                    overwritten(responseContainer[0]);
                }
                responseContainer = overwritten = undefined;
            });
            return "script";
        }
    });
    jQuery.parseHTML = function(data, context, keepScripts) {
        if (!data || typeof data !== "string") {
            return null;
        }
        if (typeof context === "boolean") {
            keepScripts = context;
            context = false;
        }
        context = context || document;
        var parsed = rsingleTag.exec(data), scripts = !keepScripts && [];
        if (parsed) {
            return [ context.createElement(parsed[1]) ];
        }
        parsed = buildFragment([ data ], context, scripts);
        if (scripts && scripts.length) {
            jQuery(scripts).remove();
        }
        return jQuery.merge([], parsed.childNodes);
    };
    var _load = jQuery.fn.load;
    jQuery.fn.load = function(url, params, callback) {
        if (typeof url !== "string" && _load) {
            return _load.apply(this, arguments);
        }
        var selector, type, response, self = this, off = url.indexOf(" ");
        if (off > -1) {
            selector = jQuery.trim(url.slice(off));
            url = url.slice(0, off);
        }
        if (jQuery.isFunction(params)) {
            callback = params;
            params = undefined;
        } else if (params && typeof params === "object") {
            type = "POST";
        }
        if (self.length > 0) {
            jQuery.ajax({
                url: url,
                type: type || "GET",
                dataType: "html",
                data: params
            }).done(function(responseText) {
                response = arguments;
                self.html(selector ? jQuery("<div>").append(jQuery.parseHTML(responseText)).find(selector) : responseText);
            }).always(callback && function(jqXHR, status) {
                self.each(function() {
                    callback.apply(this, response || [ jqXHR.responseText, status, jqXHR ]);
                });
            });
        }
        return this;
    };
    jQuery.each([ "ajaxStart", "ajaxStop", "ajaxComplete", "ajaxError", "ajaxSuccess", "ajaxSend" ], function(i, type) {
        jQuery.fn[type] = function(fn) {
            return this.on(type, fn);
        };
    });
    jQuery.expr.filters.animated = function(elem) {
        return jQuery.grep(jQuery.timers, function(fn) {
            return elem === fn.elem;
        }).length;
    };
    function getWindow(elem) {
        return jQuery.isWindow(elem) ? elem : elem.nodeType === 9 && elem.defaultView;
    }
    jQuery.offset = {
        setOffset: function(elem, options, i) {
            var curPosition, curLeft, curCSSTop, curTop, curOffset, curCSSLeft, calculatePosition, position = jQuery.css(elem, "position"), curElem = jQuery(elem), props = {};
            if (position === "static") {
                elem.style.position = "relative";
            }
            curOffset = curElem.offset();
            curCSSTop = jQuery.css(elem, "top");
            curCSSLeft = jQuery.css(elem, "left");
            calculatePosition = (position === "absolute" || position === "fixed") && (curCSSTop + curCSSLeft).indexOf("auto") > -1;
            if (calculatePosition) {
                curPosition = curElem.position();
                curTop = curPosition.top;
                curLeft = curPosition.left;
            } else {
                curTop = parseFloat(curCSSTop) || 0;
                curLeft = parseFloat(curCSSLeft) || 0;
            }
            if (jQuery.isFunction(options)) {
                options = options.call(elem, i, jQuery.extend({}, curOffset));
            }
            if (options.top != null) {
                props.top = options.top - curOffset.top + curTop;
            }
            if (options.left != null) {
                props.left = options.left - curOffset.left + curLeft;
            }
            if ("using" in options) {
                options.using.call(elem, props);
            } else {
                curElem.css(props);
            }
        }
    };
    jQuery.fn.extend({
        offset: function(options) {
            if (arguments.length) {
                return options === undefined ? this : this.each(function(i) {
                    jQuery.offset.setOffset(this, options, i);
                });
            }
            var docElem, win, elem = this[0], box = {
                top: 0,
                left: 0
            }, doc = elem && elem.ownerDocument;
            if (!doc) {
                return;
            }
            docElem = doc.documentElement;
            if (!jQuery.contains(docElem, elem)) {
                return box;
            }
            box = elem.getBoundingClientRect();
            win = getWindow(doc);
            return {
                top: box.top + win.pageYOffset - docElem.clientTop,
                left: box.left + win.pageXOffset - docElem.clientLeft
            };
        },
        position: function() {
            if (!this[0]) {
                return;
            }
            var offsetParent, offset, elem = this[0], parentOffset = {
                top: 0,
                left: 0
            };
            if (jQuery.css(elem, "position") === "fixed") {
                offset = elem.getBoundingClientRect();
            } else {
                offsetParent = this.offsetParent();
                offset = this.offset();
                if (!jQuery.nodeName(offsetParent[0], "html")) {
                    parentOffset = offsetParent.offset();
                }
                parentOffset.top += jQuery.css(offsetParent[0], "borderTopWidth", true);
                parentOffset.left += jQuery.css(offsetParent[0], "borderLeftWidth", true);
            }
            return {
                top: offset.top - parentOffset.top - jQuery.css(elem, "marginTop", true),
                left: offset.left - parentOffset.left - jQuery.css(elem, "marginLeft", true)
            };
        },
        offsetParent: function() {
            return this.map(function() {
                var offsetParent = this.offsetParent;
                while (offsetParent && jQuery.css(offsetParent, "position") === "static") {
                    offsetParent = offsetParent.offsetParent;
                }
                return offsetParent || documentElement;
            });
        }
    });
    jQuery.each({
        scrollLeft: "pageXOffset",
        scrollTop: "pageYOffset"
    }, function(method, prop) {
        var top = "pageYOffset" === prop;
        jQuery.fn[method] = function(val) {
            return access(this, function(elem, method, val) {
                var win = getWindow(elem);
                if (val === undefined) {
                    return win ? win[prop] : elem[method];
                }
                if (win) {
                    win.scrollTo(!top ? val : win.pageXOffset, top ? val : win.pageYOffset);
                } else {
                    elem[method] = val;
                }
            }, method, val, arguments.length);
        };
    });
    jQuery.each([ "top", "left" ], function(i, prop) {
        jQuery.cssHooks[prop] = addGetHookIf(support.pixelPosition, function(elem, computed) {
            if (computed) {
                computed = curCSS(elem, prop);
                return rnumnonpx.test(computed) ? jQuery(elem).position()[prop] + "px" : computed;
            }
        });
    });
    jQuery.each({
        Height: "height",
        Width: "width"
    }, function(name, type) {
        jQuery.each({
            padding: "inner" + name,
            content: type,
            "": "outer" + name
        }, function(defaultExtra, funcName) {
            jQuery.fn[funcName] = function(margin, value) {
                var chainable = arguments.length && (defaultExtra || typeof margin !== "boolean"), extra = defaultExtra || (margin === true || value === true ? "margin" : "border");
                return access(this, function(elem, type, value) {
                    var doc;
                    if (jQuery.isWindow(elem)) {
                        return elem.document.documentElement["client" + name];
                    }
                    if (elem.nodeType === 9) {
                        doc = elem.documentElement;
                        return Math.max(elem.body["scroll" + name], doc["scroll" + name], elem.body["offset" + name], doc["offset" + name], doc["client" + name]);
                    }
                    return value === undefined ? jQuery.css(elem, type, extra) : jQuery.style(elem, type, value, extra);
                }, type, chainable ? margin : undefined, chainable, null);
            };
        });
    });
    jQuery.fn.extend({
        bind: function(types, data, fn) {
            return this.on(types, null, data, fn);
        },
        unbind: function(types, fn) {
            return this.off(types, null, fn);
        },
        delegate: function(selector, types, data, fn) {
            return this.on(types, selector, data, fn);
        },
        undelegate: function(selector, types, fn) {
            return arguments.length === 1 ? this.off(selector, "**") : this.off(types, selector || "**", fn);
        },
        size: function() {
            return this.length;
        }
    });
    jQuery.fn.andSelf = jQuery.fn.addBack;
    if (typeof define === "function" && define.amd) {
        define("jquery", [], function() {
            return jQuery;
        });
    }
    var _jQuery = window.jQuery, _$ = window.$;
    jQuery.noConflict = function(deep) {
        if (window.$ === jQuery) {
            window.$ = _$;
        }
        if (deep && window.jQuery === jQuery) {
            window.jQuery = _jQuery;
        }
        return jQuery;
    };
    if (!noGlobal) {
        window.jQuery = window.$ = jQuery;
    }
    return jQuery;
});

if (typeof jQuery === "undefined") {
    throw new Error("Bootstrap's JavaScript requires jQuery");
}

+function($) {
    "use strict";
    var version = $.fn.jquery.split(" ")[0].split(".");
    if (version[0] < 2 && version[1] < 9 || version[0] == 1 && version[1] == 9 && version[2] < 1 || version[0] > 3) {
        throw new Error("Bootstrap's JavaScript requires jQuery version 1.9.1 or higher, but lower than version 4");
    }
}(jQuery);

+function($) {
    "use strict";
    function transitionEnd() {
        var el = document.createElement("bootstrap");
        var transEndEventNames = {
            WebkitTransition: "webkitTransitionEnd",
            MozTransition: "transitionend",
            OTransition: "oTransitionEnd otransitionend",
            transition: "transitionend"
        };
        for (var name in transEndEventNames) {
            if (el.style[name] !== undefined) {
                return {
                    end: transEndEventNames[name]
                };
            }
        }
        return false;
    }
    $.fn.emulateTransitionEnd = function(duration) {
        var called = false;
        var $el = this;
        $(this).one("bsTransitionEnd", function() {
            called = true;
        });
        var callback = function() {
            if (!called) $($el).trigger($.support.transition.end);
        };
        setTimeout(callback, duration);
        return this;
    };
    $(function() {
        $.support.transition = transitionEnd();
        if (!$.support.transition) return;
        $.event.special.bsTransitionEnd = {
            bindType: $.support.transition.end,
            delegateType: $.support.transition.end,
            handle: function(e) {
                if ($(e.target).is(this)) return e.handleObj.handler.apply(this, arguments);
            }
        };
    });
}(jQuery);

+function($) {
    "use strict";
    var dismiss = '[data-dismiss="alert"]';
    var Alert = function(el) {
        $(el).on("click", dismiss, this.close);
    };
    Alert.VERSION = "3.3.7";
    Alert.TRANSITION_DURATION = 150;
    Alert.prototype.close = function(e) {
        var $this = $(this);
        var selector = $this.attr("data-target");
        if (!selector) {
            selector = $this.attr("href");
            selector = selector && selector.replace(/.*(?=#[^\s]*$)/, "");
        }
        var $parent = $(selector === "#" ? [] : selector);
        if (e) e.preventDefault();
        if (!$parent.length) {
            $parent = $this.closest(".alert");
        }
        $parent.trigger(e = $.Event("close.bs.alert"));
        if (e.isDefaultPrevented()) return;
        $parent.removeClass("in");
        function removeElement() {
            $parent.detach().trigger("closed.bs.alert").remove();
        }
        $.support.transition && $parent.hasClass("fade") ? $parent.one("bsTransitionEnd", removeElement).emulateTransitionEnd(Alert.TRANSITION_DURATION) : removeElement();
    };
    function Plugin(option) {
        return this.each(function() {
            var $this = $(this);
            var data = $this.data("bs.alert");
            if (!data) $this.data("bs.alert", data = new Alert(this));
            if (typeof option == "string") data[option].call($this);
        });
    }
    var old = $.fn.alert;
    $.fn.alert = Plugin;
    $.fn.alert.Constructor = Alert;
    $.fn.alert.noConflict = function() {
        $.fn.alert = old;
        return this;
    };
    $(document).on("click.bs.alert.data-api", dismiss, Alert.prototype.close);
}(jQuery);

+function($) {
    "use strict";
    var Button = function(element, options) {
        this.$element = $(element);
        this.options = $.extend({}, Button.DEFAULTS, options);
        this.isLoading = false;
    };
    Button.VERSION = "3.3.7";
    Button.DEFAULTS = {
        loadingText: "loading..."
    };
    Button.prototype.setState = function(state) {
        var d = "disabled";
        var $el = this.$element;
        var val = $el.is("input") ? "val" : "html";
        var data = $el.data();
        state += "Text";
        if (data.resetText == null) $el.data("resetText", $el[val]());
        setTimeout($.proxy(function() {
            $el[val](data[state] == null ? this.options[state] : data[state]);
            if (state == "loadingText") {
                this.isLoading = true;
                $el.addClass(d).attr(d, d).prop(d, true);
            } else if (this.isLoading) {
                this.isLoading = false;
                $el.removeClass(d).removeAttr(d).prop(d, false);
            }
        }, this), 0);
    };
    Button.prototype.toggle = function() {
        var changed = true;
        var $parent = this.$element.closest('[data-toggle="buttons"]');
        if ($parent.length) {
            var $input = this.$element.find("input");
            if ($input.prop("type") == "radio") {
                if ($input.prop("checked")) changed = false;
                $parent.find(".active").removeClass("active");
                this.$element.addClass("active");
            } else if ($input.prop("type") == "checkbox") {
                if ($input.prop("checked") !== this.$element.hasClass("active")) changed = false;
                this.$element.toggleClass("active");
            }
            $input.prop("checked", this.$element.hasClass("active"));
            if (changed) $input.trigger("change");
        } else {
            this.$element.attr("aria-pressed", !this.$element.hasClass("active"));
            this.$element.toggleClass("active");
        }
    };
    function Plugin(option) {
        return this.each(function() {
            var $this = $(this);
            var data = $this.data("bs.button");
            var options = typeof option == "object" && option;
            if (!data) $this.data("bs.button", data = new Button(this, options));
            if (option == "toggle") data.toggle(); else if (option) data.setState(option);
        });
    }
    var old = $.fn.button;
    $.fn.button = Plugin;
    $.fn.button.Constructor = Button;
    $.fn.button.noConflict = function() {
        $.fn.button = old;
        return this;
    };
    $(document).on("click.bs.button.data-api", '[data-toggle^="button"]', function(e) {
        var $btn = $(e.target).closest(".btn");
        Plugin.call($btn, "toggle");
        if (!$(e.target).is('input[type="radio"], input[type="checkbox"]')) {
            e.preventDefault();
            if ($btn.is("input,button")) $btn.trigger("focus"); else $btn.find("input:visible,button:visible").first().trigger("focus");
        }
    }).on("focus.bs.button.data-api blur.bs.button.data-api", '[data-toggle^="button"]', function(e) {
        $(e.target).closest(".btn").toggleClass("focus", /^focus(in)?$/.test(e.type));
    });
}(jQuery);

+function($) {
    "use strict";
    var Carousel = function(element, options) {
        this.$element = $(element);
        this.$indicators = this.$element.find(".carousel-indicators");
        this.options = options;
        this.paused = null;
        this.sliding = null;
        this.interval = null;
        this.$active = null;
        this.$items = null;
        this.options.keyboard && this.$element.on("keydown.bs.carousel", $.proxy(this.keydown, this));
        this.options.pause == "hover" && !("ontouchstart" in document.documentElement) && this.$element.on("mouseenter.bs.carousel", $.proxy(this.pause, this)).on("mouseleave.bs.carousel", $.proxy(this.cycle, this));
    };
    Carousel.VERSION = "3.3.7";
    Carousel.TRANSITION_DURATION = 600;
    Carousel.DEFAULTS = {
        interval: 5e3,
        pause: "hover",
        wrap: true,
        keyboard: true
    };
    Carousel.prototype.keydown = function(e) {
        if (/input|textarea/i.test(e.target.tagName)) return;
        switch (e.which) {
          case 37:
            this.prev();
            break;

          case 39:
            this.next();
            break;

          default:
            return;
        }
        e.preventDefault();
    };
    Carousel.prototype.cycle = function(e) {
        e || (this.paused = false);
        this.interval && clearInterval(this.interval);
        this.options.interval && !this.paused && (this.interval = setInterval($.proxy(this.next, this), this.options.interval));
        return this;
    };
    Carousel.prototype.getItemIndex = function(item) {
        this.$items = item.parent().children(".item");
        return this.$items.index(item || this.$active);
    };
    Carousel.prototype.getItemForDirection = function(direction, active) {
        var activeIndex = this.getItemIndex(active);
        var willWrap = direction == "prev" && activeIndex === 0 || direction == "next" && activeIndex == this.$items.length - 1;
        if (willWrap && !this.options.wrap) return active;
        var delta = direction == "prev" ? -1 : 1;
        var itemIndex = (activeIndex + delta) % this.$items.length;
        return this.$items.eq(itemIndex);
    };
    Carousel.prototype.to = function(pos) {
        var that = this;
        var activeIndex = this.getItemIndex(this.$active = this.$element.find(".item.active"));
        if (pos > this.$items.length - 1 || pos < 0) return;
        if (this.sliding) return this.$element.one("slid.bs.carousel", function() {
            that.to(pos);
        });
        if (activeIndex == pos) return this.pause().cycle();
        return this.slide(pos > activeIndex ? "next" : "prev", this.$items.eq(pos));
    };
    Carousel.prototype.pause = function(e) {
        e || (this.paused = true);
        if (this.$element.find(".next, .prev").length && $.support.transition) {
            this.$element.trigger($.support.transition.end);
            this.cycle(true);
        }
        this.interval = clearInterval(this.interval);
        return this;
    };
    Carousel.prototype.next = function() {
        if (this.sliding) return;
        return this.slide("next");
    };
    Carousel.prototype.prev = function() {
        if (this.sliding) return;
        return this.slide("prev");
    };
    Carousel.prototype.slide = function(type, next) {
        var $active = this.$element.find(".item.active");
        var $next = next || this.getItemForDirection(type, $active);
        var isCycling = this.interval;
        var direction = type == "next" ? "left" : "right";
        var that = this;
        if ($next.hasClass("active")) return this.sliding = false;
        var relatedTarget = $next[0];
        var slideEvent = $.Event("slide.bs.carousel", {
            relatedTarget: relatedTarget,
            direction: direction
        });
        this.$element.trigger(slideEvent);
        if (slideEvent.isDefaultPrevented()) return;
        this.sliding = true;
        isCycling && this.pause();
        if (this.$indicators.length) {
            this.$indicators.find(".active").removeClass("active");
            var $nextIndicator = $(this.$indicators.children()[this.getItemIndex($next)]);
            $nextIndicator && $nextIndicator.addClass("active");
        }
        var slidEvent = $.Event("slid.bs.carousel", {
            relatedTarget: relatedTarget,
            direction: direction
        });
        if ($.support.transition && this.$element.hasClass("slide")) {
            $next.addClass(type);
            $next[0].offsetWidth;
            $active.addClass(direction);
            $next.addClass(direction);
            $active.one("bsTransitionEnd", function() {
                $next.removeClass([ type, direction ].join(" ")).addClass("active");
                $active.removeClass([ "active", direction ].join(" "));
                that.sliding = false;
                setTimeout(function() {
                    that.$element.trigger(slidEvent);
                }, 0);
            }).emulateTransitionEnd(Carousel.TRANSITION_DURATION);
        } else {
            $active.removeClass("active");
            $next.addClass("active");
            this.sliding = false;
            this.$element.trigger(slidEvent);
        }
        isCycling && this.cycle();
        return this;
    };
    function Plugin(option) {
        return this.each(function() {
            var $this = $(this);
            var data = $this.data("bs.carousel");
            var options = $.extend({}, Carousel.DEFAULTS, $this.data(), typeof option == "object" && option);
            var action = typeof option == "string" ? option : options.slide;
            if (!data) $this.data("bs.carousel", data = new Carousel(this, options));
            if (typeof option == "number") data.to(option); else if (action) data[action](); else if (options.interval) data.pause().cycle();
        });
    }
    var old = $.fn.carousel;
    $.fn.carousel = Plugin;
    $.fn.carousel.Constructor = Carousel;
    $.fn.carousel.noConflict = function() {
        $.fn.carousel = old;
        return this;
    };
    var clickHandler = function(e) {
        var href;
        var $this = $(this);
        var $target = $($this.attr("data-target") || (href = $this.attr("href")) && href.replace(/.*(?=#[^\s]+$)/, ""));
        if (!$target.hasClass("carousel")) return;
        var options = $.extend({}, $target.data(), $this.data());
        var slideIndex = $this.attr("data-slide-to");
        if (slideIndex) options.interval = false;
        Plugin.call($target, options);
        if (slideIndex) {
            $target.data("bs.carousel").to(slideIndex);
        }
        e.preventDefault();
    };
    $(document).on("click.bs.carousel.data-api", "[data-slide]", clickHandler).on("click.bs.carousel.data-api", "[data-slide-to]", clickHandler);
    $(window).on("load", function() {
        $('[data-ride="carousel"]').each(function() {
            var $carousel = $(this);
            Plugin.call($carousel, $carousel.data());
        });
    });
}(jQuery);

+function($) {
    "use strict";
    var Collapse = function(element, options) {
        this.$element = $(element);
        this.options = $.extend({}, Collapse.DEFAULTS, options);
        this.$trigger = $('[data-toggle="collapse"][href="#' + element.id + '"],' + '[data-toggle="collapse"][data-target="#' + element.id + '"]');
        this.transitioning = null;
        if (this.options.parent) {
            this.$parent = this.getParent();
        } else {
            this.addAriaAndCollapsedClass(this.$element, this.$trigger);
        }
        if (this.options.toggle) this.toggle();
    };
    Collapse.VERSION = "3.3.7";
    Collapse.TRANSITION_DURATION = 350;
    Collapse.DEFAULTS = {
        toggle: true
    };
    Collapse.prototype.dimension = function() {
        var hasWidth = this.$element.hasClass("width");
        return hasWidth ? "width" : "height";
    };
    Collapse.prototype.show = function() {
        if (this.transitioning || this.$element.hasClass("in")) return;
        var activesData;
        var actives = this.$parent && this.$parent.children(".panel").children(".in, .collapsing");
        if (actives && actives.length) {
            activesData = actives.data("bs.collapse");
            if (activesData && activesData.transitioning) return;
        }
        var startEvent = $.Event("show.bs.collapse");
        this.$element.trigger(startEvent);
        if (startEvent.isDefaultPrevented()) return;
        if (actives && actives.length) {
            Plugin.call(actives, "hide");
            activesData || actives.data("bs.collapse", null);
        }
        var dimension = this.dimension();
        this.$element.removeClass("collapse").addClass("collapsing")[dimension](0).attr("aria-expanded", true);
        this.$trigger.removeClass("collapsed").attr("aria-expanded", true);
        this.transitioning = 1;
        var complete = function() {
            this.$element.removeClass("collapsing").addClass("collapse in")[dimension]("");
            this.transitioning = 0;
            this.$element.trigger("shown.bs.collapse");
        };
        if (!$.support.transition) return complete.call(this);
        var scrollSize = $.camelCase([ "scroll", dimension ].join("-"));
        this.$element.one("bsTransitionEnd", $.proxy(complete, this)).emulateTransitionEnd(Collapse.TRANSITION_DURATION)[dimension](this.$element[0][scrollSize]);
    };
    Collapse.prototype.hide = function() {
        if (this.transitioning || !this.$element.hasClass("in")) return;
        var startEvent = $.Event("hide.bs.collapse");
        this.$element.trigger(startEvent);
        if (startEvent.isDefaultPrevented()) return;
        var dimension = this.dimension();
        this.$element[dimension](this.$element[dimension]())[0].offsetHeight;
        this.$element.addClass("collapsing").removeClass("collapse in").attr("aria-expanded", false);
        this.$trigger.addClass("collapsed").attr("aria-expanded", false);
        this.transitioning = 1;
        var complete = function() {
            this.transitioning = 0;
            this.$element.removeClass("collapsing").addClass("collapse").trigger("hidden.bs.collapse");
        };
        if (!$.support.transition) return complete.call(this);
        this.$element[dimension](0).one("bsTransitionEnd", $.proxy(complete, this)).emulateTransitionEnd(Collapse.TRANSITION_DURATION);
    };
    Collapse.prototype.toggle = function() {
        this[this.$element.hasClass("in") ? "hide" : "show"]();
    };
    Collapse.prototype.getParent = function() {
        return $(this.options.parent).find('[data-toggle="collapse"][data-parent="' + this.options.parent + '"]').each($.proxy(function(i, element) {
            var $element = $(element);
            this.addAriaAndCollapsedClass(getTargetFromTrigger($element), $element);
        }, this)).end();
    };
    Collapse.prototype.addAriaAndCollapsedClass = function($element, $trigger) {
        var isOpen = $element.hasClass("in");
        $element.attr("aria-expanded", isOpen);
        $trigger.toggleClass("collapsed", !isOpen).attr("aria-expanded", isOpen);
    };
    function getTargetFromTrigger($trigger) {
        var href;
        var target = $trigger.attr("data-target") || (href = $trigger.attr("href")) && href.replace(/.*(?=#[^\s]+$)/, "");
        return $(target);
    }
    function Plugin(option) {
        return this.each(function() {
            var $this = $(this);
            var data = $this.data("bs.collapse");
            var options = $.extend({}, Collapse.DEFAULTS, $this.data(), typeof option == "object" && option);
            if (!data && options.toggle && /show|hide/.test(option)) options.toggle = false;
            if (!data) $this.data("bs.collapse", data = new Collapse(this, options));
            if (typeof option == "string") data[option]();
        });
    }
    var old = $.fn.collapse;
    $.fn.collapse = Plugin;
    $.fn.collapse.Constructor = Collapse;
    $.fn.collapse.noConflict = function() {
        $.fn.collapse = old;
        return this;
    };
    $(document).on("click.bs.collapse.data-api", '[data-toggle="collapse"]', function(e) {
        var $this = $(this);
        if (!$this.attr("data-target")) e.preventDefault();
        var $target = getTargetFromTrigger($this);
        var data = $target.data("bs.collapse");
        var option = data ? "toggle" : $this.data();
        Plugin.call($target, option);
    });
}(jQuery);

+function($) {
    "use strict";
    var backdrop = ".dropdown-backdrop";
    var toggle = '[data-toggle="dropdown"]';
    var Dropdown = function(element) {
        $(element).on("click.bs.dropdown", this.toggle);
    };
    Dropdown.VERSION = "3.3.7";
    function getParent($this) {
        var selector = $this.attr("data-target");
        if (!selector) {
            selector = $this.attr("href");
            selector = selector && /#[A-Za-z]/.test(selector) && selector.replace(/.*(?=#[^\s]*$)/, "");
        }
        var $parent = selector && $(selector);
        return $parent && $parent.length ? $parent : $this.parent();
    }
    function clearMenus(e) {
        if (e && e.which === 3) return;
        $(backdrop).remove();
        $(toggle).each(function() {
            var $this = $(this);
            var $parent = getParent($this);
            var relatedTarget = {
                relatedTarget: this
            };
            if (!$parent.hasClass("open")) return;
            if (e && e.type == "click" && /input|textarea/i.test(e.target.tagName) && $.contains($parent[0], e.target)) return;
            $parent.trigger(e = $.Event("hide.bs.dropdown", relatedTarget));
            if (e.isDefaultPrevented()) return;
            $this.attr("aria-expanded", "false");
            $parent.removeClass("open").trigger($.Event("hidden.bs.dropdown", relatedTarget));
        });
    }
    Dropdown.prototype.toggle = function(e) {
        var $this = $(this);
        if ($this.is(".disabled, :disabled")) return;
        var $parent = getParent($this);
        var isActive = $parent.hasClass("open");
        clearMenus();
        if (!isActive) {
            if ("ontouchstart" in document.documentElement && !$parent.closest(".navbar-nav").length) {
                $(document.createElement("div")).addClass("dropdown-backdrop").insertAfter($(this)).on("click", clearMenus);
            }
            var relatedTarget = {
                relatedTarget: this
            };
            $parent.trigger(e = $.Event("show.bs.dropdown", relatedTarget));
            if (e.isDefaultPrevented()) return;
            $this.trigger("focus").attr("aria-expanded", "true");
            $parent.toggleClass("open").trigger($.Event("shown.bs.dropdown", relatedTarget));
        }
        return false;
    };
    Dropdown.prototype.keydown = function(e) {
        if (!/(38|40|27|32)/.test(e.which) || /input|textarea/i.test(e.target.tagName)) return;
        var $this = $(this);
        e.preventDefault();
        e.stopPropagation();
        if ($this.is(".disabled, :disabled")) return;
        var $parent = getParent($this);
        var isActive = $parent.hasClass("open");
        if (!isActive && e.which != 27 || isActive && e.which == 27) {
            if (e.which == 27) $parent.find(toggle).trigger("focus");
            return $this.trigger("click");
        }
        var desc = " li:not(.disabled):visible a";
        var $items = $parent.find(".dropdown-menu" + desc);
        if (!$items.length) return;
        var index = $items.index(e.target);
        if (e.which == 38 && index > 0) index--;
        if (e.which == 40 && index < $items.length - 1) index++;
        if (!~index) index = 0;
        $items.eq(index).trigger("focus");
    };
    function Plugin(option) {
        return this.each(function() {
            var $this = $(this);
            var data = $this.data("bs.dropdown");
            if (!data) $this.data("bs.dropdown", data = new Dropdown(this));
            if (typeof option == "string") data[option].call($this);
        });
    }
    var old = $.fn.dropdown;
    $.fn.dropdown = Plugin;
    $.fn.dropdown.Constructor = Dropdown;
    $.fn.dropdown.noConflict = function() {
        $.fn.dropdown = old;
        return this;
    };
    $(document).on("click.bs.dropdown.data-api", clearMenus).on("click.bs.dropdown.data-api", ".dropdown form", function(e) {
        e.stopPropagation();
    }).on("click.bs.dropdown.data-api", toggle, Dropdown.prototype.toggle).on("keydown.bs.dropdown.data-api", toggle, Dropdown.prototype.keydown).on("keydown.bs.dropdown.data-api", ".dropdown-menu", Dropdown.prototype.keydown);
}(jQuery);

+function($) {
    "use strict";
    var Modal = function(element, options) {
        this.options = options;
        this.$body = $(document.body);
        this.$element = $(element);
        this.$dialog = this.$element.find(".modal-dialog");
        this.$backdrop = null;
        this.isShown = null;
        this.originalBodyPad = null;
        this.scrollbarWidth = 0;
        this.ignoreBackdropClick = false;
        if (this.options.remote) {
            this.$element.find(".modal-content").load(this.options.remote, $.proxy(function() {
                this.$element.trigger("loaded.bs.modal");
            }, this));
        }
    };
    Modal.VERSION = "3.3.7";
    Modal.TRANSITION_DURATION = 300;
    Modal.BACKDROP_TRANSITION_DURATION = 150;
    Modal.DEFAULTS = {
        backdrop: true,
        keyboard: true,
        show: true
    };
    Modal.prototype.toggle = function(_relatedTarget) {
        return this.isShown ? this.hide() : this.show(_relatedTarget);
    };
    Modal.prototype.show = function(_relatedTarget) {
        var that = this;
        var e = $.Event("show.bs.modal", {
            relatedTarget: _relatedTarget
        });
        this.$element.trigger(e);
        if (this.isShown || e.isDefaultPrevented()) return;
        this.isShown = true;
        this.checkScrollbar();
        this.setScrollbar();
        this.$body.addClass("modal-open");
        this.escape();
        this.resize();
        this.$element.on("click.dismiss.bs.modal", '[data-dismiss="modal"]', $.proxy(this.hide, this));
        this.$dialog.on("mousedown.dismiss.bs.modal", function() {
            that.$element.one("mouseup.dismiss.bs.modal", function(e) {
                if ($(e.target).is(that.$element)) that.ignoreBackdropClick = true;
            });
        });
        this.backdrop(function() {
            var transition = $.support.transition && that.$element.hasClass("fade");
            if (!that.$element.parent().length) {
                that.$element.appendTo(that.$body);
            }
            that.$element.show().scrollTop(0);
            that.adjustDialog();
            if (transition) {
                that.$element[0].offsetWidth;
            }
            that.$element.addClass("in");
            that.enforceFocus();
            var e = $.Event("shown.bs.modal", {
                relatedTarget: _relatedTarget
            });
            transition ? that.$dialog.one("bsTransitionEnd", function() {
                that.$element.trigger("focus").trigger(e);
            }).emulateTransitionEnd(Modal.TRANSITION_DURATION) : that.$element.trigger("focus").trigger(e);
        });
    };
    Modal.prototype.hide = function(e) {
        if (e) e.preventDefault();
        e = $.Event("hide.bs.modal");
        this.$element.trigger(e);
        if (!this.isShown || e.isDefaultPrevented()) return;
        this.isShown = false;
        this.escape();
        this.resize();
        $(document).off("focusin.bs.modal");
        this.$element.removeClass("in").off("click.dismiss.bs.modal").off("mouseup.dismiss.bs.modal");
        this.$dialog.off("mousedown.dismiss.bs.modal");
        $.support.transition && this.$element.hasClass("fade") ? this.$element.one("bsTransitionEnd", $.proxy(this.hideModal, this)).emulateTransitionEnd(Modal.TRANSITION_DURATION) : this.hideModal();
    };
    Modal.prototype.enforceFocus = function() {
        $(document).off("focusin.bs.modal").on("focusin.bs.modal", $.proxy(function(e) {
            if (document !== e.target && this.$element[0] !== e.target && !this.$element.has(e.target).length) {
                this.$element.trigger("focus");
            }
        }, this));
    };
    Modal.prototype.escape = function() {
        if (this.isShown && this.options.keyboard) {
            this.$element.on("keydown.dismiss.bs.modal", $.proxy(function(e) {
                e.which == 27 && this.hide();
            }, this));
        } else if (!this.isShown) {
            this.$element.off("keydown.dismiss.bs.modal");
        }
    };
    Modal.prototype.resize = function() {
        if (this.isShown) {
            $(window).on("resize.bs.modal", $.proxy(this.handleUpdate, this));
        } else {
            $(window).off("resize.bs.modal");
        }
    };
    Modal.prototype.hideModal = function() {
        var that = this;
        this.$element.hide();
        this.backdrop(function() {
            that.$body.removeClass("modal-open");
            that.resetAdjustments();
            that.resetScrollbar();
            that.$element.trigger("hidden.bs.modal");
        });
    };
    Modal.prototype.removeBackdrop = function() {
        this.$backdrop && this.$backdrop.remove();
        this.$backdrop = null;
    };
    Modal.prototype.backdrop = function(callback) {
        var that = this;
        var animate = this.$element.hasClass("fade") ? "fade" : "";
        if (this.isShown && this.options.backdrop) {
            var doAnimate = $.support.transition && animate;
            this.$backdrop = $(document.createElement("div")).addClass("modal-backdrop " + animate).appendTo(this.$body);
            this.$element.on("click.dismiss.bs.modal", $.proxy(function(e) {
                if (this.ignoreBackdropClick) {
                    this.ignoreBackdropClick = false;
                    return;
                }
                if (e.target !== e.currentTarget) return;
                this.options.backdrop == "static" ? this.$element[0].focus() : this.hide();
            }, this));
            if (doAnimate) this.$backdrop[0].offsetWidth;
            this.$backdrop.addClass("in");
            if (!callback) return;
            doAnimate ? this.$backdrop.one("bsTransitionEnd", callback).emulateTransitionEnd(Modal.BACKDROP_TRANSITION_DURATION) : callback();
        } else if (!this.isShown && this.$backdrop) {
            this.$backdrop.removeClass("in");
            var callbackRemove = function() {
                that.removeBackdrop();
                callback && callback();
            };
            $.support.transition && this.$element.hasClass("fade") ? this.$backdrop.one("bsTransitionEnd", callbackRemove).emulateTransitionEnd(Modal.BACKDROP_TRANSITION_DURATION) : callbackRemove();
        } else if (callback) {
            callback();
        }
    };
    Modal.prototype.handleUpdate = function() {
        this.adjustDialog();
    };
    Modal.prototype.adjustDialog = function() {
        var modalIsOverflowing = this.$element[0].scrollHeight > document.documentElement.clientHeight;
        this.$element.css({
            paddingLeft: !this.bodyIsOverflowing && modalIsOverflowing ? this.scrollbarWidth : "",
            paddingRight: this.bodyIsOverflowing && !modalIsOverflowing ? this.scrollbarWidth : ""
        });
    };
    Modal.prototype.resetAdjustments = function() {
        this.$element.css({
            paddingLeft: "",
            paddingRight: ""
        });
    };
    Modal.prototype.checkScrollbar = function() {
        var fullWindowWidth = window.innerWidth;
        if (!fullWindowWidth) {
            var documentElementRect = document.documentElement.getBoundingClientRect();
            fullWindowWidth = documentElementRect.right - Math.abs(documentElementRect.left);
        }
        this.bodyIsOverflowing = document.body.clientWidth < fullWindowWidth;
        this.scrollbarWidth = this.measureScrollbar();
    };
    Modal.prototype.setScrollbar = function() {
        var bodyPad = parseInt(this.$body.css("padding-right") || 0, 10);
        this.originalBodyPad = document.body.style.paddingRight || "";
        if (this.bodyIsOverflowing) this.$body.css("padding-right", bodyPad + this.scrollbarWidth);
    };
    Modal.prototype.resetScrollbar = function() {
        this.$body.css("padding-right", this.originalBodyPad);
    };
    Modal.prototype.measureScrollbar = function() {
        var scrollDiv = document.createElement("div");
        scrollDiv.className = "modal-scrollbar-measure";
        this.$body.append(scrollDiv);
        var scrollbarWidth = scrollDiv.offsetWidth - scrollDiv.clientWidth;
        this.$body[0].removeChild(scrollDiv);
        return scrollbarWidth;
    };
    function Plugin(option, _relatedTarget) {
        return this.each(function() {
            var $this = $(this);
            var data = $this.data("bs.modal");
            var options = $.extend({}, Modal.DEFAULTS, $this.data(), typeof option == "object" && option);
            if (!data) $this.data("bs.modal", data = new Modal(this, options));
            if (typeof option == "string") data[option](_relatedTarget); else if (options.show) data.show(_relatedTarget);
        });
    }
    var old = $.fn.modal;
    $.fn.modal = Plugin;
    $.fn.modal.Constructor = Modal;
    $.fn.modal.noConflict = function() {
        $.fn.modal = old;
        return this;
    };
    $(document).on("click.bs.modal.data-api", '[data-toggle="modal"]', function(e) {
        var $this = $(this);
        var href = $this.attr("href");
        var $target = $($this.attr("data-target") || href && href.replace(/.*(?=#[^\s]+$)/, ""));
        var option = $target.data("bs.modal") ? "toggle" : $.extend({
            remote: !/#/.test(href) && href
        }, $target.data(), $this.data());
        if ($this.is("a")) e.preventDefault();
        $target.one("show.bs.modal", function(showEvent) {
            if (showEvent.isDefaultPrevented()) return;
            $target.one("hidden.bs.modal", function() {
                $this.is(":visible") && $this.trigger("focus");
            });
        });
        Plugin.call($target, option, this);
    });
}(jQuery);

+function($) {
    "use strict";
    var Tooltip = function(element, options) {
        this.type = null;
        this.options = null;
        this.enabled = null;
        this.timeout = null;
        this.hoverState = null;
        this.$element = null;
        this.inState = null;
        this.init("tooltip", element, options);
    };
    Tooltip.VERSION = "3.3.7";
    Tooltip.TRANSITION_DURATION = 150;
    Tooltip.DEFAULTS = {
        animation: true,
        placement: "top",
        selector: false,
        template: '<div class="tooltip" role="tooltip"><div class="tooltip-arrow"></div><div class="tooltip-inner"></div></div>',
        trigger: "hover focus",
        title: "",
        delay: 0,
        html: false,
        container: false,
        viewport: {
            selector: "body",
            padding: 0
        }
    };
    Tooltip.prototype.init = function(type, element, options) {
        this.enabled = true;
        this.type = type;
        this.$element = $(element);
        this.options = this.getOptions(options);
        this.$viewport = this.options.viewport && $($.isFunction(this.options.viewport) ? this.options.viewport.call(this, this.$element) : this.options.viewport.selector || this.options.viewport);
        this.inState = {
            click: false,
            hover: false,
            focus: false
        };
        if (this.$element[0] instanceof document.constructor && !this.options.selector) {
            throw new Error("`selector` option must be specified when initializing " + this.type + " on the window.document object!");
        }
        var triggers = this.options.trigger.split(" ");
        for (var i = triggers.length; i--; ) {
            var trigger = triggers[i];
            if (trigger == "click") {
                this.$element.on("click." + this.type, this.options.selector, $.proxy(this.toggle, this));
            } else if (trigger != "manual") {
                var eventIn = trigger == "hover" ? "mouseenter" : "focusin";
                var eventOut = trigger == "hover" ? "mouseleave" : "focusout";
                this.$element.on(eventIn + "." + this.type, this.options.selector, $.proxy(this.enter, this));
                this.$element.on(eventOut + "." + this.type, this.options.selector, $.proxy(this.leave, this));
            }
        }
        this.options.selector ? this._options = $.extend({}, this.options, {
            trigger: "manual",
            selector: ""
        }) : this.fixTitle();
    };
    Tooltip.prototype.getDefaults = function() {
        return Tooltip.DEFAULTS;
    };
    Tooltip.prototype.getOptions = function(options) {
        options = $.extend({}, this.getDefaults(), this.$element.data(), options);
        if (options.delay && typeof options.delay == "number") {
            options.delay = {
                show: options.delay,
                hide: options.delay
            };
        }
        return options;
    };
    Tooltip.prototype.getDelegateOptions = function() {
        var options = {};
        var defaults = this.getDefaults();
        this._options && $.each(this._options, function(key, value) {
            if (defaults[key] != value) options[key] = value;
        });
        return options;
    };
    Tooltip.prototype.enter = function(obj) {
        var self = obj instanceof this.constructor ? obj : $(obj.currentTarget).data("bs." + this.type);
        if (!self) {
            self = new this.constructor(obj.currentTarget, this.getDelegateOptions());
            $(obj.currentTarget).data("bs." + this.type, self);
        }
        if (obj instanceof $.Event) {
            self.inState[obj.type == "focusin" ? "focus" : "hover"] = true;
        }
        if (self.tip().hasClass("in") || self.hoverState == "in") {
            self.hoverState = "in";
            return;
        }
        clearTimeout(self.timeout);
        self.hoverState = "in";
        if (!self.options.delay || !self.options.delay.show) return self.show();
        self.timeout = setTimeout(function() {
            if (self.hoverState == "in") self.show();
        }, self.options.delay.show);
    };
    Tooltip.prototype.isInStateTrue = function() {
        for (var key in this.inState) {
            if (this.inState[key]) return true;
        }
        return false;
    };
    Tooltip.prototype.leave = function(obj) {
        var self = obj instanceof this.constructor ? obj : $(obj.currentTarget).data("bs." + this.type);
        if (!self) {
            self = new this.constructor(obj.currentTarget, this.getDelegateOptions());
            $(obj.currentTarget).data("bs." + this.type, self);
        }
        if (obj instanceof $.Event) {
            self.inState[obj.type == "focusout" ? "focus" : "hover"] = false;
        }
        if (self.isInStateTrue()) return;
        clearTimeout(self.timeout);
        self.hoverState = "out";
        if (!self.options.delay || !self.options.delay.hide) return self.hide();
        self.timeout = setTimeout(function() {
            if (self.hoverState == "out") self.hide();
        }, self.options.delay.hide);
    };
    Tooltip.prototype.show = function() {
        var e = $.Event("show.bs." + this.type);
        if (this.hasContent() && this.enabled) {
            this.$element.trigger(e);
            var inDom = $.contains(this.$element[0].ownerDocument.documentElement, this.$element[0]);
            if (e.isDefaultPrevented() || !inDom) return;
            var that = this;
            var $tip = this.tip();
            var tipId = this.getUID(this.type);
            this.setContent();
            $tip.attr("id", tipId);
            this.$element.attr("aria-describedby", tipId);
            if (this.options.animation) $tip.addClass("fade");
            var placement = typeof this.options.placement == "function" ? this.options.placement.call(this, $tip[0], this.$element[0]) : this.options.placement;
            var autoToken = /\s?auto?\s?/i;
            var autoPlace = autoToken.test(placement);
            if (autoPlace) placement = placement.replace(autoToken, "") || "top";
            $tip.detach().css({
                top: 0,
                left: 0,
                display: "block"
            }).addClass(placement).data("bs." + this.type, this);
            this.options.container ? $tip.appendTo(this.options.container) : $tip.insertAfter(this.$element);
            this.$element.trigger("inserted.bs." + this.type);
            var pos = this.getPosition();
            var actualWidth = $tip[0].offsetWidth;
            var actualHeight = $tip[0].offsetHeight;
            if (autoPlace) {
                var orgPlacement = placement;
                var viewportDim = this.getPosition(this.$viewport);
                placement = placement == "bottom" && pos.bottom + actualHeight > viewportDim.bottom ? "top" : placement == "top" && pos.top - actualHeight < viewportDim.top ? "bottom" : placement == "right" && pos.right + actualWidth > viewportDim.width ? "left" : placement == "left" && pos.left - actualWidth < viewportDim.left ? "right" : placement;
                $tip.removeClass(orgPlacement).addClass(placement);
            }
            var calculatedOffset = this.getCalculatedOffset(placement, pos, actualWidth, actualHeight);
            this.applyPlacement(calculatedOffset, placement);
            var complete = function() {
                var prevHoverState = that.hoverState;
                that.$element.trigger("shown.bs." + that.type);
                that.hoverState = null;
                if (prevHoverState == "out") that.leave(that);
            };
            $.support.transition && this.$tip.hasClass("fade") ? $tip.one("bsTransitionEnd", complete).emulateTransitionEnd(Tooltip.TRANSITION_DURATION) : complete();
        }
    };
    Tooltip.prototype.applyPlacement = function(offset, placement) {
        var $tip = this.tip();
        var width = $tip[0].offsetWidth;
        var height = $tip[0].offsetHeight;
        var marginTop = parseInt($tip.css("margin-top"), 10);
        var marginLeft = parseInt($tip.css("margin-left"), 10);
        if (isNaN(marginTop)) marginTop = 0;
        if (isNaN(marginLeft)) marginLeft = 0;
        offset.top += marginTop;
        offset.left += marginLeft;
        $.offset.setOffset($tip[0], $.extend({
            using: function(props) {
                $tip.css({
                    top: Math.round(props.top),
                    left: Math.round(props.left)
                });
            }
        }, offset), 0);
        $tip.addClass("in");
        var actualWidth = $tip[0].offsetWidth;
        var actualHeight = $tip[0].offsetHeight;
        if (placement == "top" && actualHeight != height) {
            offset.top = offset.top + height - actualHeight;
        }
        var delta = this.getViewportAdjustedDelta(placement, offset, actualWidth, actualHeight);
        if (delta.left) offset.left += delta.left; else offset.top += delta.top;
        var isVertical = /top|bottom/.test(placement);
        var arrowDelta = isVertical ? delta.left * 2 - width + actualWidth : delta.top * 2 - height + actualHeight;
        var arrowOffsetPosition = isVertical ? "offsetWidth" : "offsetHeight";
        $tip.offset(offset);
        this.replaceArrow(arrowDelta, $tip[0][arrowOffsetPosition], isVertical);
    };
    Tooltip.prototype.replaceArrow = function(delta, dimension, isVertical) {
        this.arrow().css(isVertical ? "left" : "top", 50 * (1 - delta / dimension) + "%").css(isVertical ? "top" : "left", "");
    };
    Tooltip.prototype.setContent = function() {
        var $tip = this.tip();
        var title = this.getTitle();
        $tip.find(".tooltip-inner")[this.options.html ? "html" : "text"](title);
        $tip.removeClass("fade in top bottom left right");
    };
    Tooltip.prototype.hide = function(callback) {
        var that = this;
        var $tip = $(this.$tip);
        var e = $.Event("hide.bs." + this.type);
        function complete() {
            if (that.hoverState != "in") $tip.detach();
            if (that.$element) {
                that.$element.removeAttr("aria-describedby").trigger("hidden.bs." + that.type);
            }
            callback && callback();
        }
        this.$element.trigger(e);
        if (e.isDefaultPrevented()) return;
        $tip.removeClass("in");
        $.support.transition && $tip.hasClass("fade") ? $tip.one("bsTransitionEnd", complete).emulateTransitionEnd(Tooltip.TRANSITION_DURATION) : complete();
        this.hoverState = null;
        return this;
    };
    Tooltip.prototype.fixTitle = function() {
        var $e = this.$element;
        if ($e.attr("title") || typeof $e.attr("data-original-title") != "string") {
            $e.attr("data-original-title", $e.attr("title") || "").attr("title", "");
        }
    };
    Tooltip.prototype.hasContent = function() {
        return this.getTitle();
    };
    Tooltip.prototype.getPosition = function($element) {
        $element = $element || this.$element;
        var el = $element[0];
        var isBody = el.tagName == "BODY";
        var elRect = el.getBoundingClientRect();
        if (elRect.width == null) {
            elRect = $.extend({}, elRect, {
                width: elRect.right - elRect.left,
                height: elRect.bottom - elRect.top
            });
        }
        var isSvg = window.SVGElement && el instanceof window.SVGElement;
        var elOffset = isBody ? {
            top: 0,
            left: 0
        } : isSvg ? null : $element.offset();
        var scroll = {
            scroll: isBody ? document.documentElement.scrollTop || document.body.scrollTop : $element.scrollTop()
        };
        var outerDims = isBody ? {
            width: $(window).width(),
            height: $(window).height()
        } : null;
        return $.extend({}, elRect, scroll, outerDims, elOffset);
    };
    Tooltip.prototype.getCalculatedOffset = function(placement, pos, actualWidth, actualHeight) {
        return placement == "bottom" ? {
            top: pos.top + pos.height,
            left: pos.left + pos.width / 2 - actualWidth / 2
        } : placement == "top" ? {
            top: pos.top - actualHeight,
            left: pos.left + pos.width / 2 - actualWidth / 2
        } : placement == "left" ? {
            top: pos.top + pos.height / 2 - actualHeight / 2,
            left: pos.left - actualWidth
        } : {
            top: pos.top + pos.height / 2 - actualHeight / 2,
            left: pos.left + pos.width
        };
    };
    Tooltip.prototype.getViewportAdjustedDelta = function(placement, pos, actualWidth, actualHeight) {
        var delta = {
            top: 0,
            left: 0
        };
        if (!this.$viewport) return delta;
        var viewportPadding = this.options.viewport && this.options.viewport.padding || 0;
        var viewportDimensions = this.getPosition(this.$viewport);
        if (/right|left/.test(placement)) {
            var topEdgeOffset = pos.top - viewportPadding - viewportDimensions.scroll;
            var bottomEdgeOffset = pos.top + viewportPadding - viewportDimensions.scroll + actualHeight;
            if (topEdgeOffset < viewportDimensions.top) {
                delta.top = viewportDimensions.top - topEdgeOffset;
            } else if (bottomEdgeOffset > viewportDimensions.top + viewportDimensions.height) {
                delta.top = viewportDimensions.top + viewportDimensions.height - bottomEdgeOffset;
            }
        } else {
            var leftEdgeOffset = pos.left - viewportPadding;
            var rightEdgeOffset = pos.left + viewportPadding + actualWidth;
            if (leftEdgeOffset < viewportDimensions.left) {
                delta.left = viewportDimensions.left - leftEdgeOffset;
            } else if (rightEdgeOffset > viewportDimensions.right) {
                delta.left = viewportDimensions.left + viewportDimensions.width - rightEdgeOffset;
            }
        }
        return delta;
    };
    Tooltip.prototype.getTitle = function() {
        var title;
        var $e = this.$element;
        var o = this.options;
        title = $e.attr("data-original-title") || (typeof o.title == "function" ? o.title.call($e[0]) : o.title);
        return title;
    };
    Tooltip.prototype.getUID = function(prefix) {
        do prefix += ~~(Math.random() * 1e6); while (document.getElementById(prefix));
        return prefix;
    };
    Tooltip.prototype.tip = function() {
        if (!this.$tip) {
            this.$tip = $(this.options.template);
            if (this.$tip.length != 1) {
                throw new Error(this.type + " `template` option must consist of exactly 1 top-level element!");
            }
        }
        return this.$tip;
    };
    Tooltip.prototype.arrow = function() {
        return this.$arrow = this.$arrow || this.tip().find(".tooltip-arrow");
    };
    Tooltip.prototype.enable = function() {
        this.enabled = true;
    };
    Tooltip.prototype.disable = function() {
        this.enabled = false;
    };
    Tooltip.prototype.toggleEnabled = function() {
        this.enabled = !this.enabled;
    };
    Tooltip.prototype.toggle = function(e) {
        var self = this;
        if (e) {
            self = $(e.currentTarget).data("bs." + this.type);
            if (!self) {
                self = new this.constructor(e.currentTarget, this.getDelegateOptions());
                $(e.currentTarget).data("bs." + this.type, self);
            }
        }
        if (e) {
            self.inState.click = !self.inState.click;
            if (self.isInStateTrue()) self.enter(self); else self.leave(self);
        } else {
            self.tip().hasClass("in") ? self.leave(self) : self.enter(self);
        }
    };
    Tooltip.prototype.destroy = function() {
        var that = this;
        clearTimeout(this.timeout);
        this.hide(function() {
            that.$element.off("." + that.type).removeData("bs." + that.type);
            if (that.$tip) {
                that.$tip.detach();
            }
            that.$tip = null;
            that.$arrow = null;
            that.$viewport = null;
            that.$element = null;
        });
    };
    function Plugin(option) {
        return this.each(function() {
            var $this = $(this);
            var data = $this.data("bs.tooltip");
            var options = typeof option == "object" && option;
            if (!data && /destroy|hide/.test(option)) return;
            if (!data) $this.data("bs.tooltip", data = new Tooltip(this, options));
            if (typeof option == "string") data[option]();
        });
    }
    var old = $.fn.tooltip;
    $.fn.tooltip = Plugin;
    $.fn.tooltip.Constructor = Tooltip;
    $.fn.tooltip.noConflict = function() {
        $.fn.tooltip = old;
        return this;
    };
}(jQuery);

+function($) {
    "use strict";
    var Popover = function(element, options) {
        this.init("popover", element, options);
    };
    if (!$.fn.tooltip) throw new Error("Popover requires tooltip.js");
    Popover.VERSION = "3.3.7";
    Popover.DEFAULTS = $.extend({}, $.fn.tooltip.Constructor.DEFAULTS, {
        placement: "right",
        trigger: "click",
        content: "",
        template: '<div class="popover" role="tooltip"><div class="arrow"></div><h3 class="popover-title"></h3><div class="popover-content"></div></div>'
    });
    Popover.prototype = $.extend({}, $.fn.tooltip.Constructor.prototype);
    Popover.prototype.constructor = Popover;
    Popover.prototype.getDefaults = function() {
        return Popover.DEFAULTS;
    };
    Popover.prototype.setContent = function() {
        var $tip = this.tip();
        var title = this.getTitle();
        var content = this.getContent();
        $tip.find(".popover-title")[this.options.html ? "html" : "text"](title);
        $tip.find(".popover-content").children().detach().end()[this.options.html ? typeof content == "string" ? "html" : "append" : "text"](content);
        $tip.removeClass("fade top bottom left right in");
        if (!$tip.find(".popover-title").html()) $tip.find(".popover-title").hide();
    };
    Popover.prototype.hasContent = function() {
        return this.getTitle() || this.getContent();
    };
    Popover.prototype.getContent = function() {
        var $e = this.$element;
        var o = this.options;
        return $e.attr("data-content") || (typeof o.content == "function" ? o.content.call($e[0]) : o.content);
    };
    Popover.prototype.arrow = function() {
        return this.$arrow = this.$arrow || this.tip().find(".arrow");
    };
    function Plugin(option) {
        return this.each(function() {
            var $this = $(this);
            var data = $this.data("bs.popover");
            var options = typeof option == "object" && option;
            if (!data && /destroy|hide/.test(option)) return;
            if (!data) $this.data("bs.popover", data = new Popover(this, options));
            if (typeof option == "string") data[option]();
        });
    }
    var old = $.fn.popover;
    $.fn.popover = Plugin;
    $.fn.popover.Constructor = Popover;
    $.fn.popover.noConflict = function() {
        $.fn.popover = old;
        return this;
    };
}(jQuery);

+function($) {
    "use strict";
    function ScrollSpy(element, options) {
        this.$body = $(document.body);
        this.$scrollElement = $(element).is(document.body) ? $(window) : $(element);
        this.options = $.extend({}, ScrollSpy.DEFAULTS, options);
        this.selector = (this.options.target || "") + " .nav li > a";
        this.offsets = [];
        this.targets = [];
        this.activeTarget = null;
        this.scrollHeight = 0;
        this.$scrollElement.on("scroll.bs.scrollspy", $.proxy(this.process, this));
        this.refresh();
        this.process();
    }
    ScrollSpy.VERSION = "3.3.7";
    ScrollSpy.DEFAULTS = {
        offset: 10
    };
    ScrollSpy.prototype.getScrollHeight = function() {
        return this.$scrollElement[0].scrollHeight || Math.max(this.$body[0].scrollHeight, document.documentElement.scrollHeight);
    };
    ScrollSpy.prototype.refresh = function() {
        var that = this;
        var offsetMethod = "offset";
        var offsetBase = 0;
        this.offsets = [];
        this.targets = [];
        this.scrollHeight = this.getScrollHeight();
        if (!$.isWindow(this.$scrollElement[0])) {
            offsetMethod = "position";
            offsetBase = this.$scrollElement.scrollTop();
        }
        this.$body.find(this.selector).map(function() {
            var $el = $(this);
            var href = $el.data("target") || $el.attr("href");
            var $href = /^#./.test(href) && $(href);
            return $href && $href.length && $href.is(":visible") && [ [ $href[offsetMethod]().top + offsetBase, href ] ] || null;
        }).sort(function(a, b) {
            return a[0] - b[0];
        }).each(function() {
            that.offsets.push(this[0]);
            that.targets.push(this[1]);
        });
    };
    ScrollSpy.prototype.process = function() {
        var scrollTop = this.$scrollElement.scrollTop() + this.options.offset;
        var scrollHeight = this.getScrollHeight();
        var maxScroll = this.options.offset + scrollHeight - this.$scrollElement.height();
        var offsets = this.offsets;
        var targets = this.targets;
        var activeTarget = this.activeTarget;
        var i;
        if (this.scrollHeight != scrollHeight) {
            this.refresh();
        }
        if (scrollTop >= maxScroll) {
            return activeTarget != (i = targets[targets.length - 1]) && this.activate(i);
        }
        if (activeTarget && scrollTop < offsets[0]) {
            this.activeTarget = null;
            return this.clear();
        }
        for (i = offsets.length; i--; ) {
            activeTarget != targets[i] && scrollTop >= offsets[i] && (offsets[i + 1] === undefined || scrollTop < offsets[i + 1]) && this.activate(targets[i]);
        }
    };
    ScrollSpy.prototype.activate = function(target) {
        this.activeTarget = target;
        this.clear();
        var selector = this.selector + '[data-target="' + target + '"],' + this.selector + '[href="' + target + '"]';
        var active = $(selector).parents("li").addClass("active");
        if (active.parent(".dropdown-menu").length) {
            active = active.closest("li.dropdown").addClass("active");
        }
        active.trigger("activate.bs.scrollspy");
    };
    ScrollSpy.prototype.clear = function() {
        $(this.selector).parentsUntil(this.options.target, ".active").removeClass("active");
    };
    function Plugin(option) {
        return this.each(function() {
            var $this = $(this);
            var data = $this.data("bs.scrollspy");
            var options = typeof option == "object" && option;
            if (!data) $this.data("bs.scrollspy", data = new ScrollSpy(this, options));
            if (typeof option == "string") data[option]();
        });
    }
    var old = $.fn.scrollspy;
    $.fn.scrollspy = Plugin;
    $.fn.scrollspy.Constructor = ScrollSpy;
    $.fn.scrollspy.noConflict = function() {
        $.fn.scrollspy = old;
        return this;
    };
    $(window).on("load.bs.scrollspy.data-api", function() {
        $('[data-spy="scroll"]').each(function() {
            var $spy = $(this);
            Plugin.call($spy, $spy.data());
        });
    });
}(jQuery);

+function($) {
    "use strict";
    var Tab = function(element) {
        this.element = $(element);
    };
    Tab.VERSION = "3.3.7";
    Tab.TRANSITION_DURATION = 150;
    Tab.prototype.show = function() {
        var $this = this.element;
        var $ul = $this.closest("ul:not(.dropdown-menu)");
        var selector = $this.data("target");
        if (!selector) {
            selector = $this.attr("href");
            selector = selector && selector.replace(/.*(?=#[^\s]*$)/, "");
        }
        if ($this.parent("li").hasClass("active")) return;
        var $previous = $ul.find(".active:last a");
        var hideEvent = $.Event("hide.bs.tab", {
            relatedTarget: $this[0]
        });
        var showEvent = $.Event("show.bs.tab", {
            relatedTarget: $previous[0]
        });
        $previous.trigger(hideEvent);
        $this.trigger(showEvent);
        if (showEvent.isDefaultPrevented() || hideEvent.isDefaultPrevented()) return;
        var $target = $(selector);
        this.activate($this.closest("li"), $ul);
        this.activate($target, $target.parent(), function() {
            $previous.trigger({
                type: "hidden.bs.tab",
                relatedTarget: $this[0]
            });
            $this.trigger({
                type: "shown.bs.tab",
                relatedTarget: $previous[0]
            });
        });
    };
    Tab.prototype.activate = function(element, container, callback) {
        var $active = container.find("> .active");
        var transition = callback && $.support.transition && ($active.length && $active.hasClass("fade") || !!container.find("> .fade").length);
        function next() {
            $active.removeClass("active").find("> .dropdown-menu > .active").removeClass("active").end().find('[data-toggle="tab"]').attr("aria-expanded", false);
            element.addClass("active").find('[data-toggle="tab"]').attr("aria-expanded", true);
            if (transition) {
                element[0].offsetWidth;
                element.addClass("in");
            } else {
                element.removeClass("fade");
            }
            if (element.parent(".dropdown-menu").length) {
                element.closest("li.dropdown").addClass("active").end().find('[data-toggle="tab"]').attr("aria-expanded", true);
            }
            callback && callback();
        }
        $active.length && transition ? $active.one("bsTransitionEnd", next).emulateTransitionEnd(Tab.TRANSITION_DURATION) : next();
        $active.removeClass("in");
    };
    function Plugin(option) {
        return this.each(function() {
            var $this = $(this);
            var data = $this.data("bs.tab");
            if (!data) $this.data("bs.tab", data = new Tab(this));
            if (typeof option == "string") data[option]();
        });
    }
    var old = $.fn.tab;
    $.fn.tab = Plugin;
    $.fn.tab.Constructor = Tab;
    $.fn.tab.noConflict = function() {
        $.fn.tab = old;
        return this;
    };
    var clickHandler = function(e) {
        e.preventDefault();
        Plugin.call($(this), "show");
    };
    $(document).on("click.bs.tab.data-api", '[data-toggle="tab"]', clickHandler).on("click.bs.tab.data-api", '[data-toggle="pill"]', clickHandler);
}(jQuery);

+function($) {
    "use strict";
    var Affix = function(element, options) {
        this.options = $.extend({}, Affix.DEFAULTS, options);
        this.$target = $(this.options.target).on("scroll.bs.affix.data-api", $.proxy(this.checkPosition, this)).on("click.bs.affix.data-api", $.proxy(this.checkPositionWithEventLoop, this));
        this.$element = $(element);
        this.affixed = null;
        this.unpin = null;
        this.pinnedOffset = null;
        this.checkPosition();
    };
    Affix.VERSION = "3.3.7";
    Affix.RESET = "affix affix-top affix-bottom";
    Affix.DEFAULTS = {
        offset: 0,
        target: window
    };
    Affix.prototype.getState = function(scrollHeight, height, offsetTop, offsetBottom) {
        var scrollTop = this.$target.scrollTop();
        var position = this.$element.offset();
        var targetHeight = this.$target.height();
        if (offsetTop != null && this.affixed == "top") return scrollTop < offsetTop ? "top" : false;
        if (this.affixed == "bottom") {
            if (offsetTop != null) return scrollTop + this.unpin <= position.top ? false : "bottom";
            return scrollTop + targetHeight <= scrollHeight - offsetBottom ? false : "bottom";
        }
        var initializing = this.affixed == null;
        var colliderTop = initializing ? scrollTop : position.top;
        var colliderHeight = initializing ? targetHeight : height;
        if (offsetTop != null && scrollTop <= offsetTop) return "top";
        if (offsetBottom != null && colliderTop + colliderHeight >= scrollHeight - offsetBottom) return "bottom";
        return false;
    };
    Affix.prototype.getPinnedOffset = function() {
        if (this.pinnedOffset) return this.pinnedOffset;
        this.$element.removeClass(Affix.RESET).addClass("affix");
        var scrollTop = this.$target.scrollTop();
        var position = this.$element.offset();
        return this.pinnedOffset = position.top - scrollTop;
    };
    Affix.prototype.checkPositionWithEventLoop = function() {
        setTimeout($.proxy(this.checkPosition, this), 1);
    };
    Affix.prototype.checkPosition = function() {
        if (!this.$element.is(":visible")) return;
        var height = this.$element.height();
        var offset = this.options.offset;
        var offsetTop = offset.top;
        var offsetBottom = offset.bottom;
        var scrollHeight = Math.max($(document).height(), $(document.body).height());
        if (typeof offset != "object") offsetBottom = offsetTop = offset;
        if (typeof offsetTop == "function") offsetTop = offset.top(this.$element);
        if (typeof offsetBottom == "function") offsetBottom = offset.bottom(this.$element);
        var affix = this.getState(scrollHeight, height, offsetTop, offsetBottom);
        if (this.affixed != affix) {
            if (this.unpin != null) this.$element.css("top", "");
            var affixType = "affix" + (affix ? "-" + affix : "");
            var e = $.Event(affixType + ".bs.affix");
            this.$element.trigger(e);
            if (e.isDefaultPrevented()) return;
            this.affixed = affix;
            this.unpin = affix == "bottom" ? this.getPinnedOffset() : null;
            this.$element.removeClass(Affix.RESET).addClass(affixType).trigger(affixType.replace("affix", "affixed") + ".bs.affix");
        }
        if (affix == "bottom") {
            this.$element.offset({
                top: scrollHeight - height - offsetBottom
            });
        }
    };
    function Plugin(option) {
        return this.each(function() {
            var $this = $(this);
            var data = $this.data("bs.affix");
            var options = typeof option == "object" && option;
            if (!data) $this.data("bs.affix", data = new Affix(this, options));
            if (typeof option == "string") data[option]();
        });
    }
    var old = $.fn.affix;
    $.fn.affix = Plugin;
    $.fn.affix.Constructor = Affix;
    $.fn.affix.noConflict = function() {
        $.fn.affix = old;
        return this;
    };
    $(window).on("load", function() {
        $('[data-spy="affix"]').each(function() {
            var $spy = $(this);
            var data = $spy.data();
            data.offset = data.offset || {};
            if (data.offsetBottom != null) data.offset.bottom = data.offsetBottom;
            if (data.offsetTop != null) data.offset.top = data.offsetTop;
            Plugin.call($spy, data);
        });
    });
}(jQuery);

(function() {
    var undefined;
    var VERSION = "4.11.2";
    var LARGE_ARRAY_SIZE = 200;
    var FUNC_ERROR_TEXT = "Expected a function";
    var HASH_UNDEFINED = "__lodash_hash_undefined__";
    var PLACEHOLDER = "__lodash_placeholder__";
    var BIND_FLAG = 1, BIND_KEY_FLAG = 2, CURRY_BOUND_FLAG = 4, CURRY_FLAG = 8, CURRY_RIGHT_FLAG = 16, PARTIAL_FLAG = 32, PARTIAL_RIGHT_FLAG = 64, ARY_FLAG = 128, REARG_FLAG = 256, FLIP_FLAG = 512;
    var UNORDERED_COMPARE_FLAG = 1, PARTIAL_COMPARE_FLAG = 2;
    var DEFAULT_TRUNC_LENGTH = 30, DEFAULT_TRUNC_OMISSION = "...";
    var HOT_COUNT = 150, HOT_SPAN = 16;
    var LAZY_FILTER_FLAG = 1, LAZY_MAP_FLAG = 2, LAZY_WHILE_FLAG = 3;
    var INFINITY = 1 / 0, MAX_SAFE_INTEGER = 9007199254740991, MAX_INTEGER = 1.7976931348623157e308, NAN = 0 / 0;
    var MAX_ARRAY_LENGTH = 4294967295, MAX_ARRAY_INDEX = MAX_ARRAY_LENGTH - 1, HALF_MAX_ARRAY_LENGTH = MAX_ARRAY_LENGTH >>> 1;
    var argsTag = "[object Arguments]", arrayTag = "[object Array]", boolTag = "[object Boolean]", dateTag = "[object Date]", errorTag = "[object Error]", funcTag = "[object Function]", genTag = "[object GeneratorFunction]", mapTag = "[object Map]", numberTag = "[object Number]", objectTag = "[object Object]", promiseTag = "[object Promise]", regexpTag = "[object RegExp]", setTag = "[object Set]", stringTag = "[object String]", symbolTag = "[object Symbol]", weakMapTag = "[object WeakMap]", weakSetTag = "[object WeakSet]";
    var arrayBufferTag = "[object ArrayBuffer]", dataViewTag = "[object DataView]", float32Tag = "[object Float32Array]", float64Tag = "[object Float64Array]", int8Tag = "[object Int8Array]", int16Tag = "[object Int16Array]", int32Tag = "[object Int32Array]", uint8Tag = "[object Uint8Array]", uint8ClampedTag = "[object Uint8ClampedArray]", uint16Tag = "[object Uint16Array]", uint32Tag = "[object Uint32Array]";
    var reEmptyStringLeading = /\b__p \+= '';/g, reEmptyStringMiddle = /\b(__p \+=) '' \+/g, reEmptyStringTrailing = /(__e\(.*?\)|\b__t\)) \+\n'';/g;
    var reEscapedHtml = /&(?:amp|lt|gt|quot|#39|#96);/g, reUnescapedHtml = /[&<>"'`]/g, reHasEscapedHtml = RegExp(reEscapedHtml.source), reHasUnescapedHtml = RegExp(reUnescapedHtml.source);
    var reEscape = /<%-([\s\S]+?)%>/g, reEvaluate = /<%([\s\S]+?)%>/g, reInterpolate = /<%=([\s\S]+?)%>/g;
    var reIsDeepProp = /\.|\[(?:[^[\]]*|(["'])(?:(?!\1)[^\\]|\\.)*?\1)\]/, reIsPlainProp = /^\w*$/, rePropName = /[^.[\]]+|\[(?:(-?\d+(?:\.\d+)?)|(["'])((?:(?!\2)[^\\]|\\.)*?)\2)\]/g;
    var reRegExpChar = /[\\^$.*+?()[\]{}|]/g, reHasRegExpChar = RegExp(reRegExpChar.source);
    var reTrim = /^\s+|\s+$/g, reTrimStart = /^\s+/, reTrimEnd = /\s+$/;
    var reBasicWord = /[a-zA-Z0-9]+/g;
    var reEscapeChar = /\\(\\)?/g;
    var reEsTemplate = /\$\{([^\\}]*(?:\\.[^\\}]*)*)\}/g;
    var reFlags = /\w*$/;
    var reHasHexPrefix = /^0x/i;
    var reIsBadHex = /^[-+]0x[0-9a-f]+$/i;
    var reIsBinary = /^0b[01]+$/i;
    var reIsHostCtor = /^\[object .+?Constructor\]$/;
    var reIsOctal = /^0o[0-7]+$/i;
    var reIsUint = /^(?:0|[1-9]\d*)$/;
    var reLatin1 = /[\xc0-\xd6\xd8-\xde\xdf-\xf6\xf8-\xff]/g;
    var reNoMatch = /($^)/;
    var reUnescapedString = /['\n\r\u2028\u2029\\]/g;
    var rsAstralRange = "\\ud800-\\udfff", rsComboMarksRange = "\\u0300-\\u036f\\ufe20-\\ufe23", rsComboSymbolsRange = "\\u20d0-\\u20f0", rsDingbatRange = "\\u2700-\\u27bf", rsLowerRange = "a-z\\xdf-\\xf6\\xf8-\\xff", rsMathOpRange = "\\xac\\xb1\\xd7\\xf7", rsNonCharRange = "\\x00-\\x2f\\x3a-\\x40\\x5b-\\x60\\x7b-\\xbf", rsPunctuationRange = "\\u2000-\\u206f", rsSpaceRange = " \\t\\x0b\\f\\xa0\\ufeff\\n\\r\\u2028\\u2029\\u1680\\u180e\\u2000\\u2001\\u2002\\u2003\\u2004\\u2005\\u2006\\u2007\\u2008\\u2009\\u200a\\u202f\\u205f\\u3000", rsUpperRange = "A-Z\\xc0-\\xd6\\xd8-\\xde", rsVarRange = "\\ufe0e\\ufe0f", rsBreakRange = rsMathOpRange + rsNonCharRange + rsPunctuationRange + rsSpaceRange;
    var rsApos = "['â]", rsAstral = "[" + rsAstralRange + "]", rsBreak = "[" + rsBreakRange + "]", rsCombo = "[" + rsComboMarksRange + rsComboSymbolsRange + "]", rsDigits = "\\d+", rsDingbat = "[" + rsDingbatRange + "]", rsLower = "[" + rsLowerRange + "]", rsMisc = "[^" + rsAstralRange + rsBreakRange + rsDigits + rsDingbatRange + rsLowerRange + rsUpperRange + "]", rsFitz = "\\ud83c[\\udffb-\\udfff]", rsModifier = "(?:" + rsCombo + "|" + rsFitz + ")", rsNonAstral = "[^" + rsAstralRange + "]", rsRegional = "(?:\\ud83c[\\udde6-\\uddff]){2}", rsSurrPair = "[\\ud800-\\udbff][\\udc00-\\udfff]", rsUpper = "[" + rsUpperRange + "]", rsZWJ = "\\u200d";
    var rsLowerMisc = "(?:" + rsLower + "|" + rsMisc + ")", rsUpperMisc = "(?:" + rsUpper + "|" + rsMisc + ")", rsOptLowerContr = "(?:" + rsApos + "(?:d|ll|m|re|s|t|ve))?", rsOptUpperContr = "(?:" + rsApos + "(?:D|LL|M|RE|S|T|VE))?", reOptMod = rsModifier + "?", rsOptVar = "[" + rsVarRange + "]?", rsOptJoin = "(?:" + rsZWJ + "(?:" + [ rsNonAstral, rsRegional, rsSurrPair ].join("|") + ")" + rsOptVar + reOptMod + ")*", rsSeq = rsOptVar + reOptMod + rsOptJoin, rsEmoji = "(?:" + [ rsDingbat, rsRegional, rsSurrPair ].join("|") + ")" + rsSeq, rsSymbol = "(?:" + [ rsNonAstral + rsCombo + "?", rsCombo, rsRegional, rsSurrPair, rsAstral ].join("|") + ")";
    var reApos = RegExp(rsApos, "g");
    var reComboMark = RegExp(rsCombo, "g");
    var reComplexSymbol = RegExp(rsFitz + "(?=" + rsFitz + ")|" + rsSymbol + rsSeq, "g");
    var reComplexWord = RegExp([ rsUpper + "?" + rsLower + "+" + rsOptLowerContr + "(?=" + [ rsBreak, rsUpper, "$" ].join("|") + ")", rsUpperMisc + "+" + rsOptUpperContr + "(?=" + [ rsBreak, rsUpper + rsLowerMisc, "$" ].join("|") + ")", rsUpper + "?" + rsLowerMisc + "+" + rsOptLowerContr, rsUpper + "+" + rsOptUpperContr, rsDigits, rsEmoji ].join("|"), "g");
    var reHasComplexSymbol = RegExp("[" + rsZWJ + rsAstralRange + rsComboMarksRange + rsComboSymbolsRange + rsVarRange + "]");
    var reHasComplexWord = /[a-z][A-Z]|[A-Z]{2,}[a-z]|[0-9][a-zA-Z]|[a-zA-Z][0-9]|[^a-zA-Z0-9 ]/;
    var contextProps = [ "Array", "Buffer", "DataView", "Date", "Error", "Float32Array", "Float64Array", "Function", "Int8Array", "Int16Array", "Int32Array", "Map", "Math", "Object", "Promise", "Reflect", "RegExp", "Set", "String", "Symbol", "TypeError", "Uint8Array", "Uint8ClampedArray", "Uint16Array", "Uint32Array", "WeakMap", "_", "clearTimeout", "isFinite", "parseInt", "setTimeout" ];
    var templateCounter = -1;
    var typedArrayTags = {};
    typedArrayTags[float32Tag] = typedArrayTags[float64Tag] = typedArrayTags[int8Tag] = typedArrayTags[int16Tag] = typedArrayTags[int32Tag] = typedArrayTags[uint8Tag] = typedArrayTags[uint8ClampedTag] = typedArrayTags[uint16Tag] = typedArrayTags[uint32Tag] = true;
    typedArrayTags[argsTag] = typedArrayTags[arrayTag] = typedArrayTags[arrayBufferTag] = typedArrayTags[boolTag] = typedArrayTags[dataViewTag] = typedArrayTags[dateTag] = typedArrayTags[errorTag] = typedArrayTags[funcTag] = typedArrayTags[mapTag] = typedArrayTags[numberTag] = typedArrayTags[objectTag] = typedArrayTags[regexpTag] = typedArrayTags[setTag] = typedArrayTags[stringTag] = typedArrayTags[weakMapTag] = false;
    var cloneableTags = {};
    cloneableTags[argsTag] = cloneableTags[arrayTag] = cloneableTags[arrayBufferTag] = cloneableTags[dataViewTag] = cloneableTags[boolTag] = cloneableTags[dateTag] = cloneableTags[float32Tag] = cloneableTags[float64Tag] = cloneableTags[int8Tag] = cloneableTags[int16Tag] = cloneableTags[int32Tag] = cloneableTags[mapTag] = cloneableTags[numberTag] = cloneableTags[objectTag] = cloneableTags[regexpTag] = cloneableTags[setTag] = cloneableTags[stringTag] = cloneableTags[symbolTag] = cloneableTags[uint8Tag] = cloneableTags[uint8ClampedTag] = cloneableTags[uint16Tag] = cloneableTags[uint32Tag] = true;
    cloneableTags[errorTag] = cloneableTags[funcTag] = cloneableTags[weakMapTag] = false;
    var deburredLetters = {
        "Ã": "A",
        "Ã": "A",
        "Ã": "A",
        "Ã": "A",
        "Ã": "A",
        "Ã": "A",
        "Ã ": "a",
        "Ã¡": "a",
        "Ã¢": "a",
        "Ã£": "a",
        "Ã¤": "a",
        "Ã¥": "a",
        "Ã": "C",
        "Ã§": "c",
        "Ã": "D",
        "Ã°": "d",
        "Ã": "E",
        "Ã": "E",
        "Ã": "E",
        "Ã": "E",
        "Ã¨": "e",
        "Ã©": "e",
        "Ãª": "e",
        "Ã«": "e",
        "Ã": "I",
        "Ã": "I",
        "Ã": "I",
        "Ã": "I",
        "Ã¬": "i",
        "Ã­": "i",
        "Ã®": "i",
        "Ã¯": "i",
        "Ã": "N",
        "Ã±": "n",
        "Ã": "O",
        "Ã": "O",
        "Ã": "O",
        "Ã": "O",
        "Ã": "O",
        "Ã": "O",
        "Ã²": "o",
        "Ã³": "o",
        "Ã´": "o",
        "Ãµ": "o",
        "Ã¶": "o",
        "Ã¸": "o",
        "Ã": "U",
        "Ã": "U",
        "Ã": "U",
        "Ã": "U",
        "Ã¹": "u",
        "Ãº": "u",
        "Ã»": "u",
        "Ã¼": "u",
        "Ã": "Y",
        "Ã½": "y",
        "Ã¿": "y",
        "Ã": "Ae",
        "Ã¦": "ae",
        "Ã": "Th",
        "Ã¾": "th",
        "Ã": "ss"
    };
    var htmlEscapes = {
        "&": "&amp;",
        "<": "&lt;",
        ">": "&gt;",
        '"': "&quot;",
        "'": "&#39;",
        "`": "&#96;"
    };
    var htmlUnescapes = {
        "&amp;": "&",
        "&lt;": "<",
        "&gt;": ">",
        "&quot;": '"',
        "&#39;": "'",
        "&#96;": "`"
    };
    var objectTypes = {
        "function": true,
        object: true
    };
    var stringEscapes = {
        "\\": "\\",
        "'": "'",
        "\n": "n",
        "\r": "r",
        "\u2028": "u2028",
        "\u2029": "u2029"
    };
    var freeParseFloat = parseFloat, freeParseInt = parseInt;
    var freeExports = objectTypes[typeof exports] && exports && !exports.nodeType ? exports : undefined;
    var freeModule = objectTypes[typeof module] && module && !module.nodeType ? module : undefined;
    var moduleExports = freeModule && freeModule.exports === freeExports ? freeExports : undefined;
    var freeGlobal = checkGlobal(freeExports && freeModule && typeof global == "object" && global);
    var freeSelf = checkGlobal(objectTypes[typeof self] && self);
    var freeWindow = checkGlobal(objectTypes[typeof window] && window);
    var thisGlobal = checkGlobal(objectTypes[typeof this] && this);
    var root = freeGlobal || freeWindow !== (thisGlobal && thisGlobal.window) && freeWindow || freeSelf || thisGlobal || Function("return this")();
    function addMapEntry(map, pair) {
        map.set(pair[0], pair[1]);
        return map;
    }
    function addSetEntry(set, value) {
        set.add(value);
        return set;
    }
    function apply(func, thisArg, args) {
        var length = args.length;
        switch (length) {
          case 0:
            return func.call(thisArg);

          case 1:
            return func.call(thisArg, args[0]);

          case 2:
            return func.call(thisArg, args[0], args[1]);

          case 3:
            return func.call(thisArg, args[0], args[1], args[2]);
        }
        return func.apply(thisArg, args);
    }
    function arrayAggregator(array, setter, iteratee, accumulator) {
        var index = -1, length = array.length;
        while (++index < length) {
            var value = array[index];
            setter(accumulator, value, iteratee(value), array);
        }
        return accumulator;
    }
    function arrayConcat(array, other) {
        var index = -1, length = array.length, othIndex = -1, othLength = other.length, result = Array(length + othLength);
        while (++index < length) {
            result[index] = array[index];
        }
        while (++othIndex < othLength) {
            result[index++] = other[othIndex];
        }
        return result;
    }
    function arrayEach(array, iteratee) {
        var index = -1, length = array.length;
        while (++index < length) {
            if (iteratee(array[index], index, array) === false) {
                break;
            }
        }
        return array;
    }
    function arrayEachRight(array, iteratee) {
        var length = array.length;
        while (length--) {
            if (iteratee(array[length], length, array) === false) {
                break;
            }
        }
        return array;
    }
    function arrayEvery(array, predicate) {
        var index = -1, length = array.length;
        while (++index < length) {
            if (!predicate(array[index], index, array)) {
                return false;
            }
        }
        return true;
    }
    function arrayFilter(array, predicate) {
        var index = -1, length = array.length, resIndex = 0, result = [];
        while (++index < length) {
            var value = array[index];
            if (predicate(value, index, array)) {
                result[resIndex++] = value;
            }
        }
        return result;
    }
    function arrayIncludes(array, value) {
        return !!array.length && baseIndexOf(array, value, 0) > -1;
    }
    function arrayIncludesWith(array, value, comparator) {
        var index = -1, length = array.length;
        while (++index < length) {
            if (comparator(value, array[index])) {
                return true;
            }
        }
        return false;
    }
    function arrayMap(array, iteratee) {
        var index = -1, length = array.length, result = Array(length);
        while (++index < length) {
            result[index] = iteratee(array[index], index, array);
        }
        return result;
    }
    function arrayPush(array, values) {
        var index = -1, length = values.length, offset = array.length;
        while (++index < length) {
            array[offset + index] = values[index];
        }
        return array;
    }
    function arrayReduce(array, iteratee, accumulator, initAccum) {
        var index = -1, length = array.length;
        if (initAccum && length) {
            accumulator = array[++index];
        }
        while (++index < length) {
            accumulator = iteratee(accumulator, array[index], index, array);
        }
        return accumulator;
    }
    function arrayReduceRight(array, iteratee, accumulator, initAccum) {
        var length = array.length;
        if (initAccum && length) {
            accumulator = array[--length];
        }
        while (length--) {
            accumulator = iteratee(accumulator, array[length], length, array);
        }
        return accumulator;
    }
    function arraySome(array, predicate) {
        var index = -1, length = array.length;
        while (++index < length) {
            if (predicate(array[index], index, array)) {
                return true;
            }
        }
        return false;
    }
    function baseFind(collection, predicate, eachFunc, retKey) {
        var result;
        eachFunc(collection, function(value, key, collection) {
            if (predicate(value, key, collection)) {
                result = retKey ? key : value;
                return false;
            }
        });
        return result;
    }
    function baseFindIndex(array, predicate, fromRight) {
        var length = array.length, index = fromRight ? length : -1;
        while (fromRight ? index-- : ++index < length) {
            if (predicate(array[index], index, array)) {
                return index;
            }
        }
        return -1;
    }
    function baseIndexOf(array, value, fromIndex) {
        if (value !== value) {
            return indexOfNaN(array, fromIndex);
        }
        var index = fromIndex - 1, length = array.length;
        while (++index < length) {
            if (array[index] === value) {
                return index;
            }
        }
        return -1;
    }
    function baseIndexOfWith(array, value, fromIndex, comparator) {
        var index = fromIndex - 1, length = array.length;
        while (++index < length) {
            if (comparator(array[index], value)) {
                return index;
            }
        }
        return -1;
    }
    function baseMean(array, iteratee) {
        var length = array ? array.length : 0;
        return length ? baseSum(array, iteratee) / length : NAN;
    }
    function baseReduce(collection, iteratee, accumulator, initAccum, eachFunc) {
        eachFunc(collection, function(value, index, collection) {
            accumulator = initAccum ? (initAccum = false, value) : iteratee(accumulator, value, index, collection);
        });
        return accumulator;
    }
    function baseSortBy(array, comparer) {
        var length = array.length;
        array.sort(comparer);
        while (length--) {
            array[length] = array[length].value;
        }
        return array;
    }
    function baseSum(array, iteratee) {
        var result, index = -1, length = array.length;
        while (++index < length) {
            var current = iteratee(array[index]);
            if (current !== undefined) {
                result = result === undefined ? current : result + current;
            }
        }
        return result;
    }
    function baseTimes(n, iteratee) {
        var index = -1, result = Array(n);
        while (++index < n) {
            result[index] = iteratee(index);
        }
        return result;
    }
    function baseToPairs(object, props) {
        return arrayMap(props, function(key) {
            return [ key, object[key] ];
        });
    }
    function baseUnary(func) {
        return function(value) {
            return func(value);
        };
    }
    function baseValues(object, props) {
        return arrayMap(props, function(key) {
            return object[key];
        });
    }
    function charsStartIndex(strSymbols, chrSymbols) {
        var index = -1, length = strSymbols.length;
        while (++index < length && baseIndexOf(chrSymbols, strSymbols[index], 0) > -1) {}
        return index;
    }
    function charsEndIndex(strSymbols, chrSymbols) {
        var index = strSymbols.length;
        while (index-- && baseIndexOf(chrSymbols, strSymbols[index], 0) > -1) {}
        return index;
    }
    function checkGlobal(value) {
        return value && value.Object === Object ? value : null;
    }
    function countHolders(array, placeholder) {
        var length = array.length, result = 0;
        while (length--) {
            if (array[length] === placeholder) {
                result++;
            }
        }
        return result;
    }
    function deburrLetter(letter) {
        return deburredLetters[letter];
    }
    function escapeHtmlChar(chr) {
        return htmlEscapes[chr];
    }
    function escapeStringChar(chr) {
        return "\\" + stringEscapes[chr];
    }
    function indexOfNaN(array, fromIndex, fromRight) {
        var length = array.length, index = fromIndex + (fromRight ? 0 : -1);
        while (fromRight ? index-- : ++index < length) {
            var other = array[index];
            if (other !== other) {
                return index;
            }
        }
        return -1;
    }
    function isHostObject(value) {
        var result = false;
        if (value != null && typeof value.toString != "function") {
            try {
                result = !!(value + "");
            } catch (e) {}
        }
        return result;
    }
    function iteratorToArray(iterator) {
        var data, result = [];
        while (!(data = iterator.next()).done) {
            result.push(data.value);
        }
        return result;
    }
    function mapToArray(map) {
        var index = -1, result = Array(map.size);
        map.forEach(function(value, key) {
            result[++index] = [ key, value ];
        });
        return result;
    }
    function replaceHolders(array, placeholder) {
        var index = -1, length = array.length, resIndex = 0, result = [];
        while (++index < length) {
            var value = array[index];
            if (value === placeholder || value === PLACEHOLDER) {
                array[index] = PLACEHOLDER;
                result[resIndex++] = index;
            }
        }
        return result;
    }
    function setToArray(set) {
        var index = -1, result = Array(set.size);
        set.forEach(function(value) {
            result[++index] = value;
        });
        return result;
    }
    function stringSize(string) {
        if (!(string && reHasComplexSymbol.test(string))) {
            return string.length;
        }
        var result = reComplexSymbol.lastIndex = 0;
        while (reComplexSymbol.test(string)) {
            result++;
        }
        return result;
    }
    function stringToArray(string) {
        return string.match(reComplexSymbol);
    }
    function unescapeHtmlChar(chr) {
        return htmlUnescapes[chr];
    }
    function runInContext(context) {
        context = context ? _.defaults({}, context, _.pick(root, contextProps)) : root;
        var Date = context.Date, Error = context.Error, Math = context.Math, RegExp = context.RegExp, TypeError = context.TypeError;
        var arrayProto = context.Array.prototype, objectProto = context.Object.prototype, stringProto = context.String.prototype;
        var funcToString = context.Function.prototype.toString;
        var hasOwnProperty = objectProto.hasOwnProperty;
        var idCounter = 0;
        var objectCtorString = funcToString.call(Object);
        var objectToString = objectProto.toString;
        var oldDash = root._;
        var reIsNative = RegExp("^" + funcToString.call(hasOwnProperty).replace(reRegExpChar, "\\$&").replace(/hasOwnProperty|(function).*?(?=\\\()| for .+?(?=\\\])/g, "$1.*?") + "$");
        var Buffer = moduleExports ? context.Buffer : undefined, Reflect = context.Reflect, Symbol = context.Symbol, Uint8Array = context.Uint8Array, clearTimeout = context.clearTimeout, enumerate = Reflect ? Reflect.enumerate : undefined, getOwnPropertySymbols = Object.getOwnPropertySymbols, iteratorSymbol = typeof (iteratorSymbol = Symbol && Symbol.iterator) == "symbol" ? iteratorSymbol : undefined, objectCreate = Object.create, propertyIsEnumerable = objectProto.propertyIsEnumerable, setTimeout = context.setTimeout, splice = arrayProto.splice;
        var nativeCeil = Math.ceil, nativeFloor = Math.floor, nativeGetPrototype = Object.getPrototypeOf, nativeIsFinite = context.isFinite, nativeJoin = arrayProto.join, nativeKeys = Object.keys, nativeMax = Math.max, nativeMin = Math.min, nativeParseInt = context.parseInt, nativeRandom = Math.random, nativeReplace = stringProto.replace, nativeReverse = arrayProto.reverse, nativeSplit = stringProto.split;
        var DataView = getNative(context, "DataView"), Map = getNative(context, "Map"), Promise = getNative(context, "Promise"), Set = getNative(context, "Set"), WeakMap = getNative(context, "WeakMap"), nativeCreate = getNative(Object, "create");
        var metaMap = WeakMap && new WeakMap();
        var nonEnumShadows = !propertyIsEnumerable.call({
            valueOf: 1
        }, "valueOf");
        var realNames = {};
        var dataViewCtorString = toSource(DataView), mapCtorString = toSource(Map), promiseCtorString = toSource(Promise), setCtorString = toSource(Set), weakMapCtorString = toSource(WeakMap);
        var symbolProto = Symbol ? Symbol.prototype : undefined, symbolValueOf = symbolProto ? symbolProto.valueOf : undefined, symbolToString = symbolProto ? symbolProto.toString : undefined;
        function lodash(value) {
            if (isObjectLike(value) && !isArray(value) && !(value instanceof LazyWrapper)) {
                if (value instanceof LodashWrapper) {
                    return value;
                }
                if (hasOwnProperty.call(value, "__wrapped__")) {
                    return wrapperClone(value);
                }
            }
            return new LodashWrapper(value);
        }
        function baseLodash() {}
        function LodashWrapper(value, chainAll) {
            this.__wrapped__ = value;
            this.__actions__ = [];
            this.__chain__ = !!chainAll;
            this.__index__ = 0;
            this.__values__ = undefined;
        }
        lodash.templateSettings = {
            escape: reEscape,
            evaluate: reEvaluate,
            interpolate: reInterpolate,
            variable: "",
            imports: {
                _: lodash
            }
        };
        lodash.prototype = baseLodash.prototype;
        lodash.prototype.constructor = lodash;
        LodashWrapper.prototype = baseCreate(baseLodash.prototype);
        LodashWrapper.prototype.constructor = LodashWrapper;
        function LazyWrapper(value) {
            this.__wrapped__ = value;
            this.__actions__ = [];
            this.__dir__ = 1;
            this.__filtered__ = false;
            this.__iteratees__ = [];
            this.__takeCount__ = MAX_ARRAY_LENGTH;
            this.__views__ = [];
        }
        function lazyClone() {
            var result = new LazyWrapper(this.__wrapped__);
            result.__actions__ = copyArray(this.__actions__);
            result.__dir__ = this.__dir__;
            result.__filtered__ = this.__filtered__;
            result.__iteratees__ = copyArray(this.__iteratees__);
            result.__takeCount__ = this.__takeCount__;
            result.__views__ = copyArray(this.__views__);
            return result;
        }
        function lazyReverse() {
            if (this.__filtered__) {
                var result = new LazyWrapper(this);
                result.__dir__ = -1;
                result.__filtered__ = true;
            } else {
                result = this.clone();
                result.__dir__ *= -1;
            }
            return result;
        }
        function lazyValue() {
            var array = this.__wrapped__.value(), dir = this.__dir__, isArr = isArray(array), isRight = dir < 0, arrLength = isArr ? array.length : 0, view = getView(0, arrLength, this.__views__), start = view.start, end = view.end, length = end - start, index = isRight ? end : start - 1, iteratees = this.__iteratees__, iterLength = iteratees.length, resIndex = 0, takeCount = nativeMin(length, this.__takeCount__);
            if (!isArr || arrLength < LARGE_ARRAY_SIZE || arrLength == length && takeCount == length) {
                return baseWrapperValue(array, this.__actions__);
            }
            var result = [];
            outer: while (length-- && resIndex < takeCount) {
                index += dir;
                var iterIndex = -1, value = array[index];
                while (++iterIndex < iterLength) {
                    var data = iteratees[iterIndex], iteratee = data.iteratee, type = data.type, computed = iteratee(value);
                    if (type == LAZY_MAP_FLAG) {
                        value = computed;
                    } else if (!computed) {
                        if (type == LAZY_FILTER_FLAG) {
                            continue outer;
                        } else {
                            break outer;
                        }
                    }
                }
                result[resIndex++] = value;
            }
            return result;
        }
        LazyWrapper.prototype = baseCreate(baseLodash.prototype);
        LazyWrapper.prototype.constructor = LazyWrapper;
        function Hash() {}
        function hashDelete(hash, key) {
            return hashHas(hash, key) && delete hash[key];
        }
        function hashGet(hash, key) {
            if (nativeCreate) {
                var result = hash[key];
                return result === HASH_UNDEFINED ? undefined : result;
            }
            return hasOwnProperty.call(hash, key) ? hash[key] : undefined;
        }
        function hashHas(hash, key) {
            return nativeCreate ? hash[key] !== undefined : hasOwnProperty.call(hash, key);
        }
        function hashSet(hash, key, value) {
            hash[key] = nativeCreate && value === undefined ? HASH_UNDEFINED : value;
        }
        Hash.prototype = nativeCreate ? nativeCreate(null) : objectProto;
        function MapCache(values) {
            var index = -1, length = values ? values.length : 0;
            this.clear();
            while (++index < length) {
                var entry = values[index];
                this.set(entry[0], entry[1]);
            }
        }
        function mapClear() {
            this.__data__ = {
                hash: new Hash(),
                map: Map ? new Map() : [],
                string: new Hash()
            };
        }
        function mapDelete(key) {
            var data = this.__data__;
            if (isKeyable(key)) {
                return hashDelete(typeof key == "string" ? data.string : data.hash, key);
            }
            return Map ? data.map["delete"](key) : assocDelete(data.map, key);
        }
        function mapGet(key) {
            var data = this.__data__;
            if (isKeyable(key)) {
                return hashGet(typeof key == "string" ? data.string : data.hash, key);
            }
            return Map ? data.map.get(key) : assocGet(data.map, key);
        }
        function mapHas(key) {
            var data = this.__data__;
            if (isKeyable(key)) {
                return hashHas(typeof key == "string" ? data.string : data.hash, key);
            }
            return Map ? data.map.has(key) : assocHas(data.map, key);
        }
        function mapSet(key, value) {
            var data = this.__data__;
            if (isKeyable(key)) {
                hashSet(typeof key == "string" ? data.string : data.hash, key, value);
            } else if (Map) {
                data.map.set(key, value);
            } else {
                assocSet(data.map, key, value);
            }
            return this;
        }
        MapCache.prototype.clear = mapClear;
        MapCache.prototype["delete"] = mapDelete;
        MapCache.prototype.get = mapGet;
        MapCache.prototype.has = mapHas;
        MapCache.prototype.set = mapSet;
        function SetCache(values) {
            var index = -1, length = values ? values.length : 0;
            this.__data__ = new MapCache();
            while (++index < length) {
                this.push(values[index]);
            }
        }
        function cacheHas(cache, value) {
            var map = cache.__data__;
            if (isKeyable(value)) {
                var data = map.__data__, hash = typeof value == "string" ? data.string : data.hash;
                return hash[value] === HASH_UNDEFINED;
            }
            return map.has(value);
        }
        function cachePush(value) {
            var map = this.__data__;
            if (isKeyable(value)) {
                var data = map.__data__, hash = typeof value == "string" ? data.string : data.hash;
                hash[value] = HASH_UNDEFINED;
            } else {
                map.set(value, HASH_UNDEFINED);
            }
        }
        SetCache.prototype.push = cachePush;
        function Stack(values) {
            var index = -1, length = values ? values.length : 0;
            this.clear();
            while (++index < length) {
                var entry = values[index];
                this.set(entry[0], entry[1]);
            }
        }
        function stackClear() {
            this.__data__ = {
                array: [],
                map: null
            };
        }
        function stackDelete(key) {
            var data = this.__data__, array = data.array;
            return array ? assocDelete(array, key) : data.map["delete"](key);
        }
        function stackGet(key) {
            var data = this.__data__, array = data.array;
            return array ? assocGet(array, key) : data.map.get(key);
        }
        function stackHas(key) {
            var data = this.__data__, array = data.array;
            return array ? assocHas(array, key) : data.map.has(key);
        }
        function stackSet(key, value) {
            var data = this.__data__, array = data.array;
            if (array) {
                if (array.length < LARGE_ARRAY_SIZE - 1) {
                    assocSet(array, key, value);
                } else {
                    data.array = null;
                    data.map = new MapCache(array);
                }
            }
            var map = data.map;
            if (map) {
                map.set(key, value);
            }
            return this;
        }
        Stack.prototype.clear = stackClear;
        Stack.prototype["delete"] = stackDelete;
        Stack.prototype.get = stackGet;
        Stack.prototype.has = stackHas;
        Stack.prototype.set = stackSet;
        function assocDelete(array, key) {
            var index = assocIndexOf(array, key);
            if (index < 0) {
                return false;
            }
            var lastIndex = array.length - 1;
            if (index == lastIndex) {
                array.pop();
            } else {
                splice.call(array, index, 1);
            }
            return true;
        }
        function assocGet(array, key) {
            var index = assocIndexOf(array, key);
            return index < 0 ? undefined : array[index][1];
        }
        function assocHas(array, key) {
            return assocIndexOf(array, key) > -1;
        }
        function assocIndexOf(array, key) {
            var length = array.length;
            while (length--) {
                if (eq(array[length][0], key)) {
                    return length;
                }
            }
            return -1;
        }
        function assocSet(array, key, value) {
            var index = assocIndexOf(array, key);
            if (index < 0) {
                array.push([ key, value ]);
            } else {
                array[index][1] = value;
            }
        }
        function assignInDefaults(objValue, srcValue, key, object) {
            if (objValue === undefined || eq(objValue, objectProto[key]) && !hasOwnProperty.call(object, key)) {
                return srcValue;
            }
            return objValue;
        }
        function assignMergeValue(object, key, value) {
            if (value !== undefined && !eq(object[key], value) || typeof key == "number" && value === undefined && !(key in object)) {
                object[key] = value;
            }
        }
        function assignValue(object, key, value) {
            var objValue = object[key];
            if (!(hasOwnProperty.call(object, key) && eq(objValue, value)) || value === undefined && !(key in object)) {
                object[key] = value;
            }
        }
        function baseAggregator(collection, setter, iteratee, accumulator) {
            baseEach(collection, function(value, key, collection) {
                setter(accumulator, value, iteratee(value), collection);
            });
            return accumulator;
        }
        function baseAssign(object, source) {
            return object && copyObject(source, keys(source), object);
        }
        function baseAt(object, paths) {
            var index = -1, isNil = object == null, length = paths.length, result = Array(length);
            while (++index < length) {
                result[index] = isNil ? undefined : get(object, paths[index]);
            }
            return result;
        }
        function baseClamp(number, lower, upper) {
            if (number === number) {
                if (upper !== undefined) {
                    number = number <= upper ? number : upper;
                }
                if (lower !== undefined) {
                    number = number >= lower ? number : lower;
                }
            }
            return number;
        }
        function baseClone(value, isDeep, isFull, customizer, key, object, stack) {
            var result;
            if (customizer) {
                result = object ? customizer(value, key, object, stack) : customizer(value);
            }
            if (result !== undefined) {
                return result;
            }
            if (!isObject(value)) {
                return value;
            }
            var isArr = isArray(value);
            if (isArr) {
                result = initCloneArray(value);
                if (!isDeep) {
                    return copyArray(value, result);
                }
            } else {
                var tag = getTag(value), isFunc = tag == funcTag || tag == genTag;
                if (isBuffer(value)) {
                    return cloneBuffer(value, isDeep);
                }
                if (tag == objectTag || tag == argsTag || isFunc && !object) {
                    if (isHostObject(value)) {
                        return object ? value : {};
                    }
                    result = initCloneObject(isFunc ? {} : value);
                    if (!isDeep) {
                        return copySymbols(value, baseAssign(result, value));
                    }
                } else {
                    if (!cloneableTags[tag]) {
                        return object ? value : {};
                    }
                    result = initCloneByTag(value, tag, baseClone, isDeep);
                }
            }
            stack || (stack = new Stack());
            var stacked = stack.get(value);
            if (stacked) {
                return stacked;
            }
            stack.set(value, result);
            if (!isArr) {
                var props = isFull ? getAllKeys(value) : keys(value);
            }
            arrayEach(props || value, function(subValue, key) {
                if (props) {
                    key = subValue;
                    subValue = value[key];
                }
                assignValue(result, key, baseClone(subValue, isDeep, isFull, customizer, key, value, stack));
            });
            return result;
        }
        function baseConforms(source) {
            var props = keys(source), length = props.length;
            return function(object) {
                if (object == null) {
                    return !length;
                }
                var index = length;
                while (index--) {
                    var key = props[index], predicate = source[key], value = object[key];
                    if (value === undefined && !(key in Object(object)) || !predicate(value)) {
                        return false;
                    }
                }
                return true;
            };
        }
        function baseCreate(proto) {
            return isObject(proto) ? objectCreate(proto) : {};
        }
        function baseDelay(func, wait, args) {
            if (typeof func != "function") {
                throw new TypeError(FUNC_ERROR_TEXT);
            }
            return setTimeout(function() {
                func.apply(undefined, args);
            }, wait);
        }
        function baseDifference(array, values, iteratee, comparator) {
            var index = -1, includes = arrayIncludes, isCommon = true, length = array.length, result = [], valuesLength = values.length;
            if (!length) {
                return result;
            }
            if (iteratee) {
                values = arrayMap(values, baseUnary(iteratee));
            }
            if (comparator) {
                includes = arrayIncludesWith;
                isCommon = false;
            } else if (values.length >= LARGE_ARRAY_SIZE) {
                includes = cacheHas;
                isCommon = false;
                values = new SetCache(values);
            }
            outer: while (++index < length) {
                var value = array[index], computed = iteratee ? iteratee(value) : value;
                value = comparator || value !== 0 ? value : 0;
                if (isCommon && computed === computed) {
                    var valuesIndex = valuesLength;
                    while (valuesIndex--) {
                        if (values[valuesIndex] === computed) {
                            continue outer;
                        }
                    }
                    result.push(value);
                } else if (!includes(values, computed, comparator)) {
                    result.push(value);
                }
            }
            return result;
        }
        var baseEach = createBaseEach(baseForOwn);
        var baseEachRight = createBaseEach(baseForOwnRight, true);
        function baseEvery(collection, predicate) {
            var result = true;
            baseEach(collection, function(value, index, collection) {
                result = !!predicate(value, index, collection);
                return result;
            });
            return result;
        }
        function baseExtremum(array, iteratee, comparator) {
            var index = -1, length = array.length;
            while (++index < length) {
                var value = array[index], current = iteratee(value);
                if (current != null && (computed === undefined ? current === current && !isSymbol(current) : comparator(current, computed))) {
                    var computed = current, result = value;
                }
            }
            return result;
        }
        function baseFill(array, value, start, end) {
            var length = array.length;
            start = toInteger(start);
            if (start < 0) {
                start = -start > length ? 0 : length + start;
            }
            end = end === undefined || end > length ? length : toInteger(end);
            if (end < 0) {
                end += length;
            }
            end = start > end ? 0 : toLength(end);
            while (start < end) {
                array[start++] = value;
            }
            return array;
        }
        function baseFilter(collection, predicate) {
            var result = [];
            baseEach(collection, function(value, index, collection) {
                if (predicate(value, index, collection)) {
                    result.push(value);
                }
            });
            return result;
        }
        function baseFlatten(array, depth, predicate, isStrict, result) {
            var index = -1, length = array.length;
            predicate || (predicate = isFlattenable);
            result || (result = []);
            while (++index < length) {
                var value = array[index];
                if (depth > 0 && predicate(value)) {
                    if (depth > 1) {
                        baseFlatten(value, depth - 1, predicate, isStrict, result);
                    } else {
                        arrayPush(result, value);
                    }
                } else if (!isStrict) {
                    result[result.length] = value;
                }
            }
            return result;
        }
        var baseFor = createBaseFor();
        var baseForRight = createBaseFor(true);
        function baseForOwn(object, iteratee) {
            return object && baseFor(object, iteratee, keys);
        }
        function baseForOwnRight(object, iteratee) {
            return object && baseForRight(object, iteratee, keys);
        }
        function baseFunctions(object, props) {
            return arrayFilter(props, function(key) {
                return isFunction(object[key]);
            });
        }
        function baseGet(object, path) {
            path = isKey(path, object) ? [ path ] : castPath(path);
            var index = 0, length = path.length;
            while (object != null && index < length) {
                object = object[toKey(path[index++])];
            }
            return index && index == length ? object : undefined;
        }
        function baseGetAllKeys(object, keysFunc, symbolsFunc) {
            var result = keysFunc(object);
            return isArray(object) ? result : arrayPush(result, symbolsFunc(object));
        }
        function baseGt(value, other) {
            return value > other;
        }
        function baseHas(object, key) {
            return hasOwnProperty.call(object, key) || typeof object == "object" && key in object && getPrototype(object) === null;
        }
        function baseHasIn(object, key) {
            return key in Object(object);
        }
        function baseInRange(number, start, end) {
            return number >= nativeMin(start, end) && number < nativeMax(start, end);
        }
        function baseIntersection(arrays, iteratee, comparator) {
            var includes = comparator ? arrayIncludesWith : arrayIncludes, length = arrays[0].length, othLength = arrays.length, othIndex = othLength, caches = Array(othLength), maxLength = Infinity, result = [];
            while (othIndex--) {
                var array = arrays[othIndex];
                if (othIndex && iteratee) {
                    array = arrayMap(array, baseUnary(iteratee));
                }
                maxLength = nativeMin(array.length, maxLength);
                caches[othIndex] = !comparator && (iteratee || length >= 120 && array.length >= 120) ? new SetCache(othIndex && array) : undefined;
            }
            array = arrays[0];
            var index = -1, seen = caches[0];
            outer: while (++index < length && result.length < maxLength) {
                var value = array[index], computed = iteratee ? iteratee(value) : value;
                value = comparator || value !== 0 ? value : 0;
                if (!(seen ? cacheHas(seen, computed) : includes(result, computed, comparator))) {
                    othIndex = othLength;
                    while (--othIndex) {
                        var cache = caches[othIndex];
                        if (!(cache ? cacheHas(cache, computed) : includes(arrays[othIndex], computed, comparator))) {
                            continue outer;
                        }
                    }
                    if (seen) {
                        seen.push(computed);
                    }
                    result.push(value);
                }
            }
            return result;
        }
        function baseInverter(object, setter, iteratee, accumulator) {
            baseForOwn(object, function(value, key, object) {
                setter(accumulator, iteratee(value), key, object);
            });
            return accumulator;
        }
        function baseInvoke(object, path, args) {
            if (!isKey(path, object)) {
                path = castPath(path);
                object = parent(object, path);
                path = last(path);
            }
            var func = object == null ? object : object[toKey(path)];
            return func == null ? undefined : apply(func, object, args);
        }
        function baseIsEqual(value, other, customizer, bitmask, stack) {
            if (value === other) {
                return true;
            }
            if (value == null || other == null || !isObject(value) && !isObjectLike(other)) {
                return value !== value && other !== other;
            }
            return baseIsEqualDeep(value, other, baseIsEqual, customizer, bitmask, stack);
        }
        function baseIsEqualDeep(object, other, equalFunc, customizer, bitmask, stack) {
            var objIsArr = isArray(object), othIsArr = isArray(other), objTag = arrayTag, othTag = arrayTag;
            if (!objIsArr) {
                objTag = getTag(object);
                objTag = objTag == argsTag ? objectTag : objTag;
            }
            if (!othIsArr) {
                othTag = getTag(other);
                othTag = othTag == argsTag ? objectTag : othTag;
            }
            var objIsObj = objTag == objectTag && !isHostObject(object), othIsObj = othTag == objectTag && !isHostObject(other), isSameTag = objTag == othTag;
            if (isSameTag && !objIsObj) {
                stack || (stack = new Stack());
                return objIsArr || isTypedArray(object) ? equalArrays(object, other, equalFunc, customizer, bitmask, stack) : equalByTag(object, other, objTag, equalFunc, customizer, bitmask, stack);
            }
            if (!(bitmask & PARTIAL_COMPARE_FLAG)) {
                var objIsWrapped = objIsObj && hasOwnProperty.call(object, "__wrapped__"), othIsWrapped = othIsObj && hasOwnProperty.call(other, "__wrapped__");
                if (objIsWrapped || othIsWrapped) {
                    var objUnwrapped = objIsWrapped ? object.value() : object, othUnwrapped = othIsWrapped ? other.value() : other;
                    stack || (stack = new Stack());
                    return equalFunc(objUnwrapped, othUnwrapped, customizer, bitmask, stack);
                }
            }
            if (!isSameTag) {
                return false;
            }
            stack || (stack = new Stack());
            return equalObjects(object, other, equalFunc, customizer, bitmask, stack);
        }
        function baseIsMatch(object, source, matchData, customizer) {
            var index = matchData.length, length = index, noCustomizer = !customizer;
            if (object == null) {
                return !length;
            }
            object = Object(object);
            while (index--) {
                var data = matchData[index];
                if (noCustomizer && data[2] ? data[1] !== object[data[0]] : !(data[0] in object)) {
                    return false;
                }
            }
            while (++index < length) {
                data = matchData[index];
                var key = data[0], objValue = object[key], srcValue = data[1];
                if (noCustomizer && data[2]) {
                    if (objValue === undefined && !(key in object)) {
                        return false;
                    }
                } else {
                    var stack = new Stack();
                    if (customizer) {
                        var result = customizer(objValue, srcValue, key, object, source, stack);
                    }
                    if (!(result === undefined ? baseIsEqual(srcValue, objValue, customizer, UNORDERED_COMPARE_FLAG | PARTIAL_COMPARE_FLAG, stack) : result)) {
                        return false;
                    }
                }
            }
            return true;
        }
        function baseIteratee(value) {
            if (typeof value == "function") {
                return value;
            }
            if (value == null) {
                return identity;
            }
            if (typeof value == "object") {
                return isArray(value) ? baseMatchesProperty(value[0], value[1]) : baseMatches(value);
            }
            return property(value);
        }
        function baseKeys(object) {
            return nativeKeys(Object(object));
        }
        function baseKeysIn(object) {
            object = object == null ? object : Object(object);
            var result = [];
            for (var key in object) {
                result.push(key);
            }
            return result;
        }
        if (enumerate && !propertyIsEnumerable.call({
            valueOf: 1
        }, "valueOf")) {
            baseKeysIn = function(object) {
                return iteratorToArray(enumerate(object));
            };
        }
        function baseLt(value, other) {
            return value < other;
        }
        function baseMap(collection, iteratee) {
            var index = -1, result = isArrayLike(collection) ? Array(collection.length) : [];
            baseEach(collection, function(value, key, collection) {
                result[++index] = iteratee(value, key, collection);
            });
            return result;
        }
        function baseMatches(source) {
            var matchData = getMatchData(source);
            if (matchData.length == 1 && matchData[0][2]) {
                return matchesStrictComparable(matchData[0][0], matchData[0][1]);
            }
            return function(object) {
                return object === source || baseIsMatch(object, source, matchData);
            };
        }
        function baseMatchesProperty(path, srcValue) {
            if (isKey(path) && isStrictComparable(srcValue)) {
                return matchesStrictComparable(toKey(path), srcValue);
            }
            return function(object) {
                var objValue = get(object, path);
                return objValue === undefined && objValue === srcValue ? hasIn(object, path) : baseIsEqual(srcValue, objValue, undefined, UNORDERED_COMPARE_FLAG | PARTIAL_COMPARE_FLAG);
            };
        }
        function baseMerge(object, source, srcIndex, customizer, stack) {
            if (object === source) {
                return;
            }
            if (!(isArray(source) || isTypedArray(source))) {
                var props = keysIn(source);
            }
            arrayEach(props || source, function(srcValue, key) {
                if (props) {
                    key = srcValue;
                    srcValue = source[key];
                }
                if (isObject(srcValue)) {
                    stack || (stack = new Stack());
                    baseMergeDeep(object, source, key, srcIndex, baseMerge, customizer, stack);
                } else {
                    var newValue = customizer ? customizer(object[key], srcValue, key + "", object, source, stack) : undefined;
                    if (newValue === undefined) {
                        newValue = srcValue;
                    }
                    assignMergeValue(object, key, newValue);
                }
            });
        }
        function baseMergeDeep(object, source, key, srcIndex, mergeFunc, customizer, stack) {
            var objValue = object[key], srcValue = source[key], stacked = stack.get(srcValue);
            if (stacked) {
                assignMergeValue(object, key, stacked);
                return;
            }
            var newValue = customizer ? customizer(objValue, srcValue, key + "", object, source, stack) : undefined;
            var isCommon = newValue === undefined;
            if (isCommon) {
                newValue = srcValue;
                if (isArray(srcValue) || isTypedArray(srcValue)) {
                    if (isArray(objValue)) {
                        newValue = objValue;
                    } else if (isArrayLikeObject(objValue)) {
                        newValue = copyArray(objValue);
                    } else {
                        isCommon = false;
                        newValue = baseClone(srcValue, true);
                    }
                } else if (isPlainObject(srcValue) || isArguments(srcValue)) {
                    if (isArguments(objValue)) {
                        newValue = toPlainObject(objValue);
                    } else if (!isObject(objValue) || srcIndex && isFunction(objValue)) {
                        isCommon = false;
                        newValue = baseClone(srcValue, true);
                    } else {
                        newValue = objValue;
                    }
                } else {
                    isCommon = false;
                }
            }
            stack.set(srcValue, newValue);
            if (isCommon) {
                mergeFunc(newValue, srcValue, srcIndex, customizer, stack);
            }
            stack["delete"](srcValue);
            assignMergeValue(object, key, newValue);
        }
        function baseNth(array, n) {
            var length = array.length;
            if (!length) {
                return;
            }
            n += n < 0 ? length : 0;
            return isIndex(n, length) ? array[n] : undefined;
        }
        function baseOrderBy(collection, iteratees, orders) {
            var index = -1;
            iteratees = arrayMap(iteratees.length ? iteratees : [ identity ], baseUnary(getIteratee()));
            var result = baseMap(collection, function(value, key, collection) {
                var criteria = arrayMap(iteratees, function(iteratee) {
                    return iteratee(value);
                });
                return {
                    criteria: criteria,
                    index: ++index,
                    value: value
                };
            });
            return baseSortBy(result, function(object, other) {
                return compareMultiple(object, other, orders);
            });
        }
        function basePick(object, props) {
            object = Object(object);
            return arrayReduce(props, function(result, key) {
                if (key in object) {
                    result[key] = object[key];
                }
                return result;
            }, {});
        }
        function basePickBy(object, predicate) {
            var index = -1, props = getAllKeysIn(object), length = props.length, result = {};
            while (++index < length) {
                var key = props[index], value = object[key];
                if (predicate(value, key)) {
                    result[key] = value;
                }
            }
            return result;
        }
        function baseProperty(key) {
            return function(object) {
                return object == null ? undefined : object[key];
            };
        }
        function basePropertyDeep(path) {
            return function(object) {
                return baseGet(object, path);
            };
        }
        function basePullAll(array, values, iteratee, comparator) {
            var indexOf = comparator ? baseIndexOfWith : baseIndexOf, index = -1, length = values.length, seen = array;
            if (iteratee) {
                seen = arrayMap(array, baseUnary(iteratee));
            }
            while (++index < length) {
                var fromIndex = 0, value = values[index], computed = iteratee ? iteratee(value) : value;
                while ((fromIndex = indexOf(seen, computed, fromIndex, comparator)) > -1) {
                    if (seen !== array) {
                        splice.call(seen, fromIndex, 1);
                    }
                    splice.call(array, fromIndex, 1);
                }
            }
            return array;
        }
        function basePullAt(array, indexes) {
            var length = array ? indexes.length : 0, lastIndex = length - 1;
            while (length--) {
                var index = indexes[length];
                if (length == lastIndex || index !== previous) {
                    var previous = index;
                    if (isIndex(index)) {
                        splice.call(array, index, 1);
                    } else if (!isKey(index, array)) {
                        var path = castPath(index), object = parent(array, path);
                        if (object != null) {
                            delete object[toKey(last(path))];
                        }
                    } else {
                        delete array[toKey(index)];
                    }
                }
            }
            return array;
        }
        function baseRandom(lower, upper) {
            return lower + nativeFloor(nativeRandom() * (upper - lower + 1));
        }
        function baseRange(start, end, step, fromRight) {
            var index = -1, length = nativeMax(nativeCeil((end - start) / (step || 1)), 0), result = Array(length);
            while (length--) {
                result[fromRight ? length : ++index] = start;
                start += step;
            }
            return result;
        }
        function baseRepeat(string, n) {
            var result = "";
            if (!string || n < 1 || n > MAX_SAFE_INTEGER) {
                return result;
            }
            do {
                if (n % 2) {
                    result += string;
                }
                n = nativeFloor(n / 2);
                if (n) {
                    string += string;
                }
            } while (n);
            return result;
        }
        function baseSet(object, path, value, customizer) {
            path = isKey(path, object) ? [ path ] : castPath(path);
            var index = -1, length = path.length, lastIndex = length - 1, nested = object;
            while (nested != null && ++index < length) {
                var key = toKey(path[index]);
                if (isObject(nested)) {
                    var newValue = value;
                    if (index != lastIndex) {
                        var objValue = nested[key];
                        newValue = customizer ? customizer(objValue, key, nested) : undefined;
                        if (newValue === undefined) {
                            newValue = objValue == null ? isIndex(path[index + 1]) ? [] : {} : objValue;
                        }
                    }
                    assignValue(nested, key, newValue);
                }
                nested = nested[key];
            }
            return object;
        }
        var baseSetData = !metaMap ? identity : function(func, data) {
            metaMap.set(func, data);
            return func;
        };
        function baseSlice(array, start, end) {
            var index = -1, length = array.length;
            if (start < 0) {
                start = -start > length ? 0 : length + start;
            }
            end = end > length ? length : end;
            if (end < 0) {
                end += length;
            }
            length = start > end ? 0 : end - start >>> 0;
            start >>>= 0;
            var result = Array(length);
            while (++index < length) {
                result[index] = array[index + start];
            }
            return result;
        }
        function baseSome(collection, predicate) {
            var result;
            baseEach(collection, function(value, index, collection) {
                result = predicate(value, index, collection);
                return !result;
            });
            return !!result;
        }
        function baseSortedIndex(array, value, retHighest) {
            var low = 0, high = array ? array.length : low;
            if (typeof value == "number" && value === value && high <= HALF_MAX_ARRAY_LENGTH) {
                while (low < high) {
                    var mid = low + high >>> 1, computed = array[mid];
                    if (computed !== null && !isSymbol(computed) && (retHighest ? computed <= value : computed < value)) {
                        low = mid + 1;
                    } else {
                        high = mid;
                    }
                }
                return high;
            }
            return baseSortedIndexBy(array, value, identity, retHighest);
        }
        function baseSortedIndexBy(array, value, iteratee, retHighest) {
            value = iteratee(value);
            var low = 0, high = array ? array.length : 0, valIsNaN = value !== value, valIsNull = value === null, valIsSymbol = isSymbol(value), valIsUndefined = value === undefined;
            while (low < high) {
                var mid = nativeFloor((low + high) / 2), computed = iteratee(array[mid]), othIsDefined = computed !== undefined, othIsNull = computed === null, othIsReflexive = computed === computed, othIsSymbol = isSymbol(computed);
                if (valIsNaN) {
                    var setLow = retHighest || othIsReflexive;
                } else if (valIsUndefined) {
                    setLow = othIsReflexive && (retHighest || othIsDefined);
                } else if (valIsNull) {
                    setLow = othIsReflexive && othIsDefined && (retHighest || !othIsNull);
                } else if (valIsSymbol) {
                    setLow = othIsReflexive && othIsDefined && !othIsNull && (retHighest || !othIsSymbol);
                } else if (othIsNull || othIsSymbol) {
                    setLow = false;
                } else {
                    setLow = retHighest ? computed <= value : computed < value;
                }
                if (setLow) {
                    low = mid + 1;
                } else {
                    high = mid;
                }
            }
            return nativeMin(high, MAX_ARRAY_INDEX);
        }
        function baseSortedUniq(array, iteratee) {
            var index = -1, length = array.length, resIndex = 0, result = [];
            while (++index < length) {
                var value = array[index], computed = iteratee ? iteratee(value) : value;
                if (!index || !eq(computed, seen)) {
                    var seen = computed;
                    result[resIndex++] = value === 0 ? 0 : value;
                }
            }
            return result;
        }
        function baseToNumber(value) {
            if (typeof value == "number") {
                return value;
            }
            if (isSymbol(value)) {
                return NAN;
            }
            return +value;
        }
        function baseToString(value) {
            if (typeof value == "string") {
                return value;
            }
            if (isSymbol(value)) {
                return symbolToString ? symbolToString.call(value) : "";
            }
            var result = value + "";
            return result == "0" && 1 / value == -INFINITY ? "-0" : result;
        }
        function baseUniq(array, iteratee, comparator) {
            var index = -1, includes = arrayIncludes, length = array.length, isCommon = true, result = [], seen = result;
            if (comparator) {
                isCommon = false;
                includes = arrayIncludesWith;
            } else if (length >= LARGE_ARRAY_SIZE) {
                var set = iteratee ? null : createSet(array);
                if (set) {
                    return setToArray(set);
                }
                isCommon = false;
                includes = cacheHas;
                seen = new SetCache();
            } else {
                seen = iteratee ? [] : result;
            }
            outer: while (++index < length) {
                var value = array[index], computed = iteratee ? iteratee(value) : value;
                value = comparator || value !== 0 ? value : 0;
                if (isCommon && computed === computed) {
                    var seenIndex = seen.length;
                    while (seenIndex--) {
                        if (seen[seenIndex] === computed) {
                            continue outer;
                        }
                    }
                    if (iteratee) {
                        seen.push(computed);
                    }
                    result.push(value);
                } else if (!includes(seen, computed, comparator)) {
                    if (seen !== result) {
                        seen.push(computed);
                    }
                    result.push(value);
                }
            }
            return result;
        }
        function baseUnset(object, path) {
            path = isKey(path, object) ? [ path ] : castPath(path);
            object = parent(object, path);
            var key = toKey(last(path));
            return !(object != null && baseHas(object, key)) || delete object[key];
        }
        function baseUpdate(object, path, updater, customizer) {
            return baseSet(object, path, updater(baseGet(object, path)), customizer);
        }
        function baseWhile(array, predicate, isDrop, fromRight) {
            var length = array.length, index = fromRight ? length : -1;
            while ((fromRight ? index-- : ++index < length) && predicate(array[index], index, array)) {}
            return isDrop ? baseSlice(array, fromRight ? 0 : index, fromRight ? index + 1 : length) : baseSlice(array, fromRight ? index + 1 : 0, fromRight ? length : index);
        }
        function baseWrapperValue(value, actions) {
            var result = value;
            if (result instanceof LazyWrapper) {
                result = result.value();
            }
            return arrayReduce(actions, function(result, action) {
                return action.func.apply(action.thisArg, arrayPush([ result ], action.args));
            }, result);
        }
        function baseXor(arrays, iteratee, comparator) {
            var index = -1, length = arrays.length;
            while (++index < length) {
                var result = result ? arrayPush(baseDifference(result, arrays[index], iteratee, comparator), baseDifference(arrays[index], result, iteratee, comparator)) : arrays[index];
            }
            return result && result.length ? baseUniq(result, iteratee, comparator) : [];
        }
        function baseZipObject(props, values, assignFunc) {
            var index = -1, length = props.length, valsLength = values.length, result = {};
            while (++index < length) {
                var value = index < valsLength ? values[index] : undefined;
                assignFunc(result, props[index], value);
            }
            return result;
        }
        function castArrayLikeObject(value) {
            return isArrayLikeObject(value) ? value : [];
        }
        function castFunction(value) {
            return typeof value == "function" ? value : identity;
        }
        function castPath(value) {
            return isArray(value) ? value : stringToPath(value);
        }
        function castSlice(array, start, end) {
            var length = array.length;
            end = end === undefined ? length : end;
            return !start && end >= length ? array : baseSlice(array, start, end);
        }
        function cloneBuffer(buffer, isDeep) {
            if (isDeep) {
                return buffer.slice();
            }
            var result = new buffer.constructor(buffer.length);
            buffer.copy(result);
            return result;
        }
        function cloneArrayBuffer(arrayBuffer) {
            var result = new arrayBuffer.constructor(arrayBuffer.byteLength);
            new Uint8Array(result).set(new Uint8Array(arrayBuffer));
            return result;
        }
        function cloneDataView(dataView, isDeep) {
            var buffer = isDeep ? cloneArrayBuffer(dataView.buffer) : dataView.buffer;
            return new dataView.constructor(buffer, dataView.byteOffset, dataView.byteLength);
        }
        function cloneMap(map, isDeep, cloneFunc) {
            var array = isDeep ? cloneFunc(mapToArray(map), true) : mapToArray(map);
            return arrayReduce(array, addMapEntry, new map.constructor());
        }
        function cloneRegExp(regexp) {
            var result = new regexp.constructor(regexp.source, reFlags.exec(regexp));
            result.lastIndex = regexp.lastIndex;
            return result;
        }
        function cloneSet(set, isDeep, cloneFunc) {
            var array = isDeep ? cloneFunc(setToArray(set), true) : setToArray(set);
            return arrayReduce(array, addSetEntry, new set.constructor());
        }
        function cloneSymbol(symbol) {
            return symbolValueOf ? Object(symbolValueOf.call(symbol)) : {};
        }
        function cloneTypedArray(typedArray, isDeep) {
            var buffer = isDeep ? cloneArrayBuffer(typedArray.buffer) : typedArray.buffer;
            return new typedArray.constructor(buffer, typedArray.byteOffset, typedArray.length);
        }
        function compareAscending(value, other) {
            if (value !== other) {
                var valIsDefined = value !== undefined, valIsNull = value === null, valIsReflexive = value === value, valIsSymbol = isSymbol(value);
                var othIsDefined = other !== undefined, othIsNull = other === null, othIsReflexive = other === other, othIsSymbol = isSymbol(other);
                if (!othIsNull && !othIsSymbol && !valIsSymbol && value > other || valIsSymbol && othIsDefined && othIsReflexive && !othIsNull && !othIsSymbol || valIsNull && othIsDefined && othIsReflexive || !valIsDefined && othIsReflexive || !valIsReflexive) {
                    return 1;
                }
                if (!valIsNull && !valIsSymbol && !othIsSymbol && value < other || othIsSymbol && valIsDefined && valIsReflexive && !valIsNull && !valIsSymbol || othIsNull && valIsDefined && valIsReflexive || !othIsDefined && valIsReflexive || !othIsReflexive) {
                    return -1;
                }
            }
            return 0;
        }
        function compareMultiple(object, other, orders) {
            var index = -1, objCriteria = object.criteria, othCriteria = other.criteria, length = objCriteria.length, ordersLength = orders.length;
            while (++index < length) {
                var result = compareAscending(objCriteria[index], othCriteria[index]);
                if (result) {
                    if (index >= ordersLength) {
                        return result;
                    }
                    var order = orders[index];
                    return result * (order == "desc" ? -1 : 1);
                }
            }
            return object.index - other.index;
        }
        function composeArgs(args, partials, holders, isCurried) {
            var argsIndex = -1, argsLength = args.length, holdersLength = holders.length, leftIndex = -1, leftLength = partials.length, rangeLength = nativeMax(argsLength - holdersLength, 0), result = Array(leftLength + rangeLength), isUncurried = !isCurried;
            while (++leftIndex < leftLength) {
                result[leftIndex] = partials[leftIndex];
            }
            while (++argsIndex < holdersLength) {
                if (isUncurried || argsIndex < argsLength) {
                    result[holders[argsIndex]] = args[argsIndex];
                }
            }
            while (rangeLength--) {
                result[leftIndex++] = args[argsIndex++];
            }
            return result;
        }
        function composeArgsRight(args, partials, holders, isCurried) {
            var argsIndex = -1, argsLength = args.length, holdersIndex = -1, holdersLength = holders.length, rightIndex = -1, rightLength = partials.length, rangeLength = nativeMax(argsLength - holdersLength, 0), result = Array(rangeLength + rightLength), isUncurried = !isCurried;
            while (++argsIndex < rangeLength) {
                result[argsIndex] = args[argsIndex];
            }
            var offset = argsIndex;
            while (++rightIndex < rightLength) {
                result[offset + rightIndex] = partials[rightIndex];
            }
            while (++holdersIndex < holdersLength) {
                if (isUncurried || argsIndex < argsLength) {
                    result[offset + holders[holdersIndex]] = args[argsIndex++];
                }
            }
            return result;
        }
        function copyArray(source, array) {
            var index = -1, length = source.length;
            array || (array = Array(length));
            while (++index < length) {
                array[index] = source[index];
            }
            return array;
        }
        function copyObject(source, props, object, customizer) {
            object || (object = {});
            var index = -1, length = props.length;
            while (++index < length) {
                var key = props[index];
                var newValue = customizer ? customizer(object[key], source[key], key, object, source) : source[key];
                assignValue(object, key, newValue);
            }
            return object;
        }
        function copySymbols(source, object) {
            return copyObject(source, getSymbols(source), object);
        }
        function createAggregator(setter, initializer) {
            return function(collection, iteratee) {
                var func = isArray(collection) ? arrayAggregator : baseAggregator, accumulator = initializer ? initializer() : {};
                return func(collection, setter, getIteratee(iteratee), accumulator);
            };
        }
        function createAssigner(assigner) {
            return rest(function(object, sources) {
                var index = -1, length = sources.length, customizer = length > 1 ? sources[length - 1] : undefined, guard = length > 2 ? sources[2] : undefined;
                customizer = typeof customizer == "function" ? (length--, customizer) : undefined;
                if (guard && isIterateeCall(sources[0], sources[1], guard)) {
                    customizer = length < 3 ? undefined : customizer;
                    length = 1;
                }
                object = Object(object);
                while (++index < length) {
                    var source = sources[index];
                    if (source) {
                        assigner(object, source, index, customizer);
                    }
                }
                return object;
            });
        }
        function createBaseEach(eachFunc, fromRight) {
            return function(collection, iteratee) {
                if (collection == null) {
                    return collection;
                }
                if (!isArrayLike(collection)) {
                    return eachFunc(collection, iteratee);
                }
                var length = collection.length, index = fromRight ? length : -1, iterable = Object(collection);
                while (fromRight ? index-- : ++index < length) {
                    if (iteratee(iterable[index], index, iterable) === false) {
                        break;
                    }
                }
                return collection;
            };
        }
        function createBaseFor(fromRight) {
            return function(object, iteratee, keysFunc) {
                var index = -1, iterable = Object(object), props = keysFunc(object), length = props.length;
                while (length--) {
                    var key = props[fromRight ? length : ++index];
                    if (iteratee(iterable[key], key, iterable) === false) {
                        break;
                    }
                }
                return object;
            };
        }
        function createBaseWrapper(func, bitmask, thisArg) {
            var isBind = bitmask & BIND_FLAG, Ctor = createCtorWrapper(func);
            function wrapper() {
                var fn = this && this !== root && this instanceof wrapper ? Ctor : func;
                return fn.apply(isBind ? thisArg : this, arguments);
            }
            return wrapper;
        }
        function createCaseFirst(methodName) {
            return function(string) {
                string = toString(string);
                var strSymbols = reHasComplexSymbol.test(string) ? stringToArray(string) : undefined;
                var chr = strSymbols ? strSymbols[0] : string.charAt(0);
                var trailing = strSymbols ? castSlice(strSymbols, 1).join("") : string.slice(1);
                return chr[methodName]() + trailing;
            };
        }
        function createCompounder(callback) {
            return function(string) {
                return arrayReduce(words(deburr(string).replace(reApos, "")), callback, "");
            };
        }
        function createCtorWrapper(Ctor) {
            return function() {
                var args = arguments;
                switch (args.length) {
                  case 0:
                    return new Ctor();

                  case 1:
                    return new Ctor(args[0]);

                  case 2:
                    return new Ctor(args[0], args[1]);

                  case 3:
                    return new Ctor(args[0], args[1], args[2]);

                  case 4:
                    return new Ctor(args[0], args[1], args[2], args[3]);

                  case 5:
                    return new Ctor(args[0], args[1], args[2], args[3], args[4]);

                  case 6:
                    return new Ctor(args[0], args[1], args[2], args[3], args[4], args[5]);

                  case 7:
                    return new Ctor(args[0], args[1], args[2], args[3], args[4], args[5], args[6]);
                }
                var thisBinding = baseCreate(Ctor.prototype), result = Ctor.apply(thisBinding, args);
                return isObject(result) ? result : thisBinding;
            };
        }
        function createCurryWrapper(func, bitmask, arity) {
            var Ctor = createCtorWrapper(func);
            function wrapper() {
                var length = arguments.length, args = Array(length), index = length, placeholder = getPlaceholder(wrapper);
                while (index--) {
                    args[index] = arguments[index];
                }
                var holders = length < 3 && args[0] !== placeholder && args[length - 1] !== placeholder ? [] : replaceHolders(args, placeholder);
                length -= holders.length;
                if (length < arity) {
                    return createRecurryWrapper(func, bitmask, createHybridWrapper, wrapper.placeholder, undefined, args, holders, undefined, undefined, arity - length);
                }
                var fn = this && this !== root && this instanceof wrapper ? Ctor : func;
                return apply(fn, this, args);
            }
            return wrapper;
        }
        function createFlow(fromRight) {
            return rest(function(funcs) {
                funcs = baseFlatten(funcs, 1);
                var length = funcs.length, index = length, prereq = LodashWrapper.prototype.thru;
                if (fromRight) {
                    funcs.reverse();
                }
                while (index--) {
                    var func = funcs[index];
                    if (typeof func != "function") {
                        throw new TypeError(FUNC_ERROR_TEXT);
                    }
                    if (prereq && !wrapper && getFuncName(func) == "wrapper") {
                        var wrapper = new LodashWrapper([], true);
                    }
                }
                index = wrapper ? index : length;
                while (++index < length) {
                    func = funcs[index];
                    var funcName = getFuncName(func), data = funcName == "wrapper" ? getData(func) : undefined;
                    if (data && isLaziable(data[0]) && data[1] == (ARY_FLAG | CURRY_FLAG | PARTIAL_FLAG | REARG_FLAG) && !data[4].length && data[9] == 1) {
                        wrapper = wrapper[getFuncName(data[0])].apply(wrapper, data[3]);
                    } else {
                        wrapper = func.length == 1 && isLaziable(func) ? wrapper[funcName]() : wrapper.thru(func);
                    }
                }
                return function() {
                    var args = arguments, value = args[0];
                    if (wrapper && args.length == 1 && isArray(value) && value.length >= LARGE_ARRAY_SIZE) {
                        return wrapper.plant(value).value();
                    }
                    var index = 0, result = length ? funcs[index].apply(this, args) : value;
                    while (++index < length) {
                        result = funcs[index].call(this, result);
                    }
                    return result;
                };
            });
        }
        function createHybridWrapper(func, bitmask, thisArg, partials, holders, partialsRight, holdersRight, argPos, ary, arity) {
            var isAry = bitmask & ARY_FLAG, isBind = bitmask & BIND_FLAG, isBindKey = bitmask & BIND_KEY_FLAG, isCurried = bitmask & (CURRY_FLAG | CURRY_RIGHT_FLAG), isFlip = bitmask & FLIP_FLAG, Ctor = isBindKey ? undefined : createCtorWrapper(func);
            function wrapper() {
                var length = arguments.length, index = length, args = Array(length);
                while (index--) {
                    args[index] = arguments[index];
                }
                if (isCurried) {
                    var placeholder = getPlaceholder(wrapper), holdersCount = countHolders(args, placeholder);
                }
                if (partials) {
                    args = composeArgs(args, partials, holders, isCurried);
                }
                if (partialsRight) {
                    args = composeArgsRight(args, partialsRight, holdersRight, isCurried);
                }
                length -= holdersCount;
                if (isCurried && length < arity) {
                    var newHolders = replaceHolders(args, placeholder);
                    return createRecurryWrapper(func, bitmask, createHybridWrapper, wrapper.placeholder, thisArg, args, newHolders, argPos, ary, arity - length);
                }
                var thisBinding = isBind ? thisArg : this, fn = isBindKey ? thisBinding[func] : func;
                length = args.length;
                if (argPos) {
                    args = reorder(args, argPos);
                } else if (isFlip && length > 1) {
                    args.reverse();
                }
                if (isAry && ary < length) {
                    args.length = ary;
                }
                if (this && this !== root && this instanceof wrapper) {
                    fn = Ctor || createCtorWrapper(fn);
                }
                return fn.apply(thisBinding, args);
            }
            return wrapper;
        }
        function createInverter(setter, toIteratee) {
            return function(object, iteratee) {
                return baseInverter(object, setter, toIteratee(iteratee), {});
            };
        }
        function createMathOperation(operator) {
            return function(value, other) {
                var result;
                if (value === undefined && other === undefined) {
                    return 0;
                }
                if (value !== undefined) {
                    result = value;
                }
                if (other !== undefined) {
                    if (result === undefined) {
                        return other;
                    }
                    if (typeof value == "string" || typeof other == "string") {
                        value = baseToString(value);
                        other = baseToString(other);
                    } else {
                        value = baseToNumber(value);
                        other = baseToNumber(other);
                    }
                    result = operator(value, other);
                }
                return result;
            };
        }
        function createOver(arrayFunc) {
            return rest(function(iteratees) {
                iteratees = iteratees.length == 1 && isArray(iteratees[0]) ? arrayMap(iteratees[0], baseUnary(getIteratee())) : arrayMap(baseFlatten(iteratees, 1, isFlattenableIteratee), baseUnary(getIteratee()));
                return rest(function(args) {
                    var thisArg = this;
                    return arrayFunc(iteratees, function(iteratee) {
                        return apply(iteratee, thisArg, args);
                    });
                });
            });
        }
        function createPadding(length, chars) {
            chars = chars === undefined ? " " : baseToString(chars);
            var charsLength = chars.length;
            if (charsLength < 2) {
                return charsLength ? baseRepeat(chars, length) : chars;
            }
            var result = baseRepeat(chars, nativeCeil(length / stringSize(chars)));
            return reHasComplexSymbol.test(chars) ? castSlice(stringToArray(result), 0, length).join("") : result.slice(0, length);
        }
        function createPartialWrapper(func, bitmask, thisArg, partials) {
            var isBind = bitmask & BIND_FLAG, Ctor = createCtorWrapper(func);
            function wrapper() {
                var argsIndex = -1, argsLength = arguments.length, leftIndex = -1, leftLength = partials.length, args = Array(leftLength + argsLength), fn = this && this !== root && this instanceof wrapper ? Ctor : func;
                while (++leftIndex < leftLength) {
                    args[leftIndex] = partials[leftIndex];
                }
                while (argsLength--) {
                    args[leftIndex++] = arguments[++argsIndex];
                }
                return apply(fn, isBind ? thisArg : this, args);
            }
            return wrapper;
        }
        function createRange(fromRight) {
            return function(start, end, step) {
                if (step && typeof step != "number" && isIterateeCall(start, end, step)) {
                    end = step = undefined;
                }
                start = toNumber(start);
                start = start === start ? start : 0;
                if (end === undefined) {
                    end = start;
                    start = 0;
                } else {
                    end = toNumber(end) || 0;
                }
                step = step === undefined ? start < end ? 1 : -1 : toNumber(step) || 0;
                return baseRange(start, end, step, fromRight);
            };
        }
        function createRelationalOperation(operator) {
            return function(value, other) {
                if (!(typeof value == "string" && typeof other == "string")) {
                    value = toNumber(value);
                    other = toNumber(other);
                }
                return operator(value, other);
            };
        }
        function createRecurryWrapper(func, bitmask, wrapFunc, placeholder, thisArg, partials, holders, argPos, ary, arity) {
            var isCurry = bitmask & CURRY_FLAG, newHolders = isCurry ? holders : undefined, newHoldersRight = isCurry ? undefined : holders, newPartials = isCurry ? partials : undefined, newPartialsRight = isCurry ? undefined : partials;
            bitmask |= isCurry ? PARTIAL_FLAG : PARTIAL_RIGHT_FLAG;
            bitmask &= ~(isCurry ? PARTIAL_RIGHT_FLAG : PARTIAL_FLAG);
            if (!(bitmask & CURRY_BOUND_FLAG)) {
                bitmask &= ~(BIND_FLAG | BIND_KEY_FLAG);
            }
            var newData = [ func, bitmask, thisArg, newPartials, newHolders, newPartialsRight, newHoldersRight, argPos, ary, arity ];
            var result = wrapFunc.apply(undefined, newData);
            if (isLaziable(func)) {
                setData(result, newData);
            }
            result.placeholder = placeholder;
            return result;
        }
        function createRound(methodName) {
            var func = Math[methodName];
            return function(number, precision) {
                number = toNumber(number);
                precision = toInteger(precision);
                if (precision) {
                    var pair = (toString(number) + "e").split("e"), value = func(pair[0] + "e" + (+pair[1] + precision));
                    pair = (toString(value) + "e").split("e");
                    return +(pair[0] + "e" + (+pair[1] - precision));
                }
                return func(number);
            };
        }
        var createSet = !(Set && 1 / setToArray(new Set([ , -0 ]))[1] == INFINITY) ? noop : function(values) {
            return new Set(values);
        };
        function createWrapper(func, bitmask, thisArg, partials, holders, argPos, ary, arity) {
            var isBindKey = bitmask & BIND_KEY_FLAG;
            if (!isBindKey && typeof func != "function") {
                throw new TypeError(FUNC_ERROR_TEXT);
            }
            var length = partials ? partials.length : 0;
            if (!length) {
                bitmask &= ~(PARTIAL_FLAG | PARTIAL_RIGHT_FLAG);
                partials = holders = undefined;
            }
            ary = ary === undefined ? ary : nativeMax(toInteger(ary), 0);
            arity = arity === undefined ? arity : toInteger(arity);
            length -= holders ? holders.length : 0;
            if (bitmask & PARTIAL_RIGHT_FLAG) {
                var partialsRight = partials, holdersRight = holders;
                partials = holders = undefined;
            }
            var data = isBindKey ? undefined : getData(func);
            var newData = [ func, bitmask, thisArg, partials, holders, partialsRight, holdersRight, argPos, ary, arity ];
            if (data) {
                mergeData(newData, data);
            }
            func = newData[0];
            bitmask = newData[1];
            thisArg = newData[2];
            partials = newData[3];
            holders = newData[4];
            arity = newData[9] = newData[9] == null ? isBindKey ? 0 : func.length : nativeMax(newData[9] - length, 0);
            if (!arity && bitmask & (CURRY_FLAG | CURRY_RIGHT_FLAG)) {
                bitmask &= ~(CURRY_FLAG | CURRY_RIGHT_FLAG);
            }
            if (!bitmask || bitmask == BIND_FLAG) {
                var result = createBaseWrapper(func, bitmask, thisArg);
            } else if (bitmask == CURRY_FLAG || bitmask == CURRY_RIGHT_FLAG) {
                result = createCurryWrapper(func, bitmask, arity);
            } else if ((bitmask == PARTIAL_FLAG || bitmask == (BIND_FLAG | PARTIAL_FLAG)) && !holders.length) {
                result = createPartialWrapper(func, bitmask, thisArg, partials);
            } else {
                result = createHybridWrapper.apply(undefined, newData);
            }
            var setter = data ? baseSetData : setData;
            return setter(result, newData);
        }
        function equalArrays(array, other, equalFunc, customizer, bitmask, stack) {
            var index = -1, isPartial = bitmask & PARTIAL_COMPARE_FLAG, isUnordered = bitmask & UNORDERED_COMPARE_FLAG, arrLength = array.length, othLength = other.length;
            if (arrLength != othLength && !(isPartial && othLength > arrLength)) {
                return false;
            }
            var stacked = stack.get(array);
            if (stacked) {
                return stacked == other;
            }
            var result = true;
            stack.set(array, other);
            while (++index < arrLength) {
                var arrValue = array[index], othValue = other[index];
                if (customizer) {
                    var compared = isPartial ? customizer(othValue, arrValue, index, other, array, stack) : customizer(arrValue, othValue, index, array, other, stack);
                }
                if (compared !== undefined) {
                    if (compared) {
                        continue;
                    }
                    result = false;
                    break;
                }
                if (isUnordered) {
                    if (!arraySome(other, function(othValue) {
                        return arrValue === othValue || equalFunc(arrValue, othValue, customizer, bitmask, stack);
                    })) {
                        result = false;
                        break;
                    }
                } else if (!(arrValue === othValue || equalFunc(arrValue, othValue, customizer, bitmask, stack))) {
                    result = false;
                    break;
                }
            }
            stack["delete"](array);
            return result;
        }
        function equalByTag(object, other, tag, equalFunc, customizer, bitmask, stack) {
            switch (tag) {
              case dataViewTag:
                if (object.byteLength != other.byteLength || object.byteOffset != other.byteOffset) {
                    return false;
                }
                object = object.buffer;
                other = other.buffer;

              case arrayBufferTag:
                if (object.byteLength != other.byteLength || !equalFunc(new Uint8Array(object), new Uint8Array(other))) {
                    return false;
                }
                return true;

              case boolTag:
              case dateTag:
                return +object == +other;

              case errorTag:
                return object.name == other.name && object.message == other.message;

              case numberTag:
                return object != +object ? other != +other : object == +other;

              case regexpTag:
              case stringTag:
                return object == other + "";

              case mapTag:
                var convert = mapToArray;

              case setTag:
                var isPartial = bitmask & PARTIAL_COMPARE_FLAG;
                convert || (convert = setToArray);
                if (object.size != other.size && !isPartial) {
                    return false;
                }
                var stacked = stack.get(object);
                if (stacked) {
                    return stacked == other;
                }
                bitmask |= UNORDERED_COMPARE_FLAG;
                stack.set(object, other);
                return equalArrays(convert(object), convert(other), equalFunc, customizer, bitmask, stack);

              case symbolTag:
                if (symbolValueOf) {
                    return symbolValueOf.call(object) == symbolValueOf.call(other);
                }
            }
            return false;
        }
        function equalObjects(object, other, equalFunc, customizer, bitmask, stack) {
            var isPartial = bitmask & PARTIAL_COMPARE_FLAG, objProps = keys(object), objLength = objProps.length, othProps = keys(other), othLength = othProps.length;
            if (objLength != othLength && !isPartial) {
                return false;
            }
            var index = objLength;
            while (index--) {
                var key = objProps[index];
                if (!(isPartial ? key in other : baseHas(other, key))) {
                    return false;
                }
            }
            var stacked = stack.get(object);
            if (stacked) {
                return stacked == other;
            }
            var result = true;
            stack.set(object, other);
            var skipCtor = isPartial;
            while (++index < objLength) {
                key = objProps[index];
                var objValue = object[key], othValue = other[key];
                if (customizer) {
                    var compared = isPartial ? customizer(othValue, objValue, key, other, object, stack) : customizer(objValue, othValue, key, object, other, stack);
                }
                if (!(compared === undefined ? objValue === othValue || equalFunc(objValue, othValue, customizer, bitmask, stack) : compared)) {
                    result = false;
                    break;
                }
                skipCtor || (skipCtor = key == "constructor");
            }
            if (result && !skipCtor) {
                var objCtor = object.constructor, othCtor = other.constructor;
                if (objCtor != othCtor && ("constructor" in object && "constructor" in other) && !(typeof objCtor == "function" && objCtor instanceof objCtor && typeof othCtor == "function" && othCtor instanceof othCtor)) {
                    result = false;
                }
            }
            stack["delete"](object);
            return result;
        }
        function getAllKeys(object) {
            return baseGetAllKeys(object, keys, getSymbols);
        }
        function getAllKeysIn(object) {
            return baseGetAllKeys(object, keysIn, getSymbolsIn);
        }
        var getData = !metaMap ? noop : function(func) {
            return metaMap.get(func);
        };
        function getFuncName(func) {
            var result = func.name + "", array = realNames[result], length = hasOwnProperty.call(realNames, result) ? array.length : 0;
            while (length--) {
                var data = array[length], otherFunc = data.func;
                if (otherFunc == null || otherFunc == func) {
                    return data.name;
                }
            }
            return result;
        }
        function getIteratee() {
            var result = lodash.iteratee || iteratee;
            result = result === iteratee ? baseIteratee : result;
            return arguments.length ? result(arguments[0], arguments[1]) : result;
        }
        var getLength = baseProperty("length");
        function getMatchData(object) {
            var result = toPairs(object), length = result.length;
            while (length--) {
                result[length][2] = isStrictComparable(result[length][1]);
            }
            return result;
        }
        function getNative(object, key) {
            var value = object[key];
            return isNative(value) ? value : undefined;
        }
        function getPlaceholder(func) {
            var object = hasOwnProperty.call(lodash, "placeholder") ? lodash : func;
            return object.placeholder;
        }
        function getPrototype(value) {
            return nativeGetPrototype(Object(value));
        }
        function getSymbols(object) {
            return getOwnPropertySymbols(Object(object));
        }
        if (!getOwnPropertySymbols) {
            getSymbols = function() {
                return [];
            };
        }
        var getSymbolsIn = !getOwnPropertySymbols ? getSymbols : function(object) {
            var result = [];
            while (object) {
                arrayPush(result, getSymbols(object));
                object = getPrototype(object);
            }
            return result;
        };
        function getTag(value) {
            return objectToString.call(value);
        }
        if (DataView && getTag(new DataView(new ArrayBuffer(1))) != dataViewTag || Map && getTag(new Map()) != mapTag || Promise && getTag(Promise.resolve()) != promiseTag || Set && getTag(new Set()) != setTag || WeakMap && getTag(new WeakMap()) != weakMapTag) {
            getTag = function(value) {
                var result = objectToString.call(value), Ctor = result == objectTag ? value.constructor : undefined, ctorString = Ctor ? toSource(Ctor) : undefined;
                if (ctorString) {
                    switch (ctorString) {
                      case dataViewCtorString:
                        return dataViewTag;

                      case mapCtorString:
                        return mapTag;

                      case promiseCtorString:
                        return promiseTag;

                      case setCtorString:
                        return setTag;

                      case weakMapCtorString:
                        return weakMapTag;
                    }
                }
                return result;
            };
        }
        function getView(start, end, transforms) {
            var index = -1, length = transforms.length;
            while (++index < length) {
                var data = transforms[index], size = data.size;
                switch (data.type) {
                  case "drop":
                    start += size;
                    break;

                  case "dropRight":
                    end -= size;
                    break;

                  case "take":
                    end = nativeMin(end, start + size);
                    break;

                  case "takeRight":
                    start = nativeMax(start, end - size);
                    break;
                }
            }
            return {
                start: start,
                end: end
            };
        }
        function hasPath(object, path, hasFunc) {
            path = isKey(path, object) ? [ path ] : castPath(path);
            var result, index = -1, length = path.length;
            while (++index < length) {
                var key = toKey(path[index]);
                if (!(result = object != null && hasFunc(object, key))) {
                    break;
                }
                object = object[key];
            }
            if (result) {
                return result;
            }
            var length = object ? object.length : 0;
            return !!length && isLength(length) && isIndex(key, length) && (isArray(object) || isString(object) || isArguments(object));
        }
        function initCloneArray(array) {
            var length = array.length, result = array.constructor(length);
            if (length && typeof array[0] == "string" && hasOwnProperty.call(array, "index")) {
                result.index = array.index;
                result.input = array.input;
            }
            return result;
        }
        function initCloneObject(object) {
            return typeof object.constructor == "function" && !isPrototype(object) ? baseCreate(getPrototype(object)) : {};
        }
        function initCloneByTag(object, tag, cloneFunc, isDeep) {
            var Ctor = object.constructor;
            switch (tag) {
              case arrayBufferTag:
                return cloneArrayBuffer(object);

              case boolTag:
              case dateTag:
                return new Ctor((+object));

              case dataViewTag:
                return cloneDataView(object, isDeep);

              case float32Tag:
              case float64Tag:
              case int8Tag:
              case int16Tag:
              case int32Tag:
              case uint8Tag:
              case uint8ClampedTag:
              case uint16Tag:
              case uint32Tag:
                return cloneTypedArray(object, isDeep);

              case mapTag:
                return cloneMap(object, isDeep, cloneFunc);

              case numberTag:
              case stringTag:
                return new Ctor(object);

              case regexpTag:
                return cloneRegExp(object);

              case setTag:
                return cloneSet(object, isDeep, cloneFunc);

              case symbolTag:
                return cloneSymbol(object);
            }
        }
        function indexKeys(object) {
            var length = object ? object.length : undefined;
            if (isLength(length) && (isArray(object) || isString(object) || isArguments(object))) {
                return baseTimes(length, String);
            }
            return null;
        }
        function isFlattenable(value) {
            return isArrayLikeObject(value) && (isArray(value) || isArguments(value));
        }
        function isFlattenableIteratee(value) {
            return isArray(value) && !(value.length == 2 && !isFunction(value[0]));
        }
        function isIndex(value, length) {
            length = length == null ? MAX_SAFE_INTEGER : length;
            return !!length && (typeof value == "number" || reIsUint.test(value)) && (value > -1 && value % 1 == 0 && value < length);
        }
        function isIterateeCall(value, index, object) {
            if (!isObject(object)) {
                return false;
            }
            var type = typeof index;
            if (type == "number" ? isArrayLike(object) && isIndex(index, object.length) : type == "string" && index in object) {
                return eq(object[index], value);
            }
            return false;
        }
        function isKey(value, object) {
            if (isArray(value)) {
                return false;
            }
            var type = typeof value;
            if (type == "number" || type == "symbol" || type == "boolean" || value == null || isSymbol(value)) {
                return true;
            }
            return reIsPlainProp.test(value) || !reIsDeepProp.test(value) || object != null && value in Object(object);
        }
        function isKeyable(value) {
            var type = typeof value;
            return type == "string" || type == "number" || type == "symbol" || type == "boolean" ? value !== "__proto__" : value === null;
        }
        function isLaziable(func) {
            var funcName = getFuncName(func), other = lodash[funcName];
            if (typeof other != "function" || !(funcName in LazyWrapper.prototype)) {
                return false;
            }
            if (func === other) {
                return true;
            }
            var data = getData(other);
            return !!data && func === data[0];
        }
        function isPrototype(value) {
            var Ctor = value && value.constructor, proto = typeof Ctor == "function" && Ctor.prototype || objectProto;
            return value === proto;
        }
        function isStrictComparable(value) {
            return value === value && !isObject(value);
        }
        function matchesStrictComparable(key, srcValue) {
            return function(object) {
                if (object == null) {
                    return false;
                }
                return object[key] === srcValue && (srcValue !== undefined || key in Object(object));
            };
        }
        function mergeData(data, source) {
            var bitmask = data[1], srcBitmask = source[1], newBitmask = bitmask | srcBitmask, isCommon = newBitmask < (BIND_FLAG | BIND_KEY_FLAG | ARY_FLAG);
            var isCombo = srcBitmask == ARY_FLAG && bitmask == CURRY_FLAG || srcBitmask == ARY_FLAG && bitmask == REARG_FLAG && data[7].length <= source[8] || srcBitmask == (ARY_FLAG | REARG_FLAG) && source[7].length <= source[8] && bitmask == CURRY_FLAG;
            if (!(isCommon || isCombo)) {
                return data;
            }
            if (srcBitmask & BIND_FLAG) {
                data[2] = source[2];
                newBitmask |= bitmask & BIND_FLAG ? 0 : CURRY_BOUND_FLAG;
            }
            var value = source[3];
            if (value) {
                var partials = data[3];
                data[3] = partials ? composeArgs(partials, value, source[4]) : value;
                data[4] = partials ? replaceHolders(data[3], PLACEHOLDER) : source[4];
            }
            value = source[5];
            if (value) {
                partials = data[5];
                data[5] = partials ? composeArgsRight(partials, value, source[6]) : value;
                data[6] = partials ? replaceHolders(data[5], PLACEHOLDER) : source[6];
            }
            value = source[7];
            if (value) {
                data[7] = value;
            }
            if (srcBitmask & ARY_FLAG) {
                data[8] = data[8] == null ? source[8] : nativeMin(data[8], source[8]);
            }
            if (data[9] == null) {
                data[9] = source[9];
            }
            data[0] = source[0];
            data[1] = newBitmask;
            return data;
        }
        function mergeDefaults(objValue, srcValue, key, object, source, stack) {
            if (isObject(objValue) && isObject(srcValue)) {
                baseMerge(objValue, srcValue, undefined, mergeDefaults, stack.set(srcValue, objValue));
            }
            return objValue;
        }
        function parent(object, path) {
            return path.length == 1 ? object : baseGet(object, baseSlice(path, 0, -1));
        }
        function reorder(array, indexes) {
            var arrLength = array.length, length = nativeMin(indexes.length, arrLength), oldArray = copyArray(array);
            while (length--) {
                var index = indexes[length];
                array[length] = isIndex(index, arrLength) ? oldArray[index] : undefined;
            }
            return array;
        }
        var setData = function() {
            var count = 0, lastCalled = 0;
            return function(key, value) {
                var stamp = now(), remaining = HOT_SPAN - (stamp - lastCalled);
                lastCalled = stamp;
                if (remaining > 0) {
                    if (++count >= HOT_COUNT) {
                        return key;
                    }
                } else {
                    count = 0;
                }
                return baseSetData(key, value);
            };
        }();
        var stringToPath = memoize(function(string) {
            var result = [];
            toString(string).replace(rePropName, function(match, number, quote, string) {
                result.push(quote ? string.replace(reEscapeChar, "$1") : number || match);
            });
            return result;
        });
        function toKey(value) {
            if (typeof value == "string" || isSymbol(value)) {
                return value;
            }
            var result = value + "";
            return result == "0" && 1 / value == -INFINITY ? "-0" : result;
        }
        function toSource(func) {
            if (func != null) {
                try {
                    return funcToString.call(func);
                } catch (e) {}
                try {
                    return func + "";
                } catch (e) {}
            }
            return "";
        }
        function wrapperClone(wrapper) {
            if (wrapper instanceof LazyWrapper) {
                return wrapper.clone();
            }
            var result = new LodashWrapper(wrapper.__wrapped__, wrapper.__chain__);
            result.__actions__ = copyArray(wrapper.__actions__);
            result.__index__ = wrapper.__index__;
            result.__values__ = wrapper.__values__;
            return result;
        }
        function chunk(array, size, guard) {
            if (guard ? isIterateeCall(array, size, guard) : size === undefined) {
                size = 1;
            } else {
                size = nativeMax(toInteger(size), 0);
            }
            var length = array ? array.length : 0;
            if (!length || size < 1) {
                return [];
            }
            var index = 0, resIndex = 0, result = Array(nativeCeil(length / size));
            while (index < length) {
                result[resIndex++] = baseSlice(array, index, index += size);
            }
            return result;
        }
        function compact(array) {
            var index = -1, length = array ? array.length : 0, resIndex = 0, result = [];
            while (++index < length) {
                var value = array[index];
                if (value) {
                    result[resIndex++] = value;
                }
            }
            return result;
        }
        function concat() {
            var length = arguments.length, array = castArray(arguments[0]);
            if (length < 2) {
                return length ? copyArray(array) : [];
            }
            var args = Array(length - 1);
            while (length--) {
                args[length - 1] = arguments[length];
            }
            return arrayConcat(array, baseFlatten(args, 1));
        }
        var difference = rest(function(array, values) {
            return isArrayLikeObject(array) ? baseDifference(array, baseFlatten(values, 1, isArrayLikeObject, true)) : [];
        });
        var differenceBy = rest(function(array, values) {
            var iteratee = last(values);
            if (isArrayLikeObject(iteratee)) {
                iteratee = undefined;
            }
            return isArrayLikeObject(array) ? baseDifference(array, baseFlatten(values, 1, isArrayLikeObject, true), getIteratee(iteratee)) : [];
        });
        var differenceWith = rest(function(array, values) {
            var comparator = last(values);
            if (isArrayLikeObject(comparator)) {
                comparator = undefined;
            }
            return isArrayLikeObject(array) ? baseDifference(array, baseFlatten(values, 1, isArrayLikeObject, true), undefined, comparator) : [];
        });
        function drop(array, n, guard) {
            var length = array ? array.length : 0;
            if (!length) {
                return [];
            }
            n = guard || n === undefined ? 1 : toInteger(n);
            return baseSlice(array, n < 0 ? 0 : n, length);
        }
        function dropRight(array, n, guard) {
            var length = array ? array.length : 0;
            if (!length) {
                return [];
            }
            n = guard || n === undefined ? 1 : toInteger(n);
            n = length - n;
            return baseSlice(array, 0, n < 0 ? 0 : n);
        }
        function dropRightWhile(array, predicate) {
            return array && array.length ? baseWhile(array, getIteratee(predicate, 3), true, true) : [];
        }
        function dropWhile(array, predicate) {
            return array && array.length ? baseWhile(array, getIteratee(predicate, 3), true) : [];
        }
        function fill(array, value, start, end) {
            var length = array ? array.length : 0;
            if (!length) {
                return [];
            }
            if (start && typeof start != "number" && isIterateeCall(array, value, start)) {
                start = 0;
                end = length;
            }
            return baseFill(array, value, start, end);
        }
        function findIndex(array, predicate) {
            return array && array.length ? baseFindIndex(array, getIteratee(predicate, 3)) : -1;
        }
        function findLastIndex(array, predicate) {
            return array && array.length ? baseFindIndex(array, getIteratee(predicate, 3), true) : -1;
        }
        function flatten(array) {
            var length = array ? array.length : 0;
            return length ? baseFlatten(array, 1) : [];
        }
        function flattenDeep(array) {
            var length = array ? array.length : 0;
            return length ? baseFlatten(array, INFINITY) : [];
        }
        function flattenDepth(array, depth) {
            var length = array ? array.length : 0;
            if (!length) {
                return [];
            }
            depth = depth === undefined ? 1 : toInteger(depth);
            return baseFlatten(array, depth);
        }
        function fromPairs(pairs) {
            var index = -1, length = pairs ? pairs.length : 0, result = {};
            while (++index < length) {
                var pair = pairs[index];
                result[pair[0]] = pair[1];
            }
            return result;
        }
        function head(array) {
            return array && array.length ? array[0] : undefined;
        }
        function indexOf(array, value, fromIndex) {
            var length = array ? array.length : 0;
            if (!length) {
                return -1;
            }
            fromIndex = toInteger(fromIndex);
            if (fromIndex < 0) {
                fromIndex = nativeMax(length + fromIndex, 0);
            }
            return baseIndexOf(array, value, fromIndex);
        }
        function initial(array) {
            return dropRight(array, 1);
        }
        var intersection = rest(function(arrays) {
            var mapped = arrayMap(arrays, castArrayLikeObject);
            return mapped.length && mapped[0] === arrays[0] ? baseIntersection(mapped) : [];
        });
        var intersectionBy = rest(function(arrays) {
            var iteratee = last(arrays), mapped = arrayMap(arrays, castArrayLikeObject);
            if (iteratee === last(mapped)) {
                iteratee = undefined;
            } else {
                mapped.pop();
            }
            return mapped.length && mapped[0] === arrays[0] ? baseIntersection(mapped, getIteratee(iteratee)) : [];
        });
        var intersectionWith = rest(function(arrays) {
            var comparator = last(arrays), mapped = arrayMap(arrays, castArrayLikeObject);
            if (comparator === last(mapped)) {
                comparator = undefined;
            } else {
                mapped.pop();
            }
            return mapped.length && mapped[0] === arrays[0] ? baseIntersection(mapped, undefined, comparator) : [];
        });
        function join(array, separator) {
            return array ? nativeJoin.call(array, separator) : "";
        }
        function last(array) {
            var length = array ? array.length : 0;
            return length ? array[length - 1] : undefined;
        }
        function lastIndexOf(array, value, fromIndex) {
            var length = array ? array.length : 0;
            if (!length) {
                return -1;
            }
            var index = length;
            if (fromIndex !== undefined) {
                index = toInteger(fromIndex);
                index = (index < 0 ? nativeMax(length + index, 0) : nativeMin(index, length - 1)) + 1;
            }
            if (value !== value) {
                return indexOfNaN(array, index, true);
            }
            while (index--) {
                if (array[index] === value) {
                    return index;
                }
            }
            return -1;
        }
        function nth(array, n) {
            return array && array.length ? baseNth(array, toInteger(n)) : undefined;
        }
        var pull = rest(pullAll);
        function pullAll(array, values) {
            return array && array.length && values && values.length ? basePullAll(array, values) : array;
        }
        function pullAllBy(array, values, iteratee) {
            return array && array.length && values && values.length ? basePullAll(array, values, getIteratee(iteratee)) : array;
        }
        function pullAllWith(array, values, comparator) {
            return array && array.length && values && values.length ? basePullAll(array, values, undefined, comparator) : array;
        }
        var pullAt = rest(function(array, indexes) {
            indexes = baseFlatten(indexes, 1);
            var length = array ? array.length : 0, result = baseAt(array, indexes);
            basePullAt(array, arrayMap(indexes, function(index) {
                return isIndex(index, length) ? +index : index;
            }).sort(compareAscending));
            return result;
        });
        function remove(array, predicate) {
            var result = [];
            if (!(array && array.length)) {
                return result;
            }
            var index = -1, indexes = [], length = array.length;
            predicate = getIteratee(predicate, 3);
            while (++index < length) {
                var value = array[index];
                if (predicate(value, index, array)) {
                    result.push(value);
                    indexes.push(index);
                }
            }
            basePullAt(array, indexes);
            return result;
        }
        function reverse(array) {
            return array ? nativeReverse.call(array) : array;
        }
        function slice(array, start, end) {
            var length = array ? array.length : 0;
            if (!length) {
                return [];
            }
            if (end && typeof end != "number" && isIterateeCall(array, start, end)) {
                start = 0;
                end = length;
            } else {
                start = start == null ? 0 : toInteger(start);
                end = end === undefined ? length : toInteger(end);
            }
            return baseSlice(array, start, end);
        }
        function sortedIndex(array, value) {
            return baseSortedIndex(array, value);
        }
        function sortedIndexBy(array, value, iteratee) {
            return baseSortedIndexBy(array, value, getIteratee(iteratee));
        }
        function sortedIndexOf(array, value) {
            var length = array ? array.length : 0;
            if (length) {
                var index = baseSortedIndex(array, value);
                if (index < length && eq(array[index], value)) {
                    return index;
                }
            }
            return -1;
        }
        function sortedLastIndex(array, value) {
            return baseSortedIndex(array, value, true);
        }
        function sortedLastIndexBy(array, value, iteratee) {
            return baseSortedIndexBy(array, value, getIteratee(iteratee), true);
        }
        function sortedLastIndexOf(array, value) {
            var length = array ? array.length : 0;
            if (length) {
                var index = baseSortedIndex(array, value, true) - 1;
                if (eq(array[index], value)) {
                    return index;
                }
            }
            return -1;
        }
        function sortedUniq(array) {
            return array && array.length ? baseSortedUniq(array) : [];
        }
        function sortedUniqBy(array, iteratee) {
            return array && array.length ? baseSortedUniq(array, getIteratee(iteratee)) : [];
        }
        function tail(array) {
            return drop(array, 1);
        }
        function take(array, n, guard) {
            if (!(array && array.length)) {
                return [];
            }
            n = guard || n === undefined ? 1 : toInteger(n);
            return baseSlice(array, 0, n < 0 ? 0 : n);
        }
        function takeRight(array, n, guard) {
            var length = array ? array.length : 0;
            if (!length) {
                return [];
            }
            n = guard || n === undefined ? 1 : toInteger(n);
            n = length - n;
            return baseSlice(array, n < 0 ? 0 : n, length);
        }
        function takeRightWhile(array, predicate) {
            return array && array.length ? baseWhile(array, getIteratee(predicate, 3), false, true) : [];
        }
        function takeWhile(array, predicate) {
            return array && array.length ? baseWhile(array, getIteratee(predicate, 3)) : [];
        }
        var union = rest(function(arrays) {
            return baseUniq(baseFlatten(arrays, 1, isArrayLikeObject, true));
        });
        var unionBy = rest(function(arrays) {
            var iteratee = last(arrays);
            if (isArrayLikeObject(iteratee)) {
                iteratee = undefined;
            }
            return baseUniq(baseFlatten(arrays, 1, isArrayLikeObject, true), getIteratee(iteratee));
        });
        var unionWith = rest(function(arrays) {
            var comparator = last(arrays);
            if (isArrayLikeObject(comparator)) {
                comparator = undefined;
            }
            return baseUniq(baseFlatten(arrays, 1, isArrayLikeObject, true), undefined, comparator);
        });
        function uniq(array) {
            return array && array.length ? baseUniq(array) : [];
        }
        function uniqBy(array, iteratee) {
            return array && array.length ? baseUniq(array, getIteratee(iteratee)) : [];
        }
        function uniqWith(array, comparator) {
            return array && array.length ? baseUniq(array, undefined, comparator) : [];
        }
        function unzip(array) {
            if (!(array && array.length)) {
                return [];
            }
            var length = 0;
            array = arrayFilter(array, function(group) {
                if (isArrayLikeObject(group)) {
                    length = nativeMax(group.length, length);
                    return true;
                }
            });
            return baseTimes(length, function(index) {
                return arrayMap(array, baseProperty(index));
            });
        }
        function unzipWith(array, iteratee) {
            if (!(array && array.length)) {
                return [];
            }
            var result = unzip(array);
            if (iteratee == null) {
                return result;
            }
            return arrayMap(result, function(group) {
                return apply(iteratee, undefined, group);
            });
        }
        var without = rest(function(array, values) {
            return isArrayLikeObject(array) ? baseDifference(array, values) : [];
        });
        var xor = rest(function(arrays) {
            return baseXor(arrayFilter(arrays, isArrayLikeObject));
        });
        var xorBy = rest(function(arrays) {
            var iteratee = last(arrays);
            if (isArrayLikeObject(iteratee)) {
                iteratee = undefined;
            }
            return baseXor(arrayFilter(arrays, isArrayLikeObject), getIteratee(iteratee));
        });
        var xorWith = rest(function(arrays) {
            var comparator = last(arrays);
            if (isArrayLikeObject(comparator)) {
                comparator = undefined;
            }
            return baseXor(arrayFilter(arrays, isArrayLikeObject), undefined, comparator);
        });
        var zip = rest(unzip);
        function zipObject(props, values) {
            return baseZipObject(props || [], values || [], assignValue);
        }
        function zipObjectDeep(props, values) {
            return baseZipObject(props || [], values || [], baseSet);
        }
        var zipWith = rest(function(arrays) {
            var length = arrays.length, iteratee = length > 1 ? arrays[length - 1] : undefined;
            iteratee = typeof iteratee == "function" ? (arrays.pop(), iteratee) : undefined;
            return unzipWith(arrays, iteratee);
        });
        function chain(value) {
            var result = lodash(value);
            result.__chain__ = true;
            return result;
        }
        function tap(value, interceptor) {
            interceptor(value);
            return value;
        }
        function thru(value, interceptor) {
            return interceptor(value);
        }
        var wrapperAt = rest(function(paths) {
            paths = baseFlatten(paths, 1);
            var length = paths.length, start = length ? paths[0] : 0, value = this.__wrapped__, interceptor = function(object) {
                return baseAt(object, paths);
            };
            if (length > 1 || this.__actions__.length || !(value instanceof LazyWrapper) || !isIndex(start)) {
                return this.thru(interceptor);
            }
            value = value.slice(start, +start + (length ? 1 : 0));
            value.__actions__.push({
                func: thru,
                args: [ interceptor ],
                thisArg: undefined
            });
            return new LodashWrapper(value, this.__chain__).thru(function(array) {
                if (length && !array.length) {
                    array.push(undefined);
                }
                return array;
            });
        });
        function wrapperChain() {
            return chain(this);
        }
        function wrapperCommit() {
            return new LodashWrapper(this.value(), this.__chain__);
        }
        function wrapperNext() {
            if (this.__values__ === undefined) {
                this.__values__ = toArray(this.value());
            }
            var done = this.__index__ >= this.__values__.length, value = done ? undefined : this.__values__[this.__index__++];
            return {
                done: done,
                value: value
            };
        }
        function wrapperToIterator() {
            return this;
        }
        function wrapperPlant(value) {
            var result, parent = this;
            while (parent instanceof baseLodash) {
                var clone = wrapperClone(parent);
                clone.__index__ = 0;
                clone.__values__ = undefined;
                if (result) {
                    previous.__wrapped__ = clone;
                } else {
                    result = clone;
                }
                var previous = clone;
                parent = parent.__wrapped__;
            }
            previous.__wrapped__ = value;
            return result;
        }
        function wrapperReverse() {
            var value = this.__wrapped__;
            if (value instanceof LazyWrapper) {
                var wrapped = value;
                if (this.__actions__.length) {
                    wrapped = new LazyWrapper(this);
                }
                wrapped = wrapped.reverse();
                wrapped.__actions__.push({
                    func: thru,
                    args: [ reverse ],
                    thisArg: undefined
                });
                return new LodashWrapper(wrapped, this.__chain__);
            }
            return this.thru(reverse);
        }
        function wrapperValue() {
            return baseWrapperValue(this.__wrapped__, this.__actions__);
        }
        var countBy = createAggregator(function(result, value, key) {
            hasOwnProperty.call(result, key) ? ++result[key] : result[key] = 1;
        });
        function every(collection, predicate, guard) {
            var func = isArray(collection) ? arrayEvery : baseEvery;
            if (guard && isIterateeCall(collection, predicate, guard)) {
                predicate = undefined;
            }
            return func(collection, getIteratee(predicate, 3));
        }
        function filter(collection, predicate) {
            var func = isArray(collection) ? arrayFilter : baseFilter;
            return func(collection, getIteratee(predicate, 3));
        }
        function find(collection, predicate) {
            predicate = getIteratee(predicate, 3);
            if (isArray(collection)) {
                var index = baseFindIndex(collection, predicate);
                return index > -1 ? collection[index] : undefined;
            }
            return baseFind(collection, predicate, baseEach);
        }
        function findLast(collection, predicate) {
            predicate = getIteratee(predicate, 3);
            if (isArray(collection)) {
                var index = baseFindIndex(collection, predicate, true);
                return index > -1 ? collection[index] : undefined;
            }
            return baseFind(collection, predicate, baseEachRight);
        }
        function flatMap(collection, iteratee) {
            return baseFlatten(map(collection, iteratee), 1);
        }
        function flatMapDeep(collection, iteratee) {
            return baseFlatten(map(collection, iteratee), INFINITY);
        }
        function flatMapDepth(collection, iteratee, depth) {
            depth = depth === undefined ? 1 : toInteger(depth);
            return baseFlatten(map(collection, iteratee), depth);
        }
        function forEach(collection, iteratee) {
            return typeof iteratee == "function" && isArray(collection) ? arrayEach(collection, iteratee) : baseEach(collection, getIteratee(iteratee));
        }
        function forEachRight(collection, iteratee) {
            return typeof iteratee == "function" && isArray(collection) ? arrayEachRight(collection, iteratee) : baseEachRight(collection, getIteratee(iteratee));
        }
        var groupBy = createAggregator(function(result, value, key) {
            if (hasOwnProperty.call(result, key)) {
                result[key].push(value);
            } else {
                result[key] = [ value ];
            }
        });
        function includes(collection, value, fromIndex, guard) {
            collection = isArrayLike(collection) ? collection : values(collection);
            fromIndex = fromIndex && !guard ? toInteger(fromIndex) : 0;
            var length = collection.length;
            if (fromIndex < 0) {
                fromIndex = nativeMax(length + fromIndex, 0);
            }
            return isString(collection) ? fromIndex <= length && collection.indexOf(value, fromIndex) > -1 : !!length && baseIndexOf(collection, value, fromIndex) > -1;
        }
        var invokeMap = rest(function(collection, path, args) {
            var index = -1, isFunc = typeof path == "function", isProp = isKey(path), result = isArrayLike(collection) ? Array(collection.length) : [];
            baseEach(collection, function(value) {
                var func = isFunc ? path : isProp && value != null ? value[path] : undefined;
                result[++index] = func ? apply(func, value, args) : baseInvoke(value, path, args);
            });
            return result;
        });
        var keyBy = createAggregator(function(result, value, key) {
            result[key] = value;
        });
        function map(collection, iteratee) {
            var func = isArray(collection) ? arrayMap : baseMap;
            return func(collection, getIteratee(iteratee, 3));
        }
        function orderBy(collection, iteratees, orders, guard) {
            if (collection == null) {
                return [];
            }
            if (!isArray(iteratees)) {
                iteratees = iteratees == null ? [] : [ iteratees ];
            }
            orders = guard ? undefined : orders;
            if (!isArray(orders)) {
                orders = orders == null ? [] : [ orders ];
            }
            return baseOrderBy(collection, iteratees, orders);
        }
        var partition = createAggregator(function(result, value, key) {
            result[key ? 0 : 1].push(value);
        }, function() {
            return [ [], [] ];
        });
        function reduce(collection, iteratee, accumulator) {
            var func = isArray(collection) ? arrayReduce : baseReduce, initAccum = arguments.length < 3;
            return func(collection, getIteratee(iteratee, 4), accumulator, initAccum, baseEach);
        }
        function reduceRight(collection, iteratee, accumulator) {
            var func = isArray(collection) ? arrayReduceRight : baseReduce, initAccum = arguments.length < 3;
            return func(collection, getIteratee(iteratee, 4), accumulator, initAccum, baseEachRight);
        }
        function reject(collection, predicate) {
            var func = isArray(collection) ? arrayFilter : baseFilter;
            predicate = getIteratee(predicate, 3);
            return func(collection, function(value, index, collection) {
                return !predicate(value, index, collection);
            });
        }
        function sample(collection) {
            var array = isArrayLike(collection) ? collection : values(collection), length = array.length;
            return length > 0 ? array[baseRandom(0, length - 1)] : undefined;
        }
        function sampleSize(collection, n, guard) {
            var index = -1, result = toArray(collection), length = result.length, lastIndex = length - 1;
            if (guard ? isIterateeCall(collection, n, guard) : n === undefined) {
                n = 1;
            } else {
                n = baseClamp(toInteger(n), 0, length);
            }
            while (++index < n) {
                var rand = baseRandom(index, lastIndex), value = result[rand];
                result[rand] = result[index];
                result[index] = value;
            }
            result.length = n;
            return result;
        }
        function shuffle(collection) {
            return sampleSize(collection, MAX_ARRAY_LENGTH);
        }
        function size(collection) {
            if (collection == null) {
                return 0;
            }
            if (isArrayLike(collection)) {
                var result = collection.length;
                return result && isString(collection) ? stringSize(collection) : result;
            }
            if (isObjectLike(collection)) {
                var tag = getTag(collection);
                if (tag == mapTag || tag == setTag) {
                    return collection.size;
                }
            }
            return keys(collection).length;
        }
        function some(collection, predicate, guard) {
            var func = isArray(collection) ? arraySome : baseSome;
            if (guard && isIterateeCall(collection, predicate, guard)) {
                predicate = undefined;
            }
            return func(collection, getIteratee(predicate, 3));
        }
        var sortBy = rest(function(collection, iteratees) {
            if (collection == null) {
                return [];
            }
            var length = iteratees.length;
            if (length > 1 && isIterateeCall(collection, iteratees[0], iteratees[1])) {
                iteratees = [];
            } else if (length > 2 && isIterateeCall(iteratees[0], iteratees[1], iteratees[2])) {
                iteratees = [ iteratees[0] ];
            }
            iteratees = iteratees.length == 1 && isArray(iteratees[0]) ? iteratees[0] : baseFlatten(iteratees, 1, isFlattenableIteratee);
            return baseOrderBy(collection, iteratees, []);
        });
        var now = Date.now;
        function after(n, func) {
            if (typeof func != "function") {
                throw new TypeError(FUNC_ERROR_TEXT);
            }
            n = toInteger(n);
            return function() {
                if (--n < 1) {
                    return func.apply(this, arguments);
                }
            };
        }
        function ary(func, n, guard) {
            n = guard ? undefined : n;
            n = func && n == null ? func.length : n;
            return createWrapper(func, ARY_FLAG, undefined, undefined, undefined, undefined, n);
        }
        function before(n, func) {
            var result;
            if (typeof func != "function") {
                throw new TypeError(FUNC_ERROR_TEXT);
            }
            n = toInteger(n);
            return function() {
                if (--n > 0) {
                    result = func.apply(this, arguments);
                }
                if (n <= 1) {
                    func = undefined;
                }
                return result;
            };
        }
        var bind = rest(function(func, thisArg, partials) {
            var bitmask = BIND_FLAG;
            if (partials.length) {
                var holders = replaceHolders(partials, getPlaceholder(bind));
                bitmask |= PARTIAL_FLAG;
            }
            return createWrapper(func, bitmask, thisArg, partials, holders);
        });
        var bindKey = rest(function(object, key, partials) {
            var bitmask = BIND_FLAG | BIND_KEY_FLAG;
            if (partials.length) {
                var holders = replaceHolders(partials, getPlaceholder(bindKey));
                bitmask |= PARTIAL_FLAG;
            }
            return createWrapper(key, bitmask, object, partials, holders);
        });
        function curry(func, arity, guard) {
            arity = guard ? undefined : arity;
            var result = createWrapper(func, CURRY_FLAG, undefined, undefined, undefined, undefined, undefined, arity);
            result.placeholder = curry.placeholder;
            return result;
        }
        function curryRight(func, arity, guard) {
            arity = guard ? undefined : arity;
            var result = createWrapper(func, CURRY_RIGHT_FLAG, undefined, undefined, undefined, undefined, undefined, arity);
            result.placeholder = curryRight.placeholder;
            return result;
        }
        function debounce(func, wait, options) {
            var lastArgs, lastThis, maxWait, result, timerId, lastCallTime = 0, lastInvokeTime = 0, leading = false, maxing = false, trailing = true;
            if (typeof func != "function") {
                throw new TypeError(FUNC_ERROR_TEXT);
            }
            wait = toNumber(wait) || 0;
            if (isObject(options)) {
                leading = !!options.leading;
                maxing = "maxWait" in options;
                maxWait = maxing ? nativeMax(toNumber(options.maxWait) || 0, wait) : maxWait;
                trailing = "trailing" in options ? !!options.trailing : trailing;
            }
            function invokeFunc(time) {
                var args = lastArgs, thisArg = lastThis;
                lastArgs = lastThis = undefined;
                lastInvokeTime = time;
                result = func.apply(thisArg, args);
                return result;
            }
            function leadingEdge(time) {
                lastInvokeTime = time;
                timerId = setTimeout(timerExpired, wait);
                return leading ? invokeFunc(time) : result;
            }
            function remainingWait(time) {
                var timeSinceLastCall = time - lastCallTime, timeSinceLastInvoke = time - lastInvokeTime, result = wait - timeSinceLastCall;
                return maxing ? nativeMin(result, maxWait - timeSinceLastInvoke) : result;
            }
            function shouldInvoke(time) {
                var timeSinceLastCall = time - lastCallTime, timeSinceLastInvoke = time - lastInvokeTime;
                return !lastCallTime || timeSinceLastCall >= wait || timeSinceLastCall < 0 || maxing && timeSinceLastInvoke >= maxWait;
            }
            function timerExpired() {
                var time = now();
                if (shouldInvoke(time)) {
                    return trailingEdge(time);
                }
                timerId = setTimeout(timerExpired, remainingWait(time));
            }
            function trailingEdge(time) {
                clearTimeout(timerId);
                timerId = undefined;
                if (trailing && lastArgs) {
                    return invokeFunc(time);
                }
                lastArgs = lastThis = undefined;
                return result;
            }
            function cancel() {
                if (timerId !== undefined) {
                    clearTimeout(timerId);
                }
                lastCallTime = lastInvokeTime = 0;
                lastArgs = lastThis = timerId = undefined;
            }
            function flush() {
                return timerId === undefined ? result : trailingEdge(now());
            }
            function debounced() {
                var time = now(), isInvoking = shouldInvoke(time);
                lastArgs = arguments;
                lastThis = this;
                lastCallTime = time;
                if (isInvoking) {
                    if (timerId === undefined) {
                        return leadingEdge(lastCallTime);
                    }
                    if (maxing) {
                        clearTimeout(timerId);
                        timerId = setTimeout(timerExpired, wait);
                        return invokeFunc(lastCallTime);
                    }
                }
                if (timerId === undefined) {
                    timerId = setTimeout(timerExpired, wait);
                }
                return result;
            }
            debounced.cancel = cancel;
            debounced.flush = flush;
            return debounced;
        }
        var defer = rest(function(func, args) {
            return baseDelay(func, 1, args);
        });
        var delay = rest(function(func, wait, args) {
            return baseDelay(func, toNumber(wait) || 0, args);
        });
        function flip(func) {
            return createWrapper(func, FLIP_FLAG);
        }
        function memoize(func, resolver) {
            if (typeof func != "function" || resolver && typeof resolver != "function") {
                throw new TypeError(FUNC_ERROR_TEXT);
            }
            var memoized = function() {
                var args = arguments, key = resolver ? resolver.apply(this, args) : args[0], cache = memoized.cache;
                if (cache.has(key)) {
                    return cache.get(key);
                }
                var result = func.apply(this, args);
                memoized.cache = cache.set(key, result);
                return result;
            };
            memoized.cache = new (memoize.Cache || MapCache)();
            return memoized;
        }
        memoize.Cache = MapCache;
        function negate(predicate) {
            if (typeof predicate != "function") {
                throw new TypeError(FUNC_ERROR_TEXT);
            }
            return function() {
                return !predicate.apply(this, arguments);
            };
        }
        function once(func) {
            return before(2, func);
        }
        var overArgs = rest(function(func, transforms) {
            transforms = transforms.length == 1 && isArray(transforms[0]) ? arrayMap(transforms[0], baseUnary(getIteratee())) : arrayMap(baseFlatten(transforms, 1, isFlattenableIteratee), baseUnary(getIteratee()));
            var funcsLength = transforms.length;
            return rest(function(args) {
                var index = -1, length = nativeMin(args.length, funcsLength);
                while (++index < length) {
                    args[index] = transforms[index].call(this, args[index]);
                }
                return apply(func, this, args);
            });
        });
        var partial = rest(function(func, partials) {
            var holders = replaceHolders(partials, getPlaceholder(partial));
            return createWrapper(func, PARTIAL_FLAG, undefined, partials, holders);
        });
        var partialRight = rest(function(func, partials) {
            var holders = replaceHolders(partials, getPlaceholder(partialRight));
            return createWrapper(func, PARTIAL_RIGHT_FLAG, undefined, partials, holders);
        });
        var rearg = rest(function(func, indexes) {
            return createWrapper(func, REARG_FLAG, undefined, undefined, undefined, baseFlatten(indexes, 1));
        });
        function rest(func, start) {
            if (typeof func != "function") {
                throw new TypeError(FUNC_ERROR_TEXT);
            }
            start = nativeMax(start === undefined ? func.length - 1 : toInteger(start), 0);
            return function() {
                var args = arguments, index = -1, length = nativeMax(args.length - start, 0), array = Array(length);
                while (++index < length) {
                    array[index] = args[start + index];
                }
                switch (start) {
                  case 0:
                    return func.call(this, array);

                  case 1:
                    return func.call(this, args[0], array);

                  case 2:
                    return func.call(this, args[0], args[1], array);
                }
                var otherArgs = Array(start + 1);
                index = -1;
                while (++index < start) {
                    otherArgs[index] = args[index];
                }
                otherArgs[start] = array;
                return apply(func, this, otherArgs);
            };
        }
        function spread(func, start) {
            if (typeof func != "function") {
                throw new TypeError(FUNC_ERROR_TEXT);
            }
            start = start === undefined ? 0 : nativeMax(toInteger(start), 0);
            return rest(function(args) {
                var array = args[start], otherArgs = castSlice(args, 0, start);
                if (array) {
                    arrayPush(otherArgs, array);
                }
                return apply(func, this, otherArgs);
            });
        }
        function throttle(func, wait, options) {
            var leading = true, trailing = true;
            if (typeof func != "function") {
                throw new TypeError(FUNC_ERROR_TEXT);
            }
            if (isObject(options)) {
                leading = "leading" in options ? !!options.leading : leading;
                trailing = "trailing" in options ? !!options.trailing : trailing;
            }
            return debounce(func, wait, {
                leading: leading,
                maxWait: wait,
                trailing: trailing
            });
        }
        function unary(func) {
            return ary(func, 1);
        }
        function wrap(value, wrapper) {
            wrapper = wrapper == null ? identity : wrapper;
            return partial(wrapper, value);
        }
        function castArray() {
            if (!arguments.length) {
                return [];
            }
            var value = arguments[0];
            return isArray(value) ? value : [ value ];
        }
        function clone(value) {
            return baseClone(value, false, true);
        }
        function cloneWith(value, customizer) {
            return baseClone(value, false, true, customizer);
        }
        function cloneDeep(value) {
            return baseClone(value, true, true);
        }
        function cloneDeepWith(value, customizer) {
            return baseClone(value, true, true, customizer);
        }
        function eq(value, other) {
            return value === other || value !== value && other !== other;
        }
        var gt = createRelationalOperation(baseGt);
        var gte = createRelationalOperation(function(value, other) {
            return value >= other;
        });
        function isArguments(value) {
            return isArrayLikeObject(value) && hasOwnProperty.call(value, "callee") && (!propertyIsEnumerable.call(value, "callee") || objectToString.call(value) == argsTag);
        }
        var isArray = Array.isArray;
        function isArrayBuffer(value) {
            return isObjectLike(value) && objectToString.call(value) == arrayBufferTag;
        }
        function isArrayLike(value) {
            return value != null && isLength(getLength(value)) && !isFunction(value);
        }
        function isArrayLikeObject(value) {
            return isObjectLike(value) && isArrayLike(value);
        }
        function isBoolean(value) {
            return value === true || value === false || isObjectLike(value) && objectToString.call(value) == boolTag;
        }
        var isBuffer = !Buffer ? constant(false) : function(value) {
            return value instanceof Buffer;
        };
        function isDate(value) {
            return isObjectLike(value) && objectToString.call(value) == dateTag;
        }
        function isElement(value) {
            return !!value && value.nodeType === 1 && isObjectLike(value) && !isPlainObject(value);
        }
        function isEmpty(value) {
            if (isArrayLike(value) && (isArray(value) || isString(value) || isFunction(value.splice) || isArguments(value) || isBuffer(value))) {
                return !value.length;
            }
            if (isObjectLike(value)) {
                var tag = getTag(value);
                if (tag == mapTag || tag == setTag) {
                    return !value.size;
                }
            }
            for (var key in value) {
                if (hasOwnProperty.call(value, key)) {
                    return false;
                }
            }
            return !(nonEnumShadows && keys(value).length);
        }
        function isEqual(value, other) {
            return baseIsEqual(value, other);
        }
        function isEqualWith(value, other, customizer) {
            customizer = typeof customizer == "function" ? customizer : undefined;
            var result = customizer ? customizer(value, other) : undefined;
            return result === undefined ? baseIsEqual(value, other, customizer) : !!result;
        }
        function isError(value) {
            if (!isObjectLike(value)) {
                return false;
            }
            return objectToString.call(value) == errorTag || typeof value.message == "string" && typeof value.name == "string";
        }
        function isFinite(value) {
            return typeof value == "number" && nativeIsFinite(value);
        }
        function isFunction(value) {
            var tag = isObject(value) ? objectToString.call(value) : "";
            return tag == funcTag || tag == genTag;
        }
        function isInteger(value) {
            return typeof value == "number" && value == toInteger(value);
        }
        function isLength(value) {
            return typeof value == "number" && value > -1 && value % 1 == 0 && value <= MAX_SAFE_INTEGER;
        }
        function isObject(value) {
            var type = typeof value;
            return !!value && (type == "object" || type == "function");
        }
        function isObjectLike(value) {
            return !!value && typeof value == "object";
        }
        function isMap(value) {
            return isObjectLike(value) && getTag(value) == mapTag;
        }
        function isMatch(object, source) {
            return object === source || baseIsMatch(object, source, getMatchData(source));
        }
        function isMatchWith(object, source, customizer) {
            customizer = typeof customizer == "function" ? customizer : undefined;
            return baseIsMatch(object, source, getMatchData(source), customizer);
        }
        function isNaN(value) {
            return isNumber(value) && value != +value;
        }
        function isNative(value) {
            if (!isObject(value)) {
                return false;
            }
            var pattern = isFunction(value) || isHostObject(value) ? reIsNative : reIsHostCtor;
            return pattern.test(toSource(value));
        }
        function isNull(value) {
            return value === null;
        }
        function isNil(value) {
            return value == null;
        }
        function isNumber(value) {
            return typeof value == "number" || isObjectLike(value) && objectToString.call(value) == numberTag;
        }
        function isPlainObject(value) {
            if (!isObjectLike(value) || objectToString.call(value) != objectTag || isHostObject(value)) {
                return false;
            }
            var proto = getPrototype(value);
            if (proto === null) {
                return true;
            }
            var Ctor = hasOwnProperty.call(proto, "constructor") && proto.constructor;
            return typeof Ctor == "function" && Ctor instanceof Ctor && funcToString.call(Ctor) == objectCtorString;
        }
        function isRegExp(value) {
            return isObject(value) && objectToString.call(value) == regexpTag;
        }
        function isSafeInteger(value) {
            return isInteger(value) && value >= -MAX_SAFE_INTEGER && value <= MAX_SAFE_INTEGER;
        }
        function isSet(value) {
            return isObjectLike(value) && getTag(value) == setTag;
        }
        function isString(value) {
            return typeof value == "string" || !isArray(value) && isObjectLike(value) && objectToString.call(value) == stringTag;
        }
        function isSymbol(value) {
            return typeof value == "symbol" || isObjectLike(value) && objectToString.call(value) == symbolTag;
        }
        function isTypedArray(value) {
            return isObjectLike(value) && isLength(value.length) && !!typedArrayTags[objectToString.call(value)];
        }
        function isUndefined(value) {
            return value === undefined;
        }
        function isWeakMap(value) {
            return isObjectLike(value) && getTag(value) == weakMapTag;
        }
        function isWeakSet(value) {
            return isObjectLike(value) && objectToString.call(value) == weakSetTag;
        }
        var lt = createRelationalOperation(baseLt);
        var lte = createRelationalOperation(function(value, other) {
            return value <= other;
        });
        function toArray(value) {
            if (!value) {
                return [];
            }
            if (isArrayLike(value)) {
                return isString(value) ? stringToArray(value) : copyArray(value);
            }
            if (iteratorSymbol && value[iteratorSymbol]) {
                return iteratorToArray(value[iteratorSymbol]());
            }
            var tag = getTag(value), func = tag == mapTag ? mapToArray : tag == setTag ? setToArray : values;
            return func(value);
        }
        function toInteger(value) {
            if (!value) {
                return value === 0 ? value : 0;
            }
            value = toNumber(value);
            if (value === INFINITY || value === -INFINITY) {
                var sign = value < 0 ? -1 : 1;
                return sign * MAX_INTEGER;
            }
            var remainder = value % 1;
            return value === value ? remainder ? value - remainder : value : 0;
        }
        function toLength(value) {
            return value ? baseClamp(toInteger(value), 0, MAX_ARRAY_LENGTH) : 0;
        }
        function toNumber(value) {
            if (typeof value == "number") {
                return value;
            }
            if (isSymbol(value)) {
                return NAN;
            }
            if (isObject(value)) {
                var other = isFunction(value.valueOf) ? value.valueOf() : value;
                value = isObject(other) ? other + "" : other;
            }
            if (typeof value != "string") {
                return value === 0 ? value : +value;
            }
            value = value.replace(reTrim, "");
            var isBinary = reIsBinary.test(value);
            return isBinary || reIsOctal.test(value) ? freeParseInt(value.slice(2), isBinary ? 2 : 8) : reIsBadHex.test(value) ? NAN : +value;
        }
        function toPlainObject(value) {
            return copyObject(value, keysIn(value));
        }
        function toSafeInteger(value) {
            return baseClamp(toInteger(value), -MAX_SAFE_INTEGER, MAX_SAFE_INTEGER);
        }
        function toString(value) {
            return value == null ? "" : baseToString(value);
        }
        var assign = createAssigner(function(object, source) {
            if (nonEnumShadows || isPrototype(source) || isArrayLike(source)) {
                copyObject(source, keys(source), object);
                return;
            }
            for (var key in source) {
                if (hasOwnProperty.call(source, key)) {
                    assignValue(object, key, source[key]);
                }
            }
        });
        var assignIn = createAssigner(function(object, source) {
            if (nonEnumShadows || isPrototype(source) || isArrayLike(source)) {
                copyObject(source, keysIn(source), object);
                return;
            }
            for (var key in source) {
                assignValue(object, key, source[key]);
            }
        });
        var assignInWith = createAssigner(function(object, source, srcIndex, customizer) {
            copyObject(source, keysIn(source), object, customizer);
        });
        var assignWith = createAssigner(function(object, source, srcIndex, customizer) {
            copyObject(source, keys(source), object, customizer);
        });
        var at = rest(function(object, paths) {
            return baseAt(object, baseFlatten(paths, 1));
        });
        function create(prototype, properties) {
            var result = baseCreate(prototype);
            return properties ? baseAssign(result, properties) : result;
        }
        var defaults = rest(function(args) {
            args.push(undefined, assignInDefaults);
            return apply(assignInWith, undefined, args);
        });
        var defaultsDeep = rest(function(args) {
            args.push(undefined, mergeDefaults);
            return apply(mergeWith, undefined, args);
        });
        function findKey(object, predicate) {
            return baseFind(object, getIteratee(predicate, 3), baseForOwn, true);
        }
        function findLastKey(object, predicate) {
            return baseFind(object, getIteratee(predicate, 3), baseForOwnRight, true);
        }
        function forIn(object, iteratee) {
            return object == null ? object : baseFor(object, getIteratee(iteratee), keysIn);
        }
        function forInRight(object, iteratee) {
            return object == null ? object : baseForRight(object, getIteratee(iteratee), keysIn);
        }
        function forOwn(object, iteratee) {
            return object && baseForOwn(object, getIteratee(iteratee));
        }
        function forOwnRight(object, iteratee) {
            return object && baseForOwnRight(object, getIteratee(iteratee));
        }
        function functions(object) {
            return object == null ? [] : baseFunctions(object, keys(object));
        }
        function functionsIn(object) {
            return object == null ? [] : baseFunctions(object, keysIn(object));
        }
        function get(object, path, defaultValue) {
            var result = object == null ? undefined : baseGet(object, path);
            return result === undefined ? defaultValue : result;
        }
        function has(object, path) {
            return object != null && hasPath(object, path, baseHas);
        }
        function hasIn(object, path) {
            return object != null && hasPath(object, path, baseHasIn);
        }
        var invert = createInverter(function(result, value, key) {
            result[value] = key;
        }, constant(identity));
        var invertBy = createInverter(function(result, value, key) {
            if (hasOwnProperty.call(result, value)) {
                result[value].push(key);
            } else {
                result[value] = [ key ];
            }
        }, getIteratee);
        var invoke = rest(baseInvoke);
        function keys(object) {
            var isProto = isPrototype(object);
            if (!(isProto || isArrayLike(object))) {
                return baseKeys(object);
            }
            var indexes = indexKeys(object), skipIndexes = !!indexes, result = indexes || [], length = result.length;
            for (var key in object) {
                if (baseHas(object, key) && !(skipIndexes && (key == "length" || isIndex(key, length))) && !(isProto && key == "constructor")) {
                    result.push(key);
                }
            }
            return result;
        }
        function keysIn(object) {
            var index = -1, isProto = isPrototype(object), props = baseKeysIn(object), propsLength = props.length, indexes = indexKeys(object), skipIndexes = !!indexes, result = indexes || [], length = result.length;
            while (++index < propsLength) {
                var key = props[index];
                if (!(skipIndexes && (key == "length" || isIndex(key, length))) && !(key == "constructor" && (isProto || !hasOwnProperty.call(object, key)))) {
                    result.push(key);
                }
            }
            return result;
        }
        function mapKeys(object, iteratee) {
            var result = {};
            iteratee = getIteratee(iteratee, 3);
            baseForOwn(object, function(value, key, object) {
                result[iteratee(value, key, object)] = value;
            });
            return result;
        }
        function mapValues(object, iteratee) {
            var result = {};
            iteratee = getIteratee(iteratee, 3);
            baseForOwn(object, function(value, key, object) {
                result[key] = iteratee(value, key, object);
            });
            return result;
        }
        var merge = createAssigner(function(object, source, srcIndex) {
            baseMerge(object, source, srcIndex);
        });
        var mergeWith = createAssigner(function(object, source, srcIndex, customizer) {
            baseMerge(object, source, srcIndex, customizer);
        });
        var omit = rest(function(object, props) {
            if (object == null) {
                return {};
            }
            props = arrayMap(baseFlatten(props, 1), toKey);
            return basePick(object, baseDifference(getAllKeysIn(object), props));
        });
        function omitBy(object, predicate) {
            predicate = getIteratee(predicate);
            return basePickBy(object, function(value, key) {
                return !predicate(value, key);
            });
        }
        var pick = rest(function(object, props) {
            return object == null ? {} : basePick(object, arrayMap(baseFlatten(props, 1), toKey));
        });
        function pickBy(object, predicate) {
            return object == null ? {} : basePickBy(object, getIteratee(predicate));
        }
        function result(object, path, defaultValue) {
            path = isKey(path, object) ? [ path ] : castPath(path);
            var index = -1, length = path.length;
            if (!length) {
                object = undefined;
                length = 1;
            }
            while (++index < length) {
                var value = object == null ? undefined : object[toKey(path[index])];
                if (value === undefined) {
                    index = length;
                    value = defaultValue;
                }
                object = isFunction(value) ? value.call(object) : value;
            }
            return object;
        }
        function set(object, path, value) {
            return object == null ? object : baseSet(object, path, value);
        }
        function setWith(object, path, value, customizer) {
            customizer = typeof customizer == "function" ? customizer : undefined;
            return object == null ? object : baseSet(object, path, value, customizer);
        }
        function toPairs(object) {
            return baseToPairs(object, keys(object));
        }
        function toPairsIn(object) {
            return baseToPairs(object, keysIn(object));
        }
        function transform(object, iteratee, accumulator) {
            var isArr = isArray(object) || isTypedArray(object);
            iteratee = getIteratee(iteratee, 4);
            if (accumulator == null) {
                if (isArr || isObject(object)) {
                    var Ctor = object.constructor;
                    if (isArr) {
                        accumulator = isArray(object) ? new Ctor() : [];
                    } else {
                        accumulator = isFunction(Ctor) ? baseCreate(getPrototype(object)) : {};
                    }
                } else {
                    accumulator = {};
                }
            }
            (isArr ? arrayEach : baseForOwn)(object, function(value, index, object) {
                return iteratee(accumulator, value, index, object);
            });
            return accumulator;
        }
        function unset(object, path) {
            return object == null ? true : baseUnset(object, path);
        }
        function update(object, path, updater) {
            return object == null ? object : baseUpdate(object, path, castFunction(updater));
        }
        function updateWith(object, path, updater, customizer) {
            customizer = typeof customizer == "function" ? customizer : undefined;
            return object == null ? object : baseUpdate(object, path, castFunction(updater), customizer);
        }
        function values(object) {
            return object ? baseValues(object, keys(object)) : [];
        }
        function valuesIn(object) {
            return object == null ? [] : baseValues(object, keysIn(object));
        }
        function clamp(number, lower, upper) {
            if (upper === undefined) {
                upper = lower;
                lower = undefined;
            }
            if (upper !== undefined) {
                upper = toNumber(upper);
                upper = upper === upper ? upper : 0;
            }
            if (lower !== undefined) {
                lower = toNumber(lower);
                lower = lower === lower ? lower : 0;
            }
            return baseClamp(toNumber(number), lower, upper);
        }
        function inRange(number, start, end) {
            start = toNumber(start) || 0;
            if (end === undefined) {
                end = start;
                start = 0;
            } else {
                end = toNumber(end) || 0;
            }
            number = toNumber(number);
            return baseInRange(number, start, end);
        }
        function random(lower, upper, floating) {
            if (floating && typeof floating != "boolean" && isIterateeCall(lower, upper, floating)) {
                upper = floating = undefined;
            }
            if (floating === undefined) {
                if (typeof upper == "boolean") {
                    floating = upper;
                    upper = undefined;
                } else if (typeof lower == "boolean") {
                    floating = lower;
                    lower = undefined;
                }
            }
            if (lower === undefined && upper === undefined) {
                lower = 0;
                upper = 1;
            } else {
                lower = toNumber(lower) || 0;
                if (upper === undefined) {
                    upper = lower;
                    lower = 0;
                } else {
                    upper = toNumber(upper) || 0;
                }
            }
            if (lower > upper) {
                var temp = lower;
                lower = upper;
                upper = temp;
            }
            if (floating || lower % 1 || upper % 1) {
                var rand = nativeRandom();
                return nativeMin(lower + rand * (upper - lower + freeParseFloat("1e-" + ((rand + "").length - 1))), upper);
            }
            return baseRandom(lower, upper);
        }
        var camelCase = createCompounder(function(result, word, index) {
            word = word.toLowerCase();
            return result + (index ? capitalize(word) : word);
        });
        function capitalize(string) {
            return upperFirst(toString(string).toLowerCase());
        }
        function deburr(string) {
            string = toString(string);
            return string && string.replace(reLatin1, deburrLetter).replace(reComboMark, "");
        }
        function endsWith(string, target, position) {
            string = toString(string);
            target = baseToString(target);
            var length = string.length;
            position = position === undefined ? length : baseClamp(toInteger(position), 0, length);
            position -= target.length;
            return position >= 0 && string.indexOf(target, position) == position;
        }
        function escape(string) {
            string = toString(string);
            return string && reHasUnescapedHtml.test(string) ? string.replace(reUnescapedHtml, escapeHtmlChar) : string;
        }
        function escapeRegExp(string) {
            string = toString(string);
            return string && reHasRegExpChar.test(string) ? string.replace(reRegExpChar, "\\$&") : string;
        }
        var kebabCase = createCompounder(function(result, word, index) {
            return result + (index ? "-" : "") + word.toLowerCase();
        });
        var lowerCase = createCompounder(function(result, word, index) {
            return result + (index ? " " : "") + word.toLowerCase();
        });
        var lowerFirst = createCaseFirst("toLowerCase");
        function pad(string, length, chars) {
            string = toString(string);
            length = toInteger(length);
            var strLength = length ? stringSize(string) : 0;
            if (!length || strLength >= length) {
                return string;
            }
            var mid = (length - strLength) / 2;
            return createPadding(nativeFloor(mid), chars) + string + createPadding(nativeCeil(mid), chars);
        }
        function padEnd(string, length, chars) {
            string = toString(string);
            length = toInteger(length);
            var strLength = length ? stringSize(string) : 0;
            return length && strLength < length ? string + createPadding(length - strLength, chars) : string;
        }
        function padStart(string, length, chars) {
            string = toString(string);
            length = toInteger(length);
            var strLength = length ? stringSize(string) : 0;
            return length && strLength < length ? createPadding(length - strLength, chars) + string : string;
        }
        function parseInt(string, radix, guard) {
            if (guard || radix == null) {
                radix = 0;
            } else if (radix) {
                radix = +radix;
            }
            string = toString(string).replace(reTrim, "");
            return nativeParseInt(string, radix || (reHasHexPrefix.test(string) ? 16 : 10));
        }
        function repeat(string, n, guard) {
            if (guard ? isIterateeCall(string, n, guard) : n === undefined) {
                n = 1;
            } else {
                n = toInteger(n);
            }
            return baseRepeat(toString(string), n);
        }
        function replace() {
            var args = arguments, string = toString(args[0]);
            return args.length < 3 ? string : nativeReplace.call(string, args[1], args[2]);
        }
        var snakeCase = createCompounder(function(result, word, index) {
            return result + (index ? "_" : "") + word.toLowerCase();
        });
        function split(string, separator, limit) {
            if (limit && typeof limit != "number" && isIterateeCall(string, separator, limit)) {
                separator = limit = undefined;
            }
            limit = limit === undefined ? MAX_ARRAY_LENGTH : limit >>> 0;
            if (!limit) {
                return [];
            }
            string = toString(string);
            if (string && (typeof separator == "string" || separator != null && !isRegExp(separator))) {
                separator = baseToString(separator);
                if (separator == "" && reHasComplexSymbol.test(string)) {
                    return castSlice(stringToArray(string), 0, limit);
                }
            }
            return nativeSplit.call(string, separator, limit);
        }
        var startCase = createCompounder(function(result, word, index) {
            return result + (index ? " " : "") + upperFirst(word);
        });
        function startsWith(string, target, position) {
            string = toString(string);
            position = baseClamp(toInteger(position), 0, string.length);
            return string.lastIndexOf(baseToString(target), position) == position;
        }
        function template(string, options, guard) {
            var settings = lodash.templateSettings;
            if (guard && isIterateeCall(string, options, guard)) {
                options = undefined;
            }
            string = toString(string);
            options = assignInWith({}, options, settings, assignInDefaults);
            var imports = assignInWith({}, options.imports, settings.imports, assignInDefaults), importsKeys = keys(imports), importsValues = baseValues(imports, importsKeys);
            var isEscaping, isEvaluating, index = 0, interpolate = options.interpolate || reNoMatch, source = "__p += '";
            var reDelimiters = RegExp((options.escape || reNoMatch).source + "|" + interpolate.source + "|" + (interpolate === reInterpolate ? reEsTemplate : reNoMatch).source + "|" + (options.evaluate || reNoMatch).source + "|$", "g");
            var sourceURL = "//# sourceURL=" + ("sourceURL" in options ? options.sourceURL : "lodash.templateSources[" + ++templateCounter + "]") + "\n";
            string.replace(reDelimiters, function(match, escapeValue, interpolateValue, esTemplateValue, evaluateValue, offset) {
                interpolateValue || (interpolateValue = esTemplateValue);
                source += string.slice(index, offset).replace(reUnescapedString, escapeStringChar);
                if (escapeValue) {
                    isEscaping = true;
                    source += "' +\n__e(" + escapeValue + ") +\n'";
                }
                if (evaluateValue) {
                    isEvaluating = true;
                    source += "';\n" + evaluateValue + ";\n__p += '";
                }
                if (interpolateValue) {
                    source += "' +\n((__t = (" + interpolateValue + ")) == null ? '' : __t) +\n'";
                }
                index = offset + match.length;
                return match;
            });
            source += "';\n";
            var variable = options.variable;
            if (!variable) {
                source = "with (obj) {\n" + source + "\n}\n";
            }
            source = (isEvaluating ? source.replace(reEmptyStringLeading, "") : source).replace(reEmptyStringMiddle, "$1").replace(reEmptyStringTrailing, "$1;");
            source = "function(" + (variable || "obj") + ") {\n" + (variable ? "" : "obj || (obj = {});\n") + "var __t, __p = ''" + (isEscaping ? ", __e = _.escape" : "") + (isEvaluating ? ", __j = Array.prototype.join;\n" + "function print() { __p += __j.call(arguments, '') }\n" : ";\n") + source + "return __p\n}";
            var result = attempt(function() {
                return Function(importsKeys, sourceURL + "return " + source).apply(undefined, importsValues);
            });
            result.source = source;
            if (isError(result)) {
                throw result;
            }
            return result;
        }
        function toLower(value) {
            return toString(value).toLowerCase();
        }
        function toUpper(value) {
            return toString(value).toUpperCase();
        }
        function trim(string, chars, guard) {
            string = toString(string);
            if (string && (guard || chars === undefined)) {
                return string.replace(reTrim, "");
            }
            if (!string || !(chars = baseToString(chars))) {
                return string;
            }
            var strSymbols = stringToArray(string), chrSymbols = stringToArray(chars), start = charsStartIndex(strSymbols, chrSymbols), end = charsEndIndex(strSymbols, chrSymbols) + 1;
            return castSlice(strSymbols, start, end).join("");
        }
        function trimEnd(string, chars, guard) {
            string = toString(string);
            if (string && (guard || chars === undefined)) {
                return string.replace(reTrimEnd, "");
            }
            if (!string || !(chars = baseToString(chars))) {
                return string;
            }
            var strSymbols = stringToArray(string), end = charsEndIndex(strSymbols, stringToArray(chars)) + 1;
            return castSlice(strSymbols, 0, end).join("");
        }
        function trimStart(string, chars, guard) {
            string = toString(string);
            if (string && (guard || chars === undefined)) {
                return string.replace(reTrimStart, "");
            }
            if (!string || !(chars = baseToString(chars))) {
                return string;
            }
            var strSymbols = stringToArray(string), start = charsStartIndex(strSymbols, stringToArray(chars));
            return castSlice(strSymbols, start).join("");
        }
        function truncate(string, options) {
            var length = DEFAULT_TRUNC_LENGTH, omission = DEFAULT_TRUNC_OMISSION;
            if (isObject(options)) {
                var separator = "separator" in options ? options.separator : separator;
                length = "length" in options ? toInteger(options.length) : length;
                omission = "omission" in options ? baseToString(options.omission) : omission;
            }
            string = toString(string);
            var strLength = string.length;
            if (reHasComplexSymbol.test(string)) {
                var strSymbols = stringToArray(string);
                strLength = strSymbols.length;
            }
            if (length >= strLength) {
                return string;
            }
            var end = length - stringSize(omission);
            if (end < 1) {
                return omission;
            }
            var result = strSymbols ? castSlice(strSymbols, 0, end).join("") : string.slice(0, end);
            if (separator === undefined) {
                return result + omission;
            }
            if (strSymbols) {
                end += result.length - end;
            }
            if (isRegExp(separator)) {
                if (string.slice(end).search(separator)) {
                    var match, substring = result;
                    if (!separator.global) {
                        separator = RegExp(separator.source, toString(reFlags.exec(separator)) + "g");
                    }
                    separator.lastIndex = 0;
                    while (match = separator.exec(substring)) {
                        var newEnd = match.index;
                    }
                    result = result.slice(0, newEnd === undefined ? end : newEnd);
                }
            } else if (string.indexOf(baseToString(separator), end) != end) {
                var index = result.lastIndexOf(separator);
                if (index > -1) {
                    result = result.slice(0, index);
                }
            }
            return result + omission;
        }
        function unescape(string) {
            string = toString(string);
            return string && reHasEscapedHtml.test(string) ? string.replace(reEscapedHtml, unescapeHtmlChar) : string;
        }
        var upperCase = createCompounder(function(result, word, index) {
            return result + (index ? " " : "") + word.toUpperCase();
        });
        var upperFirst = createCaseFirst("toUpperCase");
        function words(string, pattern, guard) {
            string = toString(string);
            pattern = guard ? undefined : pattern;
            if (pattern === undefined) {
                pattern = reHasComplexWord.test(string) ? reComplexWord : reBasicWord;
            }
            return string.match(pattern) || [];
        }
        var attempt = rest(function(func, args) {
            try {
                return apply(func, undefined, args);
            } catch (e) {
                return isError(e) ? e : new Error(e);
            }
        });
        var bindAll = rest(function(object, methodNames) {
            arrayEach(baseFlatten(methodNames, 1), function(key) {
                key = toKey(key);
                object[key] = bind(object[key], object);
            });
            return object;
        });
        function cond(pairs) {
            var length = pairs ? pairs.length : 0, toIteratee = getIteratee();
            pairs = !length ? [] : arrayMap(pairs, function(pair) {
                if (typeof pair[1] != "function") {
                    throw new TypeError(FUNC_ERROR_TEXT);
                }
                return [ toIteratee(pair[0]), pair[1] ];
            });
            return rest(function(args) {
                var index = -1;
                while (++index < length) {
                    var pair = pairs[index];
                    if (apply(pair[0], this, args)) {
                        return apply(pair[1], this, args);
                    }
                }
            });
        }
        function conforms(source) {
            return baseConforms(baseClone(source, true));
        }
        function constant(value) {
            return function() {
                return value;
            };
        }
        var flow = createFlow();
        var flowRight = createFlow(true);
        function identity(value) {
            return value;
        }
        function iteratee(func) {
            return baseIteratee(typeof func == "function" ? func : baseClone(func, true));
        }
        function matches(source) {
            return baseMatches(baseClone(source, true));
        }
        function matchesProperty(path, srcValue) {
            return baseMatchesProperty(path, baseClone(srcValue, true));
        }
        var method = rest(function(path, args) {
            return function(object) {
                return baseInvoke(object, path, args);
            };
        });
        var methodOf = rest(function(object, args) {
            return function(path) {
                return baseInvoke(object, path, args);
            };
        });
        function mixin(object, source, options) {
            var props = keys(source), methodNames = baseFunctions(source, props);
            if (options == null && !(isObject(source) && (methodNames.length || !props.length))) {
                options = source;
                source = object;
                object = this;
                methodNames = baseFunctions(source, keys(source));
            }
            var chain = !(isObject(options) && "chain" in options) || !!options.chain, isFunc = isFunction(object);
            arrayEach(methodNames, function(methodName) {
                var func = source[methodName];
                object[methodName] = func;
                if (isFunc) {
                    object.prototype[methodName] = function() {
                        var chainAll = this.__chain__;
                        if (chain || chainAll) {
                            var result = object(this.__wrapped__), actions = result.__actions__ = copyArray(this.__actions__);
                            actions.push({
                                func: func,
                                args: arguments,
                                thisArg: object
                            });
                            result.__chain__ = chainAll;
                            return result;
                        }
                        return func.apply(object, arrayPush([ this.value() ], arguments));
                    };
                }
            });
            return object;
        }
        function noConflict() {
            if (root._ === this) {
                root._ = oldDash;
            }
            return this;
        }
        function noop() {}
        function nthArg(n) {
            n = toInteger(n);
            return rest(function(args) {
                return baseNth(args, n);
            });
        }
        var over = createOver(arrayMap);
        var overEvery = createOver(arrayEvery);
        var overSome = createOver(arraySome);
        function property(path) {
            return isKey(path) ? baseProperty(toKey(path)) : basePropertyDeep(path);
        }
        function propertyOf(object) {
            return function(path) {
                return object == null ? undefined : baseGet(object, path);
            };
        }
        var range = createRange();
        var rangeRight = createRange(true);
        function times(n, iteratee) {
            n = toInteger(n);
            if (n < 1 || n > MAX_SAFE_INTEGER) {
                return [];
            }
            var index = MAX_ARRAY_LENGTH, length = nativeMin(n, MAX_ARRAY_LENGTH);
            iteratee = getIteratee(iteratee);
            n -= MAX_ARRAY_LENGTH;
            var result = baseTimes(length, iteratee);
            while (++index < n) {
                iteratee(index);
            }
            return result;
        }
        function toPath(value) {
            if (isArray(value)) {
                return arrayMap(value, toKey);
            }
            return isSymbol(value) ? [ value ] : copyArray(stringToPath(value));
        }
        function uniqueId(prefix) {
            var id = ++idCounter;
            return toString(prefix) + id;
        }
        var add = createMathOperation(function(augend, addend) {
            return augend + addend;
        });
        var ceil = createRound("ceil");
        var divide = createMathOperation(function(dividend, divisor) {
            return dividend / divisor;
        });
        var floor = createRound("floor");
        function max(array) {
            return array && array.length ? baseExtremum(array, identity, baseGt) : undefined;
        }
        function maxBy(array, iteratee) {
            return array && array.length ? baseExtremum(array, getIteratee(iteratee), baseGt) : undefined;
        }
        function mean(array) {
            return baseMean(array, identity);
        }
        function meanBy(array, iteratee) {
            return baseMean(array, getIteratee(iteratee));
        }
        function min(array) {
            return array && array.length ? baseExtremum(array, identity, baseLt) : undefined;
        }
        function minBy(array, iteratee) {
            return array && array.length ? baseExtremum(array, getIteratee(iteratee), baseLt) : undefined;
        }
        var multiply = createMathOperation(function(multiplier, multiplicand) {
            return multiplier * multiplicand;
        });
        var round = createRound("round");
        var subtract = createMathOperation(function(minuend, subtrahend) {
            return minuend - subtrahend;
        });
        function sum(array) {
            return array && array.length ? baseSum(array, identity) : 0;
        }
        function sumBy(array, iteratee) {
            return array && array.length ? baseSum(array, getIteratee(iteratee)) : 0;
        }
        lodash.after = after;
        lodash.ary = ary;
        lodash.assign = assign;
        lodash.assignIn = assignIn;
        lodash.assignInWith = assignInWith;
        lodash.assignWith = assignWith;
        lodash.at = at;
        lodash.before = before;
        lodash.bind = bind;
        lodash.bindAll = bindAll;
        lodash.bindKey = bindKey;
        lodash.castArray = castArray;
        lodash.chain = chain;
        lodash.chunk = chunk;
        lodash.compact = compact;
        lodash.concat = concat;
        lodash.cond = cond;
        lodash.conforms = conforms;
        lodash.constant = constant;
        lodash.countBy = countBy;
        lodash.create = create;
        lodash.curry = curry;
        lodash.curryRight = curryRight;
        lodash.debounce = debounce;
        lodash.defaults = defaults;
        lodash.defaultsDeep = defaultsDeep;
        lodash.defer = defer;
        lodash.delay = delay;
        lodash.difference = difference;
        lodash.differenceBy = differenceBy;
        lodash.differenceWith = differenceWith;
        lodash.drop = drop;
        lodash.dropRight = dropRight;
        lodash.dropRightWhile = dropRightWhile;
        lodash.dropWhile = dropWhile;
        lodash.fill = fill;
        lodash.filter = filter;
        lodash.flatMap = flatMap;
        lodash.flatMapDeep = flatMapDeep;
        lodash.flatMapDepth = flatMapDepth;
        lodash.flatten = flatten;
        lodash.flattenDeep = flattenDeep;
        lodash.flattenDepth = flattenDepth;
        lodash.flip = flip;
        lodash.flow = flow;
        lodash.flowRight = flowRight;
        lodash.fromPairs = fromPairs;
        lodash.functions = functions;
        lodash.functionsIn = functionsIn;
        lodash.groupBy = groupBy;
        lodash.initial = initial;
        lodash.intersection = intersection;
        lodash.intersectionBy = intersectionBy;
        lodash.intersectionWith = intersectionWith;
        lodash.invert = invert;
        lodash.invertBy = invertBy;
        lodash.invokeMap = invokeMap;
        lodash.iteratee = iteratee;
        lodash.keyBy = keyBy;
        lodash.keys = keys;
        lodash.keysIn = keysIn;
        lodash.map = map;
        lodash.mapKeys = mapKeys;
        lodash.mapValues = mapValues;
        lodash.matches = matches;
        lodash.matchesProperty = matchesProperty;
        lodash.memoize = memoize;
        lodash.merge = merge;
        lodash.mergeWith = mergeWith;
        lodash.method = method;
        lodash.methodOf = methodOf;
        lodash.mixin = mixin;
        lodash.negate = negate;
        lodash.nthArg = nthArg;
        lodash.omit = omit;
        lodash.omitBy = omitBy;
        lodash.once = once;
        lodash.orderBy = orderBy;
        lodash.over = over;
        lodash.overArgs = overArgs;
        lodash.overEvery = overEvery;
        lodash.overSome = overSome;
        lodash.partial = partial;
        lodash.partialRight = partialRight;
        lodash.partition = partition;
        lodash.pick = pick;
        lodash.pickBy = pickBy;
        lodash.property = property;
        lodash.propertyOf = propertyOf;
        lodash.pull = pull;
        lodash.pullAll = pullAll;
        lodash.pullAllBy = pullAllBy;
        lodash.pullAllWith = pullAllWith;
        lodash.pullAt = pullAt;
        lodash.range = range;
        lodash.rangeRight = rangeRight;
        lodash.rearg = rearg;
        lodash.reject = reject;
        lodash.remove = remove;
        lodash.rest = rest;
        lodash.reverse = reverse;
        lodash.sampleSize = sampleSize;
        lodash.set = set;
        lodash.setWith = setWith;
        lodash.shuffle = shuffle;
        lodash.slice = slice;
        lodash.sortBy = sortBy;
        lodash.sortedUniq = sortedUniq;
        lodash.sortedUniqBy = sortedUniqBy;
        lodash.split = split;
        lodash.spread = spread;
        lodash.tail = tail;
        lodash.take = take;
        lodash.takeRight = takeRight;
        lodash.takeRightWhile = takeRightWhile;
        lodash.takeWhile = takeWhile;
        lodash.tap = tap;
        lodash.throttle = throttle;
        lodash.thru = thru;
        lodash.toArray = toArray;
        lodash.toPairs = toPairs;
        lodash.toPairsIn = toPairsIn;
        lodash.toPath = toPath;
        lodash.toPlainObject = toPlainObject;
        lodash.transform = transform;
        lodash.unary = unary;
        lodash.union = union;
        lodash.unionBy = unionBy;
        lodash.unionWith = unionWith;
        lodash.uniq = uniq;
        lodash.uniqBy = uniqBy;
        lodash.uniqWith = uniqWith;
        lodash.unset = unset;
        lodash.unzip = unzip;
        lodash.unzipWith = unzipWith;
        lodash.update = update;
        lodash.updateWith = updateWith;
        lodash.values = values;
        lodash.valuesIn = valuesIn;
        lodash.without = without;
        lodash.words = words;
        lodash.wrap = wrap;
        lodash.xor = xor;
        lodash.xorBy = xorBy;
        lodash.xorWith = xorWith;
        lodash.zip = zip;
        lodash.zipObject = zipObject;
        lodash.zipObjectDeep = zipObjectDeep;
        lodash.zipWith = zipWith;
        lodash.entries = toPairs;
        lodash.entriesIn = toPairsIn;
        lodash.extend = assignIn;
        lodash.extendWith = assignInWith;
        mixin(lodash, lodash);
        lodash.add = add;
        lodash.attempt = attempt;
        lodash.camelCase = camelCase;
        lodash.capitalize = capitalize;
        lodash.ceil = ceil;
        lodash.clamp = clamp;
        lodash.clone = clone;
        lodash.cloneDeep = cloneDeep;
        lodash.cloneDeepWith = cloneDeepWith;
        lodash.cloneWith = cloneWith;
        lodash.deburr = deburr;
        lodash.divide = divide;
        lodash.endsWith = endsWith;
        lodash.eq = eq;
        lodash.escape = escape;
        lodash.escapeRegExp = escapeRegExp;
        lodash.every = every;
        lodash.find = find;
        lodash.findIndex = findIndex;
        lodash.findKey = findKey;
        lodash.findLast = findLast;
        lodash.findLastIndex = findLastIndex;
        lodash.findLastKey = findLastKey;
        lodash.floor = floor;
        lodash.forEach = forEach;
        lodash.forEachRight = forEachRight;
        lodash.forIn = forIn;
        lodash.forInRight = forInRight;
        lodash.forOwn = forOwn;
        lodash.forOwnRight = forOwnRight;
        lodash.get = get;
        lodash.gt = gt;
        lodash.gte = gte;
        lodash.has = has;
        lodash.hasIn = hasIn;
        lodash.head = head;
        lodash.identity = identity;
        lodash.includes = includes;
        lodash.indexOf = indexOf;
        lodash.inRange = inRange;
        lodash.invoke = invoke;
        lodash.isArguments = isArguments;
        lodash.isArray = isArray;
        lodash.isArrayBuffer = isArrayBuffer;
        lodash.isArrayLike = isArrayLike;
        lodash.isArrayLikeObject = isArrayLikeObject;
        lodash.isBoolean = isBoolean;
        lodash.isBuffer = isBuffer;
        lodash.isDate = isDate;
        lodash.isElement = isElement;
        lodash.isEmpty = isEmpty;
        lodash.isEqual = isEqual;
        lodash.isEqualWith = isEqualWith;
        lodash.isError = isError;
        lodash.isFinite = isFinite;
        lodash.isFunction = isFunction;
        lodash.isInteger = isInteger;
        lodash.isLength = isLength;
        lodash.isMap = isMap;
        lodash.isMatch = isMatch;
        lodash.isMatchWith = isMatchWith;
        lodash.isNaN = isNaN;
        lodash.isNative = isNative;
        lodash.isNil = isNil;
        lodash.isNull = isNull;
        lodash.isNumber = isNumber;
        lodash.isObject = isObject;
        lodash.isObjectLike = isObjectLike;
        lodash.isPlainObject = isPlainObject;
        lodash.isRegExp = isRegExp;
        lodash.isSafeInteger = isSafeInteger;
        lodash.isSet = isSet;
        lodash.isString = isString;
        lodash.isSymbol = isSymbol;
        lodash.isTypedArray = isTypedArray;
        lodash.isUndefined = isUndefined;
        lodash.isWeakMap = isWeakMap;
        lodash.isWeakSet = isWeakSet;
        lodash.join = join;
        lodash.kebabCase = kebabCase;
        lodash.last = last;
        lodash.lastIndexOf = lastIndexOf;
        lodash.lowerCase = lowerCase;
        lodash.lowerFirst = lowerFirst;
        lodash.lt = lt;
        lodash.lte = lte;
        lodash.max = max;
        lodash.maxBy = maxBy;
        lodash.mean = mean;
        lodash.meanBy = meanBy;
        lodash.min = min;
        lodash.minBy = minBy;
        lodash.multiply = multiply;
        lodash.nth = nth;
        lodash.noConflict = noConflict;
        lodash.noop = noop;
        lodash.now = now;
        lodash.pad = pad;
        lodash.padEnd = padEnd;
        lodash.padStart = padStart;
        lodash.parseInt = parseInt;
        lodash.random = random;
        lodash.reduce = reduce;
        lodash.reduceRight = reduceRight;
        lodash.repeat = repeat;
        lodash.replace = replace;
        lodash.result = result;
        lodash.round = round;
        lodash.runInContext = runInContext;
        lodash.sample = sample;
        lodash.size = size;
        lodash.snakeCase = snakeCase;
        lodash.some = some;
        lodash.sortedIndex = sortedIndex;
        lodash.sortedIndexBy = sortedIndexBy;
        lodash.sortedIndexOf = sortedIndexOf;
        lodash.sortedLastIndex = sortedLastIndex;
        lodash.sortedLastIndexBy = sortedLastIndexBy;
        lodash.sortedLastIndexOf = sortedLastIndexOf;
        lodash.startCase = startCase;
        lodash.startsWith = startsWith;
        lodash.subtract = subtract;
        lodash.sum = sum;
        lodash.sumBy = sumBy;
        lodash.template = template;
        lodash.times = times;
        lodash.toInteger = toInteger;
        lodash.toLength = toLength;
        lodash.toLower = toLower;
        lodash.toNumber = toNumber;
        lodash.toSafeInteger = toSafeInteger;
        lodash.toString = toString;
        lodash.toUpper = toUpper;
        lodash.trim = trim;
        lodash.trimEnd = trimEnd;
        lodash.trimStart = trimStart;
        lodash.truncate = truncate;
        lodash.unescape = unescape;
        lodash.uniqueId = uniqueId;
        lodash.upperCase = upperCase;
        lodash.upperFirst = upperFirst;
        lodash.each = forEach;
        lodash.eachRight = forEachRight;
        lodash.first = head;
        mixin(lodash, function() {
            var source = {};
            baseForOwn(lodash, function(func, methodName) {
                if (!hasOwnProperty.call(lodash.prototype, methodName)) {
                    source[methodName] = func;
                }
            });
            return source;
        }(), {
            chain: false
        });
        lodash.VERSION = VERSION;
        arrayEach([ "bind", "bindKey", "curry", "curryRight", "partial", "partialRight" ], function(methodName) {
            lodash[methodName].placeholder = lodash;
        });
        arrayEach([ "drop", "take" ], function(methodName, index) {
            LazyWrapper.prototype[methodName] = function(n) {
                var filtered = this.__filtered__;
                if (filtered && !index) {
                    return new LazyWrapper(this);
                }
                n = n === undefined ? 1 : nativeMax(toInteger(n), 0);
                var result = this.clone();
                if (filtered) {
                    result.__takeCount__ = nativeMin(n, result.__takeCount__);
                } else {
                    result.__views__.push({
                        size: nativeMin(n, MAX_ARRAY_LENGTH),
                        type: methodName + (result.__dir__ < 0 ? "Right" : "")
                    });
                }
                return result;
            };
            LazyWrapper.prototype[methodName + "Right"] = function(n) {
                return this.reverse()[methodName](n).reverse();
            };
        });
        arrayEach([ "filter", "map", "takeWhile" ], function(methodName, index) {
            var type = index + 1, isFilter = type == LAZY_FILTER_FLAG || type == LAZY_WHILE_FLAG;
            LazyWrapper.prototype[methodName] = function(iteratee) {
                var result = this.clone();
                result.__iteratees__.push({
                    iteratee: getIteratee(iteratee, 3),
                    type: type
                });
                result.__filtered__ = result.__filtered__ || isFilter;
                return result;
            };
        });
        arrayEach([ "head", "last" ], function(methodName, index) {
            var takeName = "take" + (index ? "Right" : "");
            LazyWrapper.prototype[methodName] = function() {
                return this[takeName](1).value()[0];
            };
        });
        arrayEach([ "initial", "tail" ], function(methodName, index) {
            var dropName = "drop" + (index ? "" : "Right");
            LazyWrapper.prototype[methodName] = function() {
                return this.__filtered__ ? new LazyWrapper(this) : this[dropName](1);
            };
        });
        LazyWrapper.prototype.compact = function() {
            return this.filter(identity);
        };
        LazyWrapper.prototype.find = function(predicate) {
            return this.filter(predicate).head();
        };
        LazyWrapper.prototype.findLast = function(predicate) {
            return this.reverse().find(predicate);
        };
        LazyWrapper.prototype.invokeMap = rest(function(path, args) {
            if (typeof path == "function") {
                return new LazyWrapper(this);
            }
            return this.map(function(value) {
                return baseInvoke(value, path, args);
            });
        });
        LazyWrapper.prototype.reject = function(predicate) {
            predicate = getIteratee(predicate, 3);
            return this.filter(function(value) {
                return !predicate(value);
            });
        };
        LazyWrapper.prototype.slice = function(start, end) {
            start = toInteger(start);
            var result = this;
            if (result.__filtered__ && (start > 0 || end < 0)) {
                return new LazyWrapper(result);
            }
            if (start < 0) {
                result = result.takeRight(-start);
            } else if (start) {
                result = result.drop(start);
            }
            if (end !== undefined) {
                end = toInteger(end);
                result = end < 0 ? result.dropRight(-end) : result.take(end - start);
            }
            return result;
        };
        LazyWrapper.prototype.takeRightWhile = function(predicate) {
            return this.reverse().takeWhile(predicate).reverse();
        };
        LazyWrapper.prototype.toArray = function() {
            return this.take(MAX_ARRAY_LENGTH);
        };
        baseForOwn(LazyWrapper.prototype, function(func, methodName) {
            var checkIteratee = /^(?:filter|find|map|reject)|While$/.test(methodName), isTaker = /^(?:head|last)$/.test(methodName), lodashFunc = lodash[isTaker ? "take" + (methodName == "last" ? "Right" : "") : methodName], retUnwrapped = isTaker || /^find/.test(methodName);
            if (!lodashFunc) {
                return;
            }
            lodash.prototype[methodName] = function() {
                var value = this.__wrapped__, args = isTaker ? [ 1 ] : arguments, isLazy = value instanceof LazyWrapper, iteratee = args[0], useLazy = isLazy || isArray(value);
                var interceptor = function(value) {
                    var result = lodashFunc.apply(lodash, arrayPush([ value ], args));
                    return isTaker && chainAll ? result[0] : result;
                };
                if (useLazy && checkIteratee && typeof iteratee == "function" && iteratee.length != 1) {
                    isLazy = useLazy = false;
                }
                var chainAll = this.__chain__, isHybrid = !!this.__actions__.length, isUnwrapped = retUnwrapped && !chainAll, onlyLazy = isLazy && !isHybrid;
                if (!retUnwrapped && useLazy) {
                    value = onlyLazy ? value : new LazyWrapper(this);
                    var result = func.apply(value, args);
                    result.__actions__.push({
                        func: thru,
                        args: [ interceptor ],
                        thisArg: undefined
                    });
                    return new LodashWrapper(result, chainAll);
                }
                if (isUnwrapped && onlyLazy) {
                    return func.apply(this, args);
                }
                result = this.thru(interceptor);
                return isUnwrapped ? isTaker ? result.value()[0] : result.value() : result;
            };
        });
        arrayEach([ "pop", "push", "shift", "sort", "splice", "unshift" ], function(methodName) {
            var func = arrayProto[methodName], chainName = /^(?:push|sort|unshift)$/.test(methodName) ? "tap" : "thru", retUnwrapped = /^(?:pop|shift)$/.test(methodName);
            lodash.prototype[methodName] = function() {
                var args = arguments;
                if (retUnwrapped && !this.__chain__) {
                    var value = this.value();
                    return func.apply(isArray(value) ? value : [], args);
                }
                return this[chainName](function(value) {
                    return func.apply(isArray(value) ? value : [], args);
                });
            };
        });
        baseForOwn(LazyWrapper.prototype, function(func, methodName) {
            var lodashFunc = lodash[methodName];
            if (lodashFunc) {
                var key = lodashFunc.name + "", names = realNames[key] || (realNames[key] = []);
                names.push({
                    name: methodName,
                    func: lodashFunc
                });
            }
        });
        realNames[createHybridWrapper(undefined, BIND_KEY_FLAG).name] = [ {
            name: "wrapper",
            func: undefined
        } ];
        LazyWrapper.prototype.clone = lazyClone;
        LazyWrapper.prototype.reverse = lazyReverse;
        LazyWrapper.prototype.value = lazyValue;
        lodash.prototype.at = wrapperAt;
        lodash.prototype.chain = wrapperChain;
        lodash.prototype.commit = wrapperCommit;
        lodash.prototype.next = wrapperNext;
        lodash.prototype.plant = wrapperPlant;
        lodash.prototype.reverse = wrapperReverse;
        lodash.prototype.toJSON = lodash.prototype.valueOf = lodash.prototype.value = wrapperValue;
        if (iteratorSymbol) {
            lodash.prototype[iteratorSymbol] = wrapperToIterator;
        }
        return lodash;
    }
    var _ = runInContext();
    (freeWindow || freeSelf || {})._ = _;
    if (typeof define == "function" && typeof define.amd == "object" && define.amd) {
        define(function() {
            return _;
        });
    } else if (freeExports && freeModule) {
        if (moduleExports) {
            (freeModule.exports = _)._ = _;
        }
        freeExports._ = _;
    } else {
        root._ = _;
    }
}).call(this);

(function(window) {
    "use strict";
    function minErr(module, ErrorConstructor) {
        ErrorConstructor = ErrorConstructor || Error;
        return function() {
            var SKIP_INDEXES = 2;
            var templateArgs = arguments, code = templateArgs[0], message = "[" + (module ? module + ":" : "") + code + "] ", template = templateArgs[1], paramPrefix, i;
            message += template.replace(/\{\d+\}/g, function(match) {
                var index = +match.slice(1, -1), shiftedIndex = index + SKIP_INDEXES;
                if (shiftedIndex < templateArgs.length) {
                    return toDebugString(templateArgs[shiftedIndex]);
                }
                return match;
            });
            message += "\nhttp://errors.angularjs.org/1.5.11/" + (module ? module + "/" : "") + code;
            for (i = SKIP_INDEXES, paramPrefix = "?"; i < templateArgs.length; i++, paramPrefix = "&") {
                message += paramPrefix + "p" + (i - SKIP_INDEXES) + "=" + encodeURIComponent(toDebugString(templateArgs[i]));
            }
            return new ErrorConstructor(message);
        };
    }
    var REGEX_STRING_REGEXP = /^\/(.+)\/([a-z]*)$/;
    var VALIDITY_STATE_PROPERTY = "validity";
    var hasOwnProperty = Object.prototype.hasOwnProperty;
    var lowercase = function(string) {
        return isString(string) ? string.toLowerCase() : string;
    };
    var uppercase = function(string) {
        return isString(string) ? string.toUpperCase() : string;
    };
    var manualLowercase = function(s) {
        return isString(s) ? s.replace(/[A-Z]/g, function(ch) {
            return String.fromCharCode(ch.charCodeAt(0) | 32);
        }) : s;
    };
    var manualUppercase = function(s) {
        return isString(s) ? s.replace(/[a-z]/g, function(ch) {
            return String.fromCharCode(ch.charCodeAt(0) & ~32);
        }) : s;
    };
    if ("i" !== "I".toLowerCase()) {
        lowercase = manualLowercase;
        uppercase = manualUppercase;
    }
    var msie, jqLite, jQuery, slice = [].slice, splice = [].splice, push = [].push, toString = Object.prototype.toString, getPrototypeOf = Object.getPrototypeOf, ngMinErr = minErr("ng"), angular = window.angular || (window.angular = {}), angularModule, uid = 0;
    msie = window.document.documentMode;
    function isArrayLike(obj) {
        if (obj == null || isWindow(obj)) return false;
        if (isArray(obj) || isString(obj) || jqLite && obj instanceof jqLite) return true;
        var length = "length" in Object(obj) && obj.length;
        return isNumber(length) && (length >= 0 && (length - 1 in obj || obj instanceof Array) || typeof obj.item === "function");
    }
    function forEach(obj, iterator, context) {
        var key, length;
        if (obj) {
            if (isFunction(obj)) {
                for (key in obj) {
                    if (key !== "prototype" && key !== "length" && key !== "name" && (!obj.hasOwnProperty || obj.hasOwnProperty(key))) {
                        iterator.call(context, obj[key], key, obj);
                    }
                }
            } else if (isArray(obj) || isArrayLike(obj)) {
                var isPrimitive = typeof obj !== "object";
                for (key = 0, length = obj.length; key < length; key++) {
                    if (isPrimitive || key in obj) {
                        iterator.call(context, obj[key], key, obj);
                    }
                }
            } else if (obj.forEach && obj.forEach !== forEach) {
                obj.forEach(iterator, context, obj);
            } else if (isBlankObject(obj)) {
                for (key in obj) {
                    iterator.call(context, obj[key], key, obj);
                }
            } else if (typeof obj.hasOwnProperty === "function") {
                for (key in obj) {
                    if (obj.hasOwnProperty(key)) {
                        iterator.call(context, obj[key], key, obj);
                    }
                }
            } else {
                for (key in obj) {
                    if (hasOwnProperty.call(obj, key)) {
                        iterator.call(context, obj[key], key, obj);
                    }
                }
            }
        }
        return obj;
    }
    function forEachSorted(obj, iterator, context) {
        var keys = Object.keys(obj).sort();
        for (var i = 0; i < keys.length; i++) {
            iterator.call(context, obj[keys[i]], keys[i]);
        }
        return keys;
    }
    function reverseParams(iteratorFn) {
        return function(value, key) {
            iteratorFn(key, value);
        };
    }
    function nextUid() {
        return ++uid;
    }
    function setHashKey(obj, h) {
        if (h) {
            obj.$$hashKey = h;
        } else {
            delete obj.$$hashKey;
        }
    }
    function baseExtend(dst, objs, deep) {
        var h = dst.$$hashKey;
        for (var i = 0, ii = objs.length; i < ii; ++i) {
            var obj = objs[i];
            if (!isObject(obj) && !isFunction(obj)) continue;
            var keys = Object.keys(obj);
            for (var j = 0, jj = keys.length; j < jj; j++) {
                var key = keys[j];
                var src = obj[key];
                if (deep && isObject(src)) {
                    if (isDate(src)) {
                        dst[key] = new Date(src.valueOf());
                    } else if (isRegExp(src)) {
                        dst[key] = new RegExp(src);
                    } else if (src.nodeName) {
                        dst[key] = src.cloneNode(true);
                    } else if (isElement(src)) {
                        dst[key] = src.clone();
                    } else {
                        if (!isObject(dst[key])) dst[key] = isArray(src) ? [] : {};
                        baseExtend(dst[key], [ src ], true);
                    }
                } else {
                    dst[key] = src;
                }
            }
        }
        setHashKey(dst, h);
        return dst;
    }
    function extend(dst) {
        return baseExtend(dst, slice.call(arguments, 1), false);
    }
    function merge(dst) {
        return baseExtend(dst, slice.call(arguments, 1), true);
    }
    function toInt(str) {
        return parseInt(str, 10);
    }
    var isNumberNaN = Number.isNaN || function isNumberNaN(num) {
        return num !== num;
    };
    function inherit(parent, extra) {
        return extend(Object.create(parent), extra);
    }
    function noop() {}
    noop.$inject = [];
    function identity($) {
        return $;
    }
    identity.$inject = [];
    function valueFn(value) {
        return function valueRef() {
            return value;
        };
    }
    function hasCustomToString(obj) {
        return isFunction(obj.toString) && obj.toString !== toString;
    }
    function isUndefined(value) {
        return typeof value === "undefined";
    }
    function isDefined(value) {
        return typeof value !== "undefined";
    }
    function isObject(value) {
        return value !== null && typeof value === "object";
    }
    function isBlankObject(value) {
        return value !== null && typeof value === "object" && !getPrototypeOf(value);
    }
    function isString(value) {
        return typeof value === "string";
    }
    function isNumber(value) {
        return typeof value === "number";
    }
    function isDate(value) {
        return toString.call(value) === "[object Date]";
    }
    var isArray = Array.isArray;
    function isFunction(value) {
        return typeof value === "function";
    }
    function isRegExp(value) {
        return toString.call(value) === "[object RegExp]";
    }
    function isWindow(obj) {
        return obj && obj.window === obj;
    }
    function isScope(obj) {
        return obj && obj.$evalAsync && obj.$watch;
    }
    function isFile(obj) {
        return toString.call(obj) === "[object File]";
    }
    function isFormData(obj) {
        return toString.call(obj) === "[object FormData]";
    }
    function isBlob(obj) {
        return toString.call(obj) === "[object Blob]";
    }
    function isBoolean(value) {
        return typeof value === "boolean";
    }
    function isPromiseLike(obj) {
        return obj && isFunction(obj.then);
    }
    var TYPED_ARRAY_REGEXP = /^\[object (?:Uint8|Uint8Clamped|Uint16|Uint32|Int8|Int16|Int32|Float32|Float64)Array]$/;
    function isTypedArray(value) {
        return value && isNumber(value.length) && TYPED_ARRAY_REGEXP.test(toString.call(value));
    }
    function isArrayBuffer(obj) {
        return toString.call(obj) === "[object ArrayBuffer]";
    }
    var trim = function(value) {
        return isString(value) ? value.trim() : value;
    };
    var escapeForRegexp = function(s) {
        return s.replace(/([-()[\]{}+?*.$^|,:#<!\\])/g, "\\$1").replace(/\x08/g, "\\x08");
    };
    function isElement(node) {
        return !!(node && (node.nodeName || node.prop && node.attr && node.find));
    }
    function makeMap(str) {
        var obj = {}, items = str.split(","), i;
        for (i = 0; i < items.length; i++) {
            obj[items[i]] = true;
        }
        return obj;
    }
    function nodeName_(element) {
        return lowercase(element.nodeName || element[0] && element[0].nodeName);
    }
    function includes(array, obj) {
        return Array.prototype.indexOf.call(array, obj) !== -1;
    }
    function arrayRemove(array, value) {
        var index = array.indexOf(value);
        if (index >= 0) {
            array.splice(index, 1);
        }
        return index;
    }
    function copy(source, destination) {
        var stackSource = [];
        var stackDest = [];
        if (destination) {
            if (isTypedArray(destination) || isArrayBuffer(destination)) {
                throw ngMinErr("cpta", "Can't copy! TypedArray destination cannot be mutated.");
            }
            if (source === destination) {
                throw ngMinErr("cpi", "Can't copy! Source and destination are identical.");
            }
            if (isArray(destination)) {
                destination.length = 0;
            } else {
                forEach(destination, function(value, key) {
                    if (key !== "$$hashKey") {
                        delete destination[key];
                    }
                });
            }
            stackSource.push(source);
            stackDest.push(destination);
            return copyRecurse(source, destination);
        }
        return copyElement(source);
        function copyRecurse(source, destination) {
            var h = destination.$$hashKey;
            var key;
            if (isArray(source)) {
                for (var i = 0, ii = source.length; i < ii; i++) {
                    destination.push(copyElement(source[i]));
                }
            } else if (isBlankObject(source)) {
                for (key in source) {
                    destination[key] = copyElement(source[key]);
                }
            } else if (source && typeof source.hasOwnProperty === "function") {
                for (key in source) {
                    if (source.hasOwnProperty(key)) {
                        destination[key] = copyElement(source[key]);
                    }
                }
            } else {
                for (key in source) {
                    if (hasOwnProperty.call(source, key)) {
                        destination[key] = copyElement(source[key]);
                    }
                }
            }
            setHashKey(destination, h);
            return destination;
        }
        function copyElement(source) {
            if (!isObject(source)) {
                return source;
            }
            var index = stackSource.indexOf(source);
            if (index !== -1) {
                return stackDest[index];
            }
            if (isWindow(source) || isScope(source)) {
                throw ngMinErr("cpws", "Can't copy! Making copies of Window or Scope instances is not supported.");
            }
            var needsRecurse = false;
            var destination = copyType(source);
            if (destination === undefined) {
                destination = isArray(source) ? [] : Object.create(getPrototypeOf(source));
                needsRecurse = true;
            }
            stackSource.push(source);
            stackDest.push(destination);
            return needsRecurse ? copyRecurse(source, destination) : destination;
        }
        function copyType(source) {
            switch (toString.call(source)) {
              case "[object Int8Array]":
              case "[object Int16Array]":
              case "[object Int32Array]":
              case "[object Float32Array]":
              case "[object Float64Array]":
              case "[object Uint8Array]":
              case "[object Uint8ClampedArray]":
              case "[object Uint16Array]":
              case "[object Uint32Array]":
                return new source.constructor(copyElement(source.buffer), source.byteOffset, source.length);

              case "[object ArrayBuffer]":
                if (!source.slice) {
                    var copied = new ArrayBuffer(source.byteLength);
                    new Uint8Array(copied).set(new Uint8Array(source));
                    return copied;
                }
                return source.slice(0);

              case "[object Boolean]":
              case "[object Number]":
              case "[object String]":
              case "[object Date]":
                return new source.constructor(source.valueOf());

              case "[object RegExp]":
                var re = new RegExp(source.source, source.toString().match(/[^\/]*$/)[0]);
                re.lastIndex = source.lastIndex;
                return re;

              case "[object Blob]":
                return new source.constructor([ source ], {
                    type: source.type
                });
            }
            if (isFunction(source.cloneNode)) {
                return source.cloneNode(true);
            }
        }
    }
    function equals(o1, o2) {
        if (o1 === o2) return true;
        if (o1 === null || o2 === null) return false;
        if (o1 !== o1 && o2 !== o2) return true;
        var t1 = typeof o1, t2 = typeof o2, length, key, keySet;
        if (t1 === t2 && t1 === "object") {
            if (isArray(o1)) {
                if (!isArray(o2)) return false;
                if ((length = o1.length) === o2.length) {
                    for (key = 0; key < length; key++) {
                        if (!equals(o1[key], o2[key])) return false;
                    }
                    return true;
                }
            } else if (isDate(o1)) {
                if (!isDate(o2)) return false;
                return equals(o1.getTime(), o2.getTime());
            } else if (isRegExp(o1)) {
                if (!isRegExp(o2)) return false;
                return o1.toString() === o2.toString();
            } else {
                if (isScope(o1) || isScope(o2) || isWindow(o1) || isWindow(o2) || isArray(o2) || isDate(o2) || isRegExp(o2)) return false;
                keySet = createMap();
                for (key in o1) {
                    if (key.charAt(0) === "$" || isFunction(o1[key])) continue;
                    if (!equals(o1[key], o2[key])) return false;
                    keySet[key] = true;
                }
                for (key in o2) {
                    if (!(key in keySet) && key.charAt(0) !== "$" && isDefined(o2[key]) && !isFunction(o2[key])) return false;
                }
                return true;
            }
        }
        return false;
    }
    var csp = function() {
        if (!isDefined(csp.rules)) {
            var ngCspElement = window.document.querySelector("[ng-csp]") || window.document.querySelector("[data-ng-csp]");
            if (ngCspElement) {
                var ngCspAttribute = ngCspElement.getAttribute("ng-csp") || ngCspElement.getAttribute("data-ng-csp");
                csp.rules = {
                    noUnsafeEval: !ngCspAttribute || ngCspAttribute.indexOf("no-unsafe-eval") !== -1,
                    noInlineStyle: !ngCspAttribute || ngCspAttribute.indexOf("no-inline-style") !== -1
                };
            } else {
                csp.rules = {
                    noUnsafeEval: noUnsafeEval(),
                    noInlineStyle: false
                };
            }
        }
        return csp.rules;
        function noUnsafeEval() {
            try {
                new Function("");
                return false;
            } catch (e) {
                return true;
            }
        }
    };
    var jq = function() {
        if (isDefined(jq.name_)) return jq.name_;
        var el;
        var i, ii = ngAttrPrefixes.length, prefix, name;
        for (i = 0; i < ii; ++i) {
            prefix = ngAttrPrefixes[i];
            el = window.document.querySelector("[" + prefix.replace(":", "\\:") + "jq]");
            if (el) {
                name = el.getAttribute(prefix + "jq");
                break;
            }
        }
        return jq.name_ = name;
    };
    function concat(array1, array2, index) {
        return array1.concat(slice.call(array2, index));
    }
    function sliceArgs(args, startIndex) {
        return slice.call(args, startIndex || 0);
    }
    function bind(self, fn) {
        var curryArgs = arguments.length > 2 ? sliceArgs(arguments, 2) : [];
        if (isFunction(fn) && !(fn instanceof RegExp)) {
            return curryArgs.length ? function() {
                return arguments.length ? fn.apply(self, concat(curryArgs, arguments, 0)) : fn.apply(self, curryArgs);
            } : function() {
                return arguments.length ? fn.apply(self, arguments) : fn.call(self);
            };
        } else {
            return fn;
        }
    }
    function toJsonReplacer(key, value) {
        var val = value;
        if (typeof key === "string" && key.charAt(0) === "$" && key.charAt(1) === "$") {
            val = undefined;
        } else if (isWindow(value)) {
            val = "$WINDOW";
        } else if (value && window.document === value) {
            val = "$DOCUMENT";
        } else if (isScope(value)) {
            val = "$SCOPE";
        }
        return val;
    }
    function toJson(obj, pretty) {
        if (isUndefined(obj)) return undefined;
        if (!isNumber(pretty)) {
            pretty = pretty ? 2 : null;
        }
        return JSON.stringify(obj, toJsonReplacer, pretty);
    }
    function fromJson(json) {
        return isString(json) ? JSON.parse(json) : json;
    }
    var ALL_COLONS = /:/g;
    function timezoneToOffset(timezone, fallback) {
        timezone = timezone.replace(ALL_COLONS, "");
        var requestedTimezoneOffset = Date.parse("Jan 01, 1970 00:00:00 " + timezone) / 6e4;
        return isNumberNaN(requestedTimezoneOffset) ? fallback : requestedTimezoneOffset;
    }
    function addDateMinutes(date, minutes) {
        date = new Date(date.getTime());
        date.setMinutes(date.getMinutes() + minutes);
        return date;
    }
    function convertTimezoneToLocal(date, timezone, reverse) {
        reverse = reverse ? -1 : 1;
        var dateTimezoneOffset = date.getTimezoneOffset();
        var timezoneOffset = timezoneToOffset(timezone, dateTimezoneOffset);
        return addDateMinutes(date, reverse * (timezoneOffset - dateTimezoneOffset));
    }
    function startingTag(element) {
        element = jqLite(element).clone();
        try {
            element.empty();
        } catch (e) {}
        var elemHtml = jqLite("<div>").append(element).html();
        try {
            return element[0].nodeType === NODE_TYPE_TEXT ? lowercase(elemHtml) : elemHtml.match(/^(<[^>]+>)/)[1].replace(/^<([\w-]+)/, function(match, nodeName) {
                return "<" + lowercase(nodeName);
            });
        } catch (e) {
            return lowercase(elemHtml);
        }
    }
    function tryDecodeURIComponent(value) {
        try {
            return decodeURIComponent(value);
        } catch (e) {}
    }
    function parseKeyValue(keyValue) {
        var obj = {};
        forEach((keyValue || "").split("&"), function(keyValue) {
            var splitPoint, key, val;
            if (keyValue) {
                key = keyValue = keyValue.replace(/\+/g, "%20");
                splitPoint = keyValue.indexOf("=");
                if (splitPoint !== -1) {
                    key = keyValue.substring(0, splitPoint);
                    val = keyValue.substring(splitPoint + 1);
                }
                key = tryDecodeURIComponent(key);
                if (isDefined(key)) {
                    val = isDefined(val) ? tryDecodeURIComponent(val) : true;
                    if (!hasOwnProperty.call(obj, key)) {
                        obj[key] = val;
                    } else if (isArray(obj[key])) {
                        obj[key].push(val);
                    } else {
                        obj[key] = [ obj[key], val ];
                    }
                }
            }
        });
        return obj;
    }
    function toKeyValue(obj) {
        var parts = [];
        forEach(obj, function(value, key) {
            if (isArray(value)) {
                forEach(value, function(arrayValue) {
                    parts.push(encodeUriQuery(key, true) + (arrayValue === true ? "" : "=" + encodeUriQuery(arrayValue, true)));
                });
            } else {
                parts.push(encodeUriQuery(key, true) + (value === true ? "" : "=" + encodeUriQuery(value, true)));
            }
        });
        return parts.length ? parts.join("&") : "";
    }
    function encodeUriSegment(val) {
        return encodeUriQuery(val, true).replace(/%26/gi, "&").replace(/%3D/gi, "=").replace(/%2B/gi, "+");
    }
    function encodeUriQuery(val, pctEncodeSpaces) {
        return encodeURIComponent(val).replace(/%40/gi, "@").replace(/%3A/gi, ":").replace(/%24/g, "$").replace(/%2C/gi, ",").replace(/%3B/gi, ";").replace(/%20/g, pctEncodeSpaces ? "%20" : "+");
    }
    var ngAttrPrefixes = [ "ng-", "data-ng-", "ng:", "x-ng-" ];
    function getNgAttribute(element, ngAttr) {
        var attr, i, ii = ngAttrPrefixes.length;
        for (i = 0; i < ii; ++i) {
            attr = ngAttrPrefixes[i] + ngAttr;
            if (isString(attr = element.getAttribute(attr))) {
                return attr;
            }
        }
        return null;
    }
    function allowAutoBootstrap(document) {
        var script = document.currentScript;
        var src = script && script.getAttribute("src");
        if (!src) {
            return true;
        }
        var link = document.createElement("a");
        link.href = src;
        if (document.location.origin === link.origin) {
            return true;
        }
        switch (link.protocol) {
          case "http:":
          case "https:":
          case "ftp:":
          case "blob:":
          case "file:":
          case "data:":
            return true;

          default:
            return false;
        }
    }
    var isAutoBootstrapAllowed = allowAutoBootstrap(window.document);
    function angularInit(element, bootstrap) {
        var appElement, module, config = {};
        forEach(ngAttrPrefixes, function(prefix) {
            var name = prefix + "app";
            if (!appElement && element.hasAttribute && element.hasAttribute(name)) {
                appElement = element;
                module = element.getAttribute(name);
            }
        });
        forEach(ngAttrPrefixes, function(prefix) {
            var name = prefix + "app";
            var candidate;
            if (!appElement && (candidate = element.querySelector("[" + name.replace(":", "\\:") + "]"))) {
                appElement = candidate;
                module = candidate.getAttribute(name);
            }
        });
        if (appElement) {
            if (!isAutoBootstrapAllowed) {
                window.console.error("Angular: disabling automatic bootstrap. <script> protocol indicates " + "an extension, document.location.href does not match.");
                return;
            }
            config.strictDi = getNgAttribute(appElement, "strict-di") !== null;
            bootstrap(appElement, module ? [ module ] : [], config);
        }
    }
    function bootstrap(element, modules, config) {
        if (!isObject(config)) config = {};
        var defaultConfig = {
            strictDi: false
        };
        config = extend(defaultConfig, config);
        var doBootstrap = function() {
            element = jqLite(element);
            if (element.injector()) {
                var tag = element[0] === window.document ? "document" : startingTag(element);
                throw ngMinErr("btstrpd", "App already bootstrapped with this element '{0}'", tag.replace(/</, "&lt;").replace(/>/, "&gt;"));
            }
            modules = modules || [];
            modules.unshift([ "$provide", function($provide) {
                $provide.value("$rootElement", element);
            } ]);
            if (config.debugInfoEnabled) {
                modules.push([ "$compileProvider", function($compileProvider) {
                    $compileProvider.debugInfoEnabled(true);
                } ]);
            }
            modules.unshift("ng");
            var injector = createInjector(modules, config.strictDi);
            injector.invoke([ "$rootScope", "$rootElement", "$compile", "$injector", function bootstrapApply(scope, element, compile, injector) {
                scope.$apply(function() {
                    element.data("$injector", injector);
                    compile(element)(scope);
                });
            } ]);
            return injector;
        };
        var NG_ENABLE_DEBUG_INFO = /^NG_ENABLE_DEBUG_INFO!/;
        var NG_DEFER_BOOTSTRAP = /^NG_DEFER_BOOTSTRAP!/;
        if (window && NG_ENABLE_DEBUG_INFO.test(window.name)) {
            config.debugInfoEnabled = true;
            window.name = window.name.replace(NG_ENABLE_DEBUG_INFO, "");
        }
        if (window && !NG_DEFER_BOOTSTRAP.test(window.name)) {
            return doBootstrap();
        }
        window.name = window.name.replace(NG_DEFER_BOOTSTRAP, "");
        angular.resumeBootstrap = function(extraModules) {
            forEach(extraModules, function(module) {
                modules.push(module);
            });
            return doBootstrap();
        };
        if (isFunction(angular.resumeDeferredBootstrap)) {
            angular.resumeDeferredBootstrap();
        }
    }
    function reloadWithDebugInfo() {
        window.name = "NG_ENABLE_DEBUG_INFO!" + window.name;
        window.location.reload();
    }
    function getTestability(rootElement) {
        var injector = angular.element(rootElement).injector();
        if (!injector) {
            throw ngMinErr("test", "no injector found for element argument to getTestability");
        }
        return injector.get("$$testability");
    }
    var SNAKE_CASE_REGEXP = /[A-Z]/g;
    function snake_case(name, separator) {
        separator = separator || "_";
        return name.replace(SNAKE_CASE_REGEXP, function(letter, pos) {
            return (pos ? separator : "") + letter.toLowerCase();
        });
    }
    var bindJQueryFired = false;
    function bindJQuery() {
        var originalCleanData;
        if (bindJQueryFired) {
            return;
        }
        var jqName = jq();
        jQuery = isUndefined(jqName) ? window.jQuery : !jqName ? undefined : window[jqName];
        if (jQuery && jQuery.fn.on) {
            jqLite = jQuery;
            extend(jQuery.fn, {
                scope: JQLitePrototype.scope,
                isolateScope: JQLitePrototype.isolateScope,
                controller: JQLitePrototype.controller,
                injector: JQLitePrototype.injector,
                inheritedData: JQLitePrototype.inheritedData
            });
            originalCleanData = jQuery.cleanData;
            jQuery.cleanData = function(elems) {
                var events;
                for (var i = 0, elem; (elem = elems[i]) != null; i++) {
                    events = jQuery._data(elem, "events");
                    if (events && events.$destroy) {
                        jQuery(elem).triggerHandler("$destroy");
                    }
                }
                originalCleanData(elems);
            };
        } else {
            jqLite = JQLite;
        }
        angular.element = jqLite;
        bindJQueryFired = true;
    }
    function assertArg(arg, name, reason) {
        if (!arg) {
            throw ngMinErr("areq", "Argument '{0}' is {1}", name || "?", reason || "required");
        }
        return arg;
    }
    function assertArgFn(arg, name, acceptArrayAnnotation) {
        if (acceptArrayAnnotation && isArray(arg)) {
            arg = arg[arg.length - 1];
        }
        assertArg(isFunction(arg), name, "not a function, got " + (arg && typeof arg === "object" ? arg.constructor.name || "Object" : typeof arg));
        return arg;
    }
    function assertNotHasOwnProperty(name, context) {
        if (name === "hasOwnProperty") {
            throw ngMinErr("badname", "hasOwnProperty is not a valid {0} name", context);
        }
    }
    function getter(obj, path, bindFnToScope) {
        if (!path) return obj;
        var keys = path.split(".");
        var key;
        var lastInstance = obj;
        var len = keys.length;
        for (var i = 0; i < len; i++) {
            key = keys[i];
            if (obj) {
                obj = (lastInstance = obj)[key];
            }
        }
        if (!bindFnToScope && isFunction(obj)) {
            return bind(lastInstance, obj);
        }
        return obj;
    }
    function getBlockNodes(nodes) {
        var node = nodes[0];
        var endNode = nodes[nodes.length - 1];
        var blockNodes;
        for (var i = 1; node !== endNode && (node = node.nextSibling); i++) {
            if (blockNodes || nodes[i] !== node) {
                if (!blockNodes) {
                    blockNodes = jqLite(slice.call(nodes, 0, i));
                }
                blockNodes.push(node);
            }
        }
        return blockNodes || nodes;
    }
    function createMap() {
        return Object.create(null);
    }
    var NODE_TYPE_ELEMENT = 1;
    var NODE_TYPE_ATTRIBUTE = 2;
    var NODE_TYPE_TEXT = 3;
    var NODE_TYPE_COMMENT = 8;
    var NODE_TYPE_DOCUMENT = 9;
    var NODE_TYPE_DOCUMENT_FRAGMENT = 11;
    function setupModuleLoader(window) {
        var $injectorMinErr = minErr("$injector");
        var ngMinErr = minErr("ng");
        function ensure(obj, name, factory) {
            return obj[name] || (obj[name] = factory());
        }
        var angular = ensure(window, "angular", Object);
        angular.$$minErr = angular.$$minErr || minErr;
        return ensure(angular, "module", function() {
            var modules = {};
            return function module(name, requires, configFn) {
                var assertNotHasOwnProperty = function(name, context) {
                    if (name === "hasOwnProperty") {
                        throw ngMinErr("badname", "hasOwnProperty is not a valid {0} name", context);
                    }
                };
                assertNotHasOwnProperty(name, "module");
                if (requires && modules.hasOwnProperty(name)) {
                    modules[name] = null;
                }
                return ensure(modules, name, function() {
                    if (!requires) {
                        throw $injectorMinErr("nomod", "Module '{0}' is not available! You either misspelled " + "the module name or forgot to load it. If registering a module ensure that you " + "specify the dependencies as the second argument.", name);
                    }
                    var invokeQueue = [];
                    var configBlocks = [];
                    var runBlocks = [];
                    var config = invokeLater("$injector", "invoke", "push", configBlocks);
                    var moduleInstance = {
                        _invokeQueue: invokeQueue,
                        _configBlocks: configBlocks,
                        _runBlocks: runBlocks,
                        requires: requires,
                        name: name,
                        provider: invokeLaterAndSetModuleName("$provide", "provider"),
                        factory: invokeLaterAndSetModuleName("$provide", "factory"),
                        service: invokeLaterAndSetModuleName("$provide", "service"),
                        value: invokeLater("$provide", "value"),
                        constant: invokeLater("$provide", "constant", "unshift"),
                        decorator: invokeLaterAndSetModuleName("$provide", "decorator"),
                        animation: invokeLaterAndSetModuleName("$animateProvider", "register"),
                        filter: invokeLaterAndSetModuleName("$filterProvider", "register"),
                        controller: invokeLaterAndSetModuleName("$controllerProvider", "register"),
                        directive: invokeLaterAndSetModuleName("$compileProvider", "directive"),
                        component: invokeLaterAndSetModuleName("$compileProvider", "component"),
                        config: config,
                        run: function(block) {
                            runBlocks.push(block);
                            return this;
                        }
                    };
                    if (configFn) {
                        config(configFn);
                    }
                    return moduleInstance;
                    function invokeLater(provider, method, insertMethod, queue) {
                        if (!queue) queue = invokeQueue;
                        return function() {
                            queue[insertMethod || "push"]([ provider, method, arguments ]);
                            return moduleInstance;
                        };
                    }
                    function invokeLaterAndSetModuleName(provider, method) {
                        return function(recipeName, factoryFunction) {
                            if (factoryFunction && isFunction(factoryFunction)) factoryFunction.$$moduleName = name;
                            invokeQueue.push([ provider, method, arguments ]);
                            return moduleInstance;
                        };
                    }
                });
            };
        });
    }
    function shallowCopy(src, dst) {
        if (isArray(src)) {
            dst = dst || [];
            for (var i = 0, ii = src.length; i < ii; i++) {
                dst[i] = src[i];
            }
        } else if (isObject(src)) {
            dst = dst || {};
            for (var key in src) {
                if (!(key.charAt(0) === "$" && key.charAt(1) === "$")) {
                    dst[key] = src[key];
                }
            }
        }
        return dst || src;
    }
    function serializeObject(obj) {
        var seen = [];
        return JSON.stringify(obj, function(key, val) {
            val = toJsonReplacer(key, val);
            if (isObject(val)) {
                if (seen.indexOf(val) >= 0) return "...";
                seen.push(val);
            }
            return val;
        });
    }
    function toDebugString(obj) {
        if (typeof obj === "function") {
            return obj.toString().replace(/ \{[\s\S]*$/, "");
        } else if (isUndefined(obj)) {
            return "undefined";
        } else if (typeof obj !== "string") {
            return serializeObject(obj);
        }
        return obj;
    }
    var version = {
        full: "1.5.11",
        major: 1,
        minor: 5,
        dot: 11,
        codeName: "princely-quest"
    };
    function publishExternalAPI(angular) {
        extend(angular, {
            bootstrap: bootstrap,
            copy: copy,
            extend: extend,
            merge: merge,
            equals: equals,
            element: jqLite,
            forEach: forEach,
            injector: createInjector,
            noop: noop,
            bind: bind,
            toJson: toJson,
            fromJson: fromJson,
            identity: identity,
            isUndefined: isUndefined,
            isDefined: isDefined,
            isString: isString,
            isFunction: isFunction,
            isObject: isObject,
            isNumber: isNumber,
            isElement: isElement,
            isArray: isArray,
            version: version,
            isDate: isDate,
            lowercase: lowercase,
            uppercase: uppercase,
            callbacks: {
                $$counter: 0
            },
            getTestability: getTestability,
            $$minErr: minErr,
            $$csp: csp,
            reloadWithDebugInfo: reloadWithDebugInfo
        });
        angularModule = setupModuleLoader(window);
        angularModule("ng", [ "ngLocale" ], [ "$provide", function ngModule($provide) {
            $provide.provider({
                $$sanitizeUri: $$SanitizeUriProvider
            });
            $provide.provider("$compile", $CompileProvider).directive({
                a: htmlAnchorDirective,
                input: inputDirective,
                textarea: inputDirective,
                form: formDirective,
                script: scriptDirective,
                select: selectDirective,
                option: optionDirective,
                ngBind: ngBindDirective,
                ngBindHtml: ngBindHtmlDirective,
                ngBindTemplate: ngBindTemplateDirective,
                ngClass: ngClassDirective,
                ngClassEven: ngClassEvenDirective,
                ngClassOdd: ngClassOddDirective,
                ngCloak: ngCloakDirective,
                ngController: ngControllerDirective,
                ngForm: ngFormDirective,
                ngHide: ngHideDirective,
                ngIf: ngIfDirective,
                ngInclude: ngIncludeDirective,
                ngInit: ngInitDirective,
                ngNonBindable: ngNonBindableDirective,
                ngPluralize: ngPluralizeDirective,
                ngRepeat: ngRepeatDirective,
                ngShow: ngShowDirective,
                ngStyle: ngStyleDirective,
                ngSwitch: ngSwitchDirective,
                ngSwitchWhen: ngSwitchWhenDirective,
                ngSwitchDefault: ngSwitchDefaultDirective,
                ngOptions: ngOptionsDirective,
                ngTransclude: ngTranscludeDirective,
                ngModel: ngModelDirective,
                ngList: ngListDirective,
                ngChange: ngChangeDirective,
                pattern: patternDirective,
                ngPattern: patternDirective,
                required: requiredDirective,
                ngRequired: requiredDirective,
                minlength: minlengthDirective,
                ngMinlength: minlengthDirective,
                maxlength: maxlengthDirective,
                ngMaxlength: maxlengthDirective,
                ngValue: ngValueDirective,
                ngModelOptions: ngModelOptionsDirective
            }).directive({
                ngInclude: ngIncludeFillContentDirective
            }).directive(ngAttributeAliasDirectives).directive(ngEventDirectives);
            $provide.provider({
                $anchorScroll: $AnchorScrollProvider,
                $animate: $AnimateProvider,
                $animateCss: $CoreAnimateCssProvider,
                $$animateJs: $$CoreAnimateJsProvider,
                $$animateQueue: $$CoreAnimateQueueProvider,
                $$AnimateRunner: $$AnimateRunnerFactoryProvider,
                $$animateAsyncRun: $$AnimateAsyncRunFactoryProvider,
                $browser: $BrowserProvider,
                $cacheFactory: $CacheFactoryProvider,
                $controller: $ControllerProvider,
                $document: $DocumentProvider,
                $exceptionHandler: $ExceptionHandlerProvider,
                $filter: $FilterProvider,
                $$forceReflow: $$ForceReflowProvider,
                $interpolate: $InterpolateProvider,
                $interval: $IntervalProvider,
                $http: $HttpProvider,
                $httpParamSerializer: $HttpParamSerializerProvider,
                $httpParamSerializerJQLike: $HttpParamSerializerJQLikeProvider,
                $httpBackend: $HttpBackendProvider,
                $xhrFactory: $xhrFactoryProvider,
                $jsonpCallbacks: $jsonpCallbacksProvider,
                $location: $LocationProvider,
                $log: $LogProvider,
                $parse: $ParseProvider,
                $rootScope: $RootScopeProvider,
                $q: $QProvider,
                $$q: $$QProvider,
                $sce: $SceProvider,
                $sceDelegate: $SceDelegateProvider,
                $sniffer: $SnifferProvider,
                $templateCache: $TemplateCacheProvider,
                $templateRequest: $TemplateRequestProvider,
                $$testability: $$TestabilityProvider,
                $timeout: $TimeoutProvider,
                $window: $WindowProvider,
                $$rAF: $$RAFProvider,
                $$jqLite: $$jqLiteProvider,
                $$HashMap: $$HashMapProvider,
                $$cookieReader: $$CookieReaderProvider
            });
        } ]);
    }
    JQLite.expando = "ng339";
    var jqCache = JQLite.cache = {}, jqId = 1, addEventListenerFn = function(element, type, fn) {
        element.addEventListener(type, fn, false);
    }, removeEventListenerFn = function(element, type, fn) {
        element.removeEventListener(type, fn, false);
    };
    JQLite._data = function(node) {
        return this.cache[node[this.expando]] || {};
    };
    function jqNextId() {
        return ++jqId;
    }
    var SPECIAL_CHARS_REGEXP = /([:\-_]+(.))/g;
    var MOZ_HACK_REGEXP = /^moz([A-Z])/;
    var MOUSE_EVENT_MAP = {
        mouseleave: "mouseout",
        mouseenter: "mouseover"
    };
    var jqLiteMinErr = minErr("jqLite");
    function camelCase(name) {
        return name.replace(SPECIAL_CHARS_REGEXP, function(_, separator, letter, offset) {
            return offset ? letter.toUpperCase() : letter;
        }).replace(MOZ_HACK_REGEXP, "Moz$1");
    }
    var SINGLE_TAG_REGEXP = /^<([\w-]+)\s*\/?>(?:<\/\1>|)$/;
    var HTML_REGEXP = /<|&#?\w+;/;
    var TAG_NAME_REGEXP = /<([\w:-]+)/;
    var XHTML_TAG_REGEXP = /<(?!area|br|col|embed|hr|img|input|link|meta|param)(([\w:-]+)[^>]*)\/>/gi;
    var wrapMap = {
        option: [ 1, '<select multiple="multiple">', "</select>" ],
        thead: [ 1, "<table>", "</table>" ],
        col: [ 2, "<table><colgroup>", "</colgroup></table>" ],
        tr: [ 2, "<table><tbody>", "</tbody></table>" ],
        td: [ 3, "<table><tbody><tr>", "</tr></tbody></table>" ],
        _default: [ 0, "", "" ]
    };
    wrapMap.optgroup = wrapMap.option;
    wrapMap.tbody = wrapMap.tfoot = wrapMap.colgroup = wrapMap.caption = wrapMap.thead;
    wrapMap.th = wrapMap.td;
    function jqLiteIsTextNode(html) {
        return !HTML_REGEXP.test(html);
    }
    function jqLiteAcceptsData(node) {
        var nodeType = node.nodeType;
        return nodeType === NODE_TYPE_ELEMENT || !nodeType || nodeType === NODE_TYPE_DOCUMENT;
    }
    function jqLiteHasData(node) {
        for (var key in jqCache[node.ng339]) {
            return true;
        }
        return false;
    }
    function jqLiteCleanData(nodes) {
        for (var i = 0, ii = nodes.length; i < ii; i++) {
            jqLiteRemoveData(nodes[i]);
        }
    }
    function jqLiteBuildFragment(html, context) {
        var tmp, tag, wrap, fragment = context.createDocumentFragment(), nodes = [], i;
        if (jqLiteIsTextNode(html)) {
            nodes.push(context.createTextNode(html));
        } else {
            tmp = fragment.appendChild(context.createElement("div"));
            tag = (TAG_NAME_REGEXP.exec(html) || [ "", "" ])[1].toLowerCase();
            wrap = wrapMap[tag] || wrapMap._default;
            tmp.innerHTML = wrap[1] + html.replace(XHTML_TAG_REGEXP, "<$1></$2>") + wrap[2];
            i = wrap[0];
            while (i--) {
                tmp = tmp.lastChild;
            }
            nodes = concat(nodes, tmp.childNodes);
            tmp = fragment.firstChild;
            tmp.textContent = "";
        }
        fragment.textContent = "";
        fragment.innerHTML = "";
        forEach(nodes, function(node) {
            fragment.appendChild(node);
        });
        return fragment;
    }
    function jqLiteParseHTML(html, context) {
        context = context || window.document;
        var parsed;
        if (parsed = SINGLE_TAG_REGEXP.exec(html)) {
            return [ context.createElement(parsed[1]) ];
        }
        if (parsed = jqLiteBuildFragment(html, context)) {
            return parsed.childNodes;
        }
        return [];
    }
    function jqLiteWrapNode(node, wrapper) {
        var parent = node.parentNode;
        if (parent) {
            parent.replaceChild(wrapper, node);
        }
        wrapper.appendChild(node);
    }
    var jqLiteContains = window.Node.prototype.contains || function(arg) {
        return !!(this.compareDocumentPosition(arg) & 16);
    };
    function JQLite(element) {
        if (element instanceof JQLite) {
            return element;
        }
        var argIsString;
        if (isString(element)) {
            element = trim(element);
            argIsString = true;
        }
        if (!(this instanceof JQLite)) {
            if (argIsString && element.charAt(0) !== "<") {
                throw jqLiteMinErr("nosel", "Looking up elements via selectors is not supported by jqLite! See: http://docs.angularjs.org/api/angular.element");
            }
            return new JQLite(element);
        }
        if (argIsString) {
            jqLiteAddNodes(this, jqLiteParseHTML(element));
        } else {
            jqLiteAddNodes(this, element);
        }
    }
    function jqLiteClone(element) {
        return element.cloneNode(true);
    }
    function jqLiteDealoc(element, onlyDescendants) {
        if (!onlyDescendants) jqLiteRemoveData(element);
        if (element.querySelectorAll) {
            var descendants = element.querySelectorAll("*");
            for (var i = 0, l = descendants.length; i < l; i++) {
                jqLiteRemoveData(descendants[i]);
            }
        }
    }
    function jqLiteOff(element, type, fn, unsupported) {
        if (isDefined(unsupported)) throw jqLiteMinErr("offargs", "jqLite#off() does not support the `selector` argument");
        var expandoStore = jqLiteExpandoStore(element);
        var events = expandoStore && expandoStore.events;
        var handle = expandoStore && expandoStore.handle;
        if (!handle) return;
        if (!type) {
            for (type in events) {
                if (type !== "$destroy") {
                    removeEventListenerFn(element, type, handle);
                }
                delete events[type];
            }
        } else {
            var removeHandler = function(type) {
                var listenerFns = events[type];
                if (isDefined(fn)) {
                    arrayRemove(listenerFns || [], fn);
                }
                if (!(isDefined(fn) && listenerFns && listenerFns.length > 0)) {
                    removeEventListenerFn(element, type, handle);
                    delete events[type];
                }
            };
            forEach(type.split(" "), function(type) {
                removeHandler(type);
                if (MOUSE_EVENT_MAP[type]) {
                    removeHandler(MOUSE_EVENT_MAP[type]);
                }
            });
        }
    }
    function jqLiteRemoveData(element, name) {
        var expandoId = element.ng339;
        var expandoStore = expandoId && jqCache[expandoId];
        if (expandoStore) {
            if (name) {
                delete expandoStore.data[name];
                return;
            }
            if (expandoStore.handle) {
                if (expandoStore.events.$destroy) {
                    expandoStore.handle({}, "$destroy");
                }
                jqLiteOff(element);
            }
            delete jqCache[expandoId];
            element.ng339 = undefined;
        }
    }
    function jqLiteExpandoStore(element, createIfNecessary) {
        var expandoId = element.ng339, expandoStore = expandoId && jqCache[expandoId];
        if (createIfNecessary && !expandoStore) {
            element.ng339 = expandoId = jqNextId();
            expandoStore = jqCache[expandoId] = {
                events: {},
                data: {},
                handle: undefined
            };
        }
        return expandoStore;
    }
    function jqLiteData(element, key, value) {
        if (jqLiteAcceptsData(element)) {
            var isSimpleSetter = isDefined(value);
            var isSimpleGetter = !isSimpleSetter && key && !isObject(key);
            var massGetter = !key;
            var expandoStore = jqLiteExpandoStore(element, !isSimpleGetter);
            var data = expandoStore && expandoStore.data;
            if (isSimpleSetter) {
                data[key] = value;
            } else {
                if (massGetter) {
                    return data;
                } else {
                    if (isSimpleGetter) {
                        return data && data[key];
                    } else {
                        extend(data, key);
                    }
                }
            }
        }
    }
    function jqLiteHasClass(element, selector) {
        if (!element.getAttribute) return false;
        return (" " + (element.getAttribute("class") || "") + " ").replace(/[\n\t]/g, " ").indexOf(" " + selector + " ") > -1;
    }
    function jqLiteRemoveClass(element, cssClasses) {
        if (cssClasses && element.setAttribute) {
            forEach(cssClasses.split(" "), function(cssClass) {
                element.setAttribute("class", trim((" " + (element.getAttribute("class") || "") + " ").replace(/[\n\t]/g, " ").replace(" " + trim(cssClass) + " ", " ")));
            });
        }
    }
    function jqLiteAddClass(element, cssClasses) {
        if (cssClasses && element.setAttribute) {
            var existingClasses = (" " + (element.getAttribute("class") || "") + " ").replace(/[\n\t]/g, " ");
            forEach(cssClasses.split(" "), function(cssClass) {
                cssClass = trim(cssClass);
                if (existingClasses.indexOf(" " + cssClass + " ") === -1) {
                    existingClasses += cssClass + " ";
                }
            });
            element.setAttribute("class", trim(existingClasses));
        }
    }
    function jqLiteAddNodes(root, elements) {
        if (elements) {
            if (elements.nodeType) {
                root[root.length++] = elements;
            } else {
                var length = elements.length;
                if (typeof length === "number" && elements.window !== elements) {
                    if (length) {
                        for (var i = 0; i < length; i++) {
                            root[root.length++] = elements[i];
                        }
                    }
                } else {
                    root[root.length++] = elements;
                }
            }
        }
    }
    function jqLiteController(element, name) {
        return jqLiteInheritedData(element, "$" + (name || "ngController") + "Controller");
    }
    function jqLiteInheritedData(element, name, value) {
        if (element.nodeType === NODE_TYPE_DOCUMENT) {
            element = element.documentElement;
        }
        var names = isArray(name) ? name : [ name ];
        while (element) {
            for (var i = 0, ii = names.length; i < ii; i++) {
                if (isDefined(value = jqLite.data(element, names[i]))) return value;
            }
            element = element.parentNode || element.nodeType === NODE_TYPE_DOCUMENT_FRAGMENT && element.host;
        }
    }
    function jqLiteEmpty(element) {
        jqLiteDealoc(element, true);
        while (element.firstChild) {
            element.removeChild(element.firstChild);
        }
    }
    function jqLiteRemove(element, keepData) {
        if (!keepData) jqLiteDealoc(element);
        var parent = element.parentNode;
        if (parent) parent.removeChild(element);
    }
    function jqLiteDocumentLoaded(action, win) {
        win = win || window;
        if (win.document.readyState === "complete") {
            win.setTimeout(action);
        } else {
            jqLite(win).on("load", action);
        }
    }
    var JQLitePrototype = JQLite.prototype = {
        ready: function(fn) {
            var fired = false;
            function trigger() {
                if (fired) return;
                fired = true;
                fn();
            }
            if (window.document.readyState === "complete") {
                window.setTimeout(trigger);
            } else {
                this.on("DOMContentLoaded", trigger);
                JQLite(window).on("load", trigger);
            }
        },
        toString: function() {
            var value = [];
            forEach(this, function(e) {
                value.push("" + e);
            });
            return "[" + value.join(", ") + "]";
        },
        eq: function(index) {
            return index >= 0 ? jqLite(this[index]) : jqLite(this[this.length + index]);
        },
        length: 0,
        push: push,
        sort: [].sort,
        splice: [].splice
    };
    var BOOLEAN_ATTR = {};
    forEach("multiple,selected,checked,disabled,readOnly,required,open".split(","), function(value) {
        BOOLEAN_ATTR[lowercase(value)] = value;
    });
    var BOOLEAN_ELEMENTS = {};
    forEach("input,select,option,textarea,button,form,details".split(","), function(value) {
        BOOLEAN_ELEMENTS[value] = true;
    });
    var ALIASED_ATTR = {
        ngMinlength: "minlength",
        ngMaxlength: "maxlength",
        ngMin: "min",
        ngMax: "max",
        ngPattern: "pattern"
    };
    function getBooleanAttrName(element, name) {
        var booleanAttr = BOOLEAN_ATTR[name.toLowerCase()];
        return booleanAttr && BOOLEAN_ELEMENTS[nodeName_(element)] && booleanAttr;
    }
    function getAliasedAttrName(name) {
        return ALIASED_ATTR[name];
    }
    forEach({
        data: jqLiteData,
        removeData: jqLiteRemoveData,
        hasData: jqLiteHasData,
        cleanData: jqLiteCleanData
    }, function(fn, name) {
        JQLite[name] = fn;
    });
    forEach({
        data: jqLiteData,
        inheritedData: jqLiteInheritedData,
        scope: function(element) {
            return jqLite.data(element, "$scope") || jqLiteInheritedData(element.parentNode || element, [ "$isolateScope", "$scope" ]);
        },
        isolateScope: function(element) {
            return jqLite.data(element, "$isolateScope") || jqLite.data(element, "$isolateScopeNoTemplate");
        },
        controller: jqLiteController,
        injector: function(element) {
            return jqLiteInheritedData(element, "$injector");
        },
        removeAttr: function(element, name) {
            element.removeAttribute(name);
        },
        hasClass: jqLiteHasClass,
        css: function(element, name, value) {
            name = camelCase(name);
            if (isDefined(value)) {
                element.style[name] = value;
            } else {
                return element.style[name];
            }
        },
        attr: function(element, name, value) {
            var nodeType = element.nodeType;
            if (nodeType === NODE_TYPE_TEXT || nodeType === NODE_TYPE_ATTRIBUTE || nodeType === NODE_TYPE_COMMENT) {
                return;
            }
            var lowercasedName = lowercase(name);
            if (BOOLEAN_ATTR[lowercasedName]) {
                if (isDefined(value)) {
                    if (value) {
                        element[name] = true;
                        element.setAttribute(name, lowercasedName);
                    } else {
                        element[name] = false;
                        element.removeAttribute(lowercasedName);
                    }
                } else {
                    return element[name] || (element.attributes.getNamedItem(name) || noop).specified ? lowercasedName : undefined;
                }
            } else if (isDefined(value)) {
                element.setAttribute(name, value);
            } else if (element.getAttribute) {
                var ret = element.getAttribute(name, 2);
                return ret === null ? undefined : ret;
            }
        },
        prop: function(element, name, value) {
            if (isDefined(value)) {
                element[name] = value;
            } else {
                return element[name];
            }
        },
        text: function() {
            getText.$dv = "";
            return getText;
            function getText(element, value) {
                if (isUndefined(value)) {
                    var nodeType = element.nodeType;
                    return nodeType === NODE_TYPE_ELEMENT || nodeType === NODE_TYPE_TEXT ? element.textContent : "";
                }
                element.textContent = value;
            }
        }(),
        val: function(element, value) {
            if (isUndefined(value)) {
                if (element.multiple && nodeName_(element) === "select") {
                    var result = [];
                    forEach(element.options, function(option) {
                        if (option.selected) {
                            result.push(option.value || option.text);
                        }
                    });
                    return result.length === 0 ? null : result;
                }
                return element.value;
            }
            element.value = value;
        },
        html: function(element, value) {
            if (isUndefined(value)) {
                return element.innerHTML;
            }
            jqLiteDealoc(element, true);
            element.innerHTML = value;
        },
        empty: jqLiteEmpty
    }, function(fn, name) {
        JQLite.prototype[name] = function(arg1, arg2) {
            var i, key;
            var nodeCount = this.length;
            if (fn !== jqLiteEmpty && isUndefined(fn.length === 2 && (fn !== jqLiteHasClass && fn !== jqLiteController) ? arg1 : arg2)) {
                if (isObject(arg1)) {
                    for (i = 0; i < nodeCount; i++) {
                        if (fn === jqLiteData) {
                            fn(this[i], arg1);
                        } else {
                            for (key in arg1) {
                                fn(this[i], key, arg1[key]);
                            }
                        }
                    }
                    return this;
                } else {
                    var value = fn.$dv;
                    var jj = isUndefined(value) ? Math.min(nodeCount, 1) : nodeCount;
                    for (var j = 0; j < jj; j++) {
                        var nodeValue = fn(this[j], arg1, arg2);
                        value = value ? value + nodeValue : nodeValue;
                    }
                    return value;
                }
            } else {
                for (i = 0; i < nodeCount; i++) {
                    fn(this[i], arg1, arg2);
                }
                return this;
            }
        };
    });
    function createEventHandler(element, events) {
        var eventHandler = function(event, type) {
            event.isDefaultPrevented = function() {
                return event.defaultPrevented;
            };
            var eventFns = events[type || event.type];
            var eventFnsLength = eventFns ? eventFns.length : 0;
            if (!eventFnsLength) return;
            if (isUndefined(event.immediatePropagationStopped)) {
                var originalStopImmediatePropagation = event.stopImmediatePropagation;
                event.stopImmediatePropagation = function() {
                    event.immediatePropagationStopped = true;
                    if (event.stopPropagation) {
                        event.stopPropagation();
                    }
                    if (originalStopImmediatePropagation) {
                        originalStopImmediatePropagation.call(event);
                    }
                };
            }
            event.isImmediatePropagationStopped = function() {
                return event.immediatePropagationStopped === true;
            };
            var handlerWrapper = eventFns.specialHandlerWrapper || defaultHandlerWrapper;
            if (eventFnsLength > 1) {
                eventFns = shallowCopy(eventFns);
            }
            for (var i = 0; i < eventFnsLength; i++) {
                if (!event.isImmediatePropagationStopped()) {
                    handlerWrapper(element, event, eventFns[i]);
                }
            }
        };
        eventHandler.elem = element;
        return eventHandler;
    }
    function defaultHandlerWrapper(element, event, handler) {
        handler.call(element, event);
    }
    function specialMouseHandlerWrapper(target, event, handler) {
        var related = event.relatedTarget;
        if (!related || related !== target && !jqLiteContains.call(target, related)) {
            handler.call(target, event);
        }
    }
    forEach({
        removeData: jqLiteRemoveData,
        on: function jqLiteOn(element, type, fn, unsupported) {
            if (isDefined(unsupported)) throw jqLiteMinErr("onargs", "jqLite#on() does not support the `selector` or `eventData` parameters");
            if (!jqLiteAcceptsData(element)) {
                return;
            }
            var expandoStore = jqLiteExpandoStore(element, true);
            var events = expandoStore.events;
            var handle = expandoStore.handle;
            if (!handle) {
                handle = expandoStore.handle = createEventHandler(element, events);
            }
            var types = type.indexOf(" ") >= 0 ? type.split(" ") : [ type ];
            var i = types.length;
            var addHandler = function(type, specialHandlerWrapper, noEventListener) {
                var eventFns = events[type];
                if (!eventFns) {
                    eventFns = events[type] = [];
                    eventFns.specialHandlerWrapper = specialHandlerWrapper;
                    if (type !== "$destroy" && !noEventListener) {
                        addEventListenerFn(element, type, handle);
                    }
                }
                eventFns.push(fn);
            };
            while (i--) {
                type = types[i];
                if (MOUSE_EVENT_MAP[type]) {
                    addHandler(MOUSE_EVENT_MAP[type], specialMouseHandlerWrapper);
                    addHandler(type, undefined, true);
                } else {
                    addHandler(type);
                }
            }
        },
        off: jqLiteOff,
        one: function(element, type, fn) {
            element = jqLite(element);
            element.on(type, function onFn() {
                element.off(type, fn);
                element.off(type, onFn);
            });
            element.on(type, fn);
        },
        replaceWith: function(element, replaceNode) {
            var index, parent = element.parentNode;
            jqLiteDealoc(element);
            forEach(new JQLite(replaceNode), function(node) {
                if (index) {
                    parent.insertBefore(node, index.nextSibling);
                } else {
                    parent.replaceChild(node, element);
                }
                index = node;
            });
        },
        children: function(element) {
            var children = [];
            forEach(element.childNodes, function(element) {
                if (element.nodeType === NODE_TYPE_ELEMENT) {
                    children.push(element);
                }
            });
            return children;
        },
        contents: function(element) {
            return element.contentDocument || element.childNodes || [];
        },
        append: function(element, node) {
            var nodeType = element.nodeType;
            if (nodeType !== NODE_TYPE_ELEMENT && nodeType !== NODE_TYPE_DOCUMENT_FRAGMENT) return;
            node = new JQLite(node);
            for (var i = 0, ii = node.length; i < ii; i++) {
                var child = node[i];
                element.appendChild(child);
            }
        },
        prepend: function(element, node) {
            if (element.nodeType === NODE_TYPE_ELEMENT) {
                var index = element.firstChild;
                forEach(new JQLite(node), function(child) {
                    element.insertBefore(child, index);
                });
            }
        },
        wrap: function(element, wrapNode) {
            jqLiteWrapNode(element, jqLite(wrapNode).eq(0).clone()[0]);
        },
        remove: jqLiteRemove,
        detach: function(element) {
            jqLiteRemove(element, true);
        },
        after: function(element, newElement) {
            var index = element, parent = element.parentNode;
            if (parent) {
                newElement = new JQLite(newElement);
                for (var i = 0, ii = newElement.length; i < ii; i++) {
                    var node = newElement[i];
                    parent.insertBefore(node, index.nextSibling);
                    index = node;
                }
            }
        },
        addClass: jqLiteAddClass,
        removeClass: jqLiteRemoveClass,
        toggleClass: function(element, selector, condition) {
            if (selector) {
                forEach(selector.split(" "), function(className) {
                    var classCondition = condition;
                    if (isUndefined(classCondition)) {
                        classCondition = !jqLiteHasClass(element, className);
                    }
                    (classCondition ? jqLiteAddClass : jqLiteRemoveClass)(element, className);
                });
            }
        },
        parent: function(element) {
            var parent = element.parentNode;
            return parent && parent.nodeType !== NODE_TYPE_DOCUMENT_FRAGMENT ? parent : null;
        },
        next: function(element) {
            return element.nextElementSibling;
        },
        find: function(element, selector) {
            if (element.getElementsByTagName) {
                return element.getElementsByTagName(selector);
            } else {
                return [];
            }
        },
        clone: jqLiteClone,
        triggerHandler: function(element, event, extraParameters) {
            var dummyEvent, eventFnsCopy, handlerArgs;
            var eventName = event.type || event;
            var expandoStore = jqLiteExpandoStore(element);
            var events = expandoStore && expandoStore.events;
            var eventFns = events && events[eventName];
            if (eventFns) {
                dummyEvent = {
                    preventDefault: function() {
                        this.defaultPrevented = true;
                    },
                    isDefaultPrevented: function() {
                        return this.defaultPrevented === true;
                    },
                    stopImmediatePropagation: function() {
                        this.immediatePropagationStopped = true;
                    },
                    isImmediatePropagationStopped: function() {
                        return this.immediatePropagationStopped === true;
                    },
                    stopPropagation: noop,
                    type: eventName,
                    target: element
                };
                if (event.type) {
                    dummyEvent = extend(dummyEvent, event);
                }
                eventFnsCopy = shallowCopy(eventFns);
                handlerArgs = extraParameters ? [ dummyEvent ].concat(extraParameters) : [ dummyEvent ];
                forEach(eventFnsCopy, function(fn) {
                    if (!dummyEvent.isImmediatePropagationStopped()) {
                        fn.apply(element, handlerArgs);
                    }
                });
            }
        }
    }, function(fn, name) {
        JQLite.prototype[name] = function(arg1, arg2, arg3) {
            var value;
            for (var i = 0, ii = this.length; i < ii; i++) {
                if (isUndefined(value)) {
                    value = fn(this[i], arg1, arg2, arg3);
                    if (isDefined(value)) {
                        value = jqLite(value);
                    }
                } else {
                    jqLiteAddNodes(value, fn(this[i], arg1, arg2, arg3));
                }
            }
            return isDefined(value) ? value : this;
        };
    });
    JQLite.prototype.bind = JQLite.prototype.on;
    JQLite.prototype.unbind = JQLite.prototype.off;
    function $$jqLiteProvider() {
        this.$get = function $$jqLite() {
            return extend(JQLite, {
                hasClass: function(node, classes) {
                    if (node.attr) node = node[0];
                    return jqLiteHasClass(node, classes);
                },
                addClass: function(node, classes) {
                    if (node.attr) node = node[0];
                    return jqLiteAddClass(node, classes);
                },
                removeClass: function(node, classes) {
                    if (node.attr) node = node[0];
                    return jqLiteRemoveClass(node, classes);
                }
            });
        };
    }
    function hashKey(obj, nextUidFn) {
        var key = obj && obj.$$hashKey;
        if (key) {
            if (typeof key === "function") {
                key = obj.$$hashKey();
            }
            return key;
        }
        var objType = typeof obj;
        if (objType === "function" || objType === "object" && obj !== null) {
            key = obj.$$hashKey = objType + ":" + (nextUidFn || nextUid)();
        } else {
            key = objType + ":" + obj;
        }
        return key;
    }
    function HashMap(array, isolatedUid) {
        if (isolatedUid) {
            var uid = 0;
            this.nextUid = function() {
                return ++uid;
            };
        }
        forEach(array, this.put, this);
    }
    HashMap.prototype = {
        put: function(key, value) {
            this[hashKey(key, this.nextUid)] = value;
        },
        get: function(key) {
            return this[hashKey(key, this.nextUid)];
        },
        remove: function(key) {
            var value = this[key = hashKey(key, this.nextUid)];
            delete this[key];
            return value;
        }
    };
    var $$HashMapProvider = [ function() {
        this.$get = [ function() {
            return HashMap;
        } ];
    } ];
    var ARROW_ARG = /^([^(]+?)=>/;
    var FN_ARGS = /^[^(]*\(\s*([^)]*)\)/m;
    var FN_ARG_SPLIT = /,/;
    var FN_ARG = /^\s*(_?)(\S+?)\1\s*$/;
    var STRIP_COMMENTS = /((\/\/.*$)|(\/\*[\s\S]*?\*\/))/gm;
    var $injectorMinErr = minErr("$injector");
    function stringifyFn(fn) {
        return Function.prototype.toString.call(fn) + " ";
    }
    function extractArgs(fn) {
        var fnText = stringifyFn(fn).replace(STRIP_COMMENTS, ""), args = fnText.match(ARROW_ARG) || fnText.match(FN_ARGS);
        return args;
    }
    function anonFn(fn) {
        var args = extractArgs(fn);
        if (args) {
            return "function(" + (args[1] || "").replace(/[\s\r\n]+/, " ") + ")";
        }
        return "fn";
    }
    function annotate(fn, strictDi, name) {
        var $inject, argDecl, last;
        if (typeof fn === "function") {
            if (!($inject = fn.$inject)) {
                $inject = [];
                if (fn.length) {
                    if (strictDi) {
                        if (!isString(name) || !name) {
                            name = fn.name || anonFn(fn);
                        }
                        throw $injectorMinErr("strictdi", "{0} is not using explicit annotation and cannot be invoked in strict mode", name);
                    }
                    argDecl = extractArgs(fn);
                    forEach(argDecl[1].split(FN_ARG_SPLIT), function(arg) {
                        arg.replace(FN_ARG, function(all, underscore, name) {
                            $inject.push(name);
                        });
                    });
                }
                fn.$inject = $inject;
            }
        } else if (isArray(fn)) {
            last = fn.length - 1;
            assertArgFn(fn[last], "fn");
            $inject = fn.slice(0, last);
        } else {
            assertArgFn(fn, "fn", true);
        }
        return $inject;
    }
    function createInjector(modulesToLoad, strictDi) {
        strictDi = strictDi === true;
        var INSTANTIATING = {}, providerSuffix = "Provider", path = [], loadedModules = new HashMap([], true), providerCache = {
            $provide: {
                provider: supportObject(provider),
                factory: supportObject(factory),
                service: supportObject(service),
                value: supportObject(value),
                constant: supportObject(constant),
                decorator: decorator
            }
        }, providerInjector = providerCache.$injector = createInternalInjector(providerCache, function(serviceName, caller) {
            if (angular.isString(caller)) {
                path.push(caller);
            }
            throw $injectorMinErr("unpr", "Unknown provider: {0}", path.join(" <- "));
        }), instanceCache = {}, protoInstanceInjector = createInternalInjector(instanceCache, function(serviceName, caller) {
            var provider = providerInjector.get(serviceName + providerSuffix, caller);
            return instanceInjector.invoke(provider.$get, provider, undefined, serviceName);
        }), instanceInjector = protoInstanceInjector;
        providerCache["$injector" + providerSuffix] = {
            $get: valueFn(protoInstanceInjector)
        };
        var runBlocks = loadModules(modulesToLoad);
        instanceInjector = protoInstanceInjector.get("$injector");
        instanceInjector.strictDi = strictDi;
        forEach(runBlocks, function(fn) {
            if (fn) instanceInjector.invoke(fn);
        });
        return instanceInjector;
        function supportObject(delegate) {
            return function(key, value) {
                if (isObject(key)) {
                    forEach(key, reverseParams(delegate));
                } else {
                    return delegate(key, value);
                }
            };
        }
        function provider(name, provider_) {
            assertNotHasOwnProperty(name, "service");
            if (isFunction(provider_) || isArray(provider_)) {
                provider_ = providerInjector.instantiate(provider_);
            }
            if (!provider_.$get) {
                throw $injectorMinErr("pget", "Provider '{0}' must define $get factory method.", name);
            }
            return providerCache[name + providerSuffix] = provider_;
        }
        function enforceReturnValue(name, factory) {
            return function enforcedReturnValue() {
                var result = instanceInjector.invoke(factory, this);
                if (isUndefined(result)) {
                    throw $injectorMinErr("undef", "Provider '{0}' must return a value from $get factory method.", name);
                }
                return result;
            };
        }
        function factory(name, factoryFn, enforce) {
            return provider(name, {
                $get: enforce !== false ? enforceReturnValue(name, factoryFn) : factoryFn
            });
        }
        function service(name, constructor) {
            return factory(name, [ "$injector", function($injector) {
                return $injector.instantiate(constructor);
            } ]);
        }
        function value(name, val) {
            return factory(name, valueFn(val), false);
        }
        function constant(name, value) {
            assertNotHasOwnProperty(name, "constant");
            providerCache[name] = value;
            instanceCache[name] = value;
        }
        function decorator(serviceName, decorFn) {
            var origProvider = providerInjector.get(serviceName + providerSuffix), orig$get = origProvider.$get;
            origProvider.$get = function() {
                var origInstance = instanceInjector.invoke(orig$get, origProvider);
                return instanceInjector.invoke(decorFn, null, {
                    $delegate: origInstance
                });
            };
        }
        function loadModules(modulesToLoad) {
            assertArg(isUndefined(modulesToLoad) || isArray(modulesToLoad), "modulesToLoad", "not an array");
            var runBlocks = [], moduleFn;
            forEach(modulesToLoad, function(module) {
                if (loadedModules.get(module)) return;
                loadedModules.put(module, true);
                function runInvokeQueue(queue) {
                    var i, ii;
                    for (i = 0, ii = queue.length; i < ii; i++) {
                        var invokeArgs = queue[i], provider = providerInjector.get(invokeArgs[0]);
                        provider[invokeArgs[1]].apply(provider, invokeArgs[2]);
                    }
                }
                try {
                    if (isString(module)) {
                        moduleFn = angularModule(module);
                        runBlocks = runBlocks.concat(loadModules(moduleFn.requires)).concat(moduleFn._runBlocks);
                        runInvokeQueue(moduleFn._invokeQueue);
                        runInvokeQueue(moduleFn._configBlocks);
                    } else if (isFunction(module)) {
                        runBlocks.push(providerInjector.invoke(module));
                    } else if (isArray(module)) {
                        runBlocks.push(providerInjector.invoke(module));
                    } else {
                        assertArgFn(module, "module");
                    }
                } catch (e) {
                    if (isArray(module)) {
                        module = module[module.length - 1];
                    }
                    if (e.message && e.stack && e.stack.indexOf(e.message) === -1) {
                        e = e.message + "\n" + e.stack;
                    }
                    throw $injectorMinErr("modulerr", "Failed to instantiate module {0} due to:\n{1}", module, e.stack || e.message || e);
                }
            });
            return runBlocks;
        }
        function createInternalInjector(cache, factory) {
            function getService(serviceName, caller) {
                if (cache.hasOwnProperty(serviceName)) {
                    if (cache[serviceName] === INSTANTIATING) {
                        throw $injectorMinErr("cdep", "Circular dependency found: {0}", serviceName + " <- " + path.join(" <- "));
                    }
                    return cache[serviceName];
                } else {
                    try {
                        path.unshift(serviceName);
                        cache[serviceName] = INSTANTIATING;
                        cache[serviceName] = factory(serviceName, caller);
                        return cache[serviceName];
                    } catch (err) {
                        if (cache[serviceName] === INSTANTIATING) {
                            delete cache[serviceName];
                        }
                        throw err;
                    } finally {
                        path.shift();
                    }
                }
            }
            function injectionArgs(fn, locals, serviceName) {
                var args = [], $inject = createInjector.$$annotate(fn, strictDi, serviceName);
                for (var i = 0, length = $inject.length; i < length; i++) {
                    var key = $inject[i];
                    if (typeof key !== "string") {
                        throw $injectorMinErr("itkn", "Incorrect injection token! Expected service name as string, got {0}", key);
                    }
                    args.push(locals && locals.hasOwnProperty(key) ? locals[key] : getService(key, serviceName));
                }
                return args;
            }
            function isClass(func) {
                if (msie <= 11) {
                    return false;
                }
                return typeof func === "function" && /^(?:class\b|constructor\()/.test(stringifyFn(func));
            }
            function invoke(fn, self, locals, serviceName) {
                if (typeof locals === "string") {
                    serviceName = locals;
                    locals = null;
                }
                var args = injectionArgs(fn, locals, serviceName);
                if (isArray(fn)) {
                    fn = fn[fn.length - 1];
                }
                if (!isClass(fn)) {
                    return fn.apply(self, args);
                } else {
                    args.unshift(null);
                    return new (Function.prototype.bind.apply(fn, args))();
                }
            }
            function instantiate(Type, locals, serviceName) {
                var ctor = isArray(Type) ? Type[Type.length - 1] : Type;
                var args = injectionArgs(Type, locals, serviceName);
                args.unshift(null);
                return new (Function.prototype.bind.apply(ctor, args))();
            }
            return {
                invoke: invoke,
                instantiate: instantiate,
                get: getService,
                annotate: createInjector.$$annotate,
                has: function(name) {
                    return providerCache.hasOwnProperty(name + providerSuffix) || cache.hasOwnProperty(name);
                }
            };
        }
    }
    createInjector.$$annotate = annotate;
    function $AnchorScrollProvider() {
        var autoScrollingEnabled = true;
        this.disableAutoScrolling = function() {
            autoScrollingEnabled = false;
        };
        this.$get = [ "$window", "$location", "$rootScope", function($window, $location, $rootScope) {
            var document = $window.document;
            function getFirstAnchor(list) {
                var result = null;
                Array.prototype.some.call(list, function(element) {
                    if (nodeName_(element) === "a") {
                        result = element;
                        return true;
                    }
                });
                return result;
            }
            function getYOffset() {
                var offset = scroll.yOffset;
                if (isFunction(offset)) {
                    offset = offset();
                } else if (isElement(offset)) {
                    var elem = offset[0];
                    var style = $window.getComputedStyle(elem);
                    if (style.position !== "fixed") {
                        offset = 0;
                    } else {
                        offset = elem.getBoundingClientRect().bottom;
                    }
                } else if (!isNumber(offset)) {
                    offset = 0;
                }
                return offset;
            }
            function scrollTo(elem) {
                if (elem) {
                    elem.scrollIntoView();
                    var offset = getYOffset();
                    if (offset) {
                        var elemTop = elem.getBoundingClientRect().top;
                        $window.scrollBy(0, elemTop - offset);
                    }
                } else {
                    $window.scrollTo(0, 0);
                }
            }
            function scroll(hash) {
                hash = isString(hash) ? hash : isNumber(hash) ? hash.toString() : $location.hash();
                var elm;
                if (!hash) scrollTo(null); else if (elm = document.getElementById(hash)) scrollTo(elm); else if (elm = getFirstAnchor(document.getElementsByName(hash))) scrollTo(elm); else if (hash === "top") scrollTo(null);
            }
            if (autoScrollingEnabled) {
                $rootScope.$watch(function autoScrollWatch() {
                    return $location.hash();
                }, function autoScrollWatchAction(newVal, oldVal) {
                    if (newVal === oldVal && newVal === "") return;
                    jqLiteDocumentLoaded(function() {
                        $rootScope.$evalAsync(scroll);
                    });
                });
            }
            return scroll;
        } ];
    }
    var $animateMinErr = minErr("$animate");
    var ELEMENT_NODE = 1;
    var NG_ANIMATE_CLASSNAME = "ng-animate";
    function mergeClasses(a, b) {
        if (!a && !b) return "";
        if (!a) return b;
        if (!b) return a;
        if (isArray(a)) a = a.join(" ");
        if (isArray(b)) b = b.join(" ");
        return a + " " + b;
    }
    function extractElementNode(element) {
        for (var i = 0; i < element.length; i++) {
            var elm = element[i];
            if (elm.nodeType === ELEMENT_NODE) {
                return elm;
            }
        }
    }
    function splitClasses(classes) {
        if (isString(classes)) {
            classes = classes.split(" ");
        }
        var obj = createMap();
        forEach(classes, function(klass) {
            if (klass.length) {
                obj[klass] = true;
            }
        });
        return obj;
    }
    function prepareAnimateOptions(options) {
        return isObject(options) ? options : {};
    }
    var $$CoreAnimateJsProvider = function() {
        this.$get = noop;
    };
    var $$CoreAnimateQueueProvider = function() {
        var postDigestQueue = new HashMap();
        var postDigestElements = [];
        this.$get = [ "$$AnimateRunner", "$rootScope", function($$AnimateRunner, $rootScope) {
            return {
                enabled: noop,
                on: noop,
                off: noop,
                pin: noop,
                push: function(element, event, options, domOperation) {
                    if (domOperation) {
                        domOperation();
                    }
                    options = options || {};
                    if (options.from) {
                        element.css(options.from);
                    }
                    if (options.to) {
                        element.css(options.to);
                    }
                    if (options.addClass || options.removeClass) {
                        addRemoveClassesPostDigest(element, options.addClass, options.removeClass);
                    }
                    var runner = new $$AnimateRunner();
                    runner.complete();
                    return runner;
                }
            };
            function updateData(data, classes, value) {
                var changed = false;
                if (classes) {
                    classes = isString(classes) ? classes.split(" ") : isArray(classes) ? classes : [];
                    forEach(classes, function(className) {
                        if (className) {
                            changed = true;
                            data[className] = value;
                        }
                    });
                }
                return changed;
            }
            function handleCSSClassChanges() {
                forEach(postDigestElements, function(element) {
                    var data = postDigestQueue.get(element);
                    if (data) {
                        var existing = splitClasses(element.attr("class"));
                        var toAdd = "";
                        var toRemove = "";
                        forEach(data, function(status, className) {
                            var hasClass = !!existing[className];
                            if (status !== hasClass) {
                                if (status) {
                                    toAdd += (toAdd.length ? " " : "") + className;
                                } else {
                                    toRemove += (toRemove.length ? " " : "") + className;
                                }
                            }
                        });
                        forEach(element, function(elm) {
                            if (toAdd) {
                                jqLiteAddClass(elm, toAdd);
                            }
                            if (toRemove) {
                                jqLiteRemoveClass(elm, toRemove);
                            }
                        });
                        postDigestQueue.remove(element);
                    }
                });
                postDigestElements.length = 0;
            }
            function addRemoveClassesPostDigest(element, add, remove) {
                var data = postDigestQueue.get(element) || {};
                var classesAdded = updateData(data, add, true);
                var classesRemoved = updateData(data, remove, false);
                if (classesAdded || classesRemoved) {
                    postDigestQueue.put(element, data);
                    postDigestElements.push(element);
                    if (postDigestElements.length === 1) {
                        $rootScope.$$postDigest(handleCSSClassChanges);
                    }
                }
            }
        } ];
    };
    var $AnimateProvider = [ "$provide", function($provide) {
        var provider = this;
        this.$$registeredAnimations = Object.create(null);
        this.register = function(name, factory) {
            if (name && name.charAt(0) !== ".") {
                throw $animateMinErr("notcsel", "Expecting class selector starting with '.' got '{0}'.", name);
            }
            var key = name + "-animation";
            provider.$$registeredAnimations[name.substr(1)] = key;
            $provide.factory(key, factory);
        };
        this.classNameFilter = function(expression) {
            if (arguments.length === 1) {
                this.$$classNameFilter = expression instanceof RegExp ? expression : null;
                if (this.$$classNameFilter) {
                    var reservedRegex = new RegExp("(\\s+|\\/)" + NG_ANIMATE_CLASSNAME + "(\\s+|\\/)");
                    if (reservedRegex.test(this.$$classNameFilter.toString())) {
                        throw $animateMinErr("nongcls", '$animateProvider.classNameFilter(regex) prohibits accepting a regex value which matches/contains the "{0}" CSS class.', NG_ANIMATE_CLASSNAME);
                    }
                }
            }
            return this.$$classNameFilter;
        };
        this.$get = [ "$$animateQueue", function($$animateQueue) {
            function domInsert(element, parentElement, afterElement) {
                if (afterElement) {
                    var afterNode = extractElementNode(afterElement);
                    if (afterNode && !afterNode.parentNode && !afterNode.previousElementSibling) {
                        afterElement = null;
                    }
                }
                if (afterElement) {
                    afterElement.after(element);
                } else {
                    parentElement.prepend(element);
                }
            }
            return {
                on: $$animateQueue.on,
                off: $$animateQueue.off,
                pin: $$animateQueue.pin,
                enabled: $$animateQueue.enabled,
                cancel: function(runner) {
                    if (runner.end) {
                        runner.end();
                    }
                },
                enter: function(element, parent, after, options) {
                    parent = parent && jqLite(parent);
                    after = after && jqLite(after);
                    parent = parent || after.parent();
                    domInsert(element, parent, after);
                    return $$animateQueue.push(element, "enter", prepareAnimateOptions(options));
                },
                move: function(element, parent, after, options) {
                    parent = parent && jqLite(parent);
                    after = after && jqLite(after);
                    parent = parent || after.parent();
                    domInsert(element, parent, after);
                    return $$animateQueue.push(element, "move", prepareAnimateOptions(options));
                },
                leave: function(element, options) {
                    return $$animateQueue.push(element, "leave", prepareAnimateOptions(options), function() {
                        element.remove();
                    });
                },
                addClass: function(element, className, options) {
                    options = prepareAnimateOptions(options);
                    options.addClass = mergeClasses(options.addclass, className);
                    return $$animateQueue.push(element, "addClass", options);
                },
                removeClass: function(element, className, options) {
                    options = prepareAnimateOptions(options);
                    options.removeClass = mergeClasses(options.removeClass, className);
                    return $$animateQueue.push(element, "removeClass", options);
                },
                setClass: function(element, add, remove, options) {
                    options = prepareAnimateOptions(options);
                    options.addClass = mergeClasses(options.addClass, add);
                    options.removeClass = mergeClasses(options.removeClass, remove);
                    return $$animateQueue.push(element, "setClass", options);
                },
                animate: function(element, from, to, className, options) {
                    options = prepareAnimateOptions(options);
                    options.from = options.from ? extend(options.from, from) : from;
                    options.to = options.to ? extend(options.to, to) : to;
                    className = className || "ng-inline-animate";
                    options.tempClasses = mergeClasses(options.tempClasses, className);
                    return $$animateQueue.push(element, "animate", options);
                }
            };
        } ];
    } ];
    var $$AnimateAsyncRunFactoryProvider = function() {
        this.$get = [ "$$rAF", function($$rAF) {
            var waitQueue = [];
            function waitForTick(fn) {
                waitQueue.push(fn);
                if (waitQueue.length > 1) return;
                $$rAF(function() {
                    for (var i = 0; i < waitQueue.length; i++) {
                        waitQueue[i]();
                    }
                    waitQueue = [];
                });
            }
            return function() {
                var passed = false;
                waitForTick(function() {
                    passed = true;
                });
                return function(callback) {
                    if (passed) {
                        callback();
                    } else {
                        waitForTick(callback);
                    }
                };
            };
        } ];
    };
    var $$AnimateRunnerFactoryProvider = function() {
        this.$get = [ "$q", "$sniffer", "$$animateAsyncRun", "$document", "$timeout", function($q, $sniffer, $$animateAsyncRun, $document, $timeout) {
            var INITIAL_STATE = 0;
            var DONE_PENDING_STATE = 1;
            var DONE_COMPLETE_STATE = 2;
            AnimateRunner.chain = function(chain, callback) {
                var index = 0;
                next();
                function next() {
                    if (index === chain.length) {
                        callback(true);
                        return;
                    }
                    chain[index](function(response) {
                        if (response === false) {
                            callback(false);
                            return;
                        }
                        index++;
                        next();
                    });
                }
            };
            AnimateRunner.all = function(runners, callback) {
                var count = 0;
                var status = true;
                forEach(runners, function(runner) {
                    runner.done(onProgress);
                });
                function onProgress(response) {
                    status = status && response;
                    if (++count === runners.length) {
                        callback(status);
                    }
                }
            };
            function AnimateRunner(host) {
                this.setHost(host);
                var rafTick = $$animateAsyncRun();
                var timeoutTick = function(fn) {
                    $timeout(fn, 0, false);
                };
                this._doneCallbacks = [];
                this._tick = function(fn) {
                    var doc = $document[0];
                    if (doc && doc.hidden) {
                        timeoutTick(fn);
                    } else {
                        rafTick(fn);
                    }
                };
                this._state = 0;
            }
            AnimateRunner.prototype = {
                setHost: function(host) {
                    this.host = host || {};
                },
                done: function(fn) {
                    if (this._state === DONE_COMPLETE_STATE) {
                        fn();
                    } else {
                        this._doneCallbacks.push(fn);
                    }
                },
                progress: noop,
                getPromise: function() {
                    if (!this.promise) {
                        var self = this;
                        this.promise = $q(function(resolve, reject) {
                            self.done(function(status) {
                                if (status === false) {
                                    reject();
                                } else {
                                    resolve();
                                }
                            });
                        });
                    }
                    return this.promise;
                },
                then: function(resolveHandler, rejectHandler) {
                    return this.getPromise().then(resolveHandler, rejectHandler);
                },
                "catch": function(handler) {
                    return this.getPromise()["catch"](handler);
                },
                "finally": function(handler) {
                    return this.getPromise()["finally"](handler);
                },
                pause: function() {
                    if (this.host.pause) {
                        this.host.pause();
                    }
                },
                resume: function() {
                    if (this.host.resume) {
                        this.host.resume();
                    }
                },
                end: function() {
                    if (this.host.end) {
                        this.host.end();
                    }
                    this._resolve(true);
                },
                cancel: function() {
                    if (this.host.cancel) {
                        this.host.cancel();
                    }
                    this._resolve(false);
                },
                complete: function(response) {
                    var self = this;
                    if (self._state === INITIAL_STATE) {
                        self._state = DONE_PENDING_STATE;
                        self._tick(function() {
                            self._resolve(response);
                        });
                    }
                },
                _resolve: function(response) {
                    if (this._state !== DONE_COMPLETE_STATE) {
                        forEach(this._doneCallbacks, function(fn) {
                            fn(response);
                        });
                        this._doneCallbacks.length = 0;
                        this._state = DONE_COMPLETE_STATE;
                    }
                }
            };
            return AnimateRunner;
        } ];
    };
    var $CoreAnimateCssProvider = function() {
        this.$get = [ "$$rAF", "$q", "$$AnimateRunner", function($$rAF, $q, $$AnimateRunner) {
            return function(element, initialOptions) {
                var options = initialOptions || {};
                if (!options.$$prepared) {
                    options = copy(options);
                }
                if (options.cleanupStyles) {
                    options.from = options.to = null;
                }
                if (options.from) {
                    element.css(options.from);
                    options.from = null;
                }
                var closed, runner = new $$AnimateRunner();
                return {
                    start: run,
                    end: run
                };
                function run() {
                    $$rAF(function() {
                        applyAnimationContents();
                        if (!closed) {
                            runner.complete();
                        }
                        closed = true;
                    });
                    return runner;
                }
                function applyAnimationContents() {
                    if (options.addClass) {
                        element.addClass(options.addClass);
                        options.addClass = null;
                    }
                    if (options.removeClass) {
                        element.removeClass(options.removeClass);
                        options.removeClass = null;
                    }
                    if (options.to) {
                        element.css(options.to);
                        options.to = null;
                    }
                }
            };
        } ];
    };
    function Browser(window, document, $log, $sniffer) {
        var self = this, location = window.location, history = window.history, setTimeout = window.setTimeout, clearTimeout = window.clearTimeout, pendingDeferIds = {};
        self.isMock = false;
        var outstandingRequestCount = 0;
        var outstandingRequestCallbacks = [];
        self.$$completeOutstandingRequest = completeOutstandingRequest;
        self.$$incOutstandingRequestCount = function() {
            outstandingRequestCount++;
        };
        function completeOutstandingRequest(fn) {
            try {
                fn.apply(null, sliceArgs(arguments, 1));
            } finally {
                outstandingRequestCount--;
                if (outstandingRequestCount === 0) {
                    while (outstandingRequestCallbacks.length) {
                        try {
                            outstandingRequestCallbacks.pop()();
                        } catch (e) {
                            $log.error(e);
                        }
                    }
                }
            }
        }
        function getHash(url) {
            var index = url.indexOf("#");
            return index === -1 ? "" : url.substr(index);
        }
        self.notifyWhenNoOutstandingRequests = function(callback) {
            if (outstandingRequestCount === 0) {
                callback();
            } else {
                outstandingRequestCallbacks.push(callback);
            }
        };
        var cachedState, lastHistoryState, lastBrowserUrl = location.href, baseElement = document.find("base"), pendingLocation = null, getCurrentState = !$sniffer.history ? noop : function getCurrentState() {
            try {
                return history.state;
            } catch (e) {}
        };
        cacheState();
        lastHistoryState = cachedState;
        self.url = function(url, replace, state) {
            if (isUndefined(state)) {
                state = null;
            }
            if (location !== window.location) location = window.location;
            if (history !== window.history) history = window.history;
            if (url) {
                var sameState = lastHistoryState === state;
                if (lastBrowserUrl === url && (!$sniffer.history || sameState)) {
                    return self;
                }
                var sameBase = lastBrowserUrl && stripHash(lastBrowserUrl) === stripHash(url);
                lastBrowserUrl = url;
                lastHistoryState = state;
                if ($sniffer.history && (!sameBase || !sameState)) {
                    history[replace ? "replaceState" : "pushState"](state, "", url);
                    cacheState();
                    lastHistoryState = cachedState;
                } else {
                    if (!sameBase) {
                        pendingLocation = url;
                    }
                    if (replace) {
                        location.replace(url);
                    } else if (!sameBase) {
                        location.href = url;
                    } else {
                        location.hash = getHash(url);
                    }
                    if (location.href !== url) {
                        pendingLocation = url;
                    }
                }
                if (pendingLocation) {
                    pendingLocation = url;
                }
                return self;
            } else {
                return pendingLocation || location.href.replace(/%27/g, "'");
            }
        };
        self.state = function() {
            return cachedState;
        };
        var urlChangeListeners = [], urlChangeInit = false;
        function cacheStateAndFireUrlChange() {
            pendingLocation = null;
            cacheState();
            fireUrlChange();
        }
        var lastCachedState = null;
        function cacheState() {
            cachedState = getCurrentState();
            cachedState = isUndefined(cachedState) ? null : cachedState;
            if (equals(cachedState, lastCachedState)) {
                cachedState = lastCachedState;
            }
            lastCachedState = cachedState;
        }
        function fireUrlChange() {
            if (lastBrowserUrl === self.url() && lastHistoryState === cachedState) {
                return;
            }
            lastBrowserUrl = self.url();
            lastHistoryState = cachedState;
            forEach(urlChangeListeners, function(listener) {
                listener(self.url(), cachedState);
            });
        }
        self.onUrlChange = function(callback) {
            if (!urlChangeInit) {
                if ($sniffer.history) jqLite(window).on("popstate", cacheStateAndFireUrlChange);
                jqLite(window).on("hashchange", cacheStateAndFireUrlChange);
                urlChangeInit = true;
            }
            urlChangeListeners.push(callback);
            return callback;
        };
        self.$$applicationDestroyed = function() {
            jqLite(window).off("hashchange popstate", cacheStateAndFireUrlChange);
        };
        self.$$checkUrlChange = fireUrlChange;
        self.baseHref = function() {
            var href = baseElement.attr("href");
            return href ? href.replace(/^(https?:)?\/\/[^\/]*/, "") : "";
        };
        self.defer = function(fn, delay) {
            var timeoutId;
            outstandingRequestCount++;
            timeoutId = setTimeout(function() {
                delete pendingDeferIds[timeoutId];
                completeOutstandingRequest(fn);
            }, delay || 0);
            pendingDeferIds[timeoutId] = true;
            return timeoutId;
        };
        self.defer.cancel = function(deferId) {
            if (pendingDeferIds[deferId]) {
                delete pendingDeferIds[deferId];
                clearTimeout(deferId);
                completeOutstandingRequest(noop);
                return true;
            }
            return false;
        };
    }
    function $BrowserProvider() {
        this.$get = [ "$window", "$log", "$sniffer", "$document", function($window, $log, $sniffer, $document) {
            return new Browser($window, $document, $log, $sniffer);
        } ];
    }
    function $CacheFactoryProvider() {
        this.$get = function() {
            var caches = {};
            function cacheFactory(cacheId, options) {
                if (cacheId in caches) {
                    throw minErr("$cacheFactory")("iid", "CacheId '{0}' is already taken!", cacheId);
                }
                var size = 0, stats = extend({}, options, {
                    id: cacheId
                }), data = createMap(), capacity = options && options.capacity || Number.MAX_VALUE, lruHash = createMap(), freshEnd = null, staleEnd = null;
                return caches[cacheId] = {
                    put: function(key, value) {
                        if (isUndefined(value)) return;
                        if (capacity < Number.MAX_VALUE) {
                            var lruEntry = lruHash[key] || (lruHash[key] = {
                                key: key
                            });
                            refresh(lruEntry);
                        }
                        if (!(key in data)) size++;
                        data[key] = value;
                        if (size > capacity) {
                            this.remove(staleEnd.key);
                        }
                        return value;
                    },
                    get: function(key) {
                        if (capacity < Number.MAX_VALUE) {
                            var lruEntry = lruHash[key];
                            if (!lruEntry) return;
                            refresh(lruEntry);
                        }
                        return data[key];
                    },
                    remove: function(key) {
                        if (capacity < Number.MAX_VALUE) {
                            var lruEntry = lruHash[key];
                            if (!lruEntry) return;
                            if (lruEntry === freshEnd) freshEnd = lruEntry.p;
                            if (lruEntry === staleEnd) staleEnd = lruEntry.n;
                            link(lruEntry.n, lruEntry.p);
                            delete lruHash[key];
                        }
                        if (!(key in data)) return;
                        delete data[key];
                        size--;
                    },
                    removeAll: function() {
                        data = createMap();
                        size = 0;
                        lruHash = createMap();
                        freshEnd = staleEnd = null;
                    },
                    destroy: function() {
                        data = null;
                        stats = null;
                        lruHash = null;
                        delete caches[cacheId];
                    },
                    info: function() {
                        return extend({}, stats, {
                            size: size
                        });
                    }
                };
                function refresh(entry) {
                    if (entry !== freshEnd) {
                        if (!staleEnd) {
                            staleEnd = entry;
                        } else if (staleEnd === entry) {
                            staleEnd = entry.n;
                        }
                        link(entry.n, entry.p);
                        link(entry, freshEnd);
                        freshEnd = entry;
                        freshEnd.n = null;
                    }
                }
                function link(nextEntry, prevEntry) {
                    if (nextEntry !== prevEntry) {
                        if (nextEntry) nextEntry.p = prevEntry;
                        if (prevEntry) prevEntry.n = nextEntry;
                    }
                }
            }
            cacheFactory.info = function() {
                var info = {};
                forEach(caches, function(cache, cacheId) {
                    info[cacheId] = cache.info();
                });
                return info;
            };
            cacheFactory.get = function(cacheId) {
                return caches[cacheId];
            };
            return cacheFactory;
        };
    }
    function $TemplateCacheProvider() {
        this.$get = [ "$cacheFactory", function($cacheFactory) {
            return $cacheFactory("templates");
        } ];
    }
    var $compileMinErr = minErr("$compile");
    function UNINITIALIZED_VALUE() {}
    var _UNINITIALIZED_VALUE = new UNINITIALIZED_VALUE();
    $CompileProvider.$inject = [ "$provide", "$$sanitizeUriProvider" ];
    function $CompileProvider($provide, $$sanitizeUriProvider) {
        var hasDirectives = {}, Suffix = "Directive", COMMENT_DIRECTIVE_REGEXP = /^\s*directive:\s*([\w-]+)\s+(.*)$/, CLASS_DIRECTIVE_REGEXP = /(([\w-]+)(?::([^;]+))?;?)/, ALL_OR_NOTHING_ATTRS = makeMap("ngSrc,ngSrcset,src,srcset"), REQUIRE_PREFIX_REGEXP = /^(?:(\^\^?)?(\?)?(\^\^?)?)?/;
        var EVENT_HANDLER_ATTR_REGEXP = /^(on[a-z]+|formaction)$/;
        var bindingCache = createMap();
        function parseIsolateBindings(scope, directiveName, isController) {
            var LOCAL_REGEXP = /^\s*([@&<]|=(\*?))(\??)\s*([\w$]*)\s*$/;
            var bindings = createMap();
            forEach(scope, function(definition, scopeName) {
                if (definition in bindingCache) {
                    bindings[scopeName] = bindingCache[definition];
                    return;
                }
                var match = definition.match(LOCAL_REGEXP);
                if (!match) {
                    throw $compileMinErr("iscp", "Invalid {3} for directive '{0}'." + " Definition: {... {1}: '{2}' ...}", directiveName, scopeName, definition, isController ? "controller bindings definition" : "isolate scope definition");
                }
                bindings[scopeName] = {
                    mode: match[1][0],
                    collection: match[2] === "*",
                    optional: match[3] === "?",
                    attrName: match[4] || scopeName
                };
                if (match[4]) {
                    bindingCache[definition] = bindings[scopeName];
                }
            });
            return bindings;
        }
        function parseDirectiveBindings(directive, directiveName) {
            var bindings = {
                isolateScope: null,
                bindToController: null
            };
            if (isObject(directive.scope)) {
                if (directive.bindToController === true) {
                    bindings.bindToController = parseIsolateBindings(directive.scope, directiveName, true);
                    bindings.isolateScope = {};
                } else {
                    bindings.isolateScope = parseIsolateBindings(directive.scope, directiveName, false);
                }
            }
            if (isObject(directive.bindToController)) {
                bindings.bindToController = parseIsolateBindings(directive.bindToController, directiveName, true);
            }
            if (bindings.bindToController && !directive.controller) {
                throw $compileMinErr("noctrl", "Cannot bind to controller without directive '{0}'s controller.", directiveName);
            }
            return bindings;
        }
        function assertValidDirectiveName(name) {
            var letter = name.charAt(0);
            if (!letter || letter !== lowercase(letter)) {
                throw $compileMinErr("baddir", "Directive/Component name '{0}' is invalid. The first character must be a lowercase letter", name);
            }
            if (name !== name.trim()) {
                throw $compileMinErr("baddir", "Directive/Component name '{0}' is invalid. The name should not contain leading or trailing whitespaces", name);
            }
        }
        function getDirectiveRequire(directive) {
            var require = directive.require || directive.controller && directive.name;
            if (!isArray(require) && isObject(require)) {
                forEach(require, function(value, key) {
                    var match = value.match(REQUIRE_PREFIX_REGEXP);
                    var name = value.substring(match[0].length);
                    if (!name) require[key] = match[0] + key;
                });
            }
            return require;
        }
        function getDirectiveRestrict(restrict, name) {
            if (restrict && !(isString(restrict) && /[EACM]/.test(restrict))) {
                throw $compileMinErr("badrestrict", "Restrict property '{0}' of directive '{1}' is invalid", restrict, name);
            }
            return restrict || "EA";
        }
        this.directive = function registerDirective(name, directiveFactory) {
            assertArg(name, "name");
            assertNotHasOwnProperty(name, "directive");
            if (isString(name)) {
                assertValidDirectiveName(name);
                assertArg(directiveFactory, "directiveFactory");
                if (!hasDirectives.hasOwnProperty(name)) {
                    hasDirectives[name] = [];
                    $provide.factory(name + Suffix, [ "$injector", "$exceptionHandler", function($injector, $exceptionHandler) {
                        var directives = [];
                        forEach(hasDirectives[name], function(directiveFactory, index) {
                            try {
                                var directive = $injector.invoke(directiveFactory);
                                if (isFunction(directive)) {
                                    directive = {
                                        compile: valueFn(directive)
                                    };
                                } else if (!directive.compile && directive.link) {
                                    directive.compile = valueFn(directive.link);
                                }
                                directive.priority = directive.priority || 0;
                                directive.index = index;
                                directive.name = directive.name || name;
                                directive.require = getDirectiveRequire(directive);
                                directive.restrict = getDirectiveRestrict(directive.restrict, name);
                                directive.$$moduleName = directiveFactory.$$moduleName;
                                directives.push(directive);
                            } catch (e) {
                                $exceptionHandler(e);
                            }
                        });
                        return directives;
                    } ]);
                }
                hasDirectives[name].push(directiveFactory);
            } else {
                forEach(name, reverseParams(registerDirective));
            }
            return this;
        };
        this.component = function registerComponent(name, options) {
            var controller = options.controller || function() {};
            function factory($injector) {
                function makeInjectable(fn) {
                    if (isFunction(fn) || isArray(fn)) {
                        return function(tElement, tAttrs) {
                            return $injector.invoke(fn, this, {
                                $element: tElement,
                                $attrs: tAttrs
                            });
                        };
                    } else {
                        return fn;
                    }
                }
                var template = !options.template && !options.templateUrl ? "" : options.template;
                var ddo = {
                    controller: controller,
                    controllerAs: identifierForController(options.controller) || options.controllerAs || "$ctrl",
                    template: makeInjectable(template),
                    templateUrl: makeInjectable(options.templateUrl),
                    transclude: options.transclude,
                    scope: {},
                    bindToController: options.bindings || {},
                    restrict: "E",
                    require: options.require
                };
                forEach(options, function(val, key) {
                    if (key.charAt(0) === "$") ddo[key] = val;
                });
                return ddo;
            }
            forEach(options, function(val, key) {
                if (key.charAt(0) === "$") {
                    factory[key] = val;
                    if (isFunction(controller)) controller[key] = val;
                }
            });
            factory.$inject = [ "$injector" ];
            return this.directive(name, factory);
        };
        this.aHrefSanitizationWhitelist = function(regexp) {
            if (isDefined(regexp)) {
                $$sanitizeUriProvider.aHrefSanitizationWhitelist(regexp);
                return this;
            } else {
                return $$sanitizeUriProvider.aHrefSanitizationWhitelist();
            }
        };
        this.imgSrcSanitizationWhitelist = function(regexp) {
            if (isDefined(regexp)) {
                $$sanitizeUriProvider.imgSrcSanitizationWhitelist(regexp);
                return this;
            } else {
                return $$sanitizeUriProvider.imgSrcSanitizationWhitelist();
            }
        };
        var debugInfoEnabled = true;
        this.debugInfoEnabled = function(enabled) {
            if (isDefined(enabled)) {
                debugInfoEnabled = enabled;
                return this;
            }
            return debugInfoEnabled;
        };
        var preAssignBindingsEnabled = true;
        this.preAssignBindingsEnabled = function(enabled) {
            if (isDefined(enabled)) {
                preAssignBindingsEnabled = enabled;
                return this;
            }
            return preAssignBindingsEnabled;
        };
        var TTL = 10;
        this.onChangesTtl = function(value) {
            if (arguments.length) {
                TTL = value;
                return this;
            }
            return TTL;
        };
        var commentDirectivesEnabledConfig = true;
        this.commentDirectivesEnabled = function(value) {
            if (arguments.length) {
                commentDirectivesEnabledConfig = value;
                return this;
            }
            return commentDirectivesEnabledConfig;
        };
        var cssClassDirectivesEnabledConfig = true;
        this.cssClassDirectivesEnabled = function(value) {
            if (arguments.length) {
                cssClassDirectivesEnabledConfig = value;
                return this;
            }
            return cssClassDirectivesEnabledConfig;
        };
        this.$get = [ "$injector", "$interpolate", "$exceptionHandler", "$templateRequest", "$parse", "$controller", "$rootScope", "$sce", "$animate", "$$sanitizeUri", function($injector, $interpolate, $exceptionHandler, $templateRequest, $parse, $controller, $rootScope, $sce, $animate, $$sanitizeUri) {
            var SIMPLE_ATTR_NAME = /^\w/;
            var specialAttrHolder = window.document.createElement("div");
            var commentDirectivesEnabled = commentDirectivesEnabledConfig;
            var cssClassDirectivesEnabled = cssClassDirectivesEnabledConfig;
            var onChangesTtl = TTL;
            var onChangesQueue;
            function flushOnChangesQueue() {
                try {
                    if (!--onChangesTtl) {
                        onChangesQueue = undefined;
                        throw $compileMinErr("infchng", "{0} $onChanges() iterations reached. Aborting!\n", TTL);
                    }
                    $rootScope.$apply(function() {
                        var errors = [];
                        for (var i = 0, ii = onChangesQueue.length; i < ii; ++i) {
                            try {
                                onChangesQueue[i]();
                            } catch (e) {
                                errors.push(e);
                            }
                        }
                        onChangesQueue = undefined;
                        if (errors.length) {
                            throw errors;
                        }
                    });
                } finally {
                    onChangesTtl++;
                }
            }
            function Attributes(element, attributesToCopy) {
                if (attributesToCopy) {
                    var keys = Object.keys(attributesToCopy);
                    var i, l, key;
                    for (i = 0, l = keys.length; i < l; i++) {
                        key = keys[i];
                        this[key] = attributesToCopy[key];
                    }
                } else {
                    this.$attr = {};
                }
                this.$$element = element;
            }
            Attributes.prototype = {
                $normalize: directiveNormalize,
                $addClass: function(classVal) {
                    if (classVal && classVal.length > 0) {
                        $animate.addClass(this.$$element, classVal);
                    }
                },
                $removeClass: function(classVal) {
                    if (classVal && classVal.length > 0) {
                        $animate.removeClass(this.$$element, classVal);
                    }
                },
                $updateClass: function(newClasses, oldClasses) {
                    var toAdd = tokenDifference(newClasses, oldClasses);
                    if (toAdd && toAdd.length) {
                        $animate.addClass(this.$$element, toAdd);
                    }
                    var toRemove = tokenDifference(oldClasses, newClasses);
                    if (toRemove && toRemove.length) {
                        $animate.removeClass(this.$$element, toRemove);
                    }
                },
                $set: function(key, value, writeAttr, attrName) {
                    var node = this.$$element[0], booleanKey = getBooleanAttrName(node, key), aliasedKey = getAliasedAttrName(key), observer = key, nodeName;
                    if (booleanKey) {
                        this.$$element.prop(key, value);
                        attrName = booleanKey;
                    } else if (aliasedKey) {
                        this[aliasedKey] = value;
                        observer = aliasedKey;
                    }
                    this[key] = value;
                    if (attrName) {
                        this.$attr[key] = attrName;
                    } else {
                        attrName = this.$attr[key];
                        if (!attrName) {
                            this.$attr[key] = attrName = snake_case(key, "-");
                        }
                    }
                    nodeName = nodeName_(this.$$element);
                    if (nodeName === "a" && (key === "href" || key === "xlinkHref") || nodeName === "img" && key === "src") {
                        this[key] = value = $$sanitizeUri(value, key === "src");
                    } else if (nodeName === "img" && key === "srcset" && isDefined(value)) {
                        var result = "";
                        var trimmedSrcset = trim(value);
                        var srcPattern = /(\s+\d+x\s*,|\s+\d+w\s*,|\s+,|,\s+)/;
                        var pattern = /\s/.test(trimmedSrcset) ? srcPattern : /(,)/;
                        var rawUris = trimmedSrcset.split(pattern);
                        var nbrUrisWith2parts = Math.floor(rawUris.length / 2);
                        for (var i = 0; i < nbrUrisWith2parts; i++) {
                            var innerIdx = i * 2;
                            result += $$sanitizeUri(trim(rawUris[innerIdx]), true);
                            result += " " + trim(rawUris[innerIdx + 1]);
                        }
                        var lastTuple = trim(rawUris[i * 2]).split(/\s/);
                        result += $$sanitizeUri(trim(lastTuple[0]), true);
                        if (lastTuple.length === 2) {
                            result += " " + trim(lastTuple[1]);
                        }
                        this[key] = value = result;
                    }
                    if (writeAttr !== false) {
                        if (value === null || isUndefined(value)) {
                            this.$$element.removeAttr(attrName);
                        } else {
                            if (SIMPLE_ATTR_NAME.test(attrName)) {
                                this.$$element.attr(attrName, value);
                            } else {
                                setSpecialAttr(this.$$element[0], attrName, value);
                            }
                        }
                    }
                    var $$observers = this.$$observers;
                    if ($$observers) {
                        forEach($$observers[observer], function(fn) {
                            try {
                                fn(value);
                            } catch (e) {
                                $exceptionHandler(e);
                            }
                        });
                    }
                },
                $observe: function(key, fn) {
                    var attrs = this, $$observers = attrs.$$observers || (attrs.$$observers = createMap()), listeners = $$observers[key] || ($$observers[key] = []);
                    listeners.push(fn);
                    $rootScope.$evalAsync(function() {
                        if (!listeners.$$inter && attrs.hasOwnProperty(key) && !isUndefined(attrs[key])) {
                            fn(attrs[key]);
                        }
                    });
                    return function() {
                        arrayRemove(listeners, fn);
                    };
                }
            };
            function setSpecialAttr(element, attrName, value) {
                specialAttrHolder.innerHTML = "<span " + attrName + ">";
                var attributes = specialAttrHolder.firstChild.attributes;
                var attribute = attributes[0];
                attributes.removeNamedItem(attribute.name);
                attribute.value = value;
                element.attributes.setNamedItem(attribute);
            }
            function safeAddClass($element, className) {
                try {
                    $element.addClass(className);
                } catch (e) {}
            }
            var startSymbol = $interpolate.startSymbol(), endSymbol = $interpolate.endSymbol(), denormalizeTemplate = startSymbol === "{{" && endSymbol === "}}" ? identity : function denormalizeTemplate(template) {
                return template.replace(/\{\{/g, startSymbol).replace(/}}/g, endSymbol);
            }, NG_ATTR_BINDING = /^ngAttr[A-Z]/;
            var MULTI_ELEMENT_DIR_RE = /^(.+)Start$/;
            compile.$$addBindingInfo = debugInfoEnabled ? function $$addBindingInfo($element, binding) {
                var bindings = $element.data("$binding") || [];
                if (isArray(binding)) {
                    bindings = bindings.concat(binding);
                } else {
                    bindings.push(binding);
                }
                $element.data("$binding", bindings);
            } : noop;
            compile.$$addBindingClass = debugInfoEnabled ? function $$addBindingClass($element) {
                safeAddClass($element, "ng-binding");
            } : noop;
            compile.$$addScopeInfo = debugInfoEnabled ? function $$addScopeInfo($element, scope, isolated, noTemplate) {
                var dataName = isolated ? noTemplate ? "$isolateScopeNoTemplate" : "$isolateScope" : "$scope";
                $element.data(dataName, scope);
            } : noop;
            compile.$$addScopeClass = debugInfoEnabled ? function $$addScopeClass($element, isolated) {
                safeAddClass($element, isolated ? "ng-isolate-scope" : "ng-scope");
            } : noop;
            compile.$$createComment = function(directiveName, comment) {
                var content = "";
                if (debugInfoEnabled) {
                    content = " " + (directiveName || "") + ": ";
                    if (comment) content += comment + " ";
                }
                return window.document.createComment(content);
            };
            return compile;
            function compile($compileNodes, transcludeFn, maxPriority, ignoreDirective, previousCompileContext) {
                if (!($compileNodes instanceof jqLite)) {
                    $compileNodes = jqLite($compileNodes);
                }
                var NOT_EMPTY = /\S+/;
                for (var i = 0, len = $compileNodes.length; i < len; i++) {
                    var domNode = $compileNodes[i];
                    if (domNode.nodeType === NODE_TYPE_TEXT && domNode.nodeValue.match(NOT_EMPTY)) {
                        jqLiteWrapNode(domNode, $compileNodes[i] = window.document.createElement("span"));
                    }
                }
                var compositeLinkFn = compileNodes($compileNodes, transcludeFn, $compileNodes, maxPriority, ignoreDirective, previousCompileContext);
                compile.$$addScopeClass($compileNodes);
                var namespace = null;
                return function publicLinkFn(scope, cloneConnectFn, options) {
                    assertArg(scope, "scope");
                    if (previousCompileContext && previousCompileContext.needsNewScope) {
                        scope = scope.$parent.$new();
                    }
                    options = options || {};
                    var parentBoundTranscludeFn = options.parentBoundTranscludeFn, transcludeControllers = options.transcludeControllers, futureParentElement = options.futureParentElement;
                    if (parentBoundTranscludeFn && parentBoundTranscludeFn.$$boundTransclude) {
                        parentBoundTranscludeFn = parentBoundTranscludeFn.$$boundTransclude;
                    }
                    if (!namespace) {
                        namespace = detectNamespaceForChildElements(futureParentElement);
                    }
                    var $linkNode;
                    if (namespace !== "html") {
                        $linkNode = jqLite(wrapTemplate(namespace, jqLite("<div>").append($compileNodes).html()));
                    } else if (cloneConnectFn) {
                        $linkNode = JQLitePrototype.clone.call($compileNodes);
                    } else {
                        $linkNode = $compileNodes;
                    }
                    if (transcludeControllers) {
                        for (var controllerName in transcludeControllers) {
                            $linkNode.data("$" + controllerName + "Controller", transcludeControllers[controllerName].instance);
                        }
                    }
                    compile.$$addScopeInfo($linkNode, scope);
                    if (cloneConnectFn) cloneConnectFn($linkNode, scope);
                    if (compositeLinkFn) compositeLinkFn(scope, $linkNode, $linkNode, parentBoundTranscludeFn);
                    return $linkNode;
                };
            }
            function detectNamespaceForChildElements(parentElement) {
                var node = parentElement && parentElement[0];
                if (!node) {
                    return "html";
                } else {
                    return nodeName_(node) !== "foreignobject" && toString.call(node).match(/SVG/) ? "svg" : "html";
                }
            }
            function compileNodes(nodeList, transcludeFn, $rootElement, maxPriority, ignoreDirective, previousCompileContext) {
                var linkFns = [], attrs, directives, nodeLinkFn, childNodes, childLinkFn, linkFnFound, nodeLinkFnFound;
                for (var i = 0; i < nodeList.length; i++) {
                    attrs = new Attributes();
                    directives = collectDirectives(nodeList[i], [], attrs, i === 0 ? maxPriority : undefined, ignoreDirective);
                    nodeLinkFn = directives.length ? applyDirectivesToNode(directives, nodeList[i], attrs, transcludeFn, $rootElement, null, [], [], previousCompileContext) : null;
                    if (nodeLinkFn && nodeLinkFn.scope) {
                        compile.$$addScopeClass(attrs.$$element);
                    }
                    childLinkFn = nodeLinkFn && nodeLinkFn.terminal || !(childNodes = nodeList[i].childNodes) || !childNodes.length ? null : compileNodes(childNodes, nodeLinkFn ? (nodeLinkFn.transcludeOnThisElement || !nodeLinkFn.templateOnThisElement) && nodeLinkFn.transclude : transcludeFn);
                    if (nodeLinkFn || childLinkFn) {
                        linkFns.push(i, nodeLinkFn, childLinkFn);
                        linkFnFound = true;
                        nodeLinkFnFound = nodeLinkFnFound || nodeLinkFn;
                    }
                    previousCompileContext = null;
                }
                return linkFnFound ? compositeLinkFn : null;
                function compositeLinkFn(scope, nodeList, $rootElement, parentBoundTranscludeFn) {
                    var nodeLinkFn, childLinkFn, node, childScope, i, ii, idx, childBoundTranscludeFn;
                    var stableNodeList;
                    if (nodeLinkFnFound) {
                        var nodeListLength = nodeList.length;
                        stableNodeList = new Array(nodeListLength);
                        for (i = 0; i < linkFns.length; i += 3) {
                            idx = linkFns[i];
                            stableNodeList[idx] = nodeList[idx];
                        }
                    } else {
                        stableNodeList = nodeList;
                    }
                    for (i = 0, ii = linkFns.length; i < ii; ) {
                        node = stableNodeList[linkFns[i++]];
                        nodeLinkFn = linkFns[i++];
                        childLinkFn = linkFns[i++];
                        if (nodeLinkFn) {
                            if (nodeLinkFn.scope) {
                                childScope = scope.$new();
                                compile.$$addScopeInfo(jqLite(node), childScope);
                            } else {
                                childScope = scope;
                            }
                            if (nodeLinkFn.transcludeOnThisElement) {
                                childBoundTranscludeFn = createBoundTranscludeFn(scope, nodeLinkFn.transclude, parentBoundTranscludeFn);
                            } else if (!nodeLinkFn.templateOnThisElement && parentBoundTranscludeFn) {
                                childBoundTranscludeFn = parentBoundTranscludeFn;
                            } else if (!parentBoundTranscludeFn && transcludeFn) {
                                childBoundTranscludeFn = createBoundTranscludeFn(scope, transcludeFn);
                            } else {
                                childBoundTranscludeFn = null;
                            }
                            nodeLinkFn(childLinkFn, childScope, node, $rootElement, childBoundTranscludeFn);
                        } else if (childLinkFn) {
                            childLinkFn(scope, node.childNodes, undefined, parentBoundTranscludeFn);
                        }
                    }
                }
            }
            function createBoundTranscludeFn(scope, transcludeFn, previousBoundTranscludeFn) {
                function boundTranscludeFn(transcludedScope, cloneFn, controllers, futureParentElement, containingScope) {
                    if (!transcludedScope) {
                        transcludedScope = scope.$new(false, containingScope);
                        transcludedScope.$$transcluded = true;
                    }
                    return transcludeFn(transcludedScope, cloneFn, {
                        parentBoundTranscludeFn: previousBoundTranscludeFn,
                        transcludeControllers: controllers,
                        futureParentElement: futureParentElement
                    });
                }
                var boundSlots = boundTranscludeFn.$$slots = createMap();
                for (var slotName in transcludeFn.$$slots) {
                    if (transcludeFn.$$slots[slotName]) {
                        boundSlots[slotName] = createBoundTranscludeFn(scope, transcludeFn.$$slots[slotName], previousBoundTranscludeFn);
                    } else {
                        boundSlots[slotName] = null;
                    }
                }
                return boundTranscludeFn;
            }
            function collectDirectives(node, directives, attrs, maxPriority, ignoreDirective) {
                var nodeType = node.nodeType, attrsMap = attrs.$attr, match, nodeName, className;
                switch (nodeType) {
                  case NODE_TYPE_ELEMENT:
                    nodeName = nodeName_(node);
                    addDirective(directives, directiveNormalize(nodeName), "E", maxPriority, ignoreDirective);
                    for (var attr, name, nName, ngAttrName, value, isNgAttr, nAttrs = node.attributes, j = 0, jj = nAttrs && nAttrs.length; j < jj; j++) {
                        var attrStartName = false;
                        var attrEndName = false;
                        attr = nAttrs[j];
                        name = attr.name;
                        value = trim(attr.value);
                        ngAttrName = directiveNormalize(name);
                        isNgAttr = NG_ATTR_BINDING.test(ngAttrName);
                        if (isNgAttr) {
                            name = name.replace(PREFIX_REGEXP, "").substr(8).replace(/_(.)/g, function(match, letter) {
                                return letter.toUpperCase();
                            });
                        }
                        var multiElementMatch = ngAttrName.match(MULTI_ELEMENT_DIR_RE);
                        if (multiElementMatch && directiveIsMultiElement(multiElementMatch[1])) {
                            attrStartName = name;
                            attrEndName = name.substr(0, name.length - 5) + "end";
                            name = name.substr(0, name.length - 6);
                        }
                        nName = directiveNormalize(name.toLowerCase());
                        attrsMap[nName] = name;
                        if (isNgAttr || !attrs.hasOwnProperty(nName)) {
                            attrs[nName] = value;
                            if (getBooleanAttrName(node, nName)) {
                                attrs[nName] = true;
                            }
                        }
                        addAttrInterpolateDirective(node, directives, value, nName, isNgAttr);
                        addDirective(directives, nName, "A", maxPriority, ignoreDirective, attrStartName, attrEndName);
                    }
                    if (nodeName === "input" && node.getAttribute("type") === "hidden") {
                        node.setAttribute("autocomplete", "off");
                    }
                    if (!cssClassDirectivesEnabled) break;
                    className = node.className;
                    if (isObject(className)) {
                        className = className.animVal;
                    }
                    if (isString(className) && className !== "") {
                        while (match = CLASS_DIRECTIVE_REGEXP.exec(className)) {
                            nName = directiveNormalize(match[2]);
                            if (addDirective(directives, nName, "C", maxPriority, ignoreDirective)) {
                                attrs[nName] = trim(match[3]);
                            }
                            className = className.substr(match.index + match[0].length);
                        }
                    }
                    break;

                  case NODE_TYPE_TEXT:
                    if (msie === 11) {
                        while (node.parentNode && node.nextSibling && node.nextSibling.nodeType === NODE_TYPE_TEXT) {
                            node.nodeValue = node.nodeValue + node.nextSibling.nodeValue;
                            node.parentNode.removeChild(node.nextSibling);
                        }
                    }
                    addTextInterpolateDirective(directives, node.nodeValue);
                    break;

                  case NODE_TYPE_COMMENT:
                    if (!commentDirectivesEnabled) break;
                    collectCommentDirectives(node, directives, attrs, maxPriority, ignoreDirective);
                    break;
                }
                directives.sort(byPriority);
                return directives;
            }
            function collectCommentDirectives(node, directives, attrs, maxPriority, ignoreDirective) {
                try {
                    var match = COMMENT_DIRECTIVE_REGEXP.exec(node.nodeValue);
                    if (match) {
                        var nName = directiveNormalize(match[1]);
                        if (addDirective(directives, nName, "M", maxPriority, ignoreDirective)) {
                            attrs[nName] = trim(match[2]);
                        }
                    }
                } catch (e) {}
            }
            function groupScan(node, attrStart, attrEnd) {
                var nodes = [];
                var depth = 0;
                if (attrStart && node.hasAttribute && node.hasAttribute(attrStart)) {
                    do {
                        if (!node) {
                            throw $compileMinErr("uterdir", "Unterminated attribute, found '{0}' but no matching '{1}' found.", attrStart, attrEnd);
                        }
                        if (node.nodeType === NODE_TYPE_ELEMENT) {
                            if (node.hasAttribute(attrStart)) depth++;
                            if (node.hasAttribute(attrEnd)) depth--;
                        }
                        nodes.push(node);
                        node = node.nextSibling;
                    } while (depth > 0);
                } else {
                    nodes.push(node);
                }
                return jqLite(nodes);
            }
            function groupElementsLinkFnWrapper(linkFn, attrStart, attrEnd) {
                return function groupedElementsLink(scope, element, attrs, controllers, transcludeFn) {
                    element = groupScan(element[0], attrStart, attrEnd);
                    return linkFn(scope, element, attrs, controllers, transcludeFn);
                };
            }
            function compilationGenerator(eager, $compileNodes, transcludeFn, maxPriority, ignoreDirective, previousCompileContext) {
                var compiled;
                if (eager) {
                    return compile($compileNodes, transcludeFn, maxPriority, ignoreDirective, previousCompileContext);
                }
                return function lazyCompilation() {
                    if (!compiled) {
                        compiled = compile($compileNodes, transcludeFn, maxPriority, ignoreDirective, previousCompileContext);
                        $compileNodes = transcludeFn = previousCompileContext = null;
                    }
                    return compiled.apply(this, arguments);
                };
            }
            function applyDirectivesToNode(directives, compileNode, templateAttrs, transcludeFn, jqCollection, originalReplaceDirective, preLinkFns, postLinkFns, previousCompileContext) {
                previousCompileContext = previousCompileContext || {};
                var terminalPriority = -Number.MAX_VALUE, newScopeDirective = previousCompileContext.newScopeDirective, controllerDirectives = previousCompileContext.controllerDirectives, newIsolateScopeDirective = previousCompileContext.newIsolateScopeDirective, templateDirective = previousCompileContext.templateDirective, nonTlbTranscludeDirective = previousCompileContext.nonTlbTranscludeDirective, hasTranscludeDirective = false, hasTemplate = false, hasElementTranscludeDirective = previousCompileContext.hasElementTranscludeDirective, $compileNode = templateAttrs.$$element = jqLite(compileNode), directive, directiveName, $template, replaceDirective = originalReplaceDirective, childTranscludeFn = transcludeFn, linkFn, didScanForMultipleTransclusion = false, mightHaveMultipleTransclusionError = false, directiveValue;
                for (var i = 0, ii = directives.length; i < ii; i++) {
                    directive = directives[i];
                    var attrStart = directive.$$start;
                    var attrEnd = directive.$$end;
                    if (attrStart) {
                        $compileNode = groupScan(compileNode, attrStart, attrEnd);
                    }
                    $template = undefined;
                    if (terminalPriority > directive.priority) {
                        break;
                    }
                    directiveValue = directive.scope;
                    if (directiveValue) {
                        if (!directive.templateUrl) {
                            if (isObject(directiveValue)) {
                                assertNoDuplicate("new/isolated scope", newIsolateScopeDirective || newScopeDirective, directive, $compileNode);
                                newIsolateScopeDirective = directive;
                            } else {
                                assertNoDuplicate("new/isolated scope", newIsolateScopeDirective, directive, $compileNode);
                            }
                        }
                        newScopeDirective = newScopeDirective || directive;
                    }
                    directiveName = directive.name;
                    if (!didScanForMultipleTransclusion && (directive.replace && (directive.templateUrl || directive.template) || directive.transclude && !directive.$$tlb)) {
                        var candidateDirective;
                        for (var scanningIndex = i + 1; candidateDirective = directives[scanningIndex++]; ) {
                            if (candidateDirective.transclude && !candidateDirective.$$tlb || candidateDirective.replace && (candidateDirective.templateUrl || candidateDirective.template)) {
                                mightHaveMultipleTransclusionError = true;
                                break;
                            }
                        }
                        didScanForMultipleTransclusion = true;
                    }
                    if (!directive.templateUrl && directive.controller) {
                        controllerDirectives = controllerDirectives || createMap();
                        assertNoDuplicate("'" + directiveName + "' controller", controllerDirectives[directiveName], directive, $compileNode);
                        controllerDirectives[directiveName] = directive;
                    }
                    directiveValue = directive.transclude;
                    if (directiveValue) {
                        hasTranscludeDirective = true;
                        if (!directive.$$tlb) {
                            assertNoDuplicate("transclusion", nonTlbTranscludeDirective, directive, $compileNode);
                            nonTlbTranscludeDirective = directive;
                        }
                        if (directiveValue === "element") {
                            hasElementTranscludeDirective = true;
                            terminalPriority = directive.priority;
                            $template = $compileNode;
                            $compileNode = templateAttrs.$$element = jqLite(compile.$$createComment(directiveName, templateAttrs[directiveName]));
                            compileNode = $compileNode[0];
                            replaceWith(jqCollection, sliceArgs($template), compileNode);
                            $template[0].$$parentNode = $template[0].parentNode;
                            childTranscludeFn = compilationGenerator(mightHaveMultipleTransclusionError, $template, transcludeFn, terminalPriority, replaceDirective && replaceDirective.name, {
                                nonTlbTranscludeDirective: nonTlbTranscludeDirective
                            });
                        } else {
                            var slots = createMap();
                            $template = jqLite(jqLiteClone(compileNode)).contents();
                            if (isObject(directiveValue)) {
                                $template = [];
                                var slotMap = createMap();
                                var filledSlots = createMap();
                                forEach(directiveValue, function(elementSelector, slotName) {
                                    var optional = elementSelector.charAt(0) === "?";
                                    elementSelector = optional ? elementSelector.substring(1) : elementSelector;
                                    slotMap[elementSelector] = slotName;
                                    slots[slotName] = null;
                                    filledSlots[slotName] = optional;
                                });
                                forEach($compileNode.contents(), function(node) {
                                    var slotName = slotMap[directiveNormalize(nodeName_(node))];
                                    if (slotName) {
                                        filledSlots[slotName] = true;
                                        slots[slotName] = slots[slotName] || [];
                                        slots[slotName].push(node);
                                    } else {
                                        $template.push(node);
                                    }
                                });
                                forEach(filledSlots, function(filled, slotName) {
                                    if (!filled) {
                                        throw $compileMinErr("reqslot", "Required transclusion slot `{0}` was not filled.", slotName);
                                    }
                                });
                                for (var slotName in slots) {
                                    if (slots[slotName]) {
                                        slots[slotName] = compilationGenerator(mightHaveMultipleTransclusionError, slots[slotName], transcludeFn);
                                    }
                                }
                            }
                            $compileNode.empty();
                            childTranscludeFn = compilationGenerator(mightHaveMultipleTransclusionError, $template, transcludeFn, undefined, undefined, {
                                needsNewScope: directive.$$isolateScope || directive.$$newScope
                            });
                            childTranscludeFn.$$slots = slots;
                        }
                    }
                    if (directive.template) {
                        hasTemplate = true;
                        assertNoDuplicate("template", templateDirective, directive, $compileNode);
                        templateDirective = directive;
                        directiveValue = isFunction(directive.template) ? directive.template($compileNode, templateAttrs) : directive.template;
                        directiveValue = denormalizeTemplate(directiveValue);
                        if (directive.replace) {
                            replaceDirective = directive;
                            if (jqLiteIsTextNode(directiveValue)) {
                                $template = [];
                            } else {
                                $template = removeComments(wrapTemplate(directive.templateNamespace, trim(directiveValue)));
                            }
                            compileNode = $template[0];
                            if ($template.length !== 1 || compileNode.nodeType !== NODE_TYPE_ELEMENT) {
                                throw $compileMinErr("tplrt", "Template for directive '{0}' must have exactly one root element. {1}", directiveName, "");
                            }
                            replaceWith(jqCollection, $compileNode, compileNode);
                            var newTemplateAttrs = {
                                $attr: {}
                            };
                            var templateDirectives = collectDirectives(compileNode, [], newTemplateAttrs);
                            var unprocessedDirectives = directives.splice(i + 1, directives.length - (i + 1));
                            if (newIsolateScopeDirective || newScopeDirective) {
                                markDirectiveScope(templateDirectives, newIsolateScopeDirective, newScopeDirective);
                            }
                            directives = directives.concat(templateDirectives).concat(unprocessedDirectives);
                            mergeTemplateAttributes(templateAttrs, newTemplateAttrs);
                            ii = directives.length;
                        } else {
                            $compileNode.html(directiveValue);
                        }
                    }
                    if (directive.templateUrl) {
                        hasTemplate = true;
                        assertNoDuplicate("template", templateDirective, directive, $compileNode);
                        templateDirective = directive;
                        if (directive.replace) {
                            replaceDirective = directive;
                        }
                        nodeLinkFn = compileTemplateUrl(directives.splice(i, directives.length - i), $compileNode, templateAttrs, jqCollection, hasTranscludeDirective && childTranscludeFn, preLinkFns, postLinkFns, {
                            controllerDirectives: controllerDirectives,
                            newScopeDirective: newScopeDirective !== directive && newScopeDirective,
                            newIsolateScopeDirective: newIsolateScopeDirective,
                            templateDirective: templateDirective,
                            nonTlbTranscludeDirective: nonTlbTranscludeDirective
                        });
                        ii = directives.length;
                    } else if (directive.compile) {
                        try {
                            linkFn = directive.compile($compileNode, templateAttrs, childTranscludeFn);
                            var context = directive.$$originalDirective || directive;
                            if (isFunction(linkFn)) {
                                addLinkFns(null, bind(context, linkFn), attrStart, attrEnd);
                            } else if (linkFn) {
                                addLinkFns(bind(context, linkFn.pre), bind(context, linkFn.post), attrStart, attrEnd);
                            }
                        } catch (e) {
                            $exceptionHandler(e, startingTag($compileNode));
                        }
                    }
                    if (directive.terminal) {
                        nodeLinkFn.terminal = true;
                        terminalPriority = Math.max(terminalPriority, directive.priority);
                    }
                }
                nodeLinkFn.scope = newScopeDirective && newScopeDirective.scope === true;
                nodeLinkFn.transcludeOnThisElement = hasTranscludeDirective;
                nodeLinkFn.templateOnThisElement = hasTemplate;
                nodeLinkFn.transclude = childTranscludeFn;
                previousCompileContext.hasElementTranscludeDirective = hasElementTranscludeDirective;
                return nodeLinkFn;
                function addLinkFns(pre, post, attrStart, attrEnd) {
                    if (pre) {
                        if (attrStart) pre = groupElementsLinkFnWrapper(pre, attrStart, attrEnd);
                        pre.require = directive.require;
                        pre.directiveName = directiveName;
                        if (newIsolateScopeDirective === directive || directive.$$isolateScope) {
                            pre = cloneAndAnnotateFn(pre, {
                                isolateScope: true
                            });
                        }
                        preLinkFns.push(pre);
                    }
                    if (post) {
                        if (attrStart) post = groupElementsLinkFnWrapper(post, attrStart, attrEnd);
                        post.require = directive.require;
                        post.directiveName = directiveName;
                        if (newIsolateScopeDirective === directive || directive.$$isolateScope) {
                            post = cloneAndAnnotateFn(post, {
                                isolateScope: true
                            });
                        }
                        postLinkFns.push(post);
                    }
                }
                function nodeLinkFn(childLinkFn, scope, linkNode, $rootElement, boundTranscludeFn) {
                    var i, ii, linkFn, isolateScope, controllerScope, elementControllers, transcludeFn, $element, attrs, scopeBindingInfo;
                    if (compileNode === linkNode) {
                        attrs = templateAttrs;
                        $element = templateAttrs.$$element;
                    } else {
                        $element = jqLite(linkNode);
                        attrs = new Attributes($element, templateAttrs);
                    }
                    controllerScope = scope;
                    if (newIsolateScopeDirective) {
                        isolateScope = scope.$new(true);
                    } else if (newScopeDirective) {
                        controllerScope = scope.$parent;
                    }
                    if (boundTranscludeFn) {
                        transcludeFn = controllersBoundTransclude;
                        transcludeFn.$$boundTransclude = boundTranscludeFn;
                        transcludeFn.isSlotFilled = function(slotName) {
                            return !!boundTranscludeFn.$$slots[slotName];
                        };
                    }
                    if (controllerDirectives) {
                        elementControllers = setupControllers($element, attrs, transcludeFn, controllerDirectives, isolateScope, scope, newIsolateScopeDirective);
                    }
                    if (newIsolateScopeDirective) {
                        compile.$$addScopeInfo($element, isolateScope, true, !(templateDirective && (templateDirective === newIsolateScopeDirective || templateDirective === newIsolateScopeDirective.$$originalDirective)));
                        compile.$$addScopeClass($element, true);
                        isolateScope.$$isolateBindings = newIsolateScopeDirective.$$isolateBindings;
                        scopeBindingInfo = initializeDirectiveBindings(scope, attrs, isolateScope, isolateScope.$$isolateBindings, newIsolateScopeDirective);
                        if (scopeBindingInfo.removeWatches) {
                            isolateScope.$on("$destroy", scopeBindingInfo.removeWatches);
                        }
                    }
                    for (var name in elementControllers) {
                        var controllerDirective = controllerDirectives[name];
                        var controller = elementControllers[name];
                        var bindings = controllerDirective.$$bindings.bindToController;
                        if (preAssignBindingsEnabled) {
                            if (bindings) {
                                controller.bindingInfo = initializeDirectiveBindings(controllerScope, attrs, controller.instance, bindings, controllerDirective);
                            } else {
                                controller.bindingInfo = {};
                            }
                            var controllerResult = controller();
                            if (controllerResult !== controller.instance) {
                                controller.instance = controllerResult;
                                $element.data("$" + controllerDirective.name + "Controller", controllerResult);
                                if (controller.bindingInfo.removeWatches) {
                                    controller.bindingInfo.removeWatches();
                                }
                                controller.bindingInfo = initializeDirectiveBindings(controllerScope, attrs, controller.instance, bindings, controllerDirective);
                            }
                        } else {
                            controller.instance = controller();
                            $element.data("$" + controllerDirective.name + "Controller", controller.instance);
                            controller.bindingInfo = initializeDirectiveBindings(controllerScope, attrs, controller.instance, bindings, controllerDirective);
                        }
                    }
                    forEach(controllerDirectives, function(controllerDirective, name) {
                        var require = controllerDirective.require;
                        if (controllerDirective.bindToController && !isArray(require) && isObject(require)) {
                            extend(elementControllers[name].instance, getControllers(name, require, $element, elementControllers));
                        }
                    });
                    forEach(elementControllers, function(controller) {
                        var controllerInstance = controller.instance;
                        if (isFunction(controllerInstance.$onChanges)) {
                            try {
                                controllerInstance.$onChanges(controller.bindingInfo.initialChanges);
                            } catch (e) {
                                $exceptionHandler(e);
                            }
                        }
                        if (isFunction(controllerInstance.$onInit)) {
                            try {
                                controllerInstance.$onInit();
                            } catch (e) {
                                $exceptionHandler(e);
                            }
                        }
                        if (isFunction(controllerInstance.$doCheck)) {
                            controllerScope.$watch(function() {
                                controllerInstance.$doCheck();
                            });
                            controllerInstance.$doCheck();
                        }
                        if (isFunction(controllerInstance.$onDestroy)) {
                            controllerScope.$on("$destroy", function callOnDestroyHook() {
                                controllerInstance.$onDestroy();
                            });
                        }
                    });
                    for (i = 0, ii = preLinkFns.length; i < ii; i++) {
                        linkFn = preLinkFns[i];
                        invokeLinkFn(linkFn, linkFn.isolateScope ? isolateScope : scope, $element, attrs, linkFn.require && getControllers(linkFn.directiveName, linkFn.require, $element, elementControllers), transcludeFn);
                    }
                    var scopeToChild = scope;
                    if (newIsolateScopeDirective && (newIsolateScopeDirective.template || newIsolateScopeDirective.templateUrl === null)) {
                        scopeToChild = isolateScope;
                    }
                    if (childLinkFn) {
                        childLinkFn(scopeToChild, linkNode.childNodes, undefined, boundTranscludeFn);
                    }
                    for (i = postLinkFns.length - 1; i >= 0; i--) {
                        linkFn = postLinkFns[i];
                        invokeLinkFn(linkFn, linkFn.isolateScope ? isolateScope : scope, $element, attrs, linkFn.require && getControllers(linkFn.directiveName, linkFn.require, $element, elementControllers), transcludeFn);
                    }
                    forEach(elementControllers, function(controller) {
                        var controllerInstance = controller.instance;
                        if (isFunction(controllerInstance.$postLink)) {
                            controllerInstance.$postLink();
                        }
                    });
                    function controllersBoundTransclude(scope, cloneAttachFn, futureParentElement, slotName) {
                        var transcludeControllers;
                        if (!isScope(scope)) {
                            slotName = futureParentElement;
                            futureParentElement = cloneAttachFn;
                            cloneAttachFn = scope;
                            scope = undefined;
                        }
                        if (hasElementTranscludeDirective) {
                            transcludeControllers = elementControllers;
                        }
                        if (!futureParentElement) {
                            futureParentElement = hasElementTranscludeDirective ? $element.parent() : $element;
                        }
                        if (slotName) {
                            var slotTranscludeFn = boundTranscludeFn.$$slots[slotName];
                            if (slotTranscludeFn) {
                                return slotTranscludeFn(scope, cloneAttachFn, transcludeControllers, futureParentElement, scopeToChild);
                            } else if (isUndefined(slotTranscludeFn)) {
                                throw $compileMinErr("noslot", 'No parent directive that requires a transclusion with slot name "{0}". ' + "Element: {1}", slotName, startingTag($element));
                            }
                        } else {
                            return boundTranscludeFn(scope, cloneAttachFn, transcludeControllers, futureParentElement, scopeToChild);
                        }
                    }
                }
            }
            function getControllers(directiveName, require, $element, elementControllers) {
                var value;
                if (isString(require)) {
                    var match = require.match(REQUIRE_PREFIX_REGEXP);
                    var name = require.substring(match[0].length);
                    var inheritType = match[1] || match[3];
                    var optional = match[2] === "?";
                    if (inheritType === "^^") {
                        $element = $element.parent();
                    } else {
                        value = elementControllers && elementControllers[name];
                        value = value && value.instance;
                    }
                    if (!value) {
                        var dataName = "$" + name + "Controller";
                        value = inheritType ? $element.inheritedData(dataName) : $element.data(dataName);
                    }
                    if (!value && !optional) {
                        throw $compileMinErr("ctreq", "Controller '{0}', required by directive '{1}', can't be found!", name, directiveName);
                    }
                } else if (isArray(require)) {
                    value = [];
                    for (var i = 0, ii = require.length; i < ii; i++) {
                        value[i] = getControllers(directiveName, require[i], $element, elementControllers);
                    }
                } else if (isObject(require)) {
                    value = {};
                    forEach(require, function(controller, property) {
                        value[property] = getControllers(directiveName, controller, $element, elementControllers);
                    });
                }
                return value || null;
            }
            function setupControllers($element, attrs, transcludeFn, controllerDirectives, isolateScope, scope, newIsolateScopeDirective) {
                var elementControllers = createMap();
                for (var controllerKey in controllerDirectives) {
                    var directive = controllerDirectives[controllerKey];
                    var locals = {
                        $scope: directive === newIsolateScopeDirective || directive.$$isolateScope ? isolateScope : scope,
                        $element: $element,
                        $attrs: attrs,
                        $transclude: transcludeFn
                    };
                    var controller = directive.controller;
                    if (controller === "@") {
                        controller = attrs[directive.name];
                    }
                    var controllerInstance = $controller(controller, locals, true, directive.controllerAs);
                    elementControllers[directive.name] = controllerInstance;
                    $element.data("$" + directive.name + "Controller", controllerInstance.instance);
                }
                return elementControllers;
            }
            function markDirectiveScope(directives, isolateScope, newScope) {
                for (var j = 0, jj = directives.length; j < jj; j++) {
                    directives[j] = inherit(directives[j], {
                        $$isolateScope: isolateScope,
                        $$newScope: newScope
                    });
                }
            }
            function addDirective(tDirectives, name, location, maxPriority, ignoreDirective, startAttrName, endAttrName) {
                if (name === ignoreDirective) return null;
                var match = null;
                if (hasDirectives.hasOwnProperty(name)) {
                    for (var directive, directives = $injector.get(name + Suffix), i = 0, ii = directives.length; i < ii; i++) {
                        directive = directives[i];
                        if ((isUndefined(maxPriority) || maxPriority > directive.priority) && directive.restrict.indexOf(location) !== -1) {
                            if (startAttrName) {
                                directive = inherit(directive, {
                                    $$start: startAttrName,
                                    $$end: endAttrName
                                });
                            }
                            if (!directive.$$bindings) {
                                var bindings = directive.$$bindings = parseDirectiveBindings(directive, directive.name);
                                if (isObject(bindings.isolateScope)) {
                                    directive.$$isolateBindings = bindings.isolateScope;
                                }
                            }
                            tDirectives.push(directive);
                            match = directive;
                        }
                    }
                }
                return match;
            }
            function directiveIsMultiElement(name) {
                if (hasDirectives.hasOwnProperty(name)) {
                    for (var directive, directives = $injector.get(name + Suffix), i = 0, ii = directives.length; i < ii; i++) {
                        directive = directives[i];
                        if (directive.multiElement) {
                            return true;
                        }
                    }
                }
                return false;
            }
            function mergeTemplateAttributes(dst, src) {
                var srcAttr = src.$attr, dstAttr = dst.$attr;
                forEach(dst, function(value, key) {
                    if (key.charAt(0) !== "$") {
                        if (src[key] && src[key] !== value) {
                            value += (key === "style" ? ";" : " ") + src[key];
                        }
                        dst.$set(key, value, true, srcAttr[key]);
                    }
                });
                forEach(src, function(value, key) {
                    if (!dst.hasOwnProperty(key) && key.charAt(0) !== "$") {
                        dst[key] = value;
                        if (key !== "class" && key !== "style") {
                            dstAttr[key] = srcAttr[key];
                        }
                    }
                });
            }
            function compileTemplateUrl(directives, $compileNode, tAttrs, $rootElement, childTranscludeFn, preLinkFns, postLinkFns, previousCompileContext) {
                var linkQueue = [], afterTemplateNodeLinkFn, afterTemplateChildLinkFn, beforeTemplateCompileNode = $compileNode[0], origAsyncDirective = directives.shift(), derivedSyncDirective = inherit(origAsyncDirective, {
                    templateUrl: null,
                    transclude: null,
                    replace: null,
                    $$originalDirective: origAsyncDirective
                }), templateUrl = isFunction(origAsyncDirective.templateUrl) ? origAsyncDirective.templateUrl($compileNode, tAttrs) : origAsyncDirective.templateUrl, templateNamespace = origAsyncDirective.templateNamespace;
                $compileNode.empty();
                $templateRequest(templateUrl).then(function(content) {
                    var compileNode, tempTemplateAttrs, $template, childBoundTranscludeFn;
                    content = denormalizeTemplate(content);
                    if (origAsyncDirective.replace) {
                        if (jqLiteIsTextNode(content)) {
                            $template = [];
                        } else {
                            $template = removeComments(wrapTemplate(templateNamespace, trim(content)));
                        }
                        compileNode = $template[0];
                        if ($template.length !== 1 || compileNode.nodeType !== NODE_TYPE_ELEMENT) {
                            throw $compileMinErr("tplrt", "Template for directive '{0}' must have exactly one root element. {1}", origAsyncDirective.name, templateUrl);
                        }
                        tempTemplateAttrs = {
                            $attr: {}
                        };
                        replaceWith($rootElement, $compileNode, compileNode);
                        var templateDirectives = collectDirectives(compileNode, [], tempTemplateAttrs);
                        if (isObject(origAsyncDirective.scope)) {
                            markDirectiveScope(templateDirectives, true);
                        }
                        directives = templateDirectives.concat(directives);
                        mergeTemplateAttributes(tAttrs, tempTemplateAttrs);
                    } else {
                        compileNode = beforeTemplateCompileNode;
                        $compileNode.html(content);
                    }
                    directives.unshift(derivedSyncDirective);
                    afterTemplateNodeLinkFn = applyDirectivesToNode(directives, compileNode, tAttrs, childTranscludeFn, $compileNode, origAsyncDirective, preLinkFns, postLinkFns, previousCompileContext);
                    forEach($rootElement, function(node, i) {
                        if (node === compileNode) {
                            $rootElement[i] = $compileNode[0];
                        }
                    });
                    afterTemplateChildLinkFn = compileNodes($compileNode[0].childNodes, childTranscludeFn);
                    while (linkQueue.length) {
                        var scope = linkQueue.shift(), beforeTemplateLinkNode = linkQueue.shift(), linkRootElement = linkQueue.shift(), boundTranscludeFn = linkQueue.shift(), linkNode = $compileNode[0];
                        if (scope.$$destroyed) continue;
                        if (beforeTemplateLinkNode !== beforeTemplateCompileNode) {
                            var oldClasses = beforeTemplateLinkNode.className;
                            if (!(previousCompileContext.hasElementTranscludeDirective && origAsyncDirective.replace)) {
                                linkNode = jqLiteClone(compileNode);
                            }
                            replaceWith(linkRootElement, jqLite(beforeTemplateLinkNode), linkNode);
                            safeAddClass(jqLite(linkNode), oldClasses);
                        }
                        if (afterTemplateNodeLinkFn.transcludeOnThisElement) {
                            childBoundTranscludeFn = createBoundTranscludeFn(scope, afterTemplateNodeLinkFn.transclude, boundTranscludeFn);
                        } else {
                            childBoundTranscludeFn = boundTranscludeFn;
                        }
                        afterTemplateNodeLinkFn(afterTemplateChildLinkFn, scope, linkNode, $rootElement, childBoundTranscludeFn);
                    }
                    linkQueue = null;
                });
                return function delayedNodeLinkFn(ignoreChildLinkFn, scope, node, rootElement, boundTranscludeFn) {
                    var childBoundTranscludeFn = boundTranscludeFn;
                    if (scope.$$destroyed) return;
                    if (linkQueue) {
                        linkQueue.push(scope, node, rootElement, childBoundTranscludeFn);
                    } else {
                        if (afterTemplateNodeLinkFn.transcludeOnThisElement) {
                            childBoundTranscludeFn = createBoundTranscludeFn(scope, afterTemplateNodeLinkFn.transclude, boundTranscludeFn);
                        }
                        afterTemplateNodeLinkFn(afterTemplateChildLinkFn, scope, node, rootElement, childBoundTranscludeFn);
                    }
                };
            }
            function byPriority(a, b) {
                var diff = b.priority - a.priority;
                if (diff !== 0) return diff;
                if (a.name !== b.name) return a.name < b.name ? -1 : 1;
                return a.index - b.index;
            }
            function assertNoDuplicate(what, previousDirective, directive, element) {
                function wrapModuleNameIfDefined(moduleName) {
                    return moduleName ? " (module: " + moduleName + ")" : "";
                }
                if (previousDirective) {
                    throw $compileMinErr("multidir", "Multiple directives [{0}{1}, {2}{3}] asking for {4} on: {5}", previousDirective.name, wrapModuleNameIfDefined(previousDirective.$$moduleName), directive.name, wrapModuleNameIfDefined(directive.$$moduleName), what, startingTag(element));
                }
            }
            function addTextInterpolateDirective(directives, text) {
                var interpolateFn = $interpolate(text, true);
                if (interpolateFn) {
                    directives.push({
                        priority: 0,
                        compile: function textInterpolateCompileFn(templateNode) {
                            var templateNodeParent = templateNode.parent(), hasCompileParent = !!templateNodeParent.length;
                            if (hasCompileParent) compile.$$addBindingClass(templateNodeParent);
                            return function textInterpolateLinkFn(scope, node) {
                                var parent = node.parent();
                                if (!hasCompileParent) compile.$$addBindingClass(parent);
                                compile.$$addBindingInfo(parent, interpolateFn.expressions);
                                scope.$watch(interpolateFn, function interpolateFnWatchAction(value) {
                                    node[0].nodeValue = value;
                                });
                            };
                        }
                    });
                }
            }
            function wrapTemplate(type, template) {
                type = lowercase(type || "html");
                switch (type) {
                  case "svg":
                  case "math":
                    var wrapper = window.document.createElement("div");
                    wrapper.innerHTML = "<" + type + ">" + template + "</" + type + ">";
                    return wrapper.childNodes[0].childNodes;

                  default:
                    return template;
                }
            }
            function getTrustedContext(node, attrNormalizedName) {
                if (attrNormalizedName === "srcdoc") {
                    return $sce.HTML;
                }
                var tag = nodeName_(node);
                if (attrNormalizedName === "src" || attrNormalizedName === "ngSrc") {
                    if ([ "img", "video", "audio", "source", "track" ].indexOf(tag) === -1) {
                        return $sce.RESOURCE_URL;
                    }
                } else if (attrNormalizedName === "xlinkHref" || tag === "form" && attrNormalizedName === "action") {
                    return $sce.RESOURCE_URL;
                }
            }
            function addAttrInterpolateDirective(node, directives, value, name, isNgAttr) {
                var trustedContext = getTrustedContext(node, name);
                var mustHaveExpression = !isNgAttr;
                var allOrNothing = ALL_OR_NOTHING_ATTRS[name] || isNgAttr;
                var interpolateFn = $interpolate(value, mustHaveExpression, trustedContext, allOrNothing);
                if (!interpolateFn) return;
                if (name === "multiple" && nodeName_(node) === "select") {
                    throw $compileMinErr("selmulti", "Binding to the 'multiple' attribute is not supported. Element: {0}", startingTag(node));
                }
                directives.push({
                    priority: 100,
                    compile: function() {
                        return {
                            pre: function attrInterpolatePreLinkFn(scope, element, attr) {
                                var $$observers = attr.$$observers || (attr.$$observers = createMap());
                                if (EVENT_HANDLER_ATTR_REGEXP.test(name)) {
                                    throw $compileMinErr("nodomevents", "Interpolations for HTML DOM event attributes are disallowed.  Please use the " + "ng- versions (such as ng-click instead of onclick) instead.");
                                }
                                var newValue = attr[name];
                                if (newValue !== value) {
                                    interpolateFn = newValue && $interpolate(newValue, true, trustedContext, allOrNothing);
                                    value = newValue;
                                }
                                if (!interpolateFn) return;
                                attr[name] = interpolateFn(scope);
                                ($$observers[name] || ($$observers[name] = [])).$$inter = true;
                                (attr.$$observers && attr.$$observers[name].$$scope || scope).$watch(interpolateFn, function interpolateFnWatchAction(newValue, oldValue) {
                                    if (name === "class" && newValue !== oldValue) {
                                        attr.$updateClass(newValue, oldValue);
                                    } else {
                                        attr.$set(name, newValue);
                                    }
                                });
                            }
                        };
                    }
                });
            }
            function replaceWith($rootElement, elementsToRemove, newNode) {
                var firstElementToRemove = elementsToRemove[0], removeCount = elementsToRemove.length, parent = firstElementToRemove.parentNode, i, ii;
                if ($rootElement) {
                    for (i = 0, ii = $rootElement.length; i < ii; i++) {
                        if ($rootElement[i] === firstElementToRemove) {
                            $rootElement[i++] = newNode;
                            for (var j = i, j2 = j + removeCount - 1, jj = $rootElement.length; j < jj; j++, 
                            j2++) {
                                if (j2 < jj) {
                                    $rootElement[j] = $rootElement[j2];
                                } else {
                                    delete $rootElement[j];
                                }
                            }
                            $rootElement.length -= removeCount - 1;
                            if ($rootElement.context === firstElementToRemove) {
                                $rootElement.context = newNode;
                            }
                            break;
                        }
                    }
                }
                if (parent) {
                    parent.replaceChild(newNode, firstElementToRemove);
                }
                var fragment = window.document.createDocumentFragment();
                for (i = 0; i < removeCount; i++) {
                    fragment.appendChild(elementsToRemove[i]);
                }
                if (jqLite.hasData(firstElementToRemove)) {
                    jqLite.data(newNode, jqLite.data(firstElementToRemove));
                    jqLite(firstElementToRemove).off("$destroy");
                }
                jqLite.cleanData(fragment.querySelectorAll("*"));
                for (i = 1; i < removeCount; i++) {
                    delete elementsToRemove[i];
                }
                elementsToRemove[0] = newNode;
                elementsToRemove.length = 1;
            }
            function cloneAndAnnotateFn(fn, annotation) {
                return extend(function() {
                    return fn.apply(null, arguments);
                }, fn, annotation);
            }
            function invokeLinkFn(linkFn, scope, $element, attrs, controllers, transcludeFn) {
                try {
                    linkFn(scope, $element, attrs, controllers, transcludeFn);
                } catch (e) {
                    $exceptionHandler(e, startingTag($element));
                }
            }
            function initializeDirectiveBindings(scope, attrs, destination, bindings, directive) {
                var removeWatchCollection = [];
                var initialChanges = {};
                var changes;
                forEach(bindings, function initializeBinding(definition, scopeName) {
                    var attrName = definition.attrName, optional = definition.optional, mode = definition.mode, lastValue, parentGet, parentSet, compare, removeWatch;
                    switch (mode) {
                      case "@":
                        if (!optional && !hasOwnProperty.call(attrs, attrName)) {
                            destination[scopeName] = attrs[attrName] = undefined;
                        }
                        removeWatch = attrs.$observe(attrName, function(value) {
                            if (isString(value) || isBoolean(value)) {
                                var oldValue = destination[scopeName];
                                recordChanges(scopeName, value, oldValue);
                                destination[scopeName] = value;
                            }
                        });
                        attrs.$$observers[attrName].$$scope = scope;
                        lastValue = attrs[attrName];
                        if (isString(lastValue)) {
                            destination[scopeName] = $interpolate(lastValue)(scope);
                        } else if (isBoolean(lastValue)) {
                            destination[scopeName] = lastValue;
                        }
                        initialChanges[scopeName] = new SimpleChange(_UNINITIALIZED_VALUE, destination[scopeName]);
                        removeWatchCollection.push(removeWatch);
                        break;

                      case "=":
                        if (!hasOwnProperty.call(attrs, attrName)) {
                            if (optional) break;
                            attrs[attrName] = undefined;
                        }
                        if (optional && !attrs[attrName]) break;
                        parentGet = $parse(attrs[attrName]);
                        if (parentGet.literal) {
                            compare = equals;
                        } else {
                            compare = function simpleCompare(a, b) {
                                return a === b || a !== a && b !== b;
                            };
                        }
                        parentSet = parentGet.assign || function() {
                            lastValue = destination[scopeName] = parentGet(scope);
                            throw $compileMinErr("nonassign", "Expression '{0}' in attribute '{1}' used with directive '{2}' is non-assignable!", attrs[attrName], attrName, directive.name);
                        };
                        lastValue = destination[scopeName] = parentGet(scope);
                        var parentValueWatch = function parentValueWatch(parentValue) {
                            if (!compare(parentValue, destination[scopeName])) {
                                if (!compare(parentValue, lastValue)) {
                                    destination[scopeName] = parentValue;
                                } else {
                                    parentSet(scope, parentValue = destination[scopeName]);
                                }
                            }
                            lastValue = parentValue;
                            return lastValue;
                        };
                        parentValueWatch.$stateful = true;
                        if (definition.collection) {
                            removeWatch = scope.$watchCollection(attrs[attrName], parentValueWatch);
                        } else {
                            removeWatch = scope.$watch($parse(attrs[attrName], parentValueWatch), null, parentGet.literal);
                        }
                        removeWatchCollection.push(removeWatch);
                        break;

                      case "<":
                        if (!hasOwnProperty.call(attrs, attrName)) {
                            if (optional) break;
                            attrs[attrName] = undefined;
                        }
                        if (optional && !attrs[attrName]) break;
                        parentGet = $parse(attrs[attrName]);
                        var deepWatch = parentGet.literal;
                        var initialValue = destination[scopeName] = parentGet(scope);
                        initialChanges[scopeName] = new SimpleChange(_UNINITIALIZED_VALUE, destination[scopeName]);
                        removeWatch = scope.$watch(parentGet, function parentValueWatchAction(newValue, oldValue) {
                            if (oldValue === newValue) {
                                if (oldValue === initialValue || deepWatch && equals(oldValue, initialValue)) {
                                    return;
                                }
                                oldValue = initialValue;
                            }
                            recordChanges(scopeName, newValue, oldValue);
                            destination[scopeName] = newValue;
                        }, deepWatch);
                        removeWatchCollection.push(removeWatch);
                        break;

                      case "&":
                        parentGet = attrs.hasOwnProperty(attrName) ? $parse(attrs[attrName]) : noop;
                        if (parentGet === noop && optional) break;
                        destination[scopeName] = function(locals) {
                            return parentGet(scope, locals);
                        };
                        break;
                    }
                });
                function recordChanges(key, currentValue, previousValue) {
                    if (isFunction(destination.$onChanges) && currentValue !== previousValue && (currentValue === currentValue || previousValue === previousValue)) {
                        if (!onChangesQueue) {
                            scope.$$postDigest(flushOnChangesQueue);
                            onChangesQueue = [];
                        }
                        if (!changes) {
                            changes = {};
                            onChangesQueue.push(triggerOnChangesHook);
                        }
                        if (changes[key]) {
                            previousValue = changes[key].previousValue;
                        }
                        changes[key] = new SimpleChange(previousValue, currentValue);
                    }
                }
                function triggerOnChangesHook() {
                    destination.$onChanges(changes);
                    changes = undefined;
                }
                return {
                    initialChanges: initialChanges,
                    removeWatches: removeWatchCollection.length && function removeWatches() {
                        for (var i = 0, ii = removeWatchCollection.length; i < ii; ++i) {
                            removeWatchCollection[i]();
                        }
                    }
                };
            }
        } ];
    }
    function SimpleChange(previous, current) {
        this.previousValue = previous;
        this.currentValue = current;
    }
    SimpleChange.prototype.isFirstChange = function() {
        return this.previousValue === _UNINITIALIZED_VALUE;
    };
    var PREFIX_REGEXP = /^((?:x|data)[:\-_])/i;
    function directiveNormalize(name) {
        return camelCase(name.replace(PREFIX_REGEXP, ""));
    }
    function nodesetLinkingFn(scope, nodeList, rootElement, boundTranscludeFn) {}
    function directiveLinkingFn(nodesetLinkingFn, scope, node, rootElement, boundTranscludeFn) {}
    function tokenDifference(str1, str2) {
        var values = "", tokens1 = str1.split(/\s+/), tokens2 = str2.split(/\s+/);
        outer: for (var i = 0; i < tokens1.length; i++) {
            var token = tokens1[i];
            for (var j = 0; j < tokens2.length; j++) {
                if (token === tokens2[j]) continue outer;
            }
            values += (values.length > 0 ? " " : "") + token;
        }
        return values;
    }
    function removeComments(jqNodes) {
        jqNodes = jqLite(jqNodes);
        var i = jqNodes.length;
        if (i <= 1) {
            return jqNodes;
        }
        while (i--) {
            var node = jqNodes[i];
            if (node.nodeType === NODE_TYPE_COMMENT || node.nodeType === NODE_TYPE_TEXT && node.nodeValue.trim() === "") {
                splice.call(jqNodes, i, 1);
            }
        }
        return jqNodes;
    }
    var $controllerMinErr = minErr("$controller");
    var CNTRL_REG = /^(\S+)(\s+as\s+([\w$]+))?$/;
    function identifierForController(controller, ident) {
        if (ident && isString(ident)) return ident;
        if (isString(controller)) {
            var match = CNTRL_REG.exec(controller);
            if (match) return match[3];
        }
    }
    function $ControllerProvider() {
        var controllers = {}, globals = false;
        this.has = function(name) {
            return controllers.hasOwnProperty(name);
        };
        this.register = function(name, constructor) {
            assertNotHasOwnProperty(name, "controller");
            if (isObject(name)) {
                extend(controllers, name);
            } else {
                controllers[name] = constructor;
            }
        };
        this.allowGlobals = function() {
            globals = true;
        };
        this.$get = [ "$injector", "$window", function($injector, $window) {
            return function $controller(expression, locals, later, ident) {
                var instance, match, constructor, identifier;
                later = later === true;
                if (ident && isString(ident)) {
                    identifier = ident;
                }
                if (isString(expression)) {
                    match = expression.match(CNTRL_REG);
                    if (!match) {
                        throw $controllerMinErr("ctrlfmt", "Badly formed controller string '{0}'. " + "Must match `__name__ as __id__` or `__name__`.", expression);
                    }
                    constructor = match[1];
                    identifier = identifier || match[3];
                    expression = controllers.hasOwnProperty(constructor) ? controllers[constructor] : getter(locals.$scope, constructor, true) || (globals ? getter($window, constructor, true) : undefined);
                    if (!expression) {
                        throw $controllerMinErr("ctrlreg", "The controller with the name '{0}' is not registered.", constructor);
                    }
                    assertArgFn(expression, constructor, true);
                }
                if (later) {
                    var controllerPrototype = (isArray(expression) ? expression[expression.length - 1] : expression).prototype;
                    instance = Object.create(controllerPrototype || null);
                    if (identifier) {
                        addIdentifier(locals, identifier, instance, constructor || expression.name);
                    }
                    return extend(function $controllerInit() {
                        var result = $injector.invoke(expression, instance, locals, constructor);
                        if (result !== instance && (isObject(result) || isFunction(result))) {
                            instance = result;
                            if (identifier) {
                                addIdentifier(locals, identifier, instance, constructor || expression.name);
                            }
                        }
                        return instance;
                    }, {
                        instance: instance,
                        identifier: identifier
                    });
                }
                instance = $injector.instantiate(expression, locals, constructor);
                if (identifier) {
                    addIdentifier(locals, identifier, instance, constructor || expression.name);
                }
                return instance;
            };
            function addIdentifier(locals, identifier, instance, name) {
                if (!(locals && isObject(locals.$scope))) {
                    throw minErr("$controller")("noscp", "Cannot export controller '{0}' as '{1}'! No $scope object provided via `locals`.", name, identifier);
                }
                locals.$scope[identifier] = instance;
            }
        } ];
    }
    function $DocumentProvider() {
        this.$get = [ "$window", function(window) {
            return jqLite(window.document);
        } ];
    }
    function $ExceptionHandlerProvider() {
        this.$get = [ "$log", function($log) {
            return function(exception, cause) {
                $log.error.apply($log, arguments);
            };
        } ];
    }
    var $$ForceReflowProvider = function() {
        this.$get = [ "$document", function($document) {
            return function(domNode) {
                if (domNode) {
                    if (!domNode.nodeType && domNode instanceof jqLite) {
                        domNode = domNode[0];
                    }
                } else {
                    domNode = $document[0].body;
                }
                return domNode.offsetWidth + 1;
            };
        } ];
    };
    var APPLICATION_JSON = "application/json";
    var CONTENT_TYPE_APPLICATION_JSON = {
        "Content-Type": APPLICATION_JSON + ";charset=utf-8"
    };
    var JSON_START = /^\[|^\{(?!\{)/;
    var JSON_ENDS = {
        "[": /]$/,
        "{": /}$/
    };
    var JSON_PROTECTION_PREFIX = /^\)]\}',?\n/;
    var $httpMinErr = minErr("$http");
    var $httpMinErrLegacyFn = function(method) {
        return function() {
            throw $httpMinErr("legacy", "The method `{0}` on the promise returned from `$http` has been disabled.", method);
        };
    };
    function serializeValue(v) {
        if (isObject(v)) {
            return isDate(v) ? v.toISOString() : toJson(v);
        }
        return v;
    }
    function $HttpParamSerializerProvider() {
        this.$get = function() {
            return function ngParamSerializer(params) {
                if (!params) return "";
                var parts = [];
                forEachSorted(params, function(value, key) {
                    if (value === null || isUndefined(value)) return;
                    if (isArray(value)) {
                        forEach(value, function(v) {
                            parts.push(encodeUriQuery(key) + "=" + encodeUriQuery(serializeValue(v)));
                        });
                    } else {
                        parts.push(encodeUriQuery(key) + "=" + encodeUriQuery(serializeValue(value)));
                    }
                });
                return parts.join("&");
            };
        };
    }
    function $HttpParamSerializerJQLikeProvider() {
        this.$get = function() {
            return function jQueryLikeParamSerializer(params) {
                if (!params) return "";
                var parts = [];
                serialize(params, "", true);
                return parts.join("&");
                function serialize(toSerialize, prefix, topLevel) {
                    if (toSerialize === null || isUndefined(toSerialize)) return;
                    if (isArray(toSerialize)) {
                        forEach(toSerialize, function(value, index) {
                            serialize(value, prefix + "[" + (isObject(value) ? index : "") + "]");
                        });
                    } else if (isObject(toSerialize) && !isDate(toSerialize)) {
                        forEachSorted(toSerialize, function(value, key) {
                            serialize(value, prefix + (topLevel ? "" : "[") + key + (topLevel ? "" : "]"));
                        });
                    } else {
                        parts.push(encodeUriQuery(prefix) + "=" + encodeUriQuery(serializeValue(toSerialize)));
                    }
                }
            };
        };
    }
    function defaultHttpResponseTransform(data, headers) {
        if (isString(data)) {
            var tempData = data.replace(JSON_PROTECTION_PREFIX, "").trim();
            if (tempData) {
                var contentType = headers("Content-Type");
                if (contentType && contentType.indexOf(APPLICATION_JSON) === 0 || isJsonLike(tempData)) {
                    data = fromJson(tempData);
                }
            }
        }
        return data;
    }
    function isJsonLike(str) {
        var jsonStart = str.match(JSON_START);
        return jsonStart && JSON_ENDS[jsonStart[0]].test(str);
    }
    function parseHeaders(headers) {
        var parsed = createMap(), i;
        function fillInParsed(key, val) {
            if (key) {
                parsed[key] = parsed[key] ? parsed[key] + ", " + val : val;
            }
        }
        if (isString(headers)) {
            forEach(headers.split("\n"), function(line) {
                i = line.indexOf(":");
                fillInParsed(lowercase(trim(line.substr(0, i))), trim(line.substr(i + 1)));
            });
        } else if (isObject(headers)) {
            forEach(headers, function(headerVal, headerKey) {
                fillInParsed(lowercase(headerKey), trim(headerVal));
            });
        }
        return parsed;
    }
    function headersGetter(headers) {
        var headersObj;
        return function(name) {
            if (!headersObj) headersObj = parseHeaders(headers);
            if (name) {
                var value = headersObj[lowercase(name)];
                if (value === undefined) {
                    value = null;
                }
                return value;
            }
            return headersObj;
        };
    }
    function transformData(data, headers, status, fns) {
        if (isFunction(fns)) {
            return fns(data, headers, status);
        }
        forEach(fns, function(fn) {
            data = fn(data, headers, status);
        });
        return data;
    }
    function isSuccess(status) {
        return 200 <= status && status < 300;
    }
    function $HttpProvider() {
        var defaults = this.defaults = {
            transformResponse: [ defaultHttpResponseTransform ],
            transformRequest: [ function(d) {
                return isObject(d) && !isFile(d) && !isBlob(d) && !isFormData(d) ? toJson(d) : d;
            } ],
            headers: {
                common: {
                    Accept: "application/json, text/plain, */*"
                },
                post: shallowCopy(CONTENT_TYPE_APPLICATION_JSON),
                put: shallowCopy(CONTENT_TYPE_APPLICATION_JSON),
                patch: shallowCopy(CONTENT_TYPE_APPLICATION_JSON)
            },
            xsrfCookieName: "XSRF-TOKEN",
            xsrfHeaderName: "X-XSRF-TOKEN",
            paramSerializer: "$httpParamSerializer"
        };
        var useApplyAsync = false;
        this.useApplyAsync = function(value) {
            if (isDefined(value)) {
                useApplyAsync = !!value;
                return this;
            }
            return useApplyAsync;
        };
        var useLegacyPromise = true;
        this.useLegacyPromiseExtensions = function(value) {
            if (isDefined(value)) {
                useLegacyPromise = !!value;
                return this;
            }
            return useLegacyPromise;
        };
        var interceptorFactories = this.interceptors = [];
        this.$get = [ "$httpBackend", "$$cookieReader", "$cacheFactory", "$rootScope", "$q", "$injector", function($httpBackend, $$cookieReader, $cacheFactory, $rootScope, $q, $injector) {
            var defaultCache = $cacheFactory("$http");
            defaults.paramSerializer = isString(defaults.paramSerializer) ? $injector.get(defaults.paramSerializer) : defaults.paramSerializer;
            var reversedInterceptors = [];
            forEach(interceptorFactories, function(interceptorFactory) {
                reversedInterceptors.unshift(isString(interceptorFactory) ? $injector.get(interceptorFactory) : $injector.invoke(interceptorFactory));
            });
            function $http(requestConfig) {
                if (!isObject(requestConfig)) {
                    throw minErr("$http")("badreq", "Http request configuration must be an object.  Received: {0}", requestConfig);
                }
                if (!isString(requestConfig.url)) {
                    throw minErr("$http")("badreq", "Http request configuration url must be a string.  Received: {0}", requestConfig.url);
                }
                var config = extend({
                    method: "get",
                    transformRequest: defaults.transformRequest,
                    transformResponse: defaults.transformResponse,
                    paramSerializer: defaults.paramSerializer
                }, requestConfig);
                config.headers = mergeHeaders(requestConfig);
                config.method = uppercase(config.method);
                config.paramSerializer = isString(config.paramSerializer) ? $injector.get(config.paramSerializer) : config.paramSerializer;
                var requestInterceptors = [];
                var responseInterceptors = [];
                var promise = $q.when(config);
                forEach(reversedInterceptors, function(interceptor) {
                    if (interceptor.request || interceptor.requestError) {
                        requestInterceptors.unshift(interceptor.request, interceptor.requestError);
                    }
                    if (interceptor.response || interceptor.responseError) {
                        responseInterceptors.push(interceptor.response, interceptor.responseError);
                    }
                });
                promise = chainInterceptors(promise, requestInterceptors);
                promise = promise.then(serverRequest);
                promise = chainInterceptors(promise, responseInterceptors);
                if (useLegacyPromise) {
                    promise.success = function(fn) {
                        assertArgFn(fn, "fn");
                        promise.then(function(response) {
                            fn(response.data, response.status, response.headers, config);
                        });
                        return promise;
                    };
                    promise.error = function(fn) {
                        assertArgFn(fn, "fn");
                        promise.then(null, function(response) {
                            fn(response.data, response.status, response.headers, config);
                        });
                        return promise;
                    };
                } else {
                    promise.success = $httpMinErrLegacyFn("success");
                    promise.error = $httpMinErrLegacyFn("error");
                }
                return promise;
                function chainInterceptors(promise, interceptors) {
                    for (var i = 0, ii = interceptors.length; i < ii; ) {
                        var thenFn = interceptors[i++];
                        var rejectFn = interceptors[i++];
                        promise = promise.then(thenFn, rejectFn);
                    }
                    interceptors.length = 0;
                    return promise;
                }
                function executeHeaderFns(headers, config) {
                    var headerContent, processedHeaders = {};
                    forEach(headers, function(headerFn, header) {
                        if (isFunction(headerFn)) {
                            headerContent = headerFn(config);
                            if (headerContent != null) {
                                processedHeaders[header] = headerContent;
                            }
                        } else {
                            processedHeaders[header] = headerFn;
                        }
                    });
                    return processedHeaders;
                }
                function mergeHeaders(config) {
                    var defHeaders = defaults.headers, reqHeaders = extend({}, config.headers), defHeaderName, lowercaseDefHeaderName, reqHeaderName;
                    defHeaders = extend({}, defHeaders.common, defHeaders[lowercase(config.method)]);
                    defaultHeadersIteration: for (defHeaderName in defHeaders) {
                        lowercaseDefHeaderName = lowercase(defHeaderName);
                        for (reqHeaderName in reqHeaders) {
                            if (lowercase(reqHeaderName) === lowercaseDefHeaderName) {
                                continue defaultHeadersIteration;
                            }
                        }
                        reqHeaders[defHeaderName] = defHeaders[defHeaderName];
                    }
                    return executeHeaderFns(reqHeaders, shallowCopy(config));
                }
                function serverRequest(config) {
                    var headers = config.headers;
                    var reqData = transformData(config.data, headersGetter(headers), undefined, config.transformRequest);
                    if (isUndefined(reqData)) {
                        forEach(headers, function(value, header) {
                            if (lowercase(header) === "content-type") {
                                delete headers[header];
                            }
                        });
                    }
                    if (isUndefined(config.withCredentials) && !isUndefined(defaults.withCredentials)) {
                        config.withCredentials = defaults.withCredentials;
                    }
                    return sendReq(config, reqData).then(transformResponse, transformResponse);
                }
                function transformResponse(response) {
                    var resp = extend({}, response);
                    resp.data = transformData(response.data, response.headers, response.status, config.transformResponse);
                    return isSuccess(response.status) ? resp : $q.reject(resp);
                }
            }
            $http.pendingRequests = [];
            createShortMethods("get", "delete", "head", "jsonp");
            createShortMethodsWithData("post", "put", "patch");
            $http.defaults = defaults;
            return $http;
            function createShortMethods(names) {
                forEach(arguments, function(name) {
                    $http[name] = function(url, config) {
                        return $http(extend({}, config || {}, {
                            method: name,
                            url: url
                        }));
                    };
                });
            }
            function createShortMethodsWithData(name) {
                forEach(arguments, function(name) {
                    $http[name] = function(url, data, config) {
                        return $http(extend({}, config || {}, {
                            method: name,
                            url: url,
                            data: data
                        }));
                    };
                });
            }
            function sendReq(config, reqData) {
                var deferred = $q.defer(), promise = deferred.promise, cache, cachedResp, reqHeaders = config.headers, url = buildUrl(config.url, config.paramSerializer(config.params));
                $http.pendingRequests.push(config);
                promise.then(removePendingReq, removePendingReq);
                if ((config.cache || defaults.cache) && config.cache !== false && (config.method === "GET" || config.method === "JSONP")) {
                    cache = isObject(config.cache) ? config.cache : isObject(defaults.cache) ? defaults.cache : defaultCache;
                }
                if (cache) {
                    cachedResp = cache.get(url);
                    if (isDefined(cachedResp)) {
                        if (isPromiseLike(cachedResp)) {
                            cachedResp.then(resolvePromiseWithResult, resolvePromiseWithResult);
                        } else {
                            if (isArray(cachedResp)) {
                                resolvePromise(cachedResp[1], cachedResp[0], shallowCopy(cachedResp[2]), cachedResp[3]);
                            } else {
                                resolvePromise(cachedResp, 200, {}, "OK");
                            }
                        }
                    } else {
                        cache.put(url, promise);
                    }
                }
                if (isUndefined(cachedResp)) {
                    var xsrfValue = urlIsSameOrigin(config.url) ? $$cookieReader()[config.xsrfCookieName || defaults.xsrfCookieName] : undefined;
                    if (xsrfValue) {
                        reqHeaders[config.xsrfHeaderName || defaults.xsrfHeaderName] = xsrfValue;
                    }
                    $httpBackend(config.method, url, reqData, done, reqHeaders, config.timeout, config.withCredentials, config.responseType, createApplyHandlers(config.eventHandlers), createApplyHandlers(config.uploadEventHandlers));
                }
                return promise;
                function createApplyHandlers(eventHandlers) {
                    if (eventHandlers) {
                        var applyHandlers = {};
                        forEach(eventHandlers, function(eventHandler, key) {
                            applyHandlers[key] = function(event) {
                                if (useApplyAsync) {
                                    $rootScope.$applyAsync(callEventHandler);
                                } else if ($rootScope.$$phase) {
                                    callEventHandler();
                                } else {
                                    $rootScope.$apply(callEventHandler);
                                }
                                function callEventHandler() {
                                    eventHandler(event);
                                }
                            };
                        });
                        return applyHandlers;
                    }
                }
                function done(status, response, headersString, statusText) {
                    if (cache) {
                        if (isSuccess(status)) {
                            cache.put(url, [ status, response, parseHeaders(headersString), statusText ]);
                        } else {
                            cache.remove(url);
                        }
                    }
                    function resolveHttpPromise() {
                        resolvePromise(response, status, headersString, statusText);
                    }
                    if (useApplyAsync) {
                        $rootScope.$applyAsync(resolveHttpPromise);
                    } else {
                        resolveHttpPromise();
                        if (!$rootScope.$$phase) $rootScope.$apply();
                    }
                }
                function resolvePromise(response, status, headers, statusText) {
                    status = status >= -1 ? status : 0;
                    (isSuccess(status) ? deferred.resolve : deferred.reject)({
                        data: response,
                        status: status,
                        headers: headersGetter(headers),
                        config: config,
                        statusText: statusText
                    });
                }
                function resolvePromiseWithResult(result) {
                    resolvePromise(result.data, result.status, shallowCopy(result.headers()), result.statusText);
                }
                function removePendingReq() {
                    var idx = $http.pendingRequests.indexOf(config);
                    if (idx !== -1) $http.pendingRequests.splice(idx, 1);
                }
            }
            function buildUrl(url, serializedParams) {
                if (serializedParams.length > 0) {
                    url += (url.indexOf("?") === -1 ? "?" : "&") + serializedParams;
                }
                return url;
            }
        } ];
    }
    function $xhrFactoryProvider() {
        this.$get = function() {
            return function createXhr() {
                return new window.XMLHttpRequest();
            };
        };
    }
    function $HttpBackendProvider() {
        this.$get = [ "$browser", "$jsonpCallbacks", "$document", "$xhrFactory", function($browser, $jsonpCallbacks, $document, $xhrFactory) {
            return createHttpBackend($browser, $xhrFactory, $browser.defer, $jsonpCallbacks, $document[0]);
        } ];
    }
    function createHttpBackend($browser, createXhr, $browserDefer, callbacks, rawDocument) {
        return function(method, url, post, callback, headers, timeout, withCredentials, responseType, eventHandlers, uploadEventHandlers) {
            $browser.$$incOutstandingRequestCount();
            url = url || $browser.url();
            if (lowercase(method) === "jsonp") {
                var callbackPath = callbacks.createCallback(url);
                var jsonpDone = jsonpReq(url, callbackPath, function(status, text) {
                    var response = status === 200 && callbacks.getResponse(callbackPath);
                    completeRequest(callback, status, response, "", text);
                    callbacks.removeCallback(callbackPath);
                });
            } else {
                var xhr = createXhr(method, url);
                xhr.open(method, url, true);
                forEach(headers, function(value, key) {
                    if (isDefined(value)) {
                        xhr.setRequestHeader(key, value);
                    }
                });
                xhr.onload = function requestLoaded() {
                    var statusText = xhr.statusText || "";
                    var response = "response" in xhr ? xhr.response : xhr.responseText;
                    var status = xhr.status === 1223 ? 204 : xhr.status;
                    if (status === 0) {
                        status = response ? 200 : urlResolve(url).protocol === "file" ? 404 : 0;
                    }
                    completeRequest(callback, status, response, xhr.getAllResponseHeaders(), statusText);
                };
                var requestError = function() {
                    completeRequest(callback, -1, null, null, "");
                };
                xhr.onerror = requestError;
                xhr.onabort = requestError;
                xhr.ontimeout = requestError;
                forEach(eventHandlers, function(value, key) {
                    xhr.addEventListener(key, value);
                });
                forEach(uploadEventHandlers, function(value, key) {
                    xhr.upload.addEventListener(key, value);
                });
                if (withCredentials) {
                    xhr.withCredentials = true;
                }
                if (responseType) {
                    try {
                        xhr.responseType = responseType;
                    } catch (e) {
                        if (responseType !== "json") {
                            throw e;
                        }
                    }
                }
                xhr.send(isUndefined(post) ? null : post);
            }
            if (timeout > 0) {
                var timeoutId = $browserDefer(timeoutRequest, timeout);
            } else if (isPromiseLike(timeout)) {
                timeout.then(timeoutRequest);
            }
            function timeoutRequest() {
                if (jsonpDone) {
                    jsonpDone();
                }
                if (xhr) {
                    xhr.abort();
                }
            }
            function completeRequest(callback, status, response, headersString, statusText) {
                if (isDefined(timeoutId)) {
                    $browserDefer.cancel(timeoutId);
                }
                jsonpDone = xhr = null;
                callback(status, response, headersString, statusText);
                $browser.$$completeOutstandingRequest(noop);
            }
        };
        function jsonpReq(url, callbackPath, done) {
            url = url.replace("JSON_CALLBACK", callbackPath);
            var script = rawDocument.createElement("script"), callback = null;
            script.type = "text/javascript";
            script.src = url;
            script.async = true;
            callback = function(event) {
                removeEventListenerFn(script, "load", callback);
                removeEventListenerFn(script, "error", callback);
                rawDocument.body.removeChild(script);
                script = null;
                var status = -1;
                var text = "unknown";
                if (event) {
                    if (event.type === "load" && !callbacks.wasCalled(callbackPath)) {
                        event = {
                            type: "error"
                        };
                    }
                    text = event.type;
                    status = event.type === "error" ? 404 : 200;
                }
                if (done) {
                    done(status, text);
                }
            };
            addEventListenerFn(script, "load", callback);
            addEventListenerFn(script, "error", callback);
            rawDocument.body.appendChild(script);
            return callback;
        }
    }
    var $interpolateMinErr = angular.$interpolateMinErr = minErr("$interpolate");
    $interpolateMinErr.throwNoconcat = function(text) {
        throw $interpolateMinErr("noconcat", "Error while interpolating: {0}\nStrict Contextual Escaping disallows " + "interpolations that concatenate multiple expressions when a trusted value is " + "required.  See http://docs.angularjs.org/api/ng.$sce", text);
    };
    $interpolateMinErr.interr = function(text, err) {
        return $interpolateMinErr("interr", "Can't interpolate: {0}\n{1}", text, err.toString());
    };
    function $InterpolateProvider() {
        var startSymbol = "{{";
        var endSymbol = "}}";
        this.startSymbol = function(value) {
            if (value) {
                startSymbol = value;
                return this;
            } else {
                return startSymbol;
            }
        };
        this.endSymbol = function(value) {
            if (value) {
                endSymbol = value;
                return this;
            } else {
                return endSymbol;
            }
        };
        this.$get = [ "$parse", "$exceptionHandler", "$sce", function($parse, $exceptionHandler, $sce) {
            var startSymbolLength = startSymbol.length, endSymbolLength = endSymbol.length, escapedStartRegexp = new RegExp(startSymbol.replace(/./g, escape), "g"), escapedEndRegexp = new RegExp(endSymbol.replace(/./g, escape), "g");
            function escape(ch) {
                return "\\\\\\" + ch;
            }
            function unescapeText(text) {
                return text.replace(escapedStartRegexp, startSymbol).replace(escapedEndRegexp, endSymbol);
            }
            function stringify(value) {
                if (value == null) {
                    return "";
                }
                switch (typeof value) {
                  case "string":
                    break;

                  case "number":
                    value = "" + value;
                    break;

                  default:
                    value = toJson(value);
                }
                return value;
            }
            function constantWatchDelegate(scope, listener, objectEquality, constantInterp) {
                var unwatch = scope.$watch(function constantInterpolateWatch(scope) {
                    unwatch();
                    return constantInterp(scope);
                }, listener, objectEquality);
                return unwatch;
            }
            function $interpolate(text, mustHaveExpression, trustedContext, allOrNothing) {
                if (!text.length || text.indexOf(startSymbol) === -1) {
                    var constantInterp;
                    if (!mustHaveExpression) {
                        var unescapedText = unescapeText(text);
                        constantInterp = valueFn(unescapedText);
                        constantInterp.exp = text;
                        constantInterp.expressions = [];
                        constantInterp.$$watchDelegate = constantWatchDelegate;
                    }
                    return constantInterp;
                }
                allOrNothing = !!allOrNothing;
                var startIndex, endIndex, index = 0, expressions = [], parseFns = [], textLength = text.length, exp, concat = [], expressionPositions = [];
                while (index < textLength) {
                    if ((startIndex = text.indexOf(startSymbol, index)) !== -1 && (endIndex = text.indexOf(endSymbol, startIndex + startSymbolLength)) !== -1) {
                        if (index !== startIndex) {
                            concat.push(unescapeText(text.substring(index, startIndex)));
                        }
                        exp = text.substring(startIndex + startSymbolLength, endIndex);
                        expressions.push(exp);
                        parseFns.push($parse(exp, parseStringifyInterceptor));
                        index = endIndex + endSymbolLength;
                        expressionPositions.push(concat.length);
                        concat.push("");
                    } else {
                        if (index !== textLength) {
                            concat.push(unescapeText(text.substring(index)));
                        }
                        break;
                    }
                }
                if (trustedContext && concat.length > 1) {
                    $interpolateMinErr.throwNoconcat(text);
                }
                if (!mustHaveExpression || expressions.length) {
                    var compute = function(values) {
                        for (var i = 0, ii = expressions.length; i < ii; i++) {
                            if (allOrNothing && isUndefined(values[i])) return;
                            concat[expressionPositions[i]] = values[i];
                        }
                        return concat.join("");
                    };
                    var getValue = function(value) {
                        return trustedContext ? $sce.getTrusted(trustedContext, value) : $sce.valueOf(value);
                    };
                    return extend(function interpolationFn(context) {
                        var i = 0;
                        var ii = expressions.length;
                        var values = new Array(ii);
                        try {
                            for (;i < ii; i++) {
                                values[i] = parseFns[i](context);
                            }
                            return compute(values);
                        } catch (err) {
                            $exceptionHandler($interpolateMinErr.interr(text, err));
                        }
                    }, {
                        exp: text,
                        expressions: expressions,
                        $$watchDelegate: function(scope, listener) {
                            var lastValue;
                            return scope.$watchGroup(parseFns, function interpolateFnWatcher(values, oldValues) {
                                var currValue = compute(values);
                                if (isFunction(listener)) {
                                    listener.call(this, currValue, values !== oldValues ? lastValue : currValue, scope);
                                }
                                lastValue = currValue;
                            });
                        }
                    });
                }
                function parseStringifyInterceptor(value) {
                    try {
                        value = getValue(value);
                        return allOrNothing && !isDefined(value) ? value : stringify(value);
                    } catch (err) {
                        $exceptionHandler($interpolateMinErr.interr(text, err));
                    }
                }
            }
            $interpolate.startSymbol = function() {
                return startSymbol;
            };
            $interpolate.endSymbol = function() {
                return endSymbol;
            };
            return $interpolate;
        } ];
    }
    function $IntervalProvider() {
        this.$get = [ "$rootScope", "$window", "$q", "$$q", "$browser", function($rootScope, $window, $q, $$q, $browser) {
            var intervals = {};
            function interval(fn, delay, count, invokeApply) {
                var hasParams = arguments.length > 4, args = hasParams ? sliceArgs(arguments, 4) : [], setInterval = $window.setInterval, clearInterval = $window.clearInterval, iteration = 0, skipApply = isDefined(invokeApply) && !invokeApply, deferred = (skipApply ? $$q : $q).defer(), promise = deferred.promise;
                count = isDefined(count) ? count : 0;
                promise.$$intervalId = setInterval(function tick() {
                    if (skipApply) {
                        $browser.defer(callback);
                    } else {
                        $rootScope.$evalAsync(callback);
                    }
                    deferred.notify(iteration++);
                    if (count > 0 && iteration >= count) {
                        deferred.resolve(iteration);
                        clearInterval(promise.$$intervalId);
                        delete intervals[promise.$$intervalId];
                    }
                    if (!skipApply) $rootScope.$apply();
                }, delay);
                intervals[promise.$$intervalId] = deferred;
                return promise;
                function callback() {
                    if (!hasParams) {
                        fn(iteration);
                    } else {
                        fn.apply(null, args);
                    }
                }
            }
            interval.cancel = function(promise) {
                if (promise && promise.$$intervalId in intervals) {
                    intervals[promise.$$intervalId].reject("canceled");
                    $window.clearInterval(promise.$$intervalId);
                    delete intervals[promise.$$intervalId];
                    return true;
                }
                return false;
            };
            return interval;
        } ];
    }
    var $jsonpCallbacksProvider = function() {
        this.$get = [ "$window", function($window) {
            var callbacks = $window.angular.callbacks;
            var callbackMap = {};
            function createCallback(callbackId) {
                var callback = function(data) {
                    callback.data = data;
                    callback.called = true;
                };
                callback.id = callbackId;
                return callback;
            }
            return {
                createCallback: function(url) {
                    var callbackId = "_" + (callbacks.$$counter++).toString(36);
                    var callbackPath = "angular.callbacks." + callbackId;
                    var callback = createCallback(callbackId);
                    callbackMap[callbackPath] = callbacks[callbackId] = callback;
                    return callbackPath;
                },
                wasCalled: function(callbackPath) {
                    return callbackMap[callbackPath].called;
                },
                getResponse: function(callbackPath) {
                    return callbackMap[callbackPath].data;
                },
                removeCallback: function(callbackPath) {
                    var callback = callbackMap[callbackPath];
                    delete callbacks[callback.id];
                    delete callbackMap[callbackPath];
                }
            };
        } ];
    };
    var PATH_MATCH = /^([^?#]*)(\?([^#]*))?(#(.*))?$/, DEFAULT_PORTS = {
        http: 80,
        https: 443,
        ftp: 21
    };
    var $locationMinErr = minErr("$location");
    function encodePath(path) {
        var segments = path.split("/"), i = segments.length;
        while (i--) {
            segments[i] = encodeUriSegment(segments[i]);
        }
        return segments.join("/");
    }
    function parseAbsoluteUrl(absoluteUrl, locationObj) {
        var parsedUrl = urlResolve(absoluteUrl);
        locationObj.$$protocol = parsedUrl.protocol;
        locationObj.$$host = parsedUrl.hostname;
        locationObj.$$port = toInt(parsedUrl.port) || DEFAULT_PORTS[parsedUrl.protocol] || null;
    }
    var DOUBLE_SLASH_REGEX = /^\s*[\\/]{2,}/;
    function parseAppUrl(url, locationObj) {
        if (DOUBLE_SLASH_REGEX.test(url)) {
            throw $locationMinErr("badpath", 'Invalid url "{0}".', url);
        }
        var prefixed = url.charAt(0) !== "/";
        if (prefixed) {
            url = "/" + url;
        }
        var match = urlResolve(url);
        locationObj.$$path = decodeURIComponent(prefixed && match.pathname.charAt(0) === "/" ? match.pathname.substring(1) : match.pathname);
        locationObj.$$search = parseKeyValue(match.search);
        locationObj.$$hash = decodeURIComponent(match.hash);
        if (locationObj.$$path && locationObj.$$path.charAt(0) !== "/") {
            locationObj.$$path = "/" + locationObj.$$path;
        }
    }
    function startsWith(str, search) {
        return str.slice(0, search.length) === search;
    }
    function stripBaseUrl(base, url) {
        if (startsWith(url, base)) {
            return url.substr(base.length);
        }
    }
    function stripHash(url) {
        var index = url.indexOf("#");
        return index === -1 ? url : url.substr(0, index);
    }
    function trimEmptyHash(url) {
        return url.replace(/(#.+)|#$/, "$1");
    }
    function stripFile(url) {
        return url.substr(0, stripHash(url).lastIndexOf("/") + 1);
    }
    function serverBase(url) {
        return url.substring(0, url.indexOf("/", url.indexOf("//") + 2));
    }
    function LocationHtml5Url(appBase, appBaseNoFile, basePrefix) {
        this.$$html5 = true;
        basePrefix = basePrefix || "";
        parseAbsoluteUrl(appBase, this);
        this.$$parse = function(url) {
            var pathUrl = stripBaseUrl(appBaseNoFile, url);
            if (!isString(pathUrl)) {
                throw $locationMinErr("ipthprfx", 'Invalid url "{0}", missing path prefix "{1}".', url, appBaseNoFile);
            }
            parseAppUrl(pathUrl, this);
            if (!this.$$path) {
                this.$$path = "/";
            }
            this.$$compose();
        };
        this.$$compose = function() {
            var search = toKeyValue(this.$$search), hash = this.$$hash ? "#" + encodeUriSegment(this.$$hash) : "";
            this.$$url = encodePath(this.$$path) + (search ? "?" + search : "") + hash;
            this.$$absUrl = appBaseNoFile + this.$$url.substr(1);
        };
        this.$$parseLinkUrl = function(url, relHref) {
            if (relHref && relHref[0] === "#") {
                this.hash(relHref.slice(1));
                return true;
            }
            var appUrl, prevAppUrl;
            var rewrittenUrl;
            if (isDefined(appUrl = stripBaseUrl(appBase, url))) {
                prevAppUrl = appUrl;
                if (basePrefix && isDefined(appUrl = stripBaseUrl(basePrefix, appUrl))) {
                    rewrittenUrl = appBaseNoFile + (stripBaseUrl("/", appUrl) || appUrl);
                } else {
                    rewrittenUrl = appBase + prevAppUrl;
                }
            } else if (isDefined(appUrl = stripBaseUrl(appBaseNoFile, url))) {
                rewrittenUrl = appBaseNoFile + appUrl;
            } else if (appBaseNoFile === url + "/") {
                rewrittenUrl = appBaseNoFile;
            }
            if (rewrittenUrl) {
                this.$$parse(rewrittenUrl);
            }
            return !!rewrittenUrl;
        };
    }
    function LocationHashbangUrl(appBase, appBaseNoFile, hashPrefix) {
        parseAbsoluteUrl(appBase, this);
        this.$$parse = function(url) {
            var withoutBaseUrl = stripBaseUrl(appBase, url) || stripBaseUrl(appBaseNoFile, url);
            var withoutHashUrl;
            if (!isUndefined(withoutBaseUrl) && withoutBaseUrl.charAt(0) === "#") {
                withoutHashUrl = stripBaseUrl(hashPrefix, withoutBaseUrl);
                if (isUndefined(withoutHashUrl)) {
                    withoutHashUrl = withoutBaseUrl;
                }
            } else {
                if (this.$$html5) {
                    withoutHashUrl = withoutBaseUrl;
                } else {
                    withoutHashUrl = "";
                    if (isUndefined(withoutBaseUrl)) {
                        appBase = url;
                        this.replace();
                    }
                }
            }
            parseAppUrl(withoutHashUrl, this);
            this.$$path = removeWindowsDriveName(this.$$path, withoutHashUrl, appBase);
            this.$$compose();
            function removeWindowsDriveName(path, url, base) {
                var windowsFilePathExp = /^\/[A-Z]:(\/.*)/;
                var firstPathSegmentMatch;
                if (startsWith(url, base)) {
                    url = url.replace(base, "");
                }
                if (windowsFilePathExp.exec(url)) {
                    return path;
                }
                firstPathSegmentMatch = windowsFilePathExp.exec(path);
                return firstPathSegmentMatch ? firstPathSegmentMatch[1] : path;
            }
        };
        this.$$compose = function() {
            var search = toKeyValue(this.$$search), hash = this.$$hash ? "#" + encodeUriSegment(this.$$hash) : "";
            this.$$url = encodePath(this.$$path) + (search ? "?" + search : "") + hash;
            this.$$absUrl = appBase + (this.$$url ? hashPrefix + this.$$url : "");
        };
        this.$$parseLinkUrl = function(url, relHref) {
            if (stripHash(appBase) === stripHash(url)) {
                this.$$parse(url);
                return true;
            }
            return false;
        };
    }
    function LocationHashbangInHtml5Url(appBase, appBaseNoFile, hashPrefix) {
        this.$$html5 = true;
        LocationHashbangUrl.apply(this, arguments);
        this.$$parseLinkUrl = function(url, relHref) {
            if (relHref && relHref[0] === "#") {
                this.hash(relHref.slice(1));
                return true;
            }
            var rewrittenUrl;
            var appUrl;
            if (appBase === stripHash(url)) {
                rewrittenUrl = url;
            } else if (appUrl = stripBaseUrl(appBaseNoFile, url)) {
                rewrittenUrl = appBase + hashPrefix + appUrl;
            } else if (appBaseNoFile === url + "/") {
                rewrittenUrl = appBaseNoFile;
            }
            if (rewrittenUrl) {
                this.$$parse(rewrittenUrl);
            }
            return !!rewrittenUrl;
        };
        this.$$compose = function() {
            var search = toKeyValue(this.$$search), hash = this.$$hash ? "#" + encodeUriSegment(this.$$hash) : "";
            this.$$url = encodePath(this.$$path) + (search ? "?" + search : "") + hash;
            this.$$absUrl = appBase + hashPrefix + this.$$url;
        };
    }
    var locationPrototype = {
        $$absUrl: "",
        $$html5: false,
        $$replace: false,
        absUrl: locationGetter("$$absUrl"),
        url: function(url) {
            if (isUndefined(url)) {
                return this.$$url;
            }
            var match = PATH_MATCH.exec(url);
            if (match[1] || url === "") this.path(decodeURIComponent(match[1]));
            if (match[2] || match[1] || url === "") this.search(match[3] || "");
            this.hash(match[5] || "");
            return this;
        },
        protocol: locationGetter("$$protocol"),
        host: locationGetter("$$host"),
        port: locationGetter("$$port"),
        path: locationGetterSetter("$$path", function(path) {
            path = path !== null ? path.toString() : "";
            return path.charAt(0) === "/" ? path : "/" + path;
        }),
        search: function(search, paramValue) {
            switch (arguments.length) {
              case 0:
                return this.$$search;

              case 1:
                if (isString(search) || isNumber(search)) {
                    search = search.toString();
                    this.$$search = parseKeyValue(search);
                } else if (isObject(search)) {
                    search = copy(search, {});
                    forEach(search, function(value, key) {
                        if (value == null) delete search[key];
                    });
                    this.$$search = search;
                } else {
                    throw $locationMinErr("isrcharg", "The first argument of the `$location#search()` call must be a string or an object.");
                }
                break;

              default:
                if (isUndefined(paramValue) || paramValue === null) {
                    delete this.$$search[search];
                } else {
                    this.$$search[search] = paramValue;
                }
            }
            this.$$compose();
            return this;
        },
        hash: locationGetterSetter("$$hash", function(hash) {
            return hash !== null ? hash.toString() : "";
        }),
        replace: function() {
            this.$$replace = true;
            return this;
        }
    };
    forEach([ LocationHashbangInHtml5Url, LocationHashbangUrl, LocationHtml5Url ], function(Location) {
        Location.prototype = Object.create(locationPrototype);
        Location.prototype.state = function(state) {
            if (!arguments.length) {
                return this.$$state;
            }
            if (Location !== LocationHtml5Url || !this.$$html5) {
                throw $locationMinErr("nostate", "History API state support is available only " + "in HTML5 mode and only in browsers supporting HTML5 History API");
            }
            this.$$state = isUndefined(state) ? null : state;
            return this;
        };
    });
    function locationGetter(property) {
        return function() {
            return this[property];
        };
    }
    function locationGetterSetter(property, preprocess) {
        return function(value) {
            if (isUndefined(value)) {
                return this[property];
            }
            this[property] = preprocess(value);
            this.$$compose();
            return this;
        };
    }
    function $LocationProvider() {
        var hashPrefix = "", html5Mode = {
            enabled: false,
            requireBase: true,
            rewriteLinks: true
        };
        this.hashPrefix = function(prefix) {
            if (isDefined(prefix)) {
                hashPrefix = prefix;
                return this;
            } else {
                return hashPrefix;
            }
        };
        this.html5Mode = function(mode) {
            if (isBoolean(mode)) {
                html5Mode.enabled = mode;
                return this;
            } else if (isObject(mode)) {
                if (isBoolean(mode.enabled)) {
                    html5Mode.enabled = mode.enabled;
                }
                if (isBoolean(mode.requireBase)) {
                    html5Mode.requireBase = mode.requireBase;
                }
                if (isBoolean(mode.rewriteLinks) || isString(mode.rewriteLinks)) {
                    html5Mode.rewriteLinks = mode.rewriteLinks;
                }
                return this;
            } else {
                return html5Mode;
            }
        };
        this.$get = [ "$rootScope", "$browser", "$sniffer", "$rootElement", "$window", function($rootScope, $browser, $sniffer, $rootElement, $window) {
            var $location, LocationMode, baseHref = $browser.baseHref(), initialUrl = $browser.url(), appBase;
            if (html5Mode.enabled) {
                if (!baseHref && html5Mode.requireBase) {
                    throw $locationMinErr("nobase", "$location in HTML5 mode requires a <base> tag to be present!");
                }
                appBase = serverBase(initialUrl) + (baseHref || "/");
                LocationMode = $sniffer.history ? LocationHtml5Url : LocationHashbangInHtml5Url;
            } else {
                appBase = stripHash(initialUrl);
                LocationMode = LocationHashbangUrl;
            }
            var appBaseNoFile = stripFile(appBase);
            $location = new LocationMode(appBase, appBaseNoFile, "#" + hashPrefix);
            $location.$$parseLinkUrl(initialUrl, initialUrl);
            $location.$$state = $browser.state();
            var IGNORE_URI_REGEXP = /^\s*(javascript|mailto):/i;
            function setBrowserUrlWithFallback(url, replace, state) {
                var oldUrl = $location.url();
                var oldState = $location.$$state;
                try {
                    $browser.url(url, replace, state);
                    $location.$$state = $browser.state();
                } catch (e) {
                    $location.url(oldUrl);
                    $location.$$state = oldState;
                    throw e;
                }
            }
            $rootElement.on("click", function(event) {
                var rewriteLinks = html5Mode.rewriteLinks;
                if (!rewriteLinks || event.ctrlKey || event.metaKey || event.shiftKey || event.which === 2 || event.button === 2) return;
                var elm = jqLite(event.target);
                while (nodeName_(elm[0]) !== "a") {
                    if (elm[0] === $rootElement[0] || !(elm = elm.parent())[0]) return;
                }
                if (isString(rewriteLinks) && isUndefined(elm.attr(rewriteLinks))) return;
                var absHref = elm.prop("href");
                var relHref = elm.attr("href") || elm.attr("xlink:href");
                if (isObject(absHref) && absHref.toString() === "[object SVGAnimatedString]") {
                    absHref = urlResolve(absHref.animVal).href;
                }
                if (IGNORE_URI_REGEXP.test(absHref)) return;
                if (absHref && !elm.attr("target") && !event.isDefaultPrevented()) {
                    if ($location.$$parseLinkUrl(absHref, relHref)) {
                        event.preventDefault();
                        if ($location.absUrl() !== $browser.url()) {
                            $rootScope.$apply();
                            $window.angular["ff-684208-preventDefault"] = true;
                        }
                    }
                }
            });
            if (trimEmptyHash($location.absUrl()) !== trimEmptyHash(initialUrl)) {
                $browser.url($location.absUrl(), true);
            }
            var initializing = true;
            $browser.onUrlChange(function(newUrl, newState) {
                if (isUndefined(stripBaseUrl(appBaseNoFile, newUrl))) {
                    $window.location.href = newUrl;
                    return;
                }
                $rootScope.$evalAsync(function() {
                    var oldUrl = $location.absUrl();
                    var oldState = $location.$$state;
                    var defaultPrevented;
                    newUrl = trimEmptyHash(newUrl);
                    $location.$$parse(newUrl);
                    $location.$$state = newState;
                    defaultPrevented = $rootScope.$broadcast("$locationChangeStart", newUrl, oldUrl, newState, oldState).defaultPrevented;
                    if ($location.absUrl() !== newUrl) return;
                    if (defaultPrevented) {
                        $location.$$parse(oldUrl);
                        $location.$$state = oldState;
                        setBrowserUrlWithFallback(oldUrl, false, oldState);
                    } else {
                        initializing = false;
                        afterLocationChange(oldUrl, oldState);
                    }
                });
                if (!$rootScope.$$phase) $rootScope.$digest();
            });
            $rootScope.$watch(function $locationWatch() {
                var oldUrl = trimEmptyHash($browser.url());
                var newUrl = trimEmptyHash($location.absUrl());
                var oldState = $browser.state();
                var currentReplace = $location.$$replace;
                var urlOrStateChanged = oldUrl !== newUrl || $location.$$html5 && $sniffer.history && oldState !== $location.$$state;
                if (initializing || urlOrStateChanged) {
                    initializing = false;
                    $rootScope.$evalAsync(function() {
                        var newUrl = $location.absUrl();
                        var defaultPrevented = $rootScope.$broadcast("$locationChangeStart", newUrl, oldUrl, $location.$$state, oldState).defaultPrevented;
                        if ($location.absUrl() !== newUrl) return;
                        if (defaultPrevented) {
                            $location.$$parse(oldUrl);
                            $location.$$state = oldState;
                        } else {
                            if (urlOrStateChanged) {
                                setBrowserUrlWithFallback(newUrl, currentReplace, oldState === $location.$$state ? null : $location.$$state);
                            }
                            afterLocationChange(oldUrl, oldState);
                        }
                    });
                }
                $location.$$replace = false;
            });
            return $location;
            function afterLocationChange(oldUrl, oldState) {
                $rootScope.$broadcast("$locationChangeSuccess", $location.absUrl(), oldUrl, $location.$$state, oldState);
            }
        } ];
    }
    function $LogProvider() {
        var debug = true, self = this;
        this.debugEnabled = function(flag) {
            if (isDefined(flag)) {
                debug = flag;
                return this;
            } else {
                return debug;
            }
        };
        this.$get = [ "$window", function($window) {
            return {
                log: consoleLog("log"),
                info: consoleLog("info"),
                warn: consoleLog("warn"),
                error: consoleLog("error"),
                debug: function() {
                    var fn = consoleLog("debug");
                    return function() {
                        if (debug) {
                            fn.apply(self, arguments);
                        }
                    };
                }()
            };
            function formatError(arg) {
                if (arg instanceof Error) {
                    if (arg.stack) {
                        arg = arg.message && arg.stack.indexOf(arg.message) === -1 ? "Error: " + arg.message + "\n" + arg.stack : arg.stack;
                    } else if (arg.sourceURL) {
                        arg = arg.message + "\n" + arg.sourceURL + ":" + arg.line;
                    }
                }
                return arg;
            }
            function consoleLog(type) {
                var console = $window.console || {}, logFn = console[type] || console.log || noop, hasApply = false;
                try {
                    hasApply = !!logFn.apply;
                } catch (e) {}
                if (hasApply) {
                    return function() {
                        var args = [];
                        forEach(arguments, function(arg) {
                            args.push(formatError(arg));
                        });
                        return logFn.apply(console, args);
                    };
                }
                return function(arg1, arg2) {
                    logFn(arg1, arg2 == null ? "" : arg2);
                };
            }
        } ];
    }
    var $parseMinErr = minErr("$parse");
    var ARRAY_CTOR = [].constructor;
    var BOOLEAN_CTOR = false.constructor;
    var FUNCTION_CTOR = Function.constructor;
    var NUMBER_CTOR = (0).constructor;
    var OBJECT_CTOR = {}.constructor;
    var STRING_CTOR = "".constructor;
    var ARRAY_CTOR_PROTO = ARRAY_CTOR.prototype;
    var BOOLEAN_CTOR_PROTO = BOOLEAN_CTOR.prototype;
    var FUNCTION_CTOR_PROTO = FUNCTION_CTOR.prototype;
    var NUMBER_CTOR_PROTO = NUMBER_CTOR.prototype;
    var OBJECT_CTOR_PROTO = OBJECT_CTOR.prototype;
    var STRING_CTOR_PROTO = STRING_CTOR.prototype;
    var CALL = FUNCTION_CTOR_PROTO.call;
    var APPLY = FUNCTION_CTOR_PROTO.apply;
    var BIND = FUNCTION_CTOR_PROTO.bind;
    var objectValueOf = OBJECT_CTOR_PROTO.valueOf;
    function ensureSafeMemberName(name, fullExpression) {
        if (name === "__defineGetter__" || name === "__defineSetter__" || name === "__lookupGetter__" || name === "__lookupSetter__" || name === "__proto__") {
            throw $parseMinErr("isecfld", "Attempting to access a disallowed field in Angular expressions! " + "Expression: {0}", fullExpression);
        }
        return name;
    }
    function getStringValue(name) {
        return name + "";
    }
    function ensureSafeObject(obj, fullExpression) {
        if (obj) {
            if (obj.constructor === obj) {
                throw $parseMinErr("isecfn", "Referencing Function in Angular expressions is disallowed! Expression: {0}", fullExpression);
            } else if (obj.window === obj) {
                throw $parseMinErr("isecwindow", "Referencing the Window in Angular expressions is disallowed! Expression: {0}", fullExpression);
            } else if (obj.children && (obj.nodeName || obj.prop && obj.attr && obj.find)) {
                throw $parseMinErr("isecdom", "Referencing DOM nodes in Angular expressions is disallowed! Expression: {0}", fullExpression);
            } else if (obj === Object) {
                throw $parseMinErr("isecobj", "Referencing Object in Angular expressions is disallowed! Expression: {0}", fullExpression);
            }
        }
        return obj;
    }
    function ensureSafeFunction(obj, fullExpression) {
        if (obj) {
            if (obj.constructor === obj) {
                throw $parseMinErr("isecfn", "Referencing Function in Angular expressions is disallowed! Expression: {0}", fullExpression);
            } else if (obj === CALL || obj === APPLY || obj === BIND) {
                throw $parseMinErr("isecff", "Referencing call, apply or bind in Angular expressions is disallowed! Expression: {0}", fullExpression);
            }
        }
    }
    function ensureSafeAssignContext(obj, fullExpression) {
        if (obj) {
            if (obj === ARRAY_CTOR || obj === BOOLEAN_CTOR || obj === FUNCTION_CTOR || obj === NUMBER_CTOR || obj === OBJECT_CTOR || obj === STRING_CTOR || obj === ARRAY_CTOR_PROTO || obj === BOOLEAN_CTOR_PROTO || obj === FUNCTION_CTOR_PROTO || obj === NUMBER_CTOR_PROTO || obj === OBJECT_CTOR_PROTO || obj === STRING_CTOR_PROTO) {
                throw $parseMinErr("isecaf", "Assigning to a constructor or its prototype is disallowed! Expression: {0}", fullExpression);
            }
        }
    }
    var OPERATORS = createMap();
    forEach("+ - * / % === !== == != < > <= >= && || ! = |".split(" "), function(operator) {
        OPERATORS[operator] = true;
    });
    var ESCAPE = {
        n: "\n",
        f: "\f",
        r: "\r",
        t: "\t",
        v: "\x0B",
        "'": "'",
        '"': '"'
    };
    var Lexer = function Lexer(options) {
        this.options = options;
    };
    Lexer.prototype = {
        constructor: Lexer,
        lex: function(text) {
            this.text = text;
            this.index = 0;
            this.tokens = [];
            while (this.index < this.text.length) {
                var ch = this.text.charAt(this.index);
                if (ch === '"' || ch === "'") {
                    this.readString(ch);
                } else if (this.isNumber(ch) || ch === "." && this.isNumber(this.peek())) {
                    this.readNumber();
                } else if (this.isIdentifierStart(this.peekMultichar())) {
                    this.readIdent();
                } else if (this.is(ch, "(){}[].,;:?")) {
                    this.tokens.push({
                        index: this.index,
                        text: ch
                    });
                    this.index++;
                } else if (this.isWhitespace(ch)) {
                    this.index++;
                } else {
                    var ch2 = ch + this.peek();
                    var ch3 = ch2 + this.peek(2);
                    var op1 = OPERATORS[ch];
                    var op2 = OPERATORS[ch2];
                    var op3 = OPERATORS[ch3];
                    if (op1 || op2 || op3) {
                        var token = op3 ? ch3 : op2 ? ch2 : ch;
                        this.tokens.push({
                            index: this.index,
                            text: token,
                            operator: true
                        });
                        this.index += token.length;
                    } else {
                        this.throwError("Unexpected next character ", this.index, this.index + 1);
                    }
                }
            }
            return this.tokens;
        },
        is: function(ch, chars) {
            return chars.indexOf(ch) !== -1;
        },
        peek: function(i) {
            var num = i || 1;
            return this.index + num < this.text.length ? this.text.charAt(this.index + num) : false;
        },
        isNumber: function(ch) {
            return "0" <= ch && ch <= "9" && typeof ch === "string";
        },
        isWhitespace: function(ch) {
            return ch === " " || ch === "\r" || ch === "\t" || ch === "\n" || ch === "\x0B" || ch === "Â ";
        },
        isIdentifierStart: function(ch) {
            return this.options.isIdentifierStart ? this.options.isIdentifierStart(ch, this.codePointAt(ch)) : this.isValidIdentifierStart(ch);
        },
        isValidIdentifierStart: function(ch) {
            return "a" <= ch && ch <= "z" || "A" <= ch && ch <= "Z" || "_" === ch || ch === "$";
        },
        isIdentifierContinue: function(ch) {
            return this.options.isIdentifierContinue ? this.options.isIdentifierContinue(ch, this.codePointAt(ch)) : this.isValidIdentifierContinue(ch);
        },
        isValidIdentifierContinue: function(ch, cp) {
            return this.isValidIdentifierStart(ch, cp) || this.isNumber(ch);
        },
        codePointAt: function(ch) {
            if (ch.length === 1) return ch.charCodeAt(0);
            return (ch.charCodeAt(0) << 10) + ch.charCodeAt(1) - 56613888;
        },
        peekMultichar: function() {
            var ch = this.text.charAt(this.index);
            var peek = this.peek();
            if (!peek) {
                return ch;
            }
            var cp1 = ch.charCodeAt(0);
            var cp2 = peek.charCodeAt(0);
            if (cp1 >= 55296 && cp1 <= 56319 && cp2 >= 56320 && cp2 <= 57343) {
                return ch + peek;
            }
            return ch;
        },
        isExpOperator: function(ch) {
            return ch === "-" || ch === "+" || this.isNumber(ch);
        },
        throwError: function(error, start, end) {
            end = end || this.index;
            var colStr = isDefined(start) ? "s " + start + "-" + this.index + " [" + this.text.substring(start, end) + "]" : " " + end;
            throw $parseMinErr("lexerr", "Lexer Error: {0} at column{1} in expression [{2}].", error, colStr, this.text);
        },
        readNumber: function() {
            var number = "";
            var start = this.index;
            while (this.index < this.text.length) {
                var ch = lowercase(this.text.charAt(this.index));
                if (ch === "." || this.isNumber(ch)) {
                    number += ch;
                } else {
                    var peekCh = this.peek();
                    if (ch === "e" && this.isExpOperator(peekCh)) {
                        number += ch;
                    } else if (this.isExpOperator(ch) && peekCh && this.isNumber(peekCh) && number.charAt(number.length - 1) === "e") {
                        number += ch;
                    } else if (this.isExpOperator(ch) && (!peekCh || !this.isNumber(peekCh)) && number.charAt(number.length - 1) === "e") {
                        this.throwError("Invalid exponent");
                    } else {
                        break;
                    }
                }
                this.index++;
            }
            this.tokens.push({
                index: start,
                text: number,
                constant: true,
                value: Number(number)
            });
        },
        readIdent: function() {
            var start = this.index;
            this.index += this.peekMultichar().length;
            while (this.index < this.text.length) {
                var ch = this.peekMultichar();
                if (!this.isIdentifierContinue(ch)) {
                    break;
                }
                this.index += ch.length;
            }
            this.tokens.push({
                index: start,
                text: this.text.slice(start, this.index),
                identifier: true
            });
        },
        readString: function(quote) {
            var start = this.index;
            this.index++;
            var string = "";
            var rawString = quote;
            var escape = false;
            while (this.index < this.text.length) {
                var ch = this.text.charAt(this.index);
                rawString += ch;
                if (escape) {
                    if (ch === "u") {
                        var hex = this.text.substring(this.index + 1, this.index + 5);
                        if (!hex.match(/[\da-f]{4}/i)) {
                            this.throwError("Invalid unicode escape [\\u" + hex + "]");
                        }
                        this.index += 4;
                        string += String.fromCharCode(parseInt(hex, 16));
                    } else {
                        var rep = ESCAPE[ch];
                        string = string + (rep || ch);
                    }
                    escape = false;
                } else if (ch === "\\") {
                    escape = true;
                } else if (ch === quote) {
                    this.index++;
                    this.tokens.push({
                        index: start,
                        text: rawString,
                        constant: true,
                        value: string
                    });
                    return;
                } else {
                    string += ch;
                }
                this.index++;
            }
            this.throwError("Unterminated quote", start);
        }
    };
    var AST = function AST(lexer, options) {
        this.lexer = lexer;
        this.options = options;
    };
    AST.Program = "Program";
    AST.ExpressionStatement = "ExpressionStatement";
    AST.AssignmentExpression = "AssignmentExpression";
    AST.ConditionalExpression = "ConditionalExpression";
    AST.LogicalExpression = "LogicalExpression";
    AST.BinaryExpression = "BinaryExpression";
    AST.UnaryExpression = "UnaryExpression";
    AST.CallExpression = "CallExpression";
    AST.MemberExpression = "MemberExpression";
    AST.Identifier = "Identifier";
    AST.Literal = "Literal";
    AST.ArrayExpression = "ArrayExpression";
    AST.Property = "Property";
    AST.ObjectExpression = "ObjectExpression";
    AST.ThisExpression = "ThisExpression";
    AST.LocalsExpression = "LocalsExpression";
    AST.NGValueParameter = "NGValueParameter";
    AST.prototype = {
        ast: function(text) {
            this.text = text;
            this.tokens = this.lexer.lex(text);
            var value = this.program();
            if (this.tokens.length !== 0) {
                this.throwError("is an unexpected token", this.tokens[0]);
            }
            return value;
        },
        program: function() {
            var body = [];
            while (true) {
                if (this.tokens.length > 0 && !this.peek("}", ")", ";", "]")) body.push(this.expressionStatement());
                if (!this.expect(";")) {
                    return {
                        type: AST.Program,
                        body: body
                    };
                }
            }
        },
        expressionStatement: function() {
            return {
                type: AST.ExpressionStatement,
                expression: this.filterChain()
            };
        },
        filterChain: function() {
            var left = this.expression();
            while (this.expect("|")) {
                left = this.filter(left);
            }
            return left;
        },
        expression: function() {
            return this.assignment();
        },
        assignment: function() {
            var result = this.ternary();
            if (this.expect("=")) {
                if (!isAssignable(result)) {
                    throw $parseMinErr("lval", "Trying to assign a value to a non l-value");
                }
                result = {
                    type: AST.AssignmentExpression,
                    left: result,
                    right: this.assignment(),
                    operator: "="
                };
            }
            return result;
        },
        ternary: function() {
            var test = this.logicalOR();
            var alternate;
            var consequent;
            if (this.expect("?")) {
                alternate = this.expression();
                if (this.consume(":")) {
                    consequent = this.expression();
                    return {
                        type: AST.ConditionalExpression,
                        test: test,
                        alternate: alternate,
                        consequent: consequent
                    };
                }
            }
            return test;
        },
        logicalOR: function() {
            var left = this.logicalAND();
            while (this.expect("||")) {
                left = {
                    type: AST.LogicalExpression,
                    operator: "||",
                    left: left,
                    right: this.logicalAND()
                };
            }
            return left;
        },
        logicalAND: function() {
            var left = this.equality();
            while (this.expect("&&")) {
                left = {
                    type: AST.LogicalExpression,
                    operator: "&&",
                    left: left,
                    right: this.equality()
                };
            }
            return left;
        },
        equality: function() {
            var left = this.relational();
            var token;
            while (token = this.expect("==", "!=", "===", "!==")) {
                left = {
                    type: AST.BinaryExpression,
                    operator: token.text,
                    left: left,
                    right: this.relational()
                };
            }
            return left;
        },
        relational: function() {
            var left = this.additive();
            var token;
            while (token = this.expect("<", ">", "<=", ">=")) {
                left = {
                    type: AST.BinaryExpression,
                    operator: token.text,
                    left: left,
                    right: this.additive()
                };
            }
            return left;
        },
        additive: function() {
            var left = this.multiplicative();
            var token;
            while (token = this.expect("+", "-")) {
                left = {
                    type: AST.BinaryExpression,
                    operator: token.text,
                    left: left,
                    right: this.multiplicative()
                };
            }
            return left;
        },
        multiplicative: function() {
            var left = this.unary();
            var token;
            while (token = this.expect("*", "/", "%")) {
                left = {
                    type: AST.BinaryExpression,
                    operator: token.text,
                    left: left,
                    right: this.unary()
                };
            }
            return left;
        },
        unary: function() {
            var token;
            if (token = this.expect("+", "-", "!")) {
                return {
                    type: AST.UnaryExpression,
                    operator: token.text,
                    prefix: true,
                    argument: this.unary()
                };
            } else {
                return this.primary();
            }
        },
        primary: function() {
            var primary;
            if (this.expect("(")) {
                primary = this.filterChain();
                this.consume(")");
            } else if (this.expect("[")) {
                primary = this.arrayDeclaration();
            } else if (this.expect("{")) {
                primary = this.object();
            } else if (this.selfReferential.hasOwnProperty(this.peek().text)) {
                primary = copy(this.selfReferential[this.consume().text]);
            } else if (this.options.literals.hasOwnProperty(this.peek().text)) {
                primary = {
                    type: AST.Literal,
                    value: this.options.literals[this.consume().text]
                };
            } else if (this.peek().identifier) {
                primary = this.identifier();
            } else if (this.peek().constant) {
                primary = this.constant();
            } else {
                this.throwError("not a primary expression", this.peek());
            }
            var next;
            while (next = this.expect("(", "[", ".")) {
                if (next.text === "(") {
                    primary = {
                        type: AST.CallExpression,
                        callee: primary,
                        arguments: this.parseArguments()
                    };
                    this.consume(")");
                } else if (next.text === "[") {
                    primary = {
                        type: AST.MemberExpression,
                        object: primary,
                        property: this.expression(),
                        computed: true
                    };
                    this.consume("]");
                } else if (next.text === ".") {
                    primary = {
                        type: AST.MemberExpression,
                        object: primary,
                        property: this.identifier(),
                        computed: false
                    };
                } else {
                    this.throwError("IMPOSSIBLE");
                }
            }
            return primary;
        },
        filter: function(baseExpression) {
            var args = [ baseExpression ];
            var result = {
                type: AST.CallExpression,
                callee: this.identifier(),
                arguments: args,
                filter: true
            };
            while (this.expect(":")) {
                args.push(this.expression());
            }
            return result;
        },
        parseArguments: function() {
            var args = [];
            if (this.peekToken().text !== ")") {
                do {
                    args.push(this.filterChain());
                } while (this.expect(","));
            }
            return args;
        },
        identifier: function() {
            var token = this.consume();
            if (!token.identifier) {
                this.throwError("is not a valid identifier", token);
            }
            return {
                type: AST.Identifier,
                name: token.text
            };
        },
        constant: function() {
            return {
                type: AST.Literal,
                value: this.consume().value
            };
        },
        arrayDeclaration: function() {
            var elements = [];
            if (this.peekToken().text !== "]") {
                do {
                    if (this.peek("]")) {
                        break;
                    }
                    elements.push(this.expression());
                } while (this.expect(","));
            }
            this.consume("]");
            return {
                type: AST.ArrayExpression,
                elements: elements
            };
        },
        object: function() {
            var properties = [], property;
            if (this.peekToken().text !== "}") {
                do {
                    if (this.peek("}")) {
                        break;
                    }
                    property = {
                        type: AST.Property,
                        kind: "init"
                    };
                    if (this.peek().constant) {
                        property.key = this.constant();
                        property.computed = false;
                        this.consume(":");
                        property.value = this.expression();
                    } else if (this.peek().identifier) {
                        property.key = this.identifier();
                        property.computed = false;
                        if (this.peek(":")) {
                            this.consume(":");
                            property.value = this.expression();
                        } else {
                            property.value = property.key;
                        }
                    } else if (this.peek("[")) {
                        this.consume("[");
                        property.key = this.expression();
                        this.consume("]");
                        property.computed = true;
                        this.consume(":");
                        property.value = this.expression();
                    } else {
                        this.throwError("invalid key", this.peek());
                    }
                    properties.push(property);
                } while (this.expect(","));
            }
            this.consume("}");
            return {
                type: AST.ObjectExpression,
                properties: properties
            };
        },
        throwError: function(msg, token) {
            throw $parseMinErr("syntax", "Syntax Error: Token '{0}' {1} at column {2} of the expression [{3}] starting at [{4}].", token.text, msg, token.index + 1, this.text, this.text.substring(token.index));
        },
        consume: function(e1) {
            if (this.tokens.length === 0) {
                throw $parseMinErr("ueoe", "Unexpected end of expression: {0}", this.text);
            }
            var token = this.expect(e1);
            if (!token) {
                this.throwError("is unexpected, expecting [" + e1 + "]", this.peek());
            }
            return token;
        },
        peekToken: function() {
            if (this.tokens.length === 0) {
                throw $parseMinErr("ueoe", "Unexpected end of expression: {0}", this.text);
            }
            return this.tokens[0];
        },
        peek: function(e1, e2, e3, e4) {
            return this.peekAhead(0, e1, e2, e3, e4);
        },
        peekAhead: function(i, e1, e2, e3, e4) {
            if (this.tokens.length > i) {
                var token = this.tokens[i];
                var t = token.text;
                if (t === e1 || t === e2 || t === e3 || t === e4 || !e1 && !e2 && !e3 && !e4) {
                    return token;
                }
            }
            return false;
        },
        expect: function(e1, e2, e3, e4) {
            var token = this.peek(e1, e2, e3, e4);
            if (token) {
                this.tokens.shift();
                return token;
            }
            return false;
        },
        selfReferential: {
            "this": {
                type: AST.ThisExpression
            },
            $locals: {
                type: AST.LocalsExpression
            }
        }
    };
    function ifDefined(v, d) {
        return typeof v !== "undefined" ? v : d;
    }
    function plusFn(l, r) {
        if (typeof l === "undefined") return r;
        if (typeof r === "undefined") return l;
        return l + r;
    }
    function isStateless($filter, filterName) {
        var fn = $filter(filterName);
        return !fn.$stateful;
    }
    function findConstantAndWatchExpressions(ast, $filter) {
        var allConstants;
        var argsToWatch;
        var isStatelessFilter;
        switch (ast.type) {
          case AST.Program:
            allConstants = true;
            forEach(ast.body, function(expr) {
                findConstantAndWatchExpressions(expr.expression, $filter);
                allConstants = allConstants && expr.expression.constant;
            });
            ast.constant = allConstants;
            break;

          case AST.Literal:
            ast.constant = true;
            ast.toWatch = [];
            break;

          case AST.UnaryExpression:
            findConstantAndWatchExpressions(ast.argument, $filter);
            ast.constant = ast.argument.constant;
            ast.toWatch = ast.argument.toWatch;
            break;

          case AST.BinaryExpression:
            findConstantAndWatchExpressions(ast.left, $filter);
            findConstantAndWatchExpressions(ast.right, $filter);
            ast.constant = ast.left.constant && ast.right.constant;
            ast.toWatch = ast.left.toWatch.concat(ast.right.toWatch);
            break;

          case AST.LogicalExpression:
            findConstantAndWatchExpressions(ast.left, $filter);
            findConstantAndWatchExpressions(ast.right, $filter);
            ast.constant = ast.left.constant && ast.right.constant;
            ast.toWatch = ast.constant ? [] : [ ast ];
            break;

          case AST.ConditionalExpression:
            findConstantAndWatchExpressions(ast.test, $filter);
            findConstantAndWatchExpressions(ast.alternate, $filter);
            findConstantAndWatchExpressions(ast.consequent, $filter);
            ast.constant = ast.test.constant && ast.alternate.constant && ast.consequent.constant;
            ast.toWatch = ast.constant ? [] : [ ast ];
            break;

          case AST.Identifier:
            ast.constant = false;
            ast.toWatch = [ ast ];
            break;

          case AST.MemberExpression:
            findConstantAndWatchExpressions(ast.object, $filter);
            if (ast.computed) {
                findConstantAndWatchExpressions(ast.property, $filter);
            }
            ast.constant = ast.object.constant && (!ast.computed || ast.property.constant);
            ast.toWatch = [ ast ];
            break;

          case AST.CallExpression:
            isStatelessFilter = ast.filter ? isStateless($filter, ast.callee.name) : false;
            allConstants = isStatelessFilter;
            argsToWatch = [];
            forEach(ast.arguments, function(expr) {
                findConstantAndWatchExpressions(expr, $filter);
                allConstants = allConstants && expr.constant;
                if (!expr.constant) {
                    argsToWatch.push.apply(argsToWatch, expr.toWatch);
                }
            });
            ast.constant = allConstants;
            ast.toWatch = isStatelessFilter ? argsToWatch : [ ast ];
            break;

          case AST.AssignmentExpression:
            findConstantAndWatchExpressions(ast.left, $filter);
            findConstantAndWatchExpressions(ast.right, $filter);
            ast.constant = ast.left.constant && ast.right.constant;
            ast.toWatch = [ ast ];
            break;

          case AST.ArrayExpression:
            allConstants = true;
            argsToWatch = [];
            forEach(ast.elements, function(expr) {
                findConstantAndWatchExpressions(expr, $filter);
                allConstants = allConstants && expr.constant;
                if (!expr.constant) {
                    argsToWatch.push.apply(argsToWatch, expr.toWatch);
                }
            });
            ast.constant = allConstants;
            ast.toWatch = argsToWatch;
            break;

          case AST.ObjectExpression:
            allConstants = true;
            argsToWatch = [];
            forEach(ast.properties, function(property) {
                findConstantAndWatchExpressions(property.value, $filter);
                allConstants = allConstants && property.value.constant && !property.computed;
                if (!property.value.constant) {
                    argsToWatch.push.apply(argsToWatch, property.value.toWatch);
                }
            });
            ast.constant = allConstants;
            ast.toWatch = argsToWatch;
            break;

          case AST.ThisExpression:
            ast.constant = false;
            ast.toWatch = [];
            break;

          case AST.LocalsExpression:
            ast.constant = false;
            ast.toWatch = [];
            break;
        }
    }
    function getInputs(body) {
        if (body.length !== 1) return;
        var lastExpression = body[0].expression;
        var candidate = lastExpression.toWatch;
        if (candidate.length !== 1) return candidate;
        return candidate[0] !== lastExpression ? candidate : undefined;
    }
    function isAssignable(ast) {
        return ast.type === AST.Identifier || ast.type === AST.MemberExpression;
    }
    function assignableAST(ast) {
        if (ast.body.length === 1 && isAssignable(ast.body[0].expression)) {
            return {
                type: AST.AssignmentExpression,
                left: ast.body[0].expression,
                right: {
                    type: AST.NGValueParameter
                },
                operator: "="
            };
        }
    }
    function isLiteral(ast) {
        return ast.body.length === 0 || ast.body.length === 1 && (ast.body[0].expression.type === AST.Literal || ast.body[0].expression.type === AST.ArrayExpression || ast.body[0].expression.type === AST.ObjectExpression);
    }
    function isConstant(ast) {
        return ast.constant;
    }
    function ASTCompiler(astBuilder, $filter) {
        this.astBuilder = astBuilder;
        this.$filter = $filter;
    }
    ASTCompiler.prototype = {
        compile: function(expression, expensiveChecks) {
            var self = this;
            var ast = this.astBuilder.ast(expression);
            this.state = {
                nextId: 0,
                filters: {},
                expensiveChecks: expensiveChecks,
                fn: {
                    vars: [],
                    body: [],
                    own: {}
                },
                assign: {
                    vars: [],
                    body: [],
                    own: {}
                },
                inputs: []
            };
            findConstantAndWatchExpressions(ast, self.$filter);
            var extra = "";
            var assignable;
            this.stage = "assign";
            if (assignable = assignableAST(ast)) {
                this.state.computing = "assign";
                var result = this.nextId();
                this.recurse(assignable, result);
                this.return_(result);
                extra = "fn.assign=" + this.generateFunction("assign", "s,v,l");
            }
            var toWatch = getInputs(ast.body);
            self.stage = "inputs";
            forEach(toWatch, function(watch, key) {
                var fnKey = "fn" + key;
                self.state[fnKey] = {
                    vars: [],
                    body: [],
                    own: {}
                };
                self.state.computing = fnKey;
                var intoId = self.nextId();
                self.recurse(watch, intoId);
                self.return_(intoId);
                self.state.inputs.push(fnKey);
                watch.watchId = key;
            });
            this.state.computing = "fn";
            this.stage = "main";
            this.recurse(ast);
            var fnString = '"' + this.USE + " " + this.STRICT + '";\n' + this.filterPrefix() + "var fn=" + this.generateFunction("fn", "s,l,a,i") + extra + this.watchFns() + "return fn;";
            var fn = new Function("$filter", "ensureSafeMemberName", "ensureSafeObject", "ensureSafeFunction", "getStringValue", "ensureSafeAssignContext", "ifDefined", "plus", "text", fnString)(this.$filter, ensureSafeMemberName, ensureSafeObject, ensureSafeFunction, getStringValue, ensureSafeAssignContext, ifDefined, plusFn, expression);
            this.state = this.stage = undefined;
            fn.literal = isLiteral(ast);
            fn.constant = isConstant(ast);
            return fn;
        },
        USE: "use",
        STRICT: "strict",
        watchFns: function() {
            var result = [];
            var fns = this.state.inputs;
            var self = this;
            forEach(fns, function(name) {
                result.push("var " + name + "=" + self.generateFunction(name, "s"));
            });
            if (fns.length) {
                result.push("fn.inputs=[" + fns.join(",") + "];");
            }
            return result.join("");
        },
        generateFunction: function(name, params) {
            return "function(" + params + "){" + this.varsPrefix(name) + this.body(name) + "};";
        },
        filterPrefix: function() {
            var parts = [];
            var self = this;
            forEach(this.state.filters, function(id, filter) {
                parts.push(id + "=$filter(" + self.escape(filter) + ")");
            });
            if (parts.length) return "var " + parts.join(",") + ";";
            return "";
        },
        varsPrefix: function(section) {
            return this.state[section].vars.length ? "var " + this.state[section].vars.join(",") + ";" : "";
        },
        body: function(section) {
            return this.state[section].body.join("");
        },
        recurse: function(ast, intoId, nameId, recursionFn, create, skipWatchIdCheck) {
            var left, right, self = this, args, expression, computed;
            recursionFn = recursionFn || noop;
            if (!skipWatchIdCheck && isDefined(ast.watchId)) {
                intoId = intoId || this.nextId();
                this.if_("i", this.lazyAssign(intoId, this.computedMember("i", ast.watchId)), this.lazyRecurse(ast, intoId, nameId, recursionFn, create, true));
                return;
            }
            switch (ast.type) {
              case AST.Program:
                forEach(ast.body, function(expression, pos) {
                    self.recurse(expression.expression, undefined, undefined, function(expr) {
                        right = expr;
                    });
                    if (pos !== ast.body.length - 1) {
                        self.current().body.push(right, ";");
                    } else {
                        self.return_(right);
                    }
                });
                break;

              case AST.Literal:
                expression = this.escape(ast.value);
                this.assign(intoId, expression);
                recursionFn(expression);
                break;

              case AST.UnaryExpression:
                this.recurse(ast.argument, undefined, undefined, function(expr) {
                    right = expr;
                });
                expression = ast.operator + "(" + this.ifDefined(right, 0) + ")";
                this.assign(intoId, expression);
                recursionFn(expression);
                break;

              case AST.BinaryExpression:
                this.recurse(ast.left, undefined, undefined, function(expr) {
                    left = expr;
                });
                this.recurse(ast.right, undefined, undefined, function(expr) {
                    right = expr;
                });
                if (ast.operator === "+") {
                    expression = this.plus(left, right);
                } else if (ast.operator === "-") {
                    expression = this.ifDefined(left, 0) + ast.operator + this.ifDefined(right, 0);
                } else {
                    expression = "(" + left + ")" + ast.operator + "(" + right + ")";
                }
                this.assign(intoId, expression);
                recursionFn(expression);
                break;

              case AST.LogicalExpression:
                intoId = intoId || this.nextId();
                self.recurse(ast.left, intoId);
                self.if_(ast.operator === "&&" ? intoId : self.not(intoId), self.lazyRecurse(ast.right, intoId));
                recursionFn(intoId);
                break;

              case AST.ConditionalExpression:
                intoId = intoId || this.nextId();
                self.recurse(ast.test, intoId);
                self.if_(intoId, self.lazyRecurse(ast.alternate, intoId), self.lazyRecurse(ast.consequent, intoId));
                recursionFn(intoId);
                break;

              case AST.Identifier:
                intoId = intoId || this.nextId();
                if (nameId) {
                    nameId.context = self.stage === "inputs" ? "s" : this.assign(this.nextId(), this.getHasOwnProperty("l", ast.name) + "?l:s");
                    nameId.computed = false;
                    nameId.name = ast.name;
                }
                ensureSafeMemberName(ast.name);
                self.if_(self.stage === "inputs" || self.not(self.getHasOwnProperty("l", ast.name)), function() {
                    self.if_(self.stage === "inputs" || "s", function() {
                        if (create && create !== 1) {
                            self.if_(self.not(self.nonComputedMember("s", ast.name)), self.lazyAssign(self.nonComputedMember("s", ast.name), "{}"));
                        }
                        self.assign(intoId, self.nonComputedMember("s", ast.name));
                    });
                }, intoId && self.lazyAssign(intoId, self.nonComputedMember("l", ast.name)));
                if (self.state.expensiveChecks || isPossiblyDangerousMemberName(ast.name)) {
                    self.addEnsureSafeObject(intoId);
                }
                recursionFn(intoId);
                break;

              case AST.MemberExpression:
                left = nameId && (nameId.context = this.nextId()) || this.nextId();
                intoId = intoId || this.nextId();
                self.recurse(ast.object, left, undefined, function() {
                    self.if_(self.notNull(left), function() {
                        if (create && create !== 1) {
                            self.addEnsureSafeAssignContext(left);
                        }
                        if (ast.computed) {
                            right = self.nextId();
                            self.recurse(ast.property, right);
                            self.getStringValue(right);
                            self.addEnsureSafeMemberName(right);
                            if (create && create !== 1) {
                                self.if_(self.not(self.computedMember(left, right)), self.lazyAssign(self.computedMember(left, right), "{}"));
                            }
                            expression = self.ensureSafeObject(self.computedMember(left, right));
                            self.assign(intoId, expression);
                            if (nameId) {
                                nameId.computed = true;
                                nameId.name = right;
                            }
                        } else {
                            ensureSafeMemberName(ast.property.name);
                            if (create && create !== 1) {
                                self.if_(self.not(self.nonComputedMember(left, ast.property.name)), self.lazyAssign(self.nonComputedMember(left, ast.property.name), "{}"));
                            }
                            expression = self.nonComputedMember(left, ast.property.name);
                            if (self.state.expensiveChecks || isPossiblyDangerousMemberName(ast.property.name)) {
                                expression = self.ensureSafeObject(expression);
                            }
                            self.assign(intoId, expression);
                            if (nameId) {
                                nameId.computed = false;
                                nameId.name = ast.property.name;
                            }
                        }
                    }, function() {
                        self.assign(intoId, "undefined");
                    });
                    recursionFn(intoId);
                }, !!create);
                break;

              case AST.CallExpression:
                intoId = intoId || this.nextId();
                if (ast.filter) {
                    right = self.filter(ast.callee.name);
                    args = [];
                    forEach(ast.arguments, function(expr) {
                        var argument = self.nextId();
                        self.recurse(expr, argument);
                        args.push(argument);
                    });
                    expression = right + "(" + args.join(",") + ")";
                    self.assign(intoId, expression);
                    recursionFn(intoId);
                } else {
                    right = self.nextId();
                    left = {};
                    args = [];
                    self.recurse(ast.callee, right, left, function() {
                        self.if_(self.notNull(right), function() {
                            self.addEnsureSafeFunction(right);
                            forEach(ast.arguments, function(expr) {
                                self.recurse(expr, self.nextId(), undefined, function(argument) {
                                    args.push(self.ensureSafeObject(argument));
                                });
                            });
                            if (left.name) {
                                if (!self.state.expensiveChecks) {
                                    self.addEnsureSafeObject(left.context);
                                }
                                expression = self.member(left.context, left.name, left.computed) + "(" + args.join(",") + ")";
                            } else {
                                expression = right + "(" + args.join(",") + ")";
                            }
                            expression = self.ensureSafeObject(expression);
                            self.assign(intoId, expression);
                        }, function() {
                            self.assign(intoId, "undefined");
                        });
                        recursionFn(intoId);
                    });
                }
                break;

              case AST.AssignmentExpression:
                right = this.nextId();
                left = {};
                this.recurse(ast.left, undefined, left, function() {
                    self.if_(self.notNull(left.context), function() {
                        self.recurse(ast.right, right);
                        self.addEnsureSafeObject(self.member(left.context, left.name, left.computed));
                        self.addEnsureSafeAssignContext(left.context);
                        expression = self.member(left.context, left.name, left.computed) + ast.operator + right;
                        self.assign(intoId, expression);
                        recursionFn(intoId || expression);
                    });
                }, 1);
                break;

              case AST.ArrayExpression:
                args = [];
                forEach(ast.elements, function(expr) {
                    self.recurse(expr, self.nextId(), undefined, function(argument) {
                        args.push(argument);
                    });
                });
                expression = "[" + args.join(",") + "]";
                this.assign(intoId, expression);
                recursionFn(expression);
                break;

              case AST.ObjectExpression:
                args = [];
                computed = false;
                forEach(ast.properties, function(property) {
                    if (property.computed) {
                        computed = true;
                    }
                });
                if (computed) {
                    intoId = intoId || this.nextId();
                    this.assign(intoId, "{}");
                    forEach(ast.properties, function(property) {
                        if (property.computed) {
                            left = self.nextId();
                            self.recurse(property.key, left);
                        } else {
                            left = property.key.type === AST.Identifier ? property.key.name : "" + property.key.value;
                        }
                        right = self.nextId();
                        self.recurse(property.value, right);
                        self.assign(self.member(intoId, left, property.computed), right);
                    });
                } else {
                    forEach(ast.properties, function(property) {
                        self.recurse(property.value, ast.constant ? undefined : self.nextId(), undefined, function(expr) {
                            args.push(self.escape(property.key.type === AST.Identifier ? property.key.name : "" + property.key.value) + ":" + expr);
                        });
                    });
                    expression = "{" + args.join(",") + "}";
                    this.assign(intoId, expression);
                }
                recursionFn(intoId || expression);
                break;

              case AST.ThisExpression:
                this.assign(intoId, "s");
                recursionFn("s");
                break;

              case AST.LocalsExpression:
                this.assign(intoId, "l");
                recursionFn("l");
                break;

              case AST.NGValueParameter:
                this.assign(intoId, "v");
                recursionFn("v");
                break;
            }
        },
        getHasOwnProperty: function(element, property) {
            var key = element + "." + property;
            var own = this.current().own;
            if (!own.hasOwnProperty(key)) {
                own[key] = this.nextId(false, element + "&&(" + this.escape(property) + " in " + element + ")");
            }
            return own[key];
        },
        assign: function(id, value) {
            if (!id) return;
            this.current().body.push(id, "=", value, ";");
            return id;
        },
        filter: function(filterName) {
            if (!this.state.filters.hasOwnProperty(filterName)) {
                this.state.filters[filterName] = this.nextId(true);
            }
            return this.state.filters[filterName];
        },
        ifDefined: function(id, defaultValue) {
            return "ifDefined(" + id + "," + this.escape(defaultValue) + ")";
        },
        plus: function(left, right) {
            return "plus(" + left + "," + right + ")";
        },
        return_: function(id) {
            this.current().body.push("return ", id, ";");
        },
        if_: function(test, alternate, consequent) {
            if (test === true) {
                alternate();
            } else {
                var body = this.current().body;
                body.push("if(", test, "){");
                alternate();
                body.push("}");
                if (consequent) {
                    body.push("else{");
                    consequent();
                    body.push("}");
                }
            }
        },
        not: function(expression) {
            return "!(" + expression + ")";
        },
        notNull: function(expression) {
            return expression + "!=null";
        },
        nonComputedMember: function(left, right) {
            var SAFE_IDENTIFIER = /^[$_a-zA-Z][$_a-zA-Z0-9]*$/;
            var UNSAFE_CHARACTERS = /[^$_a-zA-Z0-9]/g;
            if (SAFE_IDENTIFIER.test(right)) {
                return left + "." + right;
            } else {
                return left + '["' + right.replace(UNSAFE_CHARACTERS, this.stringEscapeFn) + '"]';
            }
        },
        computedMember: function(left, right) {
            return left + "[" + right + "]";
        },
        member: function(left, right, computed) {
            if (computed) return this.computedMember(left, right);
            return this.nonComputedMember(left, right);
        },
        addEnsureSafeObject: function(item) {
            this.current().body.push(this.ensureSafeObject(item), ";");
        },
        addEnsureSafeMemberName: function(item) {
            this.current().body.push(this.ensureSafeMemberName(item), ";");
        },
        addEnsureSafeFunction: function(item) {
            this.current().body.push(this.ensureSafeFunction(item), ";");
        },
        addEnsureSafeAssignContext: function(item) {
            this.current().body.push(this.ensureSafeAssignContext(item), ";");
        },
        ensureSafeObject: function(item) {
            return "ensureSafeObject(" + item + ",text)";
        },
        ensureSafeMemberName: function(item) {
            return "ensureSafeMemberName(" + item + ",text)";
        },
        ensureSafeFunction: function(item) {
            return "ensureSafeFunction(" + item + ",text)";
        },
        getStringValue: function(item) {
            this.assign(item, "getStringValue(" + item + ")");
        },
        ensureSafeAssignContext: function(item) {
            return "ensureSafeAssignContext(" + item + ",text)";
        },
        lazyRecurse: function(ast, intoId, nameId, recursionFn, create, skipWatchIdCheck) {
            var self = this;
            return function() {
                self.recurse(ast, intoId, nameId, recursionFn, create, skipWatchIdCheck);
            };
        },
        lazyAssign: function(id, value) {
            var self = this;
            return function() {
                self.assign(id, value);
            };
        },
        stringEscapeRegex: /[^ a-zA-Z0-9]/g,
        stringEscapeFn: function(c) {
            return "\\u" + ("0000" + c.charCodeAt(0).toString(16)).slice(-4);
        },
        escape: function(value) {
            if (isString(value)) return "'" + value.replace(this.stringEscapeRegex, this.stringEscapeFn) + "'";
            if (isNumber(value)) return value.toString();
            if (value === true) return "true";
            if (value === false) return "false";
            if (value === null) return "null";
            if (typeof value === "undefined") return "undefined";
            throw $parseMinErr("esc", "IMPOSSIBLE");
        },
        nextId: function(skip, init) {
            var id = "v" + this.state.nextId++;
            if (!skip) {
                this.current().vars.push(id + (init ? "=" + init : ""));
            }
            return id;
        },
        current: function() {
            return this.state[this.state.computing];
        }
    };
    function ASTInterpreter(astBuilder, $filter) {
        this.astBuilder = astBuilder;
        this.$filter = $filter;
    }
    ASTInterpreter.prototype = {
        compile: function(expression, expensiveChecks) {
            var self = this;
            var ast = this.astBuilder.ast(expression);
            this.expression = expression;
            this.expensiveChecks = expensiveChecks;
            findConstantAndWatchExpressions(ast, self.$filter);
            var assignable;
            var assign;
            if (assignable = assignableAST(ast)) {
                assign = this.recurse(assignable);
            }
            var toWatch = getInputs(ast.body);
            var inputs;
            if (toWatch) {
                inputs = [];
                forEach(toWatch, function(watch, key) {
                    var input = self.recurse(watch);
                    watch.input = input;
                    inputs.push(input);
                    watch.watchId = key;
                });
            }
            var expressions = [];
            forEach(ast.body, function(expression) {
                expressions.push(self.recurse(expression.expression));
            });
            var fn = ast.body.length === 0 ? noop : ast.body.length === 1 ? expressions[0] : function(scope, locals) {
                var lastValue;
                forEach(expressions, function(exp) {
                    lastValue = exp(scope, locals);
                });
                return lastValue;
            };
            if (assign) {
                fn.assign = function(scope, value, locals) {
                    return assign(scope, locals, value);
                };
            }
            if (inputs) {
                fn.inputs = inputs;
            }
            fn.literal = isLiteral(ast);
            fn.constant = isConstant(ast);
            return fn;
        },
        recurse: function(ast, context, create) {
            var left, right, self = this, args;
            if (ast.input) {
                return this.inputs(ast.input, ast.watchId);
            }
            switch (ast.type) {
              case AST.Literal:
                return this.value(ast.value, context);

              case AST.UnaryExpression:
                right = this.recurse(ast.argument);
                return this["unary" + ast.operator](right, context);

              case AST.BinaryExpression:
                left = this.recurse(ast.left);
                right = this.recurse(ast.right);
                return this["binary" + ast.operator](left, right, context);

              case AST.LogicalExpression:
                left = this.recurse(ast.left);
                right = this.recurse(ast.right);
                return this["binary" + ast.operator](left, right, context);

              case AST.ConditionalExpression:
                return this["ternary?:"](this.recurse(ast.test), this.recurse(ast.alternate), this.recurse(ast.consequent), context);

              case AST.Identifier:
                ensureSafeMemberName(ast.name, self.expression);
                return self.identifier(ast.name, self.expensiveChecks || isPossiblyDangerousMemberName(ast.name), context, create, self.expression);

              case AST.MemberExpression:
                left = this.recurse(ast.object, false, !!create);
                if (!ast.computed) {
                    ensureSafeMemberName(ast.property.name, self.expression);
                    right = ast.property.name;
                }
                if (ast.computed) right = this.recurse(ast.property);
                return ast.computed ? this.computedMember(left, right, context, create, self.expression) : this.nonComputedMember(left, right, self.expensiveChecks, context, create, self.expression);

              case AST.CallExpression:
                args = [];
                forEach(ast.arguments, function(expr) {
                    args.push(self.recurse(expr));
                });
                if (ast.filter) right = this.$filter(ast.callee.name);
                if (!ast.filter) right = this.recurse(ast.callee, true);
                return ast.filter ? function(scope, locals, assign, inputs) {
                    var values = [];
                    for (var i = 0; i < args.length; ++i) {
                        values.push(args[i](scope, locals, assign, inputs));
                    }
                    var value = right.apply(undefined, values, inputs);
                    return context ? {
                        context: undefined,
                        name: undefined,
                        value: value
                    } : value;
                } : function(scope, locals, assign, inputs) {
                    var rhs = right(scope, locals, assign, inputs);
                    var value;
                    if (rhs.value != null) {
                        ensureSafeObject(rhs.context, self.expression);
                        ensureSafeFunction(rhs.value, self.expression);
                        var values = [];
                        for (var i = 0; i < args.length; ++i) {
                            values.push(ensureSafeObject(args[i](scope, locals, assign, inputs), self.expression));
                        }
                        value = ensureSafeObject(rhs.value.apply(rhs.context, values), self.expression);
                    }
                    return context ? {
                        value: value
                    } : value;
                };

              case AST.AssignmentExpression:
                left = this.recurse(ast.left, true, 1);
                right = this.recurse(ast.right);
                return function(scope, locals, assign, inputs) {
                    var lhs = left(scope, locals, assign, inputs);
                    var rhs = right(scope, locals, assign, inputs);
                    ensureSafeObject(lhs.value, self.expression);
                    ensureSafeAssignContext(lhs.context);
                    lhs.context[lhs.name] = rhs;
                    return context ? {
                        value: rhs
                    } : rhs;
                };

              case AST.ArrayExpression:
                args = [];
                forEach(ast.elements, function(expr) {
                    args.push(self.recurse(expr));
                });
                return function(scope, locals, assign, inputs) {
                    var value = [];
                    for (var i = 0; i < args.length; ++i) {
                        value.push(args[i](scope, locals, assign, inputs));
                    }
                    return context ? {
                        value: value
                    } : value;
                };

              case AST.ObjectExpression:
                args = [];
                forEach(ast.properties, function(property) {
                    if (property.computed) {
                        args.push({
                            key: self.recurse(property.key),
                            computed: true,
                            value: self.recurse(property.value)
                        });
                    } else {
                        args.push({
                            key: property.key.type === AST.Identifier ? property.key.name : "" + property.key.value,
                            computed: false,
                            value: self.recurse(property.value)
                        });
                    }
                });
                return function(scope, locals, assign, inputs) {
                    var value = {};
                    for (var i = 0; i < args.length; ++i) {
                        if (args[i].computed) {
                            value[args[i].key(scope, locals, assign, inputs)] = args[i].value(scope, locals, assign, inputs);
                        } else {
                            value[args[i].key] = args[i].value(scope, locals, assign, inputs);
                        }
                    }
                    return context ? {
                        value: value
                    } : value;
                };

              case AST.ThisExpression:
                return function(scope) {
                    return context ? {
                        value: scope
                    } : scope;
                };

              case AST.LocalsExpression:
                return function(scope, locals) {
                    return context ? {
                        value: locals
                    } : locals;
                };

              case AST.NGValueParameter:
                return function(scope, locals, assign) {
                    return context ? {
                        value: assign
                    } : assign;
                };
            }
        },
        "unary+": function(argument, context) {
            return function(scope, locals, assign, inputs) {
                var arg = argument(scope, locals, assign, inputs);
                if (isDefined(arg)) {
                    arg = +arg;
                } else {
                    arg = 0;
                }
                return context ? {
                    value: arg
                } : arg;
            };
        },
        "unary-": function(argument, context) {
            return function(scope, locals, assign, inputs) {
                var arg = argument(scope, locals, assign, inputs);
                if (isDefined(arg)) {
                    arg = -arg;
                } else {
                    arg = 0;
                }
                return context ? {
                    value: arg
                } : arg;
            };
        },
        "unary!": function(argument, context) {
            return function(scope, locals, assign, inputs) {
                var arg = !argument(scope, locals, assign, inputs);
                return context ? {
                    value: arg
                } : arg;
            };
        },
        "binary+": function(left, right, context) {
            return function(scope, locals, assign, inputs) {
                var lhs = left(scope, locals, assign, inputs);
                var rhs = right(scope, locals, assign, inputs);
                var arg = plusFn(lhs, rhs);
                return context ? {
                    value: arg
                } : arg;
            };
        },
        "binary-": function(left, right, context) {
            return function(scope, locals, assign, inputs) {
                var lhs = left(scope, locals, assign, inputs);
                var rhs = right(scope, locals, assign, inputs);
                var arg = (isDefined(lhs) ? lhs : 0) - (isDefined(rhs) ? rhs : 0);
                return context ? {
                    value: arg
                } : arg;
            };
        },
        "binary*": function(left, right, context) {
            return function(scope, locals, assign, inputs) {
                var arg = left(scope, locals, assign, inputs) * right(scope, locals, assign, inputs);
                return context ? {
                    value: arg
                } : arg;
            };
        },
        "binary/": function(left, right, context) {
            return function(scope, locals, assign, inputs) {
                var arg = left(scope, locals, assign, inputs) / right(scope, locals, assign, inputs);
                return context ? {
                    value: arg
                } : arg;
            };
        },
        "binary%": function(left, right, context) {
            return function(scope, locals, assign, inputs) {
                var arg = left(scope, locals, assign, inputs) % right(scope, locals, assign, inputs);
                return context ? {
                    value: arg
                } : arg;
            };
        },
        "binary===": function(left, right, context) {
            return function(scope, locals, assign, inputs) {
                var arg = left(scope, locals, assign, inputs) === right(scope, locals, assign, inputs);
                return context ? {
                    value: arg
                } : arg;
            };
        },
        "binary!==": function(left, right, context) {
            return function(scope, locals, assign, inputs) {
                var arg = left(scope, locals, assign, inputs) !== right(scope, locals, assign, inputs);
                return context ? {
                    value: arg
                } : arg;
            };
        },
        "binary==": function(left, right, context) {
            return function(scope, locals, assign, inputs) {
                var arg = left(scope, locals, assign, inputs) == right(scope, locals, assign, inputs);
                return context ? {
                    value: arg
                } : arg;
            };
        },
        "binary!=": function(left, right, context) {
            return function(scope, locals, assign, inputs) {
                var arg = left(scope, locals, assign, inputs) != right(scope, locals, assign, inputs);
                return context ? {
                    value: arg
                } : arg;
            };
        },
        "binary<": function(left, right, context) {
            return function(scope, locals, assign, inputs) {
                var arg = left(scope, locals, assign, inputs) < right(scope, locals, assign, inputs);
                return context ? {
                    value: arg
                } : arg;
            };
        },
        "binary>": function(left, right, context) {
            return function(scope, locals, assign, inputs) {
                var arg = left(scope, locals, assign, inputs) > right(scope, locals, assign, inputs);
                return context ? {
                    value: arg
                } : arg;
            };
        },
        "binary<=": function(left, right, context) {
            return function(scope, locals, assign, inputs) {
                var arg = left(scope, locals, assign, inputs) <= right(scope, locals, assign, inputs);
                return context ? {
                    value: arg
                } : arg;
            };
        },
        "binary>=": function(left, right, context) {
            return function(scope, locals, assign, inputs) {
                var arg = left(scope, locals, assign, inputs) >= right(scope, locals, assign, inputs);
                return context ? {
                    value: arg
                } : arg;
            };
        },
        "binary&&": function(left, right, context) {
            return function(scope, locals, assign, inputs) {
                var arg = left(scope, locals, assign, inputs) && right(scope, locals, assign, inputs);
                return context ? {
                    value: arg
                } : arg;
            };
        },
        "binary||": function(left, right, context) {
            return function(scope, locals, assign, inputs) {
                var arg = left(scope, locals, assign, inputs) || right(scope, locals, assign, inputs);
                return context ? {
                    value: arg
                } : arg;
            };
        },
        "ternary?:": function(test, alternate, consequent, context) {
            return function(scope, locals, assign, inputs) {
                var arg = test(scope, locals, assign, inputs) ? alternate(scope, locals, assign, inputs) : consequent(scope, locals, assign, inputs);
                return context ? {
                    value: arg
                } : arg;
            };
        },
        value: function(value, context) {
            return function() {
                return context ? {
                    context: undefined,
                    name: undefined,
                    value: value
                } : value;
            };
        },
        identifier: function(name, expensiveChecks, context, create, expression) {
            return function(scope, locals, assign, inputs) {
                var base = locals && name in locals ? locals : scope;
                if (create && create !== 1 && base && !base[name]) {
                    base[name] = {};
                }
                var value = base ? base[name] : undefined;
                if (expensiveChecks) {
                    ensureSafeObject(value, expression);
                }
                if (context) {
                    return {
                        context: base,
                        name: name,
                        value: value
                    };
                } else {
                    return value;
                }
            };
        },
        computedMember: function(left, right, context, create, expression) {
            return function(scope, locals, assign, inputs) {
                var lhs = left(scope, locals, assign, inputs);
                var rhs;
                var value;
                if (lhs != null) {
                    rhs = right(scope, locals, assign, inputs);
                    rhs = getStringValue(rhs);
                    ensureSafeMemberName(rhs, expression);
                    if (create && create !== 1) {
                        ensureSafeAssignContext(lhs);
                        if (lhs && !lhs[rhs]) {
                            lhs[rhs] = {};
                        }
                    }
                    value = lhs[rhs];
                    ensureSafeObject(value, expression);
                }
                if (context) {
                    return {
                        context: lhs,
                        name: rhs,
                        value: value
                    };
                } else {
                    return value;
                }
            };
        },
        nonComputedMember: function(left, right, expensiveChecks, context, create, expression) {
            return function(scope, locals, assign, inputs) {
                var lhs = left(scope, locals, assign, inputs);
                if (create && create !== 1) {
                    ensureSafeAssignContext(lhs);
                    if (lhs && !lhs[right]) {
                        lhs[right] = {};
                    }
                }
                var value = lhs != null ? lhs[right] : undefined;
                if (expensiveChecks || isPossiblyDangerousMemberName(right)) {
                    ensureSafeObject(value, expression);
                }
                if (context) {
                    return {
                        context: lhs,
                        name: right,
                        value: value
                    };
                } else {
                    return value;
                }
            };
        },
        inputs: function(input, watchId) {
            return function(scope, value, locals, inputs) {
                if (inputs) return inputs[watchId];
                return input(scope, value, locals);
            };
        }
    };
    var Parser = function Parser(lexer, $filter, options) {
        this.lexer = lexer;
        this.$filter = $filter;
        this.options = options;
        this.ast = new AST(lexer, options);
        this.astCompiler = options.csp ? new ASTInterpreter(this.ast, $filter) : new ASTCompiler(this.ast, $filter);
    };
    Parser.prototype = {
        constructor: Parser,
        parse: function(text) {
            return this.astCompiler.compile(text, this.options.expensiveChecks);
        }
    };
    function isPossiblyDangerousMemberName(name) {
        return name === "constructor";
    }
    function getValueOf(value) {
        return isFunction(value.valueOf) ? value.valueOf() : objectValueOf.call(value);
    }
    function $ParseProvider() {
        var cacheDefault = createMap();
        var cacheExpensive = createMap();
        var literals = {
            "true": true,
            "false": false,
            "null": null,
            undefined: undefined
        };
        var identStart, identContinue;
        this.addLiteral = function(literalName, literalValue) {
            literals[literalName] = literalValue;
        };
        this.setIdentifierFns = function(identifierStart, identifierContinue) {
            identStart = identifierStart;
            identContinue = identifierContinue;
            return this;
        };
        this.$get = [ "$filter", function($filter) {
            var noUnsafeEval = csp().noUnsafeEval;
            var $parseOptions = {
                csp: noUnsafeEval,
                expensiveChecks: false,
                literals: copy(literals),
                isIdentifierStart: isFunction(identStart) && identStart,
                isIdentifierContinue: isFunction(identContinue) && identContinue
            }, $parseOptionsExpensive = {
                csp: noUnsafeEval,
                expensiveChecks: true,
                literals: copy(literals),
                isIdentifierStart: isFunction(identStart) && identStart,
                isIdentifierContinue: isFunction(identContinue) && identContinue
            };
            var runningChecksEnabled = false;
            $parse.$$runningExpensiveChecks = function() {
                return runningChecksEnabled;
            };
            return $parse;
            function $parse(exp, interceptorFn, expensiveChecks) {
                var parsedExpression, oneTime, cacheKey;
                expensiveChecks = expensiveChecks || runningChecksEnabled;
                switch (typeof exp) {
                  case "string":
                    exp = exp.trim();
                    cacheKey = exp;
                    var cache = expensiveChecks ? cacheExpensive : cacheDefault;
                    parsedExpression = cache[cacheKey];
                    if (!parsedExpression) {
                        if (exp.charAt(0) === ":" && exp.charAt(1) === ":") {
                            oneTime = true;
                            exp = exp.substring(2);
                        }
                        var parseOptions = expensiveChecks ? $parseOptionsExpensive : $parseOptions;
                        var lexer = new Lexer(parseOptions);
                        var parser = new Parser(lexer, $filter, parseOptions);
                        parsedExpression = parser.parse(exp);
                        if (parsedExpression.constant) {
                            parsedExpression.$$watchDelegate = constantWatchDelegate;
                        } else if (oneTime) {
                            parsedExpression.$$watchDelegate = parsedExpression.literal ? oneTimeLiteralWatchDelegate : oneTimeWatchDelegate;
                        } else if (parsedExpression.inputs) {
                            parsedExpression.$$watchDelegate = inputsWatchDelegate;
                        }
                        if (expensiveChecks) {
                            parsedExpression = expensiveChecksInterceptor(parsedExpression);
                        }
                        cache[cacheKey] = parsedExpression;
                    }
                    return addInterceptor(parsedExpression, interceptorFn);

                  case "function":
                    return addInterceptor(exp, interceptorFn);

                  default:
                    return addInterceptor(noop, interceptorFn);
                }
            }
            function expensiveChecksInterceptor(fn) {
                if (!fn) return fn;
                expensiveCheckFn.$$watchDelegate = fn.$$watchDelegate;
                expensiveCheckFn.assign = expensiveChecksInterceptor(fn.assign);
                expensiveCheckFn.constant = fn.constant;
                expensiveCheckFn.literal = fn.literal;
                for (var i = 0; fn.inputs && i < fn.inputs.length; ++i) {
                    fn.inputs[i] = expensiveChecksInterceptor(fn.inputs[i]);
                }
                expensiveCheckFn.inputs = fn.inputs;
                return expensiveCheckFn;
                function expensiveCheckFn(scope, locals, assign, inputs) {
                    var expensiveCheckOldValue = runningChecksEnabled;
                    runningChecksEnabled = true;
                    try {
                        return fn(scope, locals, assign, inputs);
                    } finally {
                        runningChecksEnabled = expensiveCheckOldValue;
                    }
                }
            }
            function expressionInputDirtyCheck(newValue, oldValueOfValue) {
                if (newValue == null || oldValueOfValue == null) {
                    return newValue === oldValueOfValue;
                }
                if (typeof newValue === "object") {
                    newValue = getValueOf(newValue);
                    if (typeof newValue === "object") {
                        return false;
                    }
                }
                return newValue === oldValueOfValue || newValue !== newValue && oldValueOfValue !== oldValueOfValue;
            }
            function inputsWatchDelegate(scope, listener, objectEquality, parsedExpression, prettyPrintExpression) {
                var inputExpressions = parsedExpression.inputs;
                var lastResult;
                if (inputExpressions.length === 1) {
                    var oldInputValueOf = expressionInputDirtyCheck;
                    inputExpressions = inputExpressions[0];
                    return scope.$watch(function expressionInputWatch(scope) {
                        var newInputValue = inputExpressions(scope);
                        if (!expressionInputDirtyCheck(newInputValue, oldInputValueOf)) {
                            lastResult = parsedExpression(scope, undefined, undefined, [ newInputValue ]);
                            oldInputValueOf = newInputValue && getValueOf(newInputValue);
                        }
                        return lastResult;
                    }, listener, objectEquality, prettyPrintExpression);
                }
                var oldInputValueOfValues = [];
                var oldInputValues = [];
                for (var i = 0, ii = inputExpressions.length; i < ii; i++) {
                    oldInputValueOfValues[i] = expressionInputDirtyCheck;
                    oldInputValues[i] = null;
                }
                return scope.$watch(function expressionInputsWatch(scope) {
                    var changed = false;
                    for (var i = 0, ii = inputExpressions.length; i < ii; i++) {
                        var newInputValue = inputExpressions[i](scope);
                        if (changed || (changed = !expressionInputDirtyCheck(newInputValue, oldInputValueOfValues[i]))) {
                            oldInputValues[i] = newInputValue;
                            oldInputValueOfValues[i] = newInputValue && getValueOf(newInputValue);
                        }
                    }
                    if (changed) {
                        lastResult = parsedExpression(scope, undefined, undefined, oldInputValues);
                    }
                    return lastResult;
                }, listener, objectEquality, prettyPrintExpression);
            }
            function oneTimeWatchDelegate(scope, listener, objectEquality, parsedExpression) {
                var unwatch, lastValue;
                unwatch = scope.$watch(function oneTimeWatch(scope) {
                    return parsedExpression(scope);
                }, function oneTimeListener(value, old, scope) {
                    lastValue = value;
                    if (isFunction(listener)) {
                        listener.apply(this, arguments);
                    }
                    if (isDefined(value)) {
                        scope.$$postDigest(function() {
                            if (isDefined(lastValue)) {
                                unwatch();
                            }
                        });
                    }
                }, objectEquality);
                return unwatch;
            }
            function oneTimeLiteralWatchDelegate(scope, listener, objectEquality, parsedExpression) {
                var unwatch, lastValue;
                unwatch = scope.$watch(function oneTimeWatch(scope) {
                    return parsedExpression(scope);
                }, function oneTimeListener(value, old, scope) {
                    lastValue = value;
                    if (isFunction(listener)) {
                        listener.call(this, value, old, scope);
                    }
                    if (isAllDefined(value)) {
                        scope.$$postDigest(function() {
                            if (isAllDefined(lastValue)) unwatch();
                        });
                    }
                }, objectEquality);
                return unwatch;
                function isAllDefined(value) {
                    var allDefined = true;
                    forEach(value, function(val) {
                        if (!isDefined(val)) allDefined = false;
                    });
                    return allDefined;
                }
            }
            function constantWatchDelegate(scope, listener, objectEquality, parsedExpression) {
                var unwatch = scope.$watch(function constantWatch(scope) {
                    unwatch();
                    return parsedExpression(scope);
                }, listener, objectEquality);
                return unwatch;
            }
            function addInterceptor(parsedExpression, interceptorFn) {
                if (!interceptorFn) return parsedExpression;
                var watchDelegate = parsedExpression.$$watchDelegate;
                var useInputs = false;
                var regularWatch = watchDelegate !== oneTimeLiteralWatchDelegate && watchDelegate !== oneTimeWatchDelegate;
                var fn = regularWatch ? function regularInterceptedExpression(scope, locals, assign, inputs) {
                    var value = useInputs && inputs ? inputs[0] : parsedExpression(scope, locals, assign, inputs);
                    return interceptorFn(value, scope, locals);
                } : function oneTimeInterceptedExpression(scope, locals, assign, inputs) {
                    var value = parsedExpression(scope, locals, assign, inputs);
                    var result = interceptorFn(value, scope, locals);
                    return isDefined(value) ? result : value;
                };
                if (parsedExpression.$$watchDelegate && parsedExpression.$$watchDelegate !== inputsWatchDelegate) {
                    fn.$$watchDelegate = parsedExpression.$$watchDelegate;
                } else if (!interceptorFn.$stateful) {
                    fn.$$watchDelegate = inputsWatchDelegate;
                    useInputs = !parsedExpression.inputs;
                    fn.inputs = parsedExpression.inputs ? parsedExpression.inputs : [ parsedExpression ];
                }
                return fn;
            }
        } ];
    }
    function $QProvider() {
        this.$get = [ "$rootScope", "$exceptionHandler", function($rootScope, $exceptionHandler) {
            return qFactory(function(callback) {
                $rootScope.$evalAsync(callback);
            }, $exceptionHandler);
        } ];
    }
    function $$QProvider() {
        this.$get = [ "$browser", "$exceptionHandler", function($browser, $exceptionHandler) {
            return qFactory(function(callback) {
                $browser.defer(callback);
            }, $exceptionHandler);
        } ];
    }
    function qFactory(nextTick, exceptionHandler) {
        var $qMinErr = minErr("$q", TypeError);
        function defer() {
            var d = new Deferred();
            d.resolve = simpleBind(d, d.resolve);
            d.reject = simpleBind(d, d.reject);
            d.notify = simpleBind(d, d.notify);
            return d;
        }
        function Promise() {
            this.$$state = {
                status: 0
            };
        }
        extend(Promise.prototype, {
            then: function(onFulfilled, onRejected, progressBack) {
                if (isUndefined(onFulfilled) && isUndefined(onRejected) && isUndefined(progressBack)) {
                    return this;
                }
                var result = new Deferred();
                this.$$state.pending = this.$$state.pending || [];
                this.$$state.pending.push([ result, onFulfilled, onRejected, progressBack ]);
                if (this.$$state.status > 0) scheduleProcessQueue(this.$$state);
                return result.promise;
            },
            "catch": function(callback) {
                return this.then(null, callback);
            },
            "finally": function(callback, progressBack) {
                return this.then(function(value) {
                    return handleCallback(value, resolve, callback);
                }, function(error) {
                    return handleCallback(error, reject, callback);
                }, progressBack);
            }
        });
        function simpleBind(context, fn) {
            return function(value) {
                fn.call(context, value);
            };
        }
        function processQueue(state) {
            var fn, deferred, pending;
            pending = state.pending;
            state.processScheduled = false;
            state.pending = undefined;
            for (var i = 0, ii = pending.length; i < ii; ++i) {
                deferred = pending[i][0];
                fn = pending[i][state.status];
                try {
                    if (isFunction(fn)) {
                        deferred.resolve(fn(state.value));
                    } else if (state.status === 1) {
                        deferred.resolve(state.value);
                    } else {
                        deferred.reject(state.value);
                    }
                } catch (e) {
                    deferred.reject(e);
                    exceptionHandler(e);
                }
            }
        }
        function scheduleProcessQueue(state) {
            if (state.processScheduled || !state.pending) return;
            state.processScheduled = true;
            nextTick(function() {
                processQueue(state);
            });
        }
        function Deferred() {
            this.promise = new Promise();
        }
        extend(Deferred.prototype, {
            resolve: function(val) {
                if (this.promise.$$state.status) return;
                if (val === this.promise) {
                    this.$$reject($qMinErr("qcycle", "Expected promise to be resolved with value other than itself '{0}'", val));
                } else {
                    this.$$resolve(val);
                }
            },
            $$resolve: function(val) {
                var then;
                var that = this;
                var done = false;
                try {
                    if (isObject(val) || isFunction(val)) then = val && val.then;
                    if (isFunction(then)) {
                        this.promise.$$state.status = -1;
                        then.call(val, resolvePromise, rejectPromise, simpleBind(this, this.notify));
                    } else {
                        this.promise.$$state.value = val;
                        this.promise.$$state.status = 1;
                        scheduleProcessQueue(this.promise.$$state);
                    }
                } catch (e) {
                    rejectPromise(e);
                    exceptionHandler(e);
                }
                function resolvePromise(val) {
                    if (done) return;
                    done = true;
                    that.$$resolve(val);
                }
                function rejectPromise(val) {
                    if (done) return;
                    done = true;
                    that.$$reject(val);
                }
            },
            reject: function(reason) {
                if (this.promise.$$state.status) return;
                this.$$reject(reason);
            },
            $$reject: function(reason) {
                this.promise.$$state.value = reason;
                this.promise.$$state.status = 2;
                scheduleProcessQueue(this.promise.$$state);
            },
            notify: function(progress) {
                var callbacks = this.promise.$$state.pending;
                if (this.promise.$$state.status <= 0 && callbacks && callbacks.length) {
                    nextTick(function() {
                        var callback, result;
                        for (var i = 0, ii = callbacks.length; i < ii; i++) {
                            result = callbacks[i][0];
                            callback = callbacks[i][3];
                            try {
                                result.notify(isFunction(callback) ? callback(progress) : progress);
                            } catch (e) {
                                exceptionHandler(e);
                            }
                        }
                    });
                }
            }
        });
        function reject(reason) {
            var result = new Deferred();
            result.reject(reason);
            return result.promise;
        }
        function handleCallback(value, resolver, callback) {
            var callbackOutput = null;
            try {
                if (isFunction(callback)) callbackOutput = callback();
            } catch (e) {
                return reject(e);
            }
            if (isPromiseLike(callbackOutput)) {
                return callbackOutput.then(function() {
                    return resolver(value);
                }, reject);
            } else {
                return resolver(value);
            }
        }
        function when(value, callback, errback, progressBack) {
            var result = new Deferred();
            result.resolve(value);
            return result.promise.then(callback, errback, progressBack);
        }
        var resolve = when;
        function all(promises) {
            var deferred = new Deferred(), counter = 0, results = isArray(promises) ? [] : {};
            forEach(promises, function(promise, key) {
                counter++;
                when(promise).then(function(value) {
                    results[key] = value;
                    if (!--counter) deferred.resolve(results);
                }, function(reason) {
                    deferred.reject(reason);
                });
            });
            if (counter === 0) {
                deferred.resolve(results);
            }
            return deferred.promise;
        }
        function race(promises) {
            var deferred = defer();
            forEach(promises, function(promise) {
                when(promise).then(deferred.resolve, deferred.reject);
            });
            return deferred.promise;
        }
        function $Q(resolver) {
            if (!isFunction(resolver)) {
                throw $qMinErr("norslvr", "Expected resolverFn, got '{0}'", resolver);
            }
            var deferred = new Deferred();
            function resolveFn(value) {
                deferred.resolve(value);
            }
            function rejectFn(reason) {
                deferred.reject(reason);
            }
            resolver(resolveFn, rejectFn);
            return deferred.promise;
        }
        $Q.prototype = Promise.prototype;
        $Q.defer = defer;
        $Q.reject = reject;
        $Q.when = when;
        $Q.resolve = resolve;
        $Q.all = all;
        $Q.race = race;
        return $Q;
    }
    function $$RAFProvider() {
        this.$get = [ "$window", "$timeout", function($window, $timeout) {
            var requestAnimationFrame = $window.requestAnimationFrame || $window.webkitRequestAnimationFrame;
            var cancelAnimationFrame = $window.cancelAnimationFrame || $window.webkitCancelAnimationFrame || $window.webkitCancelRequestAnimationFrame;
            var rafSupported = !!requestAnimationFrame;
            var raf = rafSupported ? function(fn) {
                var id = requestAnimationFrame(fn);
                return function() {
                    cancelAnimationFrame(id);
                };
            } : function(fn) {
                var timer = $timeout(fn, 16.66, false);
                return function() {
                    $timeout.cancel(timer);
                };
            };
            raf.supported = rafSupported;
            return raf;
        } ];
    }
    function $RootScopeProvider() {
        var TTL = 10;
        var $rootScopeMinErr = minErr("$rootScope");
        var lastDirtyWatch = null;
        var applyAsyncId = null;
        this.digestTtl = function(value) {
            if (arguments.length) {
                TTL = value;
            }
            return TTL;
        };
        function createChildScopeClass(parent) {
            function ChildScope() {
                this.$$watchers = this.$$nextSibling = this.$$childHead = this.$$childTail = null;
                this.$$listeners = {};
                this.$$listenerCount = {};
                this.$$watchersCount = 0;
                this.$id = nextUid();
                this.$$ChildScope = null;
            }
            ChildScope.prototype = parent;
            return ChildScope;
        }
        this.$get = [ "$exceptionHandler", "$parse", "$browser", function($exceptionHandler, $parse, $browser) {
            function destroyChildScope($event) {
                $event.currentScope.$$destroyed = true;
            }
            function cleanUpScope($scope) {
                if (msie === 9) {
                    if ($scope.$$childHead) {
                        cleanUpScope($scope.$$childHead);
                    }
                    if ($scope.$$nextSibling) {
                        cleanUpScope($scope.$$nextSibling);
                    }
                }
                $scope.$parent = $scope.$$nextSibling = $scope.$$prevSibling = $scope.$$childHead = $scope.$$childTail = $scope.$root = $scope.$$watchers = null;
            }
            function Scope() {
                this.$id = nextUid();
                this.$$phase = this.$parent = this.$$watchers = this.$$nextSibling = this.$$prevSibling = this.$$childHead = this.$$childTail = null;
                this.$root = this;
                this.$$destroyed = false;
                this.$$listeners = {};
                this.$$listenerCount = {};
                this.$$watchersCount = 0;
                this.$$isolateBindings = null;
            }
            Scope.prototype = {
                constructor: Scope,
                $new: function(isolate, parent) {
                    var child;
                    parent = parent || this;
                    if (isolate) {
                        child = new Scope();
                        child.$root = this.$root;
                    } else {
                        if (!this.$$ChildScope) {
                            this.$$ChildScope = createChildScopeClass(this);
                        }
                        child = new this.$$ChildScope();
                    }
                    child.$parent = parent;
                    child.$$prevSibling = parent.$$childTail;
                    if (parent.$$childHead) {
                        parent.$$childTail.$$nextSibling = child;
                        parent.$$childTail = child;
                    } else {
                        parent.$$childHead = parent.$$childTail = child;
                    }
                    if (isolate || parent !== this) child.$on("$destroy", destroyChildScope);
                    return child;
                },
                $watch: function(watchExp, listener, objectEquality, prettyPrintExpression) {
                    var get = $parse(watchExp);
                    if (get.$$watchDelegate) {
                        return get.$$watchDelegate(this, listener, objectEquality, get, watchExp);
                    }
                    var scope = this, array = scope.$$watchers, watcher = {
                        fn: listener,
                        last: initWatchVal,
                        get: get,
                        exp: prettyPrintExpression || watchExp,
                        eq: !!objectEquality
                    };
                    lastDirtyWatch = null;
                    if (!isFunction(listener)) {
                        watcher.fn = noop;
                    }
                    if (!array) {
                        array = scope.$$watchers = [];
                        array.$$digestWatchIndex = -1;
                    }
                    array.unshift(watcher);
                    array.$$digestWatchIndex++;
                    incrementWatchersCount(this, 1);
                    return function deregisterWatch() {
                        var index = arrayRemove(array, watcher);
                        if (index >= 0) {
                            incrementWatchersCount(scope, -1);
                            if (index < array.$$digestWatchIndex) {
                                array.$$digestWatchIndex--;
                            }
                        }
                        lastDirtyWatch = null;
                    };
                },
                $watchGroup: function(watchExpressions, listener) {
                    var oldValues = new Array(watchExpressions.length);
                    var newValues = new Array(watchExpressions.length);
                    var deregisterFns = [];
                    var self = this;
                    var changeReactionScheduled = false;
                    var firstRun = true;
                    if (!watchExpressions.length) {
                        var shouldCall = true;
                        self.$evalAsync(function() {
                            if (shouldCall) listener(newValues, newValues, self);
                        });
                        return function deregisterWatchGroup() {
                            shouldCall = false;
                        };
                    }
                    if (watchExpressions.length === 1) {
                        return this.$watch(watchExpressions[0], function watchGroupAction(value, oldValue, scope) {
                            newValues[0] = value;
                            oldValues[0] = oldValue;
                            listener(newValues, value === oldValue ? newValues : oldValues, scope);
                        });
                    }
                    forEach(watchExpressions, function(expr, i) {
                        var unwatchFn = self.$watch(expr, function watchGroupSubAction(value, oldValue) {
                            newValues[i] = value;
                            oldValues[i] = oldValue;
                            if (!changeReactionScheduled) {
                                changeReactionScheduled = true;
                                self.$evalAsync(watchGroupAction);
                            }
                        });
                        deregisterFns.push(unwatchFn);
                    });
                    function watchGroupAction() {
                        changeReactionScheduled = false;
                        if (firstRun) {
                            firstRun = false;
                            listener(newValues, newValues, self);
                        } else {
                            listener(newValues, oldValues, self);
                        }
                    }
                    return function deregisterWatchGroup() {
                        while (deregisterFns.length) {
                            deregisterFns.shift()();
                        }
                    };
                },
                $watchCollection: function(obj, listener) {
                    $watchCollectionInterceptor.$stateful = true;
                    var self = this;
                    var newValue;
                    var oldValue;
                    var veryOldValue;
                    var trackVeryOldValue = listener.length > 1;
                    var changeDetected = 0;
                    var changeDetector = $parse(obj, $watchCollectionInterceptor);
                    var internalArray = [];
                    var internalObject = {};
                    var initRun = true;
                    var oldLength = 0;
                    function $watchCollectionInterceptor(_value) {
                        newValue = _value;
                        var newLength, key, bothNaN, newItem, oldItem;
                        if (isUndefined(newValue)) return;
                        if (!isObject(newValue)) {
                            if (oldValue !== newValue) {
                                oldValue = newValue;
                                changeDetected++;
                            }
                        } else if (isArrayLike(newValue)) {
                            if (oldValue !== internalArray) {
                                oldValue = internalArray;
                                oldLength = oldValue.length = 0;
                                changeDetected++;
                            }
                            newLength = newValue.length;
                            if (oldLength !== newLength) {
                                changeDetected++;
                                oldValue.length = oldLength = newLength;
                            }
                            for (var i = 0; i < newLength; i++) {
                                oldItem = oldValue[i];
                                newItem = newValue[i];
                                bothNaN = oldItem !== oldItem && newItem !== newItem;
                                if (!bothNaN && oldItem !== newItem) {
                                    changeDetected++;
                                    oldValue[i] = newItem;
                                }
                            }
                        } else {
                            if (oldValue !== internalObject) {
                                oldValue = internalObject = {};
                                oldLength = 0;
                                changeDetected++;
                            }
                            newLength = 0;
                            for (key in newValue) {
                                if (hasOwnProperty.call(newValue, key)) {
                                    newLength++;
                                    newItem = newValue[key];
                                    oldItem = oldValue[key];
                                    if (key in oldValue) {
                                        bothNaN = oldItem !== oldItem && newItem !== newItem;
                                        if (!bothNaN && oldItem !== newItem) {
                                            changeDetected++;
                                            oldValue[key] = newItem;
                                        }
                                    } else {
                                        oldLength++;
                                        oldValue[key] = newItem;
                                        changeDetected++;
                                    }
                                }
                            }
                            if (oldLength > newLength) {
                                changeDetected++;
                                for (key in oldValue) {
                                    if (!hasOwnProperty.call(newValue, key)) {
                                        oldLength--;
                                        delete oldValue[key];
                                    }
                                }
                            }
                        }
                        return changeDetected;
                    }
                    function $watchCollectionAction() {
                        if (initRun) {
                            initRun = false;
                            listener(newValue, newValue, self);
                        } else {
                            listener(newValue, veryOldValue, self);
                        }
                        if (trackVeryOldValue) {
                            if (!isObject(newValue)) {
                                veryOldValue = newValue;
                            } else if (isArrayLike(newValue)) {
                                veryOldValue = new Array(newValue.length);
                                for (var i = 0; i < newValue.length; i++) {
                                    veryOldValue[i] = newValue[i];
                                }
                            } else {
                                veryOldValue = {};
                                for (var key in newValue) {
                                    if (hasOwnProperty.call(newValue, key)) {
                                        veryOldValue[key] = newValue[key];
                                    }
                                }
                            }
                        }
                    }
                    return this.$watch(changeDetector, $watchCollectionAction);
                },
                $digest: function() {
                    var watch, value, last, fn, get, watchers, dirty, ttl = TTL, next, current, target = this, watchLog = [], logIdx, asyncTask;
                    beginPhase("$digest");
                    $browser.$$checkUrlChange();
                    if (this === $rootScope && applyAsyncId !== null) {
                        $browser.defer.cancel(applyAsyncId);
                        flushApplyAsync();
                    }
                    lastDirtyWatch = null;
                    do {
                        dirty = false;
                        current = target;
                        for (var asyncQueuePosition = 0; asyncQueuePosition < asyncQueue.length; asyncQueuePosition++) {
                            try {
                                asyncTask = asyncQueue[asyncQueuePosition];
                                asyncTask.scope.$eval(asyncTask.expression, asyncTask.locals);
                            } catch (e) {
                                $exceptionHandler(e);
                            }
                            lastDirtyWatch = null;
                        }
                        asyncQueue.length = 0;
                        traverseScopesLoop: do {
                            if (watchers = current.$$watchers) {
                                watchers.$$digestWatchIndex = watchers.length;
                                while (watchers.$$digestWatchIndex--) {
                                    try {
                                        watch = watchers[watchers.$$digestWatchIndex];
                                        if (watch) {
                                            get = watch.get;
                                            if ((value = get(current)) !== (last = watch.last) && !(watch.eq ? equals(value, last) : isNumberNaN(value) && isNumberNaN(last))) {
                                                dirty = true;
                                                lastDirtyWatch = watch;
                                                watch.last = watch.eq ? copy(value, null) : value;
                                                fn = watch.fn;
                                                fn(value, last === initWatchVal ? value : last, current);
                                                if (ttl < 5) {
                                                    logIdx = 4 - ttl;
                                                    if (!watchLog[logIdx]) watchLog[logIdx] = [];
                                                    watchLog[logIdx].push({
                                                        msg: isFunction(watch.exp) ? "fn: " + (watch.exp.name || watch.exp.toString()) : watch.exp,
                                                        newVal: value,
                                                        oldVal: last
                                                    });
                                                }
                                            } else if (watch === lastDirtyWatch) {
                                                dirty = false;
                                                break traverseScopesLoop;
                                            }
                                        }
                                    } catch (e) {
                                        $exceptionHandler(e);
                                    }
                                }
                            }
                            if (!(next = current.$$watchersCount && current.$$childHead || current !== target && current.$$nextSibling)) {
                                while (current !== target && !(next = current.$$nextSibling)) {
                                    current = current.$parent;
                                }
                            }
                        } while (current = next);
                        if ((dirty || asyncQueue.length) && !ttl--) {
                            clearPhase();
                            throw $rootScopeMinErr("infdig", "{0} $digest() iterations reached. Aborting!\n" + "Watchers fired in the last 5 iterations: {1}", TTL, watchLog);
                        }
                    } while (dirty || asyncQueue.length);
                    clearPhase();
                    while (postDigestQueuePosition < postDigestQueue.length) {
                        try {
                            postDigestQueue[postDigestQueuePosition++]();
                        } catch (e) {
                            $exceptionHandler(e);
                        }
                    }
                    postDigestQueue.length = postDigestQueuePosition = 0;
                },
                $destroy: function() {
                    if (this.$$destroyed) return;
                    var parent = this.$parent;
                    this.$broadcast("$destroy");
                    this.$$destroyed = true;
                    if (this === $rootScope) {
                        $browser.$$applicationDestroyed();
                    }
                    incrementWatchersCount(this, -this.$$watchersCount);
                    for (var eventName in this.$$listenerCount) {
                        decrementListenerCount(this, this.$$listenerCount[eventName], eventName);
                    }
                    if (parent && parent.$$childHead === this) parent.$$childHead = this.$$nextSibling;
                    if (parent && parent.$$childTail === this) parent.$$childTail = this.$$prevSibling;
                    if (this.$$prevSibling) this.$$prevSibling.$$nextSibling = this.$$nextSibling;
                    if (this.$$nextSibling) this.$$nextSibling.$$prevSibling = this.$$prevSibling;
                    this.$destroy = this.$digest = this.$apply = this.$evalAsync = this.$applyAsync = noop;
                    this.$on = this.$watch = this.$watchGroup = function() {
                        return noop;
                    };
                    this.$$listeners = {};
                    this.$$nextSibling = null;
                    cleanUpScope(this);
                },
                $eval: function(expr, locals) {
                    return $parse(expr)(this, locals);
                },
                $evalAsync: function(expr, locals) {
                    if (!$rootScope.$$phase && !asyncQueue.length) {
                        $browser.defer(function() {
                            if (asyncQueue.length) {
                                $rootScope.$digest();
                            }
                        });
                    }
                    asyncQueue.push({
                        scope: this,
                        expression: $parse(expr),
                        locals: locals
                    });
                },
                $$postDigest: function(fn) {
                    postDigestQueue.push(fn);
                },
                $apply: function(expr) {
                    try {
                        beginPhase("$apply");
                        try {
                            return this.$eval(expr);
                        } finally {
                            clearPhase();
                        }
                    } catch (e) {
                        $exceptionHandler(e);
                    } finally {
                        try {
                            $rootScope.$digest();
                        } catch (e) {
                            $exceptionHandler(e);
                            throw e;
                        }
                    }
                },
                $applyAsync: function(expr) {
                    var scope = this;
                    if (expr) {
                        applyAsyncQueue.push($applyAsyncExpression);
                    }
                    expr = $parse(expr);
                    scheduleApplyAsync();
                    function $applyAsyncExpression() {
                        scope.$eval(expr);
                    }
                },
                $on: function(name, listener) {
                    var namedListeners = this.$$listeners[name];
                    if (!namedListeners) {
                        this.$$listeners[name] = namedListeners = [];
                    }
                    namedListeners.push(listener);
                    var current = this;
                    do {
                        if (!current.$$listenerCount[name]) {
                            current.$$listenerCount[name] = 0;
                        }
                        current.$$listenerCount[name]++;
                    } while (current = current.$parent);
                    var self = this;
                    return function() {
                        var indexOfListener = namedListeners.indexOf(listener);
                        if (indexOfListener !== -1) {
                            namedListeners[indexOfListener] = null;
                            decrementListenerCount(self, 1, name);
                        }
                    };
                },
                $emit: function(name, args) {
                    var empty = [], namedListeners, scope = this, stopPropagation = false, event = {
                        name: name,
                        targetScope: scope,
                        stopPropagation: function() {
                            stopPropagation = true;
                        },
                        preventDefault: function() {
                            event.defaultPrevented = true;
                        },
                        defaultPrevented: false
                    }, listenerArgs = concat([ event ], arguments, 1), i, length;
                    do {
                        namedListeners = scope.$$listeners[name] || empty;
                        event.currentScope = scope;
                        for (i = 0, length = namedListeners.length; i < length; i++) {
                            if (!namedListeners[i]) {
                                namedListeners.splice(i, 1);
                                i--;
                                length--;
                                continue;
                            }
                            try {
                                namedListeners[i].apply(null, listenerArgs);
                            } catch (e) {
                                $exceptionHandler(e);
                            }
                        }
                        if (stopPropagation) {
                            event.currentScope = null;
                            return event;
                        }
                        scope = scope.$parent;
                    } while (scope);
                    event.currentScope = null;
                    return event;
                },
                $broadcast: function(name, args) {
                    var target = this, current = target, next = target, event = {
                        name: name,
                        targetScope: target,
                        preventDefault: function() {
                            event.defaultPrevented = true;
                        },
                        defaultPrevented: false
                    };
                    if (!target.$$listenerCount[name]) return event;
                    var listenerArgs = concat([ event ], arguments, 1), listeners, i, length;
                    while (current = next) {
                        event.currentScope = current;
                        listeners = current.$$listeners[name] || [];
                        for (i = 0, length = listeners.length; i < length; i++) {
                            if (!listeners[i]) {
                                listeners.splice(i, 1);
                                i--;
                                length--;
                                continue;
                            }
                            try {
                                listeners[i].apply(null, listenerArgs);
                            } catch (e) {
                                $exceptionHandler(e);
                            }
                        }
                        if (!(next = current.$$listenerCount[name] && current.$$childHead || current !== target && current.$$nextSibling)) {
                            while (current !== target && !(next = current.$$nextSibling)) {
                                current = current.$parent;
                            }
                        }
                    }
                    event.currentScope = null;
                    return event;
                }
            };
            var $rootScope = new Scope();
            var asyncQueue = $rootScope.$$asyncQueue = [];
            var postDigestQueue = $rootScope.$$postDigestQueue = [];
            var applyAsyncQueue = $rootScope.$$applyAsyncQueue = [];
            var postDigestQueuePosition = 0;
            return $rootScope;
            function beginPhase(phase) {
                if ($rootScope.$$phase) {
                    throw $rootScopeMinErr("inprog", "{0} already in progress", $rootScope.$$phase);
                }
                $rootScope.$$phase = phase;
            }
            function clearPhase() {
                $rootScope.$$phase = null;
            }
            function incrementWatchersCount(current, count) {
                do {
                    current.$$watchersCount += count;
                } while (current = current.$parent);
            }
            function decrementListenerCount(current, count, name) {
                do {
                    current.$$listenerCount[name] -= count;
                    if (current.$$listenerCount[name] === 0) {
                        delete current.$$listenerCount[name];
                    }
                } while (current = current.$parent);
            }
            function initWatchVal() {}
            function flushApplyAsync() {
                while (applyAsyncQueue.length) {
                    try {
                        applyAsyncQueue.shift()();
                    } catch (e) {
                        $exceptionHandler(e);
                    }
                }
                applyAsyncId = null;
            }
            function scheduleApplyAsync() {
                if (applyAsyncId === null) {
                    applyAsyncId = $browser.defer(function() {
                        $rootScope.$apply(flushApplyAsync);
                    });
                }
            }
        } ];
    }
    function $$SanitizeUriProvider() {
        var aHrefSanitizationWhitelist = /^\s*(https?|ftp|mailto|tel|file):/, imgSrcSanitizationWhitelist = /^\s*((https?|ftp|file|blob):|data:image\/)/;
        this.aHrefSanitizationWhitelist = function(regexp) {
            if (isDefined(regexp)) {
                aHrefSanitizationWhitelist = regexp;
                return this;
            }
            return aHrefSanitizationWhitelist;
        };
        this.imgSrcSanitizationWhitelist = function(regexp) {
            if (isDefined(regexp)) {
                imgSrcSanitizationWhitelist = regexp;
                return this;
            }
            return imgSrcSanitizationWhitelist;
        };
        this.$get = function() {
            return function sanitizeUri(uri, isImage) {
                var regex = isImage ? imgSrcSanitizationWhitelist : aHrefSanitizationWhitelist;
                var normalizedVal;
                normalizedVal = urlResolve(uri).href;
                if (normalizedVal !== "" && !normalizedVal.match(regex)) {
                    return "unsafe:" + normalizedVal;
                }
                return uri;
            };
        };
    }
    var $sceMinErr = minErr("$sce");
    var SCE_CONTEXTS = {
        HTML: "html",
        CSS: "css",
        URL: "url",
        RESOURCE_URL: "resourceUrl",
        JS: "js"
    };
    function adjustMatcher(matcher) {
        if (matcher === "self") {
            return matcher;
        } else if (isString(matcher)) {
            if (matcher.indexOf("***") > -1) {
                throw $sceMinErr("iwcard", "Illegal sequence *** in string matcher.  String: {0}", matcher);
            }
            matcher = escapeForRegexp(matcher).replace(/\\\*\\\*/g, ".*").replace(/\\\*/g, "[^:/.?&;]*");
            return new RegExp("^" + matcher + "$");
        } else if (isRegExp(matcher)) {
            return new RegExp("^" + matcher.source + "$");
        } else {
            throw $sceMinErr("imatcher", 'Matchers may only be "self", string patterns or RegExp objects');
        }
    }
    function adjustMatchers(matchers) {
        var adjustedMatchers = [];
        if (isDefined(matchers)) {
            forEach(matchers, function(matcher) {
                adjustedMatchers.push(adjustMatcher(matcher));
            });
        }
        return adjustedMatchers;
    }
    function $SceDelegateProvider() {
        this.SCE_CONTEXTS = SCE_CONTEXTS;
        var resourceUrlWhitelist = [ "self" ], resourceUrlBlacklist = [];
        this.resourceUrlWhitelist = function(value) {
            if (arguments.length) {
                resourceUrlWhitelist = adjustMatchers(value);
            }
            return resourceUrlWhitelist;
        };
        this.resourceUrlBlacklist = function(value) {
            if (arguments.length) {
                resourceUrlBlacklist = adjustMatchers(value);
            }
            return resourceUrlBlacklist;
        };
        this.$get = [ "$injector", function($injector) {
            var htmlSanitizer = function htmlSanitizer(html) {
                throw $sceMinErr("unsafe", "Attempting to use an unsafe value in a safe context.");
            };
            if ($injector.has("$sanitize")) {
                htmlSanitizer = $injector.get("$sanitize");
            }
            function matchUrl(matcher, parsedUrl) {
                if (matcher === "self") {
                    return urlIsSameOrigin(parsedUrl);
                } else {
                    return !!matcher.exec(parsedUrl.href);
                }
            }
            function isResourceUrlAllowedByPolicy(url) {
                var parsedUrl = urlResolve(url.toString());
                var i, n, allowed = false;
                for (i = 0, n = resourceUrlWhitelist.length; i < n; i++) {
                    if (matchUrl(resourceUrlWhitelist[i], parsedUrl)) {
                        allowed = true;
                        break;
                    }
                }
                if (allowed) {
                    for (i = 0, n = resourceUrlBlacklist.length; i < n; i++) {
                        if (matchUrl(resourceUrlBlacklist[i], parsedUrl)) {
                            allowed = false;
                            break;
                        }
                    }
                }
                return allowed;
            }
            function generateHolderType(Base) {
                var holderType = function TrustedValueHolderType(trustedValue) {
                    this.$$unwrapTrustedValue = function() {
                        return trustedValue;
                    };
                };
                if (Base) {
                    holderType.prototype = new Base();
                }
                holderType.prototype.valueOf = function sceValueOf() {
                    return this.$$unwrapTrustedValue();
                };
                holderType.prototype.toString = function sceToString() {
                    return this.$$unwrapTrustedValue().toString();
                };
                return holderType;
            }
            var trustedValueHolderBase = generateHolderType(), byType = {};
            byType[SCE_CONTEXTS.HTML] = generateHolderType(trustedValueHolderBase);
            byType[SCE_CONTEXTS.CSS] = generateHolderType(trustedValueHolderBase);
            byType[SCE_CONTEXTS.URL] = generateHolderType(trustedValueHolderBase);
            byType[SCE_CONTEXTS.JS] = generateHolderType(trustedValueHolderBase);
            byType[SCE_CONTEXTS.RESOURCE_URL] = generateHolderType(byType[SCE_CONTEXTS.URL]);
            function trustAs(type, trustedValue) {
                var Constructor = byType.hasOwnProperty(type) ? byType[type] : null;
                if (!Constructor) {
                    throw $sceMinErr("icontext", "Attempted to trust a value in invalid context. Context: {0}; Value: {1}", type, trustedValue);
                }
                if (trustedValue === null || isUndefined(trustedValue) || trustedValue === "") {
                    return trustedValue;
                }
                if (typeof trustedValue !== "string") {
                    throw $sceMinErr("itype", "Attempted to trust a non-string value in a content requiring a string: Context: {0}", type);
                }
                return new Constructor(trustedValue);
            }
            function valueOf(maybeTrusted) {
                if (maybeTrusted instanceof trustedValueHolderBase) {
                    return maybeTrusted.$$unwrapTrustedValue();
                } else {
                    return maybeTrusted;
                }
            }
            function getTrusted(type, maybeTrusted) {
                if (maybeTrusted === null || isUndefined(maybeTrusted) || maybeTrusted === "") {
                    return maybeTrusted;
                }
                var constructor = byType.hasOwnProperty(type) ? byType[type] : null;
                if (constructor && maybeTrusted instanceof constructor) {
                    return maybeTrusted.$$unwrapTrustedValue();
                }
                if (type === SCE_CONTEXTS.RESOURCE_URL) {
                    if (isResourceUrlAllowedByPolicy(maybeTrusted)) {
                        return maybeTrusted;
                    } else {
                        throw $sceMinErr("insecurl", "Blocked loading resource from url not allowed by $sceDelegate policy.  URL: {0}", maybeTrusted.toString());
                    }
                } else if (type === SCE_CONTEXTS.HTML) {
                    return htmlSanitizer(maybeTrusted);
                }
                throw $sceMinErr("unsafe", "Attempting to use an unsafe value in a safe context.");
            }
            return {
                trustAs: trustAs,
                getTrusted: getTrusted,
                valueOf: valueOf
            };
        } ];
    }
    function $SceProvider() {
        var enabled = true;
        this.enabled = function(value) {
            if (arguments.length) {
                enabled = !!value;
            }
            return enabled;
        };
        this.$get = [ "$parse", "$sceDelegate", function($parse, $sceDelegate) {
            if (enabled && msie < 8) {
                throw $sceMinErr("iequirks", "Strict Contextual Escaping does not support Internet Explorer version < 11 in quirks " + "mode.  You can fix this by adding the text <!doctype html> to the top of your HTML " + "document.  See http://docs.angularjs.org/api/ng.$sce for more information.");
            }
            var sce = shallowCopy(SCE_CONTEXTS);
            sce.isEnabled = function() {
                return enabled;
            };
            sce.trustAs = $sceDelegate.trustAs;
            sce.getTrusted = $sceDelegate.getTrusted;
            sce.valueOf = $sceDelegate.valueOf;
            if (!enabled) {
                sce.trustAs = sce.getTrusted = function(type, value) {
                    return value;
                };
                sce.valueOf = identity;
            }
            sce.parseAs = function sceParseAs(type, expr) {
                var parsed = $parse(expr);
                if (parsed.literal && parsed.constant) {
                    return parsed;
                } else {
                    return $parse(expr, function(value) {
                        return sce.getTrusted(type, value);
                    });
                }
            };
            var parse = sce.parseAs, getTrusted = sce.getTrusted, trustAs = sce.trustAs;
            forEach(SCE_CONTEXTS, function(enumValue, name) {
                var lName = lowercase(name);
                sce[camelCase("parse_as_" + lName)] = function(expr) {
                    return parse(enumValue, expr);
                };
                sce[camelCase("get_trusted_" + lName)] = function(value) {
                    return getTrusted(enumValue, value);
                };
                sce[camelCase("trust_as_" + lName)] = function(value) {
                    return trustAs(enumValue, value);
                };
            });
            return sce;
        } ];
    }
    function $SnifferProvider() {
        this.$get = [ "$window", "$document", function($window, $document) {
            var eventSupport = {}, isChromePackagedApp = $window.chrome && ($window.chrome.app && $window.chrome.app.runtime || !$window.chrome.app && $window.chrome.runtime && $window.chrome.runtime.id), hasHistoryPushState = !isChromePackagedApp && $window.history && $window.history.pushState, android = toInt((/android (\d+)/.exec(lowercase(($window.navigator || {}).userAgent)) || [])[1]), boxee = /Boxee/i.test(($window.navigator || {}).userAgent), document = $document[0] || {}, vendorPrefix, vendorRegex = /^(Moz|webkit|ms)(?=[A-Z])/, bodyStyle = document.body && document.body.style, transitions = false, animations = false, match;
            if (bodyStyle) {
                for (var prop in bodyStyle) {
                    if (match = vendorRegex.exec(prop)) {
                        vendorPrefix = match[0];
                        vendorPrefix = vendorPrefix[0].toUpperCase() + vendorPrefix.substr(1);
                        break;
                    }
                }
                if (!vendorPrefix) {
                    vendorPrefix = "WebkitOpacity" in bodyStyle && "webkit";
                }
                transitions = !!("transition" in bodyStyle || vendorPrefix + "Transition" in bodyStyle);
                animations = !!("animation" in bodyStyle || vendorPrefix + "Animation" in bodyStyle);
                if (android && (!transitions || !animations)) {
                    transitions = isString(bodyStyle.webkitTransition);
                    animations = isString(bodyStyle.webkitAnimation);
                }
            }
            return {
                history: !!(hasHistoryPushState && !(android < 4) && !boxee),
                hasEvent: function(event) {
                    if (event === "input" && msie <= 11) return false;
                    if (isUndefined(eventSupport[event])) {
                        var divElm = document.createElement("div");
                        eventSupport[event] = "on" + event in divElm;
                    }
                    return eventSupport[event];
                },
                csp: csp(),
                vendorPrefix: vendorPrefix,
                transitions: transitions,
                animations: animations,
                android: android
            };
        } ];
    }
    var $templateRequestMinErr = minErr("$compile");
    function $TemplateRequestProvider() {
        var httpOptions;
        this.httpOptions = function(val) {
            if (val) {
                httpOptions = val;
                return this;
            }
            return httpOptions;
        };
        this.$get = [ "$templateCache", "$http", "$q", "$sce", function($templateCache, $http, $q, $sce) {
            function handleRequestFn(tpl, ignoreRequestError) {
                handleRequestFn.totalPendingRequests++;
                if (!isString(tpl) || isUndefined($templateCache.get(tpl))) {
                    tpl = $sce.getTrustedResourceUrl(tpl);
                }
                var transformResponse = $http.defaults && $http.defaults.transformResponse;
                if (isArray(transformResponse)) {
                    transformResponse = transformResponse.filter(function(transformer) {
                        return transformer !== defaultHttpResponseTransform;
                    });
                } else if (transformResponse === defaultHttpResponseTransform) {
                    transformResponse = null;
                }
                return $http.get(tpl, extend({
                    cache: $templateCache,
                    transformResponse: transformResponse
                }, httpOptions))["finally"](function() {
                    handleRequestFn.totalPendingRequests--;
                }).then(function(response) {
                    $templateCache.put(tpl, response.data);
                    return response.data;
                }, handleError);
                function handleError(resp) {
                    if (!ignoreRequestError) {
                        throw $templateRequestMinErr("tpload", "Failed to load template: {0} (HTTP status: {1} {2})", tpl, resp.status, resp.statusText);
                    }
                    return $q.reject(resp);
                }
            }
            handleRequestFn.totalPendingRequests = 0;
            return handleRequestFn;
        } ];
    }
    function $$TestabilityProvider() {
        this.$get = [ "$rootScope", "$browser", "$location", function($rootScope, $browser, $location) {
            var testability = {};
            testability.findBindings = function(element, expression, opt_exactMatch) {
                var bindings = element.getElementsByClassName("ng-binding");
                var matches = [];
                forEach(bindings, function(binding) {
                    var dataBinding = angular.element(binding).data("$binding");
                    if (dataBinding) {
                        forEach(dataBinding, function(bindingName) {
                            if (opt_exactMatch) {
                                var matcher = new RegExp("(^|\\s)" + escapeForRegexp(expression) + "(\\s|\\||$)");
                                if (matcher.test(bindingName)) {
                                    matches.push(binding);
                                }
                            } else {
                                if (bindingName.indexOf(expression) !== -1) {
                                    matches.push(binding);
                                }
                            }
                        });
                    }
                });
                return matches;
            };
            testability.findModels = function(element, expression, opt_exactMatch) {
                var prefixes = [ "ng-", "data-ng-", "ng\\:" ];
                for (var p = 0; p < prefixes.length; ++p) {
                    var attributeEquals = opt_exactMatch ? "=" : "*=";
                    var selector = "[" + prefixes[p] + "model" + attributeEquals + '"' + expression + '"]';
                    var elements = element.querySelectorAll(selector);
                    if (elements.length) {
                        return elements;
                    }
                }
            };
            testability.getLocation = function() {
                return $location.url();
            };
            testability.setLocation = function(url) {
                if (url !== $location.url()) {
                    $location.url(url);
                    $rootScope.$digest();
                }
            };
            testability.whenStable = function(callback) {
                $browser.notifyWhenNoOutstandingRequests(callback);
            };
            return testability;
        } ];
    }
    function $TimeoutProvider() {
        this.$get = [ "$rootScope", "$browser", "$q", "$$q", "$exceptionHandler", function($rootScope, $browser, $q, $$q, $exceptionHandler) {
            var deferreds = {};
            function timeout(fn, delay, invokeApply) {
                if (!isFunction(fn)) {
                    invokeApply = delay;
                    delay = fn;
                    fn = noop;
                }
                var args = sliceArgs(arguments, 3), skipApply = isDefined(invokeApply) && !invokeApply, deferred = (skipApply ? $$q : $q).defer(), promise = deferred.promise, timeoutId;
                timeoutId = $browser.defer(function() {
                    try {
                        deferred.resolve(fn.apply(null, args));
                    } catch (e) {
                        deferred.reject(e);
                        $exceptionHandler(e);
                    } finally {
                        delete deferreds[promise.$$timeoutId];
                    }
                    if (!skipApply) $rootScope.$apply();
                }, delay);
                promise.$$timeoutId = timeoutId;
                deferreds[timeoutId] = deferred;
                return promise;
            }
            timeout.cancel = function(promise) {
                if (promise && promise.$$timeoutId in deferreds) {
                    deferreds[promise.$$timeoutId].reject("canceled");
                    delete deferreds[promise.$$timeoutId];
                    return $browser.defer.cancel(promise.$$timeoutId);
                }
                return false;
            };
            return timeout;
        } ];
    }
    var urlParsingNode = window.document.createElement("a");
    var originUrl = urlResolve(window.location.href);
    function urlResolve(url) {
        var href = url;
        if (msie) {
            urlParsingNode.setAttribute("href", href);
            href = urlParsingNode.href;
        }
        urlParsingNode.setAttribute("href", href);
        return {
            href: urlParsingNode.href,
            protocol: urlParsingNode.protocol ? urlParsingNode.protocol.replace(/:$/, "") : "",
            host: urlParsingNode.host,
            search: urlParsingNode.search ? urlParsingNode.search.replace(/^\?/, "") : "",
            hash: urlParsingNode.hash ? urlParsingNode.hash.replace(/^#/, "") : "",
            hostname: urlParsingNode.hostname,
            port: urlParsingNode.port,
            pathname: urlParsingNode.pathname.charAt(0) === "/" ? urlParsingNode.pathname : "/" + urlParsingNode.pathname
        };
    }
    function urlIsSameOrigin(requestUrl) {
        var parsed = isString(requestUrl) ? urlResolve(requestUrl) : requestUrl;
        return parsed.protocol === originUrl.protocol && parsed.host === originUrl.host;
    }
    function $WindowProvider() {
        this.$get = valueFn(window);
    }
    function $$CookieReader($document) {
        var rawDocument = $document[0] || {};
        var lastCookies = {};
        var lastCookieString = "";
        function safeGetCookie(rawDocument) {
            try {
                return rawDocument.cookie || "";
            } catch (e) {
                return "";
            }
        }
        function safeDecodeURIComponent(str) {
            try {
                return decodeURIComponent(str);
            } catch (e) {
                return str;
            }
        }
        return function() {
            var cookieArray, cookie, i, index, name;
            var currentCookieString = safeGetCookie(rawDocument);
            if (currentCookieString !== lastCookieString) {
                lastCookieString = currentCookieString;
                cookieArray = lastCookieString.split("; ");
                lastCookies = {};
                for (i = 0; i < cookieArray.length; i++) {
                    cookie = cookieArray[i];
                    index = cookie.indexOf("=");
                    if (index > 0) {
                        name = safeDecodeURIComponent(cookie.substring(0, index));
                        if (isUndefined(lastCookies[name])) {
                            lastCookies[name] = safeDecodeURIComponent(cookie.substring(index + 1));
                        }
                    }
                }
            }
            return lastCookies;
        };
    }
    $$CookieReader.$inject = [ "$document" ];
    function $$CookieReaderProvider() {
        this.$get = $$CookieReader;
    }
    $FilterProvider.$inject = [ "$provide" ];
    function $FilterProvider($provide) {
        var suffix = "Filter";
        function register(name, factory) {
            if (isObject(name)) {
                var filters = {};
                forEach(name, function(filter, key) {
                    filters[key] = register(key, filter);
                });
                return filters;
            } else {
                return $provide.factory(name + suffix, factory);
            }
        }
        this.register = register;
        this.$get = [ "$injector", function($injector) {
            return function(name) {
                return $injector.get(name + suffix);
            };
        } ];
        register("currency", currencyFilter);
        register("date", dateFilter);
        register("filter", filterFilter);
        register("json", jsonFilter);
        register("limitTo", limitToFilter);
        register("lowercase", lowercaseFilter);
        register("number", numberFilter);
        register("orderBy", orderByFilter);
        register("uppercase", uppercaseFilter);
    }
    function filterFilter() {
        return function(array, expression, comparator, anyPropertyKey) {
            if (!isArrayLike(array)) {
                if (array == null) {
                    return array;
                } else {
                    throw minErr("filter")("notarray", "Expected array but received: {0}", array);
                }
            }
            anyPropertyKey = anyPropertyKey || "$";
            var expressionType = getTypeForFilter(expression);
            var predicateFn;
            var matchAgainstAnyProp;
            switch (expressionType) {
              case "function":
                predicateFn = expression;
                break;

              case "boolean":
              case "null":
              case "number":
              case "string":
                matchAgainstAnyProp = true;

              case "object":
                predicateFn = createPredicateFn(expression, comparator, anyPropertyKey, matchAgainstAnyProp);
                break;

              default:
                return array;
            }
            return Array.prototype.filter.call(array, predicateFn);
        };
    }
    function createPredicateFn(expression, comparator, anyPropertyKey, matchAgainstAnyProp) {
        var shouldMatchPrimitives = isObject(expression) && anyPropertyKey in expression;
        var predicateFn;
        if (comparator === true) {
            comparator = equals;
        } else if (!isFunction(comparator)) {
            comparator = function(actual, expected) {
                if (isUndefined(actual)) {
                    return false;
                }
                if (actual === null || expected === null) {
                    return actual === expected;
                }
                if (isObject(expected) || isObject(actual) && !hasCustomToString(actual)) {
                    return false;
                }
                actual = lowercase("" + actual);
                expected = lowercase("" + expected);
                return actual.indexOf(expected) !== -1;
            };
        }
        predicateFn = function(item) {
            if (shouldMatchPrimitives && !isObject(item)) {
                return deepCompare(item, expression[anyPropertyKey], comparator, anyPropertyKey, false);
            }
            return deepCompare(item, expression, comparator, anyPropertyKey, matchAgainstAnyProp);
        };
        return predicateFn;
    }
    function deepCompare(actual, expected, comparator, anyPropertyKey, matchAgainstAnyProp, dontMatchWholeObject) {
        var actualType = getTypeForFilter(actual);
        var expectedType = getTypeForFilter(expected);
        if (expectedType === "string" && expected.charAt(0) === "!") {
            return !deepCompare(actual, expected.substring(1), comparator, anyPropertyKey, matchAgainstAnyProp);
        } else if (isArray(actual)) {
            return actual.some(function(item) {
                return deepCompare(item, expected, comparator, anyPropertyKey, matchAgainstAnyProp);
            });
        }
        switch (actualType) {
          case "object":
            var key;
            if (matchAgainstAnyProp) {
                for (key in actual) {
                    if (key.charAt(0) !== "$" && deepCompare(actual[key], expected, comparator, anyPropertyKey, true)) {
                        return true;
                    }
                }
                return dontMatchWholeObject ? false : deepCompare(actual, expected, comparator, anyPropertyKey, false);
            } else if (expectedType === "object") {
                for (key in expected) {
                    var expectedVal = expected[key];
                    if (isFunction(expectedVal) || isUndefined(expectedVal)) {
                        continue;
                    }
                    var matchAnyProperty = key === anyPropertyKey;
                    var actualVal = matchAnyProperty ? actual : actual[key];
                    if (!deepCompare(actualVal, expectedVal, comparator, anyPropertyKey, matchAnyProperty, matchAnyProperty)) {
                        return false;
                    }
                }
                return true;
            } else {
                return comparator(actual, expected);
            }

          case "function":
            return false;

          default:
            return comparator(actual, expected);
        }
    }
    function getTypeForFilter(val) {
        return val === null ? "null" : typeof val;
    }
    var MAX_DIGITS = 22;
    var DECIMAL_SEP = ".";
    var ZERO_CHAR = "0";
    currencyFilter.$inject = [ "$locale" ];
    function currencyFilter($locale) {
        var formats = $locale.NUMBER_FORMATS;
        return function(amount, currencySymbol, fractionSize) {
            if (isUndefined(currencySymbol)) {
                currencySymbol = formats.CURRENCY_SYM;
            }
            if (isUndefined(fractionSize)) {
                fractionSize = formats.PATTERNS[1].maxFrac;
            }
            return amount == null ? amount : formatNumber(amount, formats.PATTERNS[1], formats.GROUP_SEP, formats.DECIMAL_SEP, fractionSize).replace(/\u00A4/g, currencySymbol);
        };
    }
    numberFilter.$inject = [ "$locale" ];
    function numberFilter($locale) {
        var formats = $locale.NUMBER_FORMATS;
        return function(number, fractionSize) {
            return number == null ? number : formatNumber(number, formats.PATTERNS[0], formats.GROUP_SEP, formats.DECIMAL_SEP, fractionSize);
        };
    }
    function parse(numStr) {
        var exponent = 0, digits, numberOfIntegerDigits;
        var i, j, zeros;
        if ((numberOfIntegerDigits = numStr.indexOf(DECIMAL_SEP)) > -1) {
            numStr = numStr.replace(DECIMAL_SEP, "");
        }
        if ((i = numStr.search(/e/i)) > 0) {
            if (numberOfIntegerDigits < 0) numberOfIntegerDigits = i;
            numberOfIntegerDigits += +numStr.slice(i + 1);
            numStr = numStr.substring(0, i);
        } else if (numberOfIntegerDigits < 0) {
            numberOfIntegerDigits = numStr.length;
        }
        for (i = 0; numStr.charAt(i) === ZERO_CHAR; i++) {}
        if (i === (zeros = numStr.length)) {
            digits = [ 0 ];
            numberOfIntegerDigits = 1;
        } else {
            zeros--;
            while (numStr.charAt(zeros) === ZERO_CHAR) zeros--;
            numberOfIntegerDigits -= i;
            digits = [];
            for (j = 0; i <= zeros; i++, j++) {
                digits[j] = +numStr.charAt(i);
            }
        }
        if (numberOfIntegerDigits > MAX_DIGITS) {
            digits = digits.splice(0, MAX_DIGITS - 1);
            exponent = numberOfIntegerDigits - 1;
            numberOfIntegerDigits = 1;
        }
        return {
            d: digits,
            e: exponent,
            i: numberOfIntegerDigits
        };
    }
    function roundNumber(parsedNumber, fractionSize, minFrac, maxFrac) {
        var digits = parsedNumber.d;
        var fractionLen = digits.length - parsedNumber.i;
        fractionSize = isUndefined(fractionSize) ? Math.min(Math.max(minFrac, fractionLen), maxFrac) : +fractionSize;
        var roundAt = fractionSize + parsedNumber.i;
        var digit = digits[roundAt];
        if (roundAt > 0) {
            digits.splice(Math.max(parsedNumber.i, roundAt));
            for (var j = roundAt; j < digits.length; j++) {
                digits[j] = 0;
            }
        } else {
            fractionLen = Math.max(0, fractionLen);
            parsedNumber.i = 1;
            digits.length = Math.max(1, roundAt = fractionSize + 1);
            digits[0] = 0;
            for (var i = 1; i < roundAt; i++) digits[i] = 0;
        }
        if (digit >= 5) {
            if (roundAt - 1 < 0) {
                for (var k = 0; k > roundAt; k--) {
                    digits.unshift(0);
                    parsedNumber.i++;
                }
                digits.unshift(1);
                parsedNumber.i++;
            } else {
                digits[roundAt - 1]++;
            }
        }
        for (;fractionLen < Math.max(0, fractionSize); fractionLen++) digits.push(0);
        var carry = digits.reduceRight(function(carry, d, i, digits) {
            d = d + carry;
            digits[i] = d % 10;
            return Math.floor(d / 10);
        }, 0);
        if (carry) {
            digits.unshift(carry);
            parsedNumber.i++;
        }
    }
    function formatNumber(number, pattern, groupSep, decimalSep, fractionSize) {
        if (!(isString(number) || isNumber(number)) || isNaN(number)) return "";
        var isInfinity = !isFinite(number);
        var isZero = false;
        var numStr = Math.abs(number) + "", formattedText = "", parsedNumber;
        if (isInfinity) {
            formattedText = "â";
        } else {
            parsedNumber = parse(numStr);
            roundNumber(parsedNumber, fractionSize, pattern.minFrac, pattern.maxFrac);
            var digits = parsedNumber.d;
            var integerLen = parsedNumber.i;
            var exponent = parsedNumber.e;
            var decimals = [];
            isZero = digits.reduce(function(isZero, d) {
                return isZero && !d;
            }, true);
            while (integerLen < 0) {
                digits.unshift(0);
                integerLen++;
            }
            if (integerLen > 0) {
                decimals = digits.splice(integerLen, digits.length);
            } else {
                decimals = digits;
                digits = [ 0 ];
            }
            var groups = [];
            if (digits.length >= pattern.lgSize) {
                groups.unshift(digits.splice(-pattern.lgSize, digits.length).join(""));
            }
            while (digits.length > pattern.gSize) {
                groups.unshift(digits.splice(-pattern.gSize, digits.length).join(""));
            }
            if (digits.length) {
                groups.unshift(digits.join(""));
            }
            formattedText = groups.join(groupSep);
            if (decimals.length) {
                formattedText += decimalSep + decimals.join("");
            }
            if (exponent) {
                formattedText += "e+" + exponent;
            }
        }
        if (number < 0 && !isZero) {
            return pattern.negPre + formattedText + pattern.negSuf;
        } else {
            return pattern.posPre + formattedText + pattern.posSuf;
        }
    }
    function padNumber(num, digits, trim, negWrap) {
        var neg = "";
        if (num < 0 || negWrap && num <= 0) {
            if (negWrap) {
                num = -num + 1;
            } else {
                num = -num;
                neg = "-";
            }
        }
        num = "" + num;
        while (num.length < digits) num = ZERO_CHAR + num;
        if (trim) {
            num = num.substr(num.length - digits);
        }
        return neg + num;
    }
    function dateGetter(name, size, offset, trim, negWrap) {
        offset = offset || 0;
        return function(date) {
            var value = date["get" + name]();
            if (offset > 0 || value > -offset) {
                value += offset;
            }
            if (value === 0 && offset === -12) value = 12;
            return padNumber(value, size, trim, negWrap);
        };
    }
    function dateStrGetter(name, shortForm, standAlone) {
        return function(date, formats) {
            var value = date["get" + name]();
            var propPrefix = (standAlone ? "STANDALONE" : "") + (shortForm ? "SHORT" : "");
            var get = uppercase(propPrefix + name);
            return formats[get][value];
        };
    }
    function timeZoneGetter(date, formats, offset) {
        var zone = -1 * offset;
        var paddedZone = zone >= 0 ? "+" : "";
        paddedZone += padNumber(Math[zone > 0 ? "floor" : "ceil"](zone / 60), 2) + padNumber(Math.abs(zone % 60), 2);
        return paddedZone;
    }
    function getFirstThursdayOfYear(year) {
        var dayOfWeekOnFirst = new Date(year, 0, 1).getDay();
        return new Date(year, 0, (dayOfWeekOnFirst <= 4 ? 5 : 12) - dayOfWeekOnFirst);
    }
    function getThursdayThisWeek(datetime) {
        return new Date(datetime.getFullYear(), datetime.getMonth(), datetime.getDate() + (4 - datetime.getDay()));
    }
    function weekGetter(size) {
        return function(date) {
            var firstThurs = getFirstThursdayOfYear(date.getFullYear()), thisThurs = getThursdayThisWeek(date);
            var diff = +thisThurs - +firstThurs, result = 1 + Math.round(diff / 6048e5);
            return padNumber(result, size);
        };
    }
    function ampmGetter(date, formats) {
        return date.getHours() < 12 ? formats.AMPMS[0] : formats.AMPMS[1];
    }
    function eraGetter(date, formats) {
        return date.getFullYear() <= 0 ? formats.ERAS[0] : formats.ERAS[1];
    }
    function longEraGetter(date, formats) {
        return date.getFullYear() <= 0 ? formats.ERANAMES[0] : formats.ERANAMES[1];
    }
    var DATE_FORMATS = {
        yyyy: dateGetter("FullYear", 4, 0, false, true),
        yy: dateGetter("FullYear", 2, 0, true, true),
        y: dateGetter("FullYear", 1, 0, false, true),
        MMMM: dateStrGetter("Month"),
        MMM: dateStrGetter("Month", true),
        MM: dateGetter("Month", 2, 1),
        M: dateGetter("Month", 1, 1),
        LLLL: dateStrGetter("Month", false, true),
        dd: dateGetter("Date", 2),
        d: dateGetter("Date", 1),
        HH: dateGetter("Hours", 2),
        H: dateGetter("Hours", 1),
        hh: dateGetter("Hours", 2, -12),
        h: dateGetter("Hours", 1, -12),
        mm: dateGetter("Minutes", 2),
        m: dateGetter("Minutes", 1),
        ss: dateGetter("Seconds", 2),
        s: dateGetter("Seconds", 1),
        sss: dateGetter("Milliseconds", 3),
        EEEE: dateStrGetter("Day"),
        EEE: dateStrGetter("Day", true),
        a: ampmGetter,
        Z: timeZoneGetter,
        ww: weekGetter(2),
        w: weekGetter(1),
        G: eraGetter,
        GG: eraGetter,
        GGG: eraGetter,
        GGGG: longEraGetter
    };
    var DATE_FORMATS_SPLIT = /((?:[^yMLdHhmsaZEwG']+)|(?:'(?:[^']|'')*')|(?:E+|y+|M+|L+|d+|H+|h+|m+|s+|a|Z|G+|w+))(.*)/, NUMBER_STRING = /^-?\d+$/;
    dateFilter.$inject = [ "$locale" ];
    function dateFilter($locale) {
        var R_ISO8601_STR = /^(\d{4})-?(\d\d)-?(\d\d)(?:T(\d\d)(?::?(\d\d)(?::?(\d\d)(?:\.(\d+))?)?)?(Z|([+-])(\d\d):?(\d\d))?)?$/;
        function jsonStringToDate(string) {
            var match;
            if (match = string.match(R_ISO8601_STR)) {
                var date = new Date(0), tzHour = 0, tzMin = 0, dateSetter = match[8] ? date.setUTCFullYear : date.setFullYear, timeSetter = match[8] ? date.setUTCHours : date.setHours;
                if (match[9]) {
                    tzHour = toInt(match[9] + match[10]);
                    tzMin = toInt(match[9] + match[11]);
                }
                dateSetter.call(date, toInt(match[1]), toInt(match[2]) - 1, toInt(match[3]));
                var h = toInt(match[4] || 0) - tzHour;
                var m = toInt(match[5] || 0) - tzMin;
                var s = toInt(match[6] || 0);
                var ms = Math.round(parseFloat("0." + (match[7] || 0)) * 1e3);
                timeSetter.call(date, h, m, s, ms);
                return date;
            }
            return string;
        }
        return function(date, format, timezone) {
            var text = "", parts = [], fn, match;
            format = format || "mediumDate";
            format = $locale.DATETIME_FORMATS[format] || format;
            if (isString(date)) {
                date = NUMBER_STRING.test(date) ? toInt(date) : jsonStringToDate(date);
            }
            if (isNumber(date)) {
                date = new Date(date);
            }
            if (!isDate(date) || !isFinite(date.getTime())) {
                return date;
            }
            while (format) {
                match = DATE_FORMATS_SPLIT.exec(format);
                if (match) {
                    parts = concat(parts, match, 1);
                    format = parts.pop();
                } else {
                    parts.push(format);
                    format = null;
                }
            }
            var dateTimezoneOffset = date.getTimezoneOffset();
            if (timezone) {
                dateTimezoneOffset = timezoneToOffset(timezone, dateTimezoneOffset);
                date = convertTimezoneToLocal(date, timezone, true);
            }
            forEach(parts, function(value) {
                fn = DATE_FORMATS[value];
                text += fn ? fn(date, $locale.DATETIME_FORMATS, dateTimezoneOffset) : value === "''" ? "'" : value.replace(/(^'|'$)/g, "").replace(/''/g, "'");
            });
            return text;
        };
    }
    function jsonFilter() {
        return function(object, spacing) {
            if (isUndefined(spacing)) {
                spacing = 2;
            }
            return toJson(object, spacing);
        };
    }
    var lowercaseFilter = valueFn(lowercase);
    var uppercaseFilter = valueFn(uppercase);
    function limitToFilter() {
        return function(input, limit, begin) {
            if (Math.abs(Number(limit)) === Infinity) {
                limit = Number(limit);
            } else {
                limit = toInt(limit);
            }
            if (isNumberNaN(limit)) return input;
            if (isNumber(input)) input = input.toString();
            if (!isArrayLike(input)) return input;
            begin = !begin || isNaN(begin) ? 0 : toInt(begin);
            begin = begin < 0 ? Math.max(0, input.length + begin) : begin;
            if (limit >= 0) {
                return sliceFn(input, begin, begin + limit);
            } else {
                if (begin === 0) {
                    return sliceFn(input, limit, input.length);
                } else {
                    return sliceFn(input, Math.max(0, begin + limit), begin);
                }
            }
        };
    }
    function sliceFn(input, begin, end) {
        if (isString(input)) return input.slice(begin, end);
        return slice.call(input, begin, end);
    }
    orderByFilter.$inject = [ "$parse" ];
    function orderByFilter($parse) {
        return function(array, sortPredicate, reverseOrder, compareFn) {
            if (array == null) return array;
            if (!isArrayLike(array)) {
                throw minErr("orderBy")("notarray", "Expected array but received: {0}", array);
            }
            if (!isArray(sortPredicate)) {
                sortPredicate = [ sortPredicate ];
            }
            if (sortPredicate.length === 0) {
                sortPredicate = [ "+" ];
            }
            var predicates = processPredicates(sortPredicate);
            var descending = reverseOrder ? -1 : 1;
            var compare = isFunction(compareFn) ? compareFn : defaultCompare;
            var compareValues = Array.prototype.map.call(array, getComparisonObject);
            compareValues.sort(doComparison);
            array = compareValues.map(function(item) {
                return item.value;
            });
            return array;
            function getComparisonObject(value, index) {
                return {
                    value: value,
                    tieBreaker: {
                        value: index,
                        type: "number",
                        index: index
                    },
                    predicateValues: predicates.map(function(predicate) {
                        return getPredicateValue(predicate.get(value), index);
                    })
                };
            }
            function doComparison(v1, v2) {
                for (var i = 0, ii = predicates.length; i < ii; i++) {
                    var result = compare(v1.predicateValues[i], v2.predicateValues[i]);
                    if (result) {
                        return result * predicates[i].descending * descending;
                    }
                }
                return compare(v1.tieBreaker, v2.tieBreaker) * descending;
            }
        };
        function processPredicates(sortPredicates) {
            return sortPredicates.map(function(predicate) {
                var descending = 1, get = identity;
                if (isFunction(predicate)) {
                    get = predicate;
                } else if (isString(predicate)) {
                    if (predicate.charAt(0) === "+" || predicate.charAt(0) === "-") {
                        descending = predicate.charAt(0) === "-" ? -1 : 1;
                        predicate = predicate.substring(1);
                    }
                    if (predicate !== "") {
                        get = $parse(predicate);
                        if (get.constant) {
                            var key = get();
                            get = function(value) {
                                return value[key];
                            };
                        }
                    }
                }
                return {
                    get: get,
                    descending: descending
                };
            });
        }
        function isPrimitive(value) {
            switch (typeof value) {
              case "number":
              case "boolean":
              case "string":
                return true;

              default:
                return false;
            }
        }
        function objectValue(value) {
            if (isFunction(value.valueOf)) {
                value = value.valueOf();
                if (isPrimitive(value)) return value;
            }
            if (hasCustomToString(value)) {
                value = value.toString();
                if (isPrimitive(value)) return value;
            }
            return value;
        }
        function getPredicateValue(value, index) {
            var type = typeof value;
            if (value === null) {
                type = "string";
                value = "null";
            } else if (type === "object") {
                value = objectValue(value);
            }
            return {
                value: value,
                type: type,
                index: index
            };
        }
        function defaultCompare(v1, v2) {
            var result = 0;
            var type1 = v1.type;
            var type2 = v2.type;
            if (type1 === type2) {
                var value1 = v1.value;
                var value2 = v2.value;
                if (type1 === "string") {
                    value1 = value1.toLowerCase();
                    value2 = value2.toLowerCase();
                } else if (type1 === "object") {
                    if (isObject(value1)) value1 = v1.index;
                    if (isObject(value2)) value2 = v2.index;
                }
                if (value1 !== value2) {
                    result = value1 < value2 ? -1 : 1;
                }
            } else {
                result = type1 < type2 ? -1 : 1;
            }
            return result;
        }
    }
    function ngDirective(directive) {
        if (isFunction(directive)) {
            directive = {
                link: directive
            };
        }
        directive.restrict = directive.restrict || "AC";
        return valueFn(directive);
    }
    var htmlAnchorDirective = valueFn({
        restrict: "E",
        compile: function(element, attr) {
            if (!attr.href && !attr.xlinkHref) {
                return function(scope, element) {
                    if (element[0].nodeName.toLowerCase() !== "a") return;
                    var href = toString.call(element.prop("href")) === "[object SVGAnimatedString]" ? "xlink:href" : "href";
                    element.on("click", function(event) {
                        if (!element.attr(href)) {
                            event.preventDefault();
                        }
                    });
                };
            }
        }
    });
    var ngAttributeAliasDirectives = {};
    forEach(BOOLEAN_ATTR, function(propName, attrName) {
        if (propName === "multiple") return;
        function defaultLinkFn(scope, element, attr) {
            scope.$watch(attr[normalized], function ngBooleanAttrWatchAction(value) {
                attr.$set(attrName, !!value);
            });
        }
        var normalized = directiveNormalize("ng-" + attrName);
        var linkFn = defaultLinkFn;
        if (propName === "checked") {
            linkFn = function(scope, element, attr) {
                if (attr.ngModel !== attr[normalized]) {
                    defaultLinkFn(scope, element, attr);
                }
            };
        }
        ngAttributeAliasDirectives[normalized] = function() {
            return {
                restrict: "A",
                priority: 100,
                link: linkFn
            };
        };
    });
    forEach(ALIASED_ATTR, function(htmlAttr, ngAttr) {
        ngAttributeAliasDirectives[ngAttr] = function() {
            return {
                priority: 100,
                link: function(scope, element, attr) {
                    if (ngAttr === "ngPattern" && attr.ngPattern.charAt(0) === "/") {
                        var match = attr.ngPattern.match(REGEX_STRING_REGEXP);
                        if (match) {
                            attr.$set("ngPattern", new RegExp(match[1], match[2]));
                            return;
                        }
                    }
                    scope.$watch(attr[ngAttr], function ngAttrAliasWatchAction(value) {
                        attr.$set(ngAttr, value);
                    });
                }
            };
        };
    });
    forEach([ "src", "srcset", "href" ], function(attrName) {
        var normalized = directiveNormalize("ng-" + attrName);
        ngAttributeAliasDirectives[normalized] = function() {
            return {
                priority: 99,
                link: function(scope, element, attr) {
                    var propName = attrName, name = attrName;
                    if (attrName === "href" && toString.call(element.prop("href")) === "[object SVGAnimatedString]") {
                        name = "xlinkHref";
                        attr.$attr[name] = "xlink:href";
                        propName = null;
                    }
                    attr.$observe(normalized, function(value) {
                        if (!value) {
                            if (attrName === "href") {
                                attr.$set(name, null);
                            }
                            return;
                        }
                        attr.$set(name, value);
                        if (msie && propName) element.prop(propName, attr[name]);
                    });
                }
            };
        };
    });
    var nullFormCtrl = {
        $addControl: noop,
        $$renameControl: nullFormRenameControl,
        $removeControl: noop,
        $setValidity: noop,
        $setDirty: noop,
        $setPristine: noop,
        $setSubmitted: noop
    }, SUBMITTED_CLASS = "ng-submitted";
    function nullFormRenameControl(control, name) {
        control.$name = name;
    }
    FormController.$inject = [ "$element", "$attrs", "$scope", "$animate", "$interpolate" ];
    function FormController(element, attrs, $scope, $animate, $interpolate) {
        var form = this, controls = [];
        form.$error = {};
        form.$$success = {};
        form.$pending = undefined;
        form.$name = $interpolate(attrs.name || attrs.ngForm || "")($scope);
        form.$dirty = false;
        form.$pristine = true;
        form.$valid = true;
        form.$invalid = false;
        form.$submitted = false;
        form.$$parentForm = nullFormCtrl;
        form.$rollbackViewValue = function() {
            forEach(controls, function(control) {
                control.$rollbackViewValue();
            });
        };
        form.$commitViewValue = function() {
            forEach(controls, function(control) {
                control.$commitViewValue();
            });
        };
        form.$addControl = function(control) {
            assertNotHasOwnProperty(control.$name, "input");
            controls.push(control);
            if (control.$name) {
                form[control.$name] = control;
            }
            control.$$parentForm = form;
        };
        form.$$renameControl = function(control, newName) {
            var oldName = control.$name;
            if (form[oldName] === control) {
                delete form[oldName];
            }
            form[newName] = control;
            control.$name = newName;
        };
        form.$removeControl = function(control) {
            if (control.$name && form[control.$name] === control) {
                delete form[control.$name];
            }
            forEach(form.$pending, function(value, name) {
                form.$setValidity(name, null, control);
            });
            forEach(form.$error, function(value, name) {
                form.$setValidity(name, null, control);
            });
            forEach(form.$$success, function(value, name) {
                form.$setValidity(name, null, control);
            });
            arrayRemove(controls, control);
            control.$$parentForm = nullFormCtrl;
        };
        addSetValidityMethod({
            ctrl: this,
            $element: element,
            set: function(object, property, controller) {
                var list = object[property];
                if (!list) {
                    object[property] = [ controller ];
                } else {
                    var index = list.indexOf(controller);
                    if (index === -1) {
                        list.push(controller);
                    }
                }
            },
            unset: function(object, property, controller) {
                var list = object[property];
                if (!list) {
                    return;
                }
                arrayRemove(list, controller);
                if (list.length === 0) {
                    delete object[property];
                }
            },
            $animate: $animate
        });
        form.$setDirty = function() {
            $animate.removeClass(element, PRISTINE_CLASS);
            $animate.addClass(element, DIRTY_CLASS);
            form.$dirty = true;
            form.$pristine = false;
            form.$$parentForm.$setDirty();
        };
        form.$setPristine = function() {
            $animate.setClass(element, PRISTINE_CLASS, DIRTY_CLASS + " " + SUBMITTED_CLASS);
            form.$dirty = false;
            form.$pristine = true;
            form.$submitted = false;
            forEach(controls, function(control) {
                control.$setPristine();
            });
        };
        form.$setUntouched = function() {
            forEach(controls, function(control) {
                control.$setUntouched();
            });
        };
        form.$setSubmitted = function() {
            $animate.addClass(element, SUBMITTED_CLASS);
            form.$submitted = true;
            form.$$parentForm.$setSubmitted();
        };
    }
    var formDirectiveFactory = function(isNgForm) {
        return [ "$timeout", "$parse", function($timeout, $parse) {
            var formDirective = {
                name: "form",
                restrict: isNgForm ? "EAC" : "E",
                require: [ "form", "^^?form" ],
                controller: FormController,
                compile: function ngFormCompile(formElement, attr) {
                    formElement.addClass(PRISTINE_CLASS).addClass(VALID_CLASS);
                    var nameAttr = attr.name ? "name" : isNgForm && attr.ngForm ? "ngForm" : false;
                    return {
                        pre: function ngFormPreLink(scope, formElement, attr, ctrls) {
                            var controller = ctrls[0];
                            if (!("action" in attr)) {
                                var handleFormSubmission = function(event) {
                                    scope.$apply(function() {
                                        controller.$commitViewValue();
                                        controller.$setSubmitted();
                                    });
                                    event.preventDefault();
                                };
                                addEventListenerFn(formElement[0], "submit", handleFormSubmission);
                                formElement.on("$destroy", function() {
                                    $timeout(function() {
                                        removeEventListenerFn(formElement[0], "submit", handleFormSubmission);
                                    }, 0, false);
                                });
                            }
                            var parentFormCtrl = ctrls[1] || controller.$$parentForm;
                            parentFormCtrl.$addControl(controller);
                            var setter = nameAttr ? getSetter(controller.$name) : noop;
                            if (nameAttr) {
                                setter(scope, controller);
                                attr.$observe(nameAttr, function(newValue) {
                                    if (controller.$name === newValue) return;
                                    setter(scope, undefined);
                                    controller.$$parentForm.$$renameControl(controller, newValue);
                                    setter = getSetter(controller.$name);
                                    setter(scope, controller);
                                });
                            }
                            formElement.on("$destroy", function() {
                                controller.$$parentForm.$removeControl(controller);
                                setter(scope, undefined);
                                extend(controller, nullFormCtrl);
                            });
                        }
                    };
                }
            };
            return formDirective;
            function getSetter(expression) {
                if (expression === "") {
                    return $parse('this[""]').assign;
                }
                return $parse(expression).assign || noop;
            }
        } ];
    };
    var formDirective = formDirectiveFactory();
    var ngFormDirective = formDirectiveFactory(true);
    var ISO_DATE_REGEXP = /^\d{4,}-[01]\d-[0-3]\dT[0-2]\d:[0-5]\d:[0-5]\d\.\d+(?:[+-][0-2]\d:[0-5]\d|Z)$/;
    var URL_REGEXP = /^[a-z][a-z\d.+-]*:\/*(?:[^:@]+(?::[^@]+)?@)?(?:[^\s:\/?#]+|\[[a-f\d:]+])(?::\d+)?(?:\/[^?#]*)?(?:\?[^#]*)?(?:#.*)?$/i;
    var EMAIL_REGEXP = /^(?=.{1,254}$)(?=.{1,64}@)[-!#$%&'*+\/0-9=?A-Z^_`a-z{|}~]+(\.[-!#$%&'*+\/0-9=?A-Z^_`a-z{|}~]+)*@[A-Za-z0-9]([A-Za-z0-9-]{0,61}[A-Za-z0-9])?(\.[A-Za-z0-9]([A-Za-z0-9-]{0,61}[A-Za-z0-9])?)*$/;
    var NUMBER_REGEXP = /^\s*(-|\+)?(\d+|(\d*(\.\d*)))([eE][+-]?\d+)?\s*$/;
    var DATE_REGEXP = /^(\d{4,})-(\d{2})-(\d{2})$/;
    var DATETIMELOCAL_REGEXP = /^(\d{4,})-(\d\d)-(\d\d)T(\d\d):(\d\d)(?::(\d\d)(\.\d{1,3})?)?$/;
    var WEEK_REGEXP = /^(\d{4,})-W(\d\d)$/;
    var MONTH_REGEXP = /^(\d{4,})-(\d\d)$/;
    var TIME_REGEXP = /^(\d\d):(\d\d)(?::(\d\d)(\.\d{1,3})?)?$/;
    var PARTIAL_VALIDATION_EVENTS = "keydown wheel mousedown";
    var PARTIAL_VALIDATION_TYPES = createMap();
    forEach("date,datetime-local,month,time,week".split(","), function(type) {
        PARTIAL_VALIDATION_TYPES[type] = true;
    });
    var inputType = {
        text: textInputType,
        date: createDateInputType("date", DATE_REGEXP, createDateParser(DATE_REGEXP, [ "yyyy", "MM", "dd" ]), "yyyy-MM-dd"),
        "datetime-local": createDateInputType("datetimelocal", DATETIMELOCAL_REGEXP, createDateParser(DATETIMELOCAL_REGEXP, [ "yyyy", "MM", "dd", "HH", "mm", "ss", "sss" ]), "yyyy-MM-ddTHH:mm:ss.sss"),
        time: createDateInputType("time", TIME_REGEXP, createDateParser(TIME_REGEXP, [ "HH", "mm", "ss", "sss" ]), "HH:mm:ss.sss"),
        week: createDateInputType("week", WEEK_REGEXP, weekParser, "yyyy-Www"),
        month: createDateInputType("month", MONTH_REGEXP, createDateParser(MONTH_REGEXP, [ "yyyy", "MM" ]), "yyyy-MM"),
        number: numberInputType,
        url: urlInputType,
        email: emailInputType,
        radio: radioInputType,
        range: rangeInputType,
        checkbox: checkboxInputType,
        hidden: noop,
        button: noop,
        submit: noop,
        reset: noop,
        file: noop
    };
    function stringBasedInputType(ctrl) {
        ctrl.$formatters.push(function(value) {
            return ctrl.$isEmpty(value) ? value : value.toString();
        });
    }
    function textInputType(scope, element, attr, ctrl, $sniffer, $browser) {
        baseInputType(scope, element, attr, ctrl, $sniffer, $browser);
        stringBasedInputType(ctrl);
    }
    function baseInputType(scope, element, attr, ctrl, $sniffer, $browser) {
        var type = lowercase(element[0].type);
        if (!$sniffer.android) {
            var composing = false;
            element.on("compositionstart", function() {
                composing = true;
            });
            element.on("compositionend", function() {
                composing = false;
                listener();
            });
        }
        var timeout;
        var listener = function(ev) {
            if (timeout) {
                $browser.defer.cancel(timeout);
                timeout = null;
            }
            if (composing) return;
            var value = element.val(), event = ev && ev.type;
            if (type !== "password" && (!attr.ngTrim || attr.ngTrim !== "false")) {
                value = trim(value);
            }
            if (ctrl.$viewValue !== value || value === "" && ctrl.$$hasNativeValidators) {
                ctrl.$setViewValue(value, event);
            }
        };
        if ($sniffer.hasEvent("input")) {
            element.on("input", listener);
        } else {
            var deferListener = function(ev, input, origValue) {
                if (!timeout) {
                    timeout = $browser.defer(function() {
                        timeout = null;
                        if (!input || input.value !== origValue) {
                            listener(ev);
                        }
                    });
                }
            };
            element.on("keydown", function(event) {
                var key = event.keyCode;
                if (key === 91 || 15 < key && key < 19 || 37 <= key && key <= 40) return;
                deferListener(event, this, this.value);
            });
            if ($sniffer.hasEvent("paste")) {
                element.on("paste cut", deferListener);
            }
        }
        element.on("change", listener);
        if (PARTIAL_VALIDATION_TYPES[type] && ctrl.$$hasNativeValidators && type === attr.type) {
            element.on(PARTIAL_VALIDATION_EVENTS, function(ev) {
                if (!timeout) {
                    var validity = this[VALIDITY_STATE_PROPERTY];
                    var origBadInput = validity.badInput;
                    var origTypeMismatch = validity.typeMismatch;
                    timeout = $browser.defer(function() {
                        timeout = null;
                        if (validity.badInput !== origBadInput || validity.typeMismatch !== origTypeMismatch) {
                            listener(ev);
                        }
                    });
                }
            });
        }
        ctrl.$render = function() {
            var value = ctrl.$isEmpty(ctrl.$viewValue) ? "" : ctrl.$viewValue;
            if (element.val() !== value) {
                element.val(value);
            }
        };
    }
    function weekParser(isoWeek, existingDate) {
        if (isDate(isoWeek)) {
            return isoWeek;
        }
        if (isString(isoWeek)) {
            WEEK_REGEXP.lastIndex = 0;
            var parts = WEEK_REGEXP.exec(isoWeek);
            if (parts) {
                var year = +parts[1], week = +parts[2], hours = 0, minutes = 0, seconds = 0, milliseconds = 0, firstThurs = getFirstThursdayOfYear(year), addDays = (week - 1) * 7;
                if (existingDate) {
                    hours = existingDate.getHours();
                    minutes = existingDate.getMinutes();
                    seconds = existingDate.getSeconds();
                    milliseconds = existingDate.getMilliseconds();
                }
                return new Date(year, 0, firstThurs.getDate() + addDays, hours, minutes, seconds, milliseconds);
            }
        }
        return NaN;
    }
    function createDateParser(regexp, mapping) {
        return function(iso, date) {
            var parts, map;
            if (isDate(iso)) {
                return iso;
            }
            if (isString(iso)) {
                if (iso.charAt(0) === '"' && iso.charAt(iso.length - 1) === '"') {
                    iso = iso.substring(1, iso.length - 1);
                }
                if (ISO_DATE_REGEXP.test(iso)) {
                    return new Date(iso);
                }
                regexp.lastIndex = 0;
                parts = regexp.exec(iso);
                if (parts) {
                    parts.shift();
                    if (date) {
                        map = {
                            yyyy: date.getFullYear(),
                            MM: date.getMonth() + 1,
                            dd: date.getDate(),
                            HH: date.getHours(),
                            mm: date.getMinutes(),
                            ss: date.getSeconds(),
                            sss: date.getMilliseconds() / 1e3
                        };
                    } else {
                        map = {
                            yyyy: 1970,
                            MM: 1,
                            dd: 1,
                            HH: 0,
                            mm: 0,
                            ss: 0,
                            sss: 0
                        };
                    }
                    forEach(parts, function(part, index) {
                        if (index < mapping.length) {
                            map[mapping[index]] = +part;
                        }
                    });
                    return new Date(map.yyyy, map.MM - 1, map.dd, map.HH, map.mm, map.ss || 0, map.sss * 1e3 || 0);
                }
            }
            return NaN;
        };
    }
    function createDateInputType(type, regexp, parseDate, format) {
        return function dynamicDateInputType(scope, element, attr, ctrl, $sniffer, $browser, $filter) {
            badInputChecker(scope, element, attr, ctrl);
            baseInputType(scope, element, attr, ctrl, $sniffer, $browser);
            var timezone = ctrl && ctrl.$options && ctrl.$options.timezone;
            var previousDate;
            ctrl.$$parserName = type;
            ctrl.$parsers.push(function(value) {
                if (ctrl.$isEmpty(value)) return null;
                if (regexp.test(value)) {
                    var parsedDate = parseDate(value, previousDate);
                    if (timezone) {
                        parsedDate = convertTimezoneToLocal(parsedDate, timezone);
                    }
                    return parsedDate;
                }
                return undefined;
            });
            ctrl.$formatters.push(function(value) {
                if (value && !isDate(value)) {
                    throw ngModelMinErr("datefmt", "Expected `{0}` to be a date", value);
                }
                if (isValidDate(value)) {
                    previousDate = value;
                    if (previousDate && timezone) {
                        previousDate = convertTimezoneToLocal(previousDate, timezone, true);
                    }
                    return $filter("date")(value, format, timezone);
                } else {
                    previousDate = null;
                    return "";
                }
            });
            if (isDefined(attr.min) || attr.ngMin) {
                var minVal;
                ctrl.$validators.min = function(value) {
                    return !isValidDate(value) || isUndefined(minVal) || parseDate(value) >= minVal;
                };
                attr.$observe("min", function(val) {
                    minVal = parseObservedDateValue(val);
                    ctrl.$validate();
                });
            }
            if (isDefined(attr.max) || attr.ngMax) {
                var maxVal;
                ctrl.$validators.max = function(value) {
                    return !isValidDate(value) || isUndefined(maxVal) || parseDate(value) <= maxVal;
                };
                attr.$observe("max", function(val) {
                    maxVal = parseObservedDateValue(val);
                    ctrl.$validate();
                });
            }
            function isValidDate(value) {
                return value && !(value.getTime && value.getTime() !== value.getTime());
            }
            function parseObservedDateValue(val) {
                return isDefined(val) && !isDate(val) ? parseDate(val) || undefined : val;
            }
        };
    }
    function badInputChecker(scope, element, attr, ctrl) {
        var node = element[0];
        var nativeValidation = ctrl.$$hasNativeValidators = isObject(node.validity);
        if (nativeValidation) {
            ctrl.$parsers.push(function(value) {
                var validity = element.prop(VALIDITY_STATE_PROPERTY) || {};
                return validity.badInput || validity.typeMismatch ? undefined : value;
            });
        }
    }
    function numberFormatterParser(ctrl) {
        ctrl.$$parserName = "number";
        ctrl.$parsers.push(function(value) {
            if (ctrl.$isEmpty(value)) return null;
            if (NUMBER_REGEXP.test(value)) return parseFloat(value);
            return undefined;
        });
        ctrl.$formatters.push(function(value) {
            if (!ctrl.$isEmpty(value)) {
                if (!isNumber(value)) {
                    throw ngModelMinErr("numfmt", "Expected `{0}` to be a number", value);
                }
                value = value.toString();
            }
            return value;
        });
    }
    function parseNumberAttrVal(val) {
        if (isDefined(val) && !isNumber(val)) {
            val = parseFloat(val);
        }
        return !isNumberNaN(val) ? val : undefined;
    }
    function isNumberInteger(num) {
        return (num | 0) === num;
    }
    function countDecimals(num) {
        var numString = num.toString();
        var decimalSymbolIndex = numString.indexOf(".");
        if (decimalSymbolIndex === -1) {
            if (-1 < num && num < 1) {
                var match = /e-(\d+)$/.exec(numString);
                if (match) {
                    return Number(match[1]);
                }
            }
            return 0;
        }
        return numString.length - decimalSymbolIndex - 1;
    }
    function isValidForStep(viewValue, stepBase, step) {
        var value = Number(viewValue);
        if (!isNumberInteger(value) || !isNumberInteger(stepBase) || !isNumberInteger(step)) {
            var decimalCount = Math.max(countDecimals(value), countDecimals(stepBase), countDecimals(step));
            var multiplier = Math.pow(10, decimalCount);
            value = value * multiplier;
            stepBase = stepBase * multiplier;
            step = step * multiplier;
        }
        return (value - stepBase) % step === 0;
    }
    function numberInputType(scope, element, attr, ctrl, $sniffer, $browser) {
        badInputChecker(scope, element, attr, ctrl);
        baseInputType(scope, element, attr, ctrl, $sniffer, $browser);
        numberFormatterParser(ctrl);
        var minVal;
        var maxVal;
        if (isDefined(attr.min) || attr.ngMin) {
            ctrl.$validators.min = function(value) {
                return ctrl.$isEmpty(value) || isUndefined(minVal) || value >= minVal;
            };
            attr.$observe("min", function(val) {
                minVal = parseNumberAttrVal(val);
                ctrl.$validate();
            });
        }
        if (isDefined(attr.max) || attr.ngMax) {
            ctrl.$validators.max = function(value) {
                return ctrl.$isEmpty(value) || isUndefined(maxVal) || value <= maxVal;
            };
            attr.$observe("max", function(val) {
                maxVal = parseNumberAttrVal(val);
                ctrl.$validate();
            });
        }
    }
    function rangeInputType(scope, element, attr, ctrl, $sniffer, $browser) {
        badInputChecker(scope, element, attr, ctrl);
        numberFormatterParser(ctrl);
        baseInputType(scope, element, attr, ctrl, $sniffer, $browser);
        var supportsRange = ctrl.$$hasNativeValidators && element[0].type === "range", minVal = supportsRange ? 0 : undefined, maxVal = supportsRange ? 100 : undefined, stepVal = supportsRange ? 1 : undefined, validity = element[0].validity, hasMinAttr = isDefined(attr.min), hasMaxAttr = isDefined(attr.max), hasStepAttr = isDefined(attr.step);
        var originalRender = ctrl.$render;
        ctrl.$render = supportsRange && isDefined(validity.rangeUnderflow) && isDefined(validity.rangeOverflow) ? function rangeRender() {
            originalRender();
            ctrl.$setViewValue(element.val());
        } : originalRender;
        if (hasMinAttr) {
            ctrl.$validators.min = supportsRange ? function noopMinValidator() {
                return true;
            } : function minValidator(modelValue, viewValue) {
                return ctrl.$isEmpty(viewValue) || isUndefined(minVal) || viewValue >= minVal;
            };
            setInitialValueAndObserver("min", minChange);
        }
        if (hasMaxAttr) {
            ctrl.$validators.max = supportsRange ? function noopMaxValidator() {
                return true;
            } : function maxValidator(modelValue, viewValue) {
                return ctrl.$isEmpty(viewValue) || isUndefined(maxVal) || viewValue <= maxVal;
            };
            setInitialValueAndObserver("max", maxChange);
        }
        if (hasStepAttr) {
            ctrl.$validators.step = supportsRange ? function nativeStepValidator() {
                return !validity.stepMismatch;
            } : function stepValidator(modelValue, viewValue) {
                return ctrl.$isEmpty(viewValue) || isUndefined(stepVal) || isValidForStep(viewValue, minVal || 0, stepVal);
            };
            setInitialValueAndObserver("step", stepChange);
        }
        function setInitialValueAndObserver(htmlAttrName, changeFn) {
            element.attr(htmlAttrName, attr[htmlAttrName]);
            attr.$observe(htmlAttrName, changeFn);
        }
        function minChange(val) {
            minVal = parseNumberAttrVal(val);
            if (isNumberNaN(ctrl.$modelValue)) {
                return;
            }
            if (supportsRange) {
                var elVal = element.val();
                if (minVal > elVal) {
                    elVal = minVal;
                    element.val(elVal);
                }
                ctrl.$setViewValue(elVal);
            } else {
                ctrl.$validate();
            }
        }
        function maxChange(val) {
            maxVal = parseNumberAttrVal(val);
            if (isNumberNaN(ctrl.$modelValue)) {
                return;
            }
            if (supportsRange) {
                var elVal = element.val();
                if (maxVal < elVal) {
                    element.val(maxVal);
                    elVal = maxVal < minVal ? minVal : maxVal;
                }
                ctrl.$setViewValue(elVal);
            } else {
                ctrl.$validate();
            }
        }
        function stepChange(val) {
            stepVal = parseNumberAttrVal(val);
            if (isNumberNaN(ctrl.$modelValue)) {
                return;
            }
            if (supportsRange && ctrl.$viewValue !== element.val()) {
                ctrl.$setViewValue(element.val());
            } else {
                ctrl.$validate();
            }
        }
    }
    function urlInputType(scope, element, attr, ctrl, $sniffer, $browser) {
        baseInputType(scope, element, attr, ctrl, $sniffer, $browser);
        stringBasedInputType(ctrl);
        ctrl.$$parserName = "url";
        ctrl.$validators.url = function(modelValue, viewValue) {
            var value = modelValue || viewValue;
            return ctrl.$isEmpty(value) || URL_REGEXP.test(value);
        };
    }
    function emailInputType(scope, element, attr, ctrl, $sniffer, $browser) {
        baseInputType(scope, element, attr, ctrl, $sniffer, $browser);
        stringBasedInputType(ctrl);
        ctrl.$$parserName = "email";
        ctrl.$validators.email = function(modelValue, viewValue) {
            var value = modelValue || viewValue;
            return ctrl.$isEmpty(value) || EMAIL_REGEXP.test(value);
        };
    }
    function radioInputType(scope, element, attr, ctrl) {
        if (isUndefined(attr.name)) {
            element.attr("name", nextUid());
        }
        var listener = function(ev) {
            if (element[0].checked) {
                ctrl.$setViewValue(attr.value, ev && ev.type);
            }
        };
        element.on("click", listener);
        ctrl.$render = function() {
            var value = attr.value;
            element[0].checked = value == ctrl.$viewValue;
        };
        attr.$observe("value", ctrl.$render);
    }
    function parseConstantExpr($parse, context, name, expression, fallback) {
        var parseFn;
        if (isDefined(expression)) {
            parseFn = $parse(expression);
            if (!parseFn.constant) {
                throw ngModelMinErr("constexpr", "Expected constant expression for `{0}`, but saw " + "`{1}`.", name, expression);
            }
            return parseFn(context);
        }
        return fallback;
    }
    function checkboxInputType(scope, element, attr, ctrl, $sniffer, $browser, $filter, $parse) {
        var trueValue = parseConstantExpr($parse, scope, "ngTrueValue", attr.ngTrueValue, true);
        var falseValue = parseConstantExpr($parse, scope, "ngFalseValue", attr.ngFalseValue, false);
        var listener = function(ev) {
            ctrl.$setViewValue(element[0].checked, ev && ev.type);
        };
        element.on("click", listener);
        ctrl.$render = function() {
            element[0].checked = ctrl.$viewValue;
        };
        ctrl.$isEmpty = function(value) {
            return value === false;
        };
        ctrl.$formatters.push(function(value) {
            return equals(value, trueValue);
        });
        ctrl.$parsers.push(function(value) {
            return value ? trueValue : falseValue;
        });
    }
    var inputDirective = [ "$browser", "$sniffer", "$filter", "$parse", function($browser, $sniffer, $filter, $parse) {
        return {
            restrict: "E",
            require: [ "?ngModel" ],
            link: {
                pre: function(scope, element, attr, ctrls) {
                    if (ctrls[0]) {
                        var type = lowercase(attr.type);
                        if (type === "range" && !attr.hasOwnProperty("ngInputRange")) {
                            type = "text";
                        }
                        (inputType[type] || inputType.text)(scope, element, attr, ctrls[0], $sniffer, $browser, $filter, $parse);
                    }
                }
            }
        };
    } ];
    var CONSTANT_VALUE_REGEXP = /^(true|false|\d+)$/;
    var ngValueDirective = function() {
        return {
            restrict: "A",
            priority: 100,
            compile: function(tpl, tplAttr) {
                if (CONSTANT_VALUE_REGEXP.test(tplAttr.ngValue)) {
                    return function ngValueConstantLink(scope, elm, attr) {
                        attr.$set("value", scope.$eval(attr.ngValue));
                    };
                } else {
                    return function ngValueLink(scope, elm, attr) {
                        scope.$watch(attr.ngValue, function valueWatchAction(value) {
                            attr.$set("value", value);
                        });
                    };
                }
            }
        };
    };
    var ngBindDirective = [ "$compile", function($compile) {
        return {
            restrict: "AC",
            compile: function ngBindCompile(templateElement) {
                $compile.$$addBindingClass(templateElement);
                return function ngBindLink(scope, element, attr) {
                    $compile.$$addBindingInfo(element, attr.ngBind);
                    element = element[0];
                    scope.$watch(attr.ngBind, function ngBindWatchAction(value) {
                        element.textContent = isUndefined(value) ? "" : value;
                    });
                };
            }
        };
    } ];
    var ngBindTemplateDirective = [ "$interpolate", "$compile", function($interpolate, $compile) {
        return {
            compile: function ngBindTemplateCompile(templateElement) {
                $compile.$$addBindingClass(templateElement);
                return function ngBindTemplateLink(scope, element, attr) {
                    var interpolateFn = $interpolate(element.attr(attr.$attr.ngBindTemplate));
                    $compile.$$addBindingInfo(element, interpolateFn.expressions);
                    element = element[0];
                    attr.$observe("ngBindTemplate", function(value) {
                        element.textContent = isUndefined(value) ? "" : value;
                    });
                };
            }
        };
    } ];
    var ngBindHtmlDirective = [ "$sce", "$parse", "$compile", function($sce, $parse, $compile) {
        return {
            restrict: "A",
            compile: function ngBindHtmlCompile(tElement, tAttrs) {
                var ngBindHtmlGetter = $parse(tAttrs.ngBindHtml);
                var ngBindHtmlWatch = $parse(tAttrs.ngBindHtml, function sceValueOf(val) {
                    return $sce.valueOf(val);
                });
                $compile.$$addBindingClass(tElement);
                return function ngBindHtmlLink(scope, element, attr) {
                    $compile.$$addBindingInfo(element, attr.ngBindHtml);
                    scope.$watch(ngBindHtmlWatch, function ngBindHtmlWatchAction() {
                        var value = ngBindHtmlGetter(scope);
                        element.html($sce.getTrustedHtml(value) || "");
                    });
                };
            }
        };
    } ];
    var ngChangeDirective = valueFn({
        restrict: "A",
        require: "ngModel",
        link: function(scope, element, attr, ctrl) {
            ctrl.$viewChangeListeners.push(function() {
                scope.$eval(attr.ngChange);
            });
        }
    });
    function classDirective(name, selector) {
        name = "ngClass" + name;
        return [ "$animate", function($animate) {
            return {
                restrict: "AC",
                link: function(scope, element, attr) {
                    var oldVal;
                    attr.$observe("class", function(value) {
                        ngClassWatchAction(scope.$eval(attr[name]));
                    });
                    if (name !== "ngClass") {
                        scope.$watch("$index", function($index, old$index) {
                            var mod = $index & 1;
                            if (mod !== (old$index & 1)) {
                                var classes = arrayClasses(oldVal);
                                if (mod === selector) {
                                    addClasses(classes);
                                } else {
                                    removeClasses(classes);
                                }
                            }
                        });
                    }
                    scope.$watch(attr[name], ngClassWatchAction, true);
                    function addClasses(classes) {
                        var newClasses = digestClassCounts(classes, 1);
                        attr.$addClass(newClasses);
                    }
                    function removeClasses(classes) {
                        var newClasses = digestClassCounts(classes, -1);
                        attr.$removeClass(newClasses);
                    }
                    function digestClassCounts(classes, count) {
                        var classCounts = element.data("$classCounts") || createMap();
                        var classesToUpdate = [];
                        forEach(classes, function(className) {
                            if (count > 0 || classCounts[className]) {
                                classCounts[className] = (classCounts[className] || 0) + count;
                                if (classCounts[className] === +(count > 0)) {
                                    classesToUpdate.push(className);
                                }
                            }
                        });
                        element.data("$classCounts", classCounts);
                        return classesToUpdate.join(" ");
                    }
                    function updateClasses(oldClasses, newClasses) {
                        var toAdd = arrayDifference(newClasses, oldClasses);
                        var toRemove = arrayDifference(oldClasses, newClasses);
                        toAdd = digestClassCounts(toAdd, 1);
                        toRemove = digestClassCounts(toRemove, -1);
                        if (toAdd && toAdd.length) {
                            $animate.addClass(element, toAdd);
                        }
                        if (toRemove && toRemove.length) {
                            $animate.removeClass(element, toRemove);
                        }
                    }
                    function ngClassWatchAction(newVal) {
                        if (selector === true || (scope.$index & 1) === selector) {
                            var newClasses = arrayClasses(newVal || []);
                            if (!oldVal) {
                                addClasses(newClasses);
                            } else if (!equals(newVal, oldVal)) {
                                var oldClasses = arrayClasses(oldVal);
                                updateClasses(oldClasses, newClasses);
                            }
                        }
                        if (isArray(newVal)) {
                            oldVal = newVal.map(function(v) {
                                return shallowCopy(v);
                            });
                        } else {
                            oldVal = shallowCopy(newVal);
                        }
                    }
                }
            };
            function arrayDifference(tokens1, tokens2) {
                var values = [];
                outer: for (var i = 0; i < tokens1.length; i++) {
                    var token = tokens1[i];
                    for (var j = 0; j < tokens2.length; j++) {
                        if (token === tokens2[j]) continue outer;
                    }
                    values.push(token);
                }
                return values;
            }
            function arrayClasses(classVal) {
                var classes = [];
                if (isArray(classVal)) {
                    forEach(classVal, function(v) {
                        classes = classes.concat(arrayClasses(v));
                    });
                    return classes;
                } else if (isString(classVal)) {
                    return classVal.split(" ");
                } else if (isObject(classVal)) {
                    forEach(classVal, function(v, k) {
                        if (v) {
                            classes = classes.concat(k.split(" "));
                        }
                    });
                    return classes;
                }
                return classVal;
            }
        } ];
    }
    var ngClassDirective = classDirective("", true);
    var ngClassOddDirective = classDirective("Odd", 0);
    var ngClassEvenDirective = classDirective("Even", 1);
    var ngCloakDirective = ngDirective({
        compile: function(element, attr) {
            attr.$set("ngCloak", undefined);
            element.removeClass("ng-cloak");
        }
    });
    var ngControllerDirective = [ function() {
        return {
            restrict: "A",
            scope: true,
            controller: "@",
            priority: 500
        };
    } ];
    var ngEventDirectives = {};
    var forceAsyncEvents = {
        blur: true,
        focus: true
    };
    forEach("click dblclick mousedown mouseup mouseover mouseout mousemove mouseenter mouseleave keydown keyup keypress submit focus blur copy cut paste".split(" "), function(eventName) {
        var directiveName = directiveNormalize("ng-" + eventName);
        ngEventDirectives[directiveName] = [ "$parse", "$rootScope", function($parse, $rootScope) {
            return {
                restrict: "A",
                compile: function($element, attr) {
                    var fn = $parse(attr[directiveName], null, true);
                    return function ngEventHandler(scope, element) {
                        element.on(eventName, function(event) {
                            var callback = function() {
                                fn(scope, {
                                    $event: event
                                });
                            };
                            if (forceAsyncEvents[eventName] && $rootScope.$$phase) {
                                scope.$evalAsync(callback);
                            } else {
                                scope.$apply(callback);
                            }
                        });
                    };
                }
            };
        } ];
    });
    var ngIfDirective = [ "$animate", "$compile", function($animate, $compile) {
        return {
            multiElement: true,
            transclude: "element",
            priority: 600,
            terminal: true,
            restrict: "A",
            $$tlb: true,
            link: function($scope, $element, $attr, ctrl, $transclude) {
                var block, childScope, previousElements;
                $scope.$watch($attr.ngIf, function ngIfWatchAction(value) {
                    if (value) {
                        if (!childScope) {
                            $transclude(function(clone, newScope) {
                                childScope = newScope;
                                clone[clone.length++] = $compile.$$createComment("end ngIf", $attr.ngIf);
                                block = {
                                    clone: clone
                                };
                                $animate.enter(clone, $element.parent(), $element);
                            });
                        }
                    } else {
                        if (previousElements) {
                            previousElements.remove();
                            previousElements = null;
                        }
                        if (childScope) {
                            childScope.$destroy();
                            childScope = null;
                        }
                        if (block) {
                            previousElements = getBlockNodes(block.clone);
                            $animate.leave(previousElements).done(function(response) {
                                if (response !== false) previousElements = null;
                            });
                            block = null;
                        }
                    }
                });
            }
        };
    } ];
    var ngIncludeDirective = [ "$templateRequest", "$anchorScroll", "$animate", function($templateRequest, $anchorScroll, $animate) {
        return {
            restrict: "ECA",
            priority: 400,
            terminal: true,
            transclude: "element",
            controller: angular.noop,
            compile: function(element, attr) {
                var srcExp = attr.ngInclude || attr.src, onloadExp = attr.onload || "", autoScrollExp = attr.autoscroll;
                return function(scope, $element, $attr, ctrl, $transclude) {
                    var changeCounter = 0, currentScope, previousElement, currentElement;
                    var cleanupLastIncludeContent = function() {
                        if (previousElement) {
                            previousElement.remove();
                            previousElement = null;
                        }
                        if (currentScope) {
                            currentScope.$destroy();
                            currentScope = null;
                        }
                        if (currentElement) {
                            $animate.leave(currentElement).done(function(response) {
                                if (response !== false) previousElement = null;
                            });
                            previousElement = currentElement;
                            currentElement = null;
                        }
                    };
                    scope.$watch(srcExp, function ngIncludeWatchAction(src) {
                        var afterAnimation = function(response) {
                            if (response !== false && isDefined(autoScrollExp) && (!autoScrollExp || scope.$eval(autoScrollExp))) {
                                $anchorScroll();
                            }
                        };
                        var thisChangeId = ++changeCounter;
                        if (src) {
                            $templateRequest(src, true).then(function(response) {
                                if (scope.$$destroyed) return;
                                if (thisChangeId !== changeCounter) return;
                                var newScope = scope.$new();
                                ctrl.template = response;
                                var clone = $transclude(newScope, function(clone) {
                                    cleanupLastIncludeContent();
                                    $animate.enter(clone, null, $element).done(afterAnimation);
                                });
                                currentScope = newScope;
                                currentElement = clone;
                                currentScope.$emit("$includeContentLoaded", src);
                                scope.$eval(onloadExp);
                            }, function() {
                                if (scope.$$destroyed) return;
                                if (thisChangeId === changeCounter) {
                                    cleanupLastIncludeContent();
                                    scope.$emit("$includeContentError", src);
                                }
                            });
                            scope.$emit("$includeContentRequested", src);
                        } else {
                            cleanupLastIncludeContent();
                            ctrl.template = null;
                        }
                    });
                };
            }
        };
    } ];
    var ngIncludeFillContentDirective = [ "$compile", function($compile) {
        return {
            restrict: "ECA",
            priority: -400,
            require: "ngInclude",
            link: function(scope, $element, $attr, ctrl) {
                if (toString.call($element[0]).match(/SVG/)) {
                    $element.empty();
                    $compile(jqLiteBuildFragment(ctrl.template, window.document).childNodes)(scope, function namespaceAdaptedClone(clone) {
                        $element.append(clone);
                    }, {
                        futureParentElement: $element
                    });
                    return;
                }
                $element.html(ctrl.template);
                $compile($element.contents())(scope);
            }
        };
    } ];
    var ngInitDirective = ngDirective({
        priority: 450,
        compile: function() {
            return {
                pre: function(scope, element, attrs) {
                    scope.$eval(attrs.ngInit);
                }
            };
        }
    });
    var ngListDirective = function() {
        return {
            restrict: "A",
            priority: 100,
            require: "ngModel",
            link: function(scope, element, attr, ctrl) {
                var ngList = element.attr(attr.$attr.ngList) || ", ";
                var trimValues = attr.ngTrim !== "false";
                var separator = trimValues ? trim(ngList) : ngList;
                var parse = function(viewValue) {
                    if (isUndefined(viewValue)) return;
                    var list = [];
                    if (viewValue) {
                        forEach(viewValue.split(separator), function(value) {
                            if (value) list.push(trimValues ? trim(value) : value);
                        });
                    }
                    return list;
                };
                ctrl.$parsers.push(parse);
                ctrl.$formatters.push(function(value) {
                    if (isArray(value)) {
                        return value.join(ngList);
                    }
                    return undefined;
                });
                ctrl.$isEmpty = function(value) {
                    return !value || !value.length;
                };
            }
        };
    };
    var VALID_CLASS = "ng-valid", INVALID_CLASS = "ng-invalid", PRISTINE_CLASS = "ng-pristine", DIRTY_CLASS = "ng-dirty", UNTOUCHED_CLASS = "ng-untouched", TOUCHED_CLASS = "ng-touched", PENDING_CLASS = "ng-pending", EMPTY_CLASS = "ng-empty", NOT_EMPTY_CLASS = "ng-not-empty";
    var ngModelMinErr = minErr("ngModel");
    var NgModelController = [ "$scope", "$exceptionHandler", "$attrs", "$element", "$parse", "$animate", "$timeout", "$rootScope", "$q", "$interpolate", function($scope, $exceptionHandler, $attr, $element, $parse, $animate, $timeout, $rootScope, $q, $interpolate) {
        this.$viewValue = Number.NaN;
        this.$modelValue = Number.NaN;
        this.$$rawModelValue = undefined;
        this.$validators = {};
        this.$asyncValidators = {};
        this.$parsers = [];
        this.$formatters = [];
        this.$viewChangeListeners = [];
        this.$untouched = true;
        this.$touched = false;
        this.$pristine = true;
        this.$dirty = false;
        this.$valid = true;
        this.$invalid = false;
        this.$error = {};
        this.$$success = {};
        this.$pending = undefined;
        this.$name = $interpolate($attr.name || "", false)($scope);
        this.$$parentForm = nullFormCtrl;
        var parsedNgModel = $parse($attr.ngModel), parsedNgModelAssign = parsedNgModel.assign, ngModelGet = parsedNgModel, ngModelSet = parsedNgModelAssign, pendingDebounce = null, parserValid, ctrl = this;
        this.$$setOptions = function(options) {
            ctrl.$options = options;
            if (options && options.getterSetter) {
                var invokeModelGetter = $parse($attr.ngModel + "()"), invokeModelSetter = $parse($attr.ngModel + "($$$p)");
                ngModelGet = function($scope) {
                    var modelValue = parsedNgModel($scope);
                    if (isFunction(modelValue)) {
                        modelValue = invokeModelGetter($scope);
                    }
                    return modelValue;
                };
                ngModelSet = function($scope, newValue) {
                    if (isFunction(parsedNgModel($scope))) {
                        invokeModelSetter($scope, {
                            $$$p: newValue
                        });
                    } else {
                        parsedNgModelAssign($scope, newValue);
                    }
                };
            } else if (!parsedNgModel.assign) {
                throw ngModelMinErr("nonassign", "Expression '{0}' is non-assignable. Element: {1}", $attr.ngModel, startingTag($element));
            }
        };
        this.$render = noop;
        this.$isEmpty = function(value) {
            return isUndefined(value) || value === "" || value === null || value !== value;
        };
        this.$$updateEmptyClasses = function(value) {
            if (ctrl.$isEmpty(value)) {
                $animate.removeClass($element, NOT_EMPTY_CLASS);
                $animate.addClass($element, EMPTY_CLASS);
            } else {
                $animate.removeClass($element, EMPTY_CLASS);
                $animate.addClass($element, NOT_EMPTY_CLASS);
            }
        };
        var currentValidationRunId = 0;
        addSetValidityMethod({
            ctrl: this,
            $element: $element,
            set: function(object, property) {
                object[property] = true;
            },
            unset: function(object, property) {
                delete object[property];
            },
            $animate: $animate
        });
        this.$setPristine = function() {
            ctrl.$dirty = false;
            ctrl.$pristine = true;
            $animate.removeClass($element, DIRTY_CLASS);
            $animate.addClass($element, PRISTINE_CLASS);
        };
        this.$setDirty = function() {
            ctrl.$dirty = true;
            ctrl.$pristine = false;
            $animate.removeClass($element, PRISTINE_CLASS);
            $animate.addClass($element, DIRTY_CLASS);
            ctrl.$$parentForm.$setDirty();
        };
        this.$setUntouched = function() {
            ctrl.$touched = false;
            ctrl.$untouched = true;
            $animate.setClass($element, UNTOUCHED_CLASS, TOUCHED_CLASS);
        };
        this.$setTouched = function() {
            ctrl.$touched = true;
            ctrl.$untouched = false;
            $animate.setClass($element, TOUCHED_CLASS, UNTOUCHED_CLASS);
        };
        this.$rollbackViewValue = function() {
            $timeout.cancel(pendingDebounce);
            ctrl.$viewValue = ctrl.$$lastCommittedViewValue;
            ctrl.$render();
        };
        this.$validate = function() {
            if (isNumberNaN(ctrl.$modelValue)) {
                return;
            }
            var viewValue = ctrl.$$lastCommittedViewValue;
            var modelValue = ctrl.$$rawModelValue;
            var prevValid = ctrl.$valid;
            var prevModelValue = ctrl.$modelValue;
            var allowInvalid = ctrl.$options && ctrl.$options.allowInvalid;
            ctrl.$$runValidators(modelValue, viewValue, function(allValid) {
                if (!allowInvalid && prevValid !== allValid) {
                    ctrl.$modelValue = allValid ? modelValue : undefined;
                    if (ctrl.$modelValue !== prevModelValue) {
                        ctrl.$$writeModelToScope();
                    }
                }
            });
        };
        this.$$runValidators = function(modelValue, viewValue, doneCallback) {
            currentValidationRunId++;
            var localValidationRunId = currentValidationRunId;
            if (!processParseErrors()) {
                validationDone(false);
                return;
            }
            if (!processSyncValidators()) {
                validationDone(false);
                return;
            }
            processAsyncValidators();
            function processParseErrors() {
                var errorKey = ctrl.$$parserName || "parse";
                if (isUndefined(parserValid)) {
                    setValidity(errorKey, null);
                } else {
                    if (!parserValid) {
                        forEach(ctrl.$validators, function(v, name) {
                            setValidity(name, null);
                        });
                        forEach(ctrl.$asyncValidators, function(v, name) {
                            setValidity(name, null);
                        });
                    }
                    setValidity(errorKey, parserValid);
                    return parserValid;
                }
                return true;
            }
            function processSyncValidators() {
                var syncValidatorsValid = true;
                forEach(ctrl.$validators, function(validator, name) {
                    var result = validator(modelValue, viewValue);
                    syncValidatorsValid = syncValidatorsValid && result;
                    setValidity(name, result);
                });
                if (!syncValidatorsValid) {
                    forEach(ctrl.$asyncValidators, function(v, name) {
                        setValidity(name, null);
                    });
                    return false;
                }
                return true;
            }
            function processAsyncValidators() {
                var validatorPromises = [];
                var allValid = true;
                forEach(ctrl.$asyncValidators, function(validator, name) {
                    var promise = validator(modelValue, viewValue);
                    if (!isPromiseLike(promise)) {
                        throw ngModelMinErr("nopromise", "Expected asynchronous validator to return a promise but got '{0}' instead.", promise);
                    }
                    setValidity(name, undefined);
                    validatorPromises.push(promise.then(function() {
                        setValidity(name, true);
                    }, function() {
                        allValid = false;
                        setValidity(name, false);
                    }));
                });
                if (!validatorPromises.length) {
                    validationDone(true);
                } else {
                    $q.all(validatorPromises).then(function() {
                        validationDone(allValid);
                    }, noop);
                }
            }
            function setValidity(name, isValid) {
                if (localValidationRunId === currentValidationRunId) {
                    ctrl.$setValidity(name, isValid);
                }
            }
            function validationDone(allValid) {
                if (localValidationRunId === currentValidationRunId) {
                    doneCallback(allValid);
                }
            }
        };
        this.$commitViewValue = function() {
            var viewValue = ctrl.$viewValue;
            $timeout.cancel(pendingDebounce);
            if (ctrl.$$lastCommittedViewValue === viewValue && (viewValue !== "" || !ctrl.$$hasNativeValidators)) {
                return;
            }
            ctrl.$$updateEmptyClasses(viewValue);
            ctrl.$$lastCommittedViewValue = viewValue;
            if (ctrl.$pristine) {
                this.$setDirty();
            }
            this.$$parseAndValidate();
        };
        this.$$parseAndValidate = function() {
            var viewValue = ctrl.$$lastCommittedViewValue;
            var modelValue = viewValue;
            parserValid = isUndefined(modelValue) ? undefined : true;
            if (parserValid) {
                for (var i = 0; i < ctrl.$parsers.length; i++) {
                    modelValue = ctrl.$parsers[i](modelValue);
                    if (isUndefined(modelValue)) {
                        parserValid = false;
                        break;
                    }
                }
            }
            if (isNumberNaN(ctrl.$modelValue)) {
                ctrl.$modelValue = ngModelGet($scope);
            }
            var prevModelValue = ctrl.$modelValue;
            var allowInvalid = ctrl.$options && ctrl.$options.allowInvalid;
            ctrl.$$rawModelValue = modelValue;
            if (allowInvalid) {
                ctrl.$modelValue = modelValue;
                writeToModelIfNeeded();
            }
            ctrl.$$runValidators(modelValue, ctrl.$$lastCommittedViewValue, function(allValid) {
                if (!allowInvalid) {
                    ctrl.$modelValue = allValid ? modelValue : undefined;
                    writeToModelIfNeeded();
                }
            });
            function writeToModelIfNeeded() {
                if (ctrl.$modelValue !== prevModelValue) {
                    ctrl.$$writeModelToScope();
                }
            }
        };
        this.$$writeModelToScope = function() {
            ngModelSet($scope, ctrl.$modelValue);
            forEach(ctrl.$viewChangeListeners, function(listener) {
                try {
                    listener();
                } catch (e) {
                    $exceptionHandler(e);
                }
            });
        };
        this.$setViewValue = function(value, trigger) {
            ctrl.$viewValue = value;
            if (!ctrl.$options || ctrl.$options.updateOnDefault) {
                ctrl.$$debounceViewValueCommit(trigger);
            }
        };
        this.$$debounceViewValueCommit = function(trigger) {
            var debounceDelay = 0, options = ctrl.$options, debounce;
            if (options && isDefined(options.debounce)) {
                debounce = options.debounce;
                if (isNumber(debounce)) {
                    debounceDelay = debounce;
                } else if (isNumber(debounce[trigger])) {
                    debounceDelay = debounce[trigger];
                } else if (isNumber(debounce["default"])) {
                    debounceDelay = debounce["default"];
                }
            }
            $timeout.cancel(pendingDebounce);
            if (debounceDelay) {
                pendingDebounce = $timeout(function() {
                    ctrl.$commitViewValue();
                }, debounceDelay);
            } else if ($rootScope.$$phase) {
                ctrl.$commitViewValue();
            } else {
                $scope.$apply(function() {
                    ctrl.$commitViewValue();
                });
            }
        };
        $scope.$watch(function ngModelWatch() {
            var modelValue = ngModelGet($scope);
            if (modelValue !== ctrl.$modelValue && (ctrl.$modelValue === ctrl.$modelValue || modelValue === modelValue)) {
                ctrl.$modelValue = ctrl.$$rawModelValue = modelValue;
                parserValid = undefined;
                var formatters = ctrl.$formatters, idx = formatters.length;
                var viewValue = modelValue;
                while (idx--) {
                    viewValue = formatters[idx](viewValue);
                }
                if (ctrl.$viewValue !== viewValue) {
                    ctrl.$$updateEmptyClasses(viewValue);
                    ctrl.$viewValue = ctrl.$$lastCommittedViewValue = viewValue;
                    ctrl.$render();
                    ctrl.$$runValidators(ctrl.$modelValue, ctrl.$viewValue, noop);
                }
            }
            return modelValue;
        });
    } ];
    var ngModelDirective = [ "$rootScope", function($rootScope) {
        return {
            restrict: "A",
            require: [ "ngModel", "^?form", "^?ngModelOptions" ],
            controller: NgModelController,
            priority: 1,
            compile: function ngModelCompile(element) {
                element.addClass(PRISTINE_CLASS).addClass(UNTOUCHED_CLASS).addClass(VALID_CLASS);
                return {
                    pre: function ngModelPreLink(scope, element, attr, ctrls) {
                        var modelCtrl = ctrls[0], formCtrl = ctrls[1] || modelCtrl.$$parentForm;
                        modelCtrl.$$setOptions(ctrls[2] && ctrls[2].$options);
                        formCtrl.$addControl(modelCtrl);
                        attr.$observe("name", function(newValue) {
                            if (modelCtrl.$name !== newValue) {
                                modelCtrl.$$parentForm.$$renameControl(modelCtrl, newValue);
                            }
                        });
                        scope.$on("$destroy", function() {
                            modelCtrl.$$parentForm.$removeControl(modelCtrl);
                        });
                    },
                    post: function ngModelPostLink(scope, element, attr, ctrls) {
                        var modelCtrl = ctrls[0];
                        if (modelCtrl.$options && modelCtrl.$options.updateOn) {
                            element.on(modelCtrl.$options.updateOn, function(ev) {
                                modelCtrl.$$debounceViewValueCommit(ev && ev.type);
                            });
                        }
                        element.on("blur", function() {
                            if (modelCtrl.$touched) return;
                            if ($rootScope.$$phase) {
                                scope.$evalAsync(modelCtrl.$setTouched);
                            } else {
                                scope.$apply(modelCtrl.$setTouched);
                            }
                        });
                    }
                };
            }
        };
    } ];
    var DEFAULT_REGEXP = /(\s+|^)default(\s+|$)/;
    var ngModelOptionsDirective = function() {
        return {
            restrict: "A",
            controller: [ "$scope", "$attrs", function NgModelOptionsController($scope, $attrs) {
                var that = this;
                this.$options = copy($scope.$eval($attrs.ngModelOptions));
                if (isDefined(this.$options.updateOn)) {
                    this.$options.updateOnDefault = false;
                    this.$options.updateOn = trim(this.$options.updateOn.replace(DEFAULT_REGEXP, function() {
                        that.$options.updateOnDefault = true;
                        return " ";
                    }));
                } else {
                    this.$options.updateOnDefault = true;
                }
            } ]
        };
    };
    function addSetValidityMethod(context) {
        var ctrl = context.ctrl, $element = context.$element, classCache = {}, set = context.set, unset = context.unset, $animate = context.$animate;
        classCache[INVALID_CLASS] = !(classCache[VALID_CLASS] = $element.hasClass(VALID_CLASS));
        ctrl.$setValidity = setValidity;
        function setValidity(validationErrorKey, state, controller) {
            if (isUndefined(state)) {
                createAndSet("$pending", validationErrorKey, controller);
            } else {
                unsetAndCleanup("$pending", validationErrorKey, controller);
            }
            if (!isBoolean(state)) {
                unset(ctrl.$error, validationErrorKey, controller);
                unset(ctrl.$$success, validationErrorKey, controller);
            } else {
                if (state) {
                    unset(ctrl.$error, validationErrorKey, controller);
                    set(ctrl.$$success, validationErrorKey, controller);
                } else {
                    set(ctrl.$error, validationErrorKey, controller);
                    unset(ctrl.$$success, validationErrorKey, controller);
                }
            }
            if (ctrl.$pending) {
                cachedToggleClass(PENDING_CLASS, true);
                ctrl.$valid = ctrl.$invalid = undefined;
                toggleValidationCss("", null);
            } else {
                cachedToggleClass(PENDING_CLASS, false);
                ctrl.$valid = isObjectEmpty(ctrl.$error);
                ctrl.$invalid = !ctrl.$valid;
                toggleValidationCss("", ctrl.$valid);
            }
            var combinedState;
            if (ctrl.$pending && ctrl.$pending[validationErrorKey]) {
                combinedState = undefined;
            } else if (ctrl.$error[validationErrorKey]) {
                combinedState = false;
            } else if (ctrl.$$success[validationErrorKey]) {
                combinedState = true;
            } else {
                combinedState = null;
            }
            toggleValidationCss(validationErrorKey, combinedState);
            ctrl.$$parentForm.$setValidity(validationErrorKey, combinedState, ctrl);
        }
        function createAndSet(name, value, controller) {
            if (!ctrl[name]) {
                ctrl[name] = {};
            }
            set(ctrl[name], value, controller);
        }
        function unsetAndCleanup(name, value, controller) {
            if (ctrl[name]) {
                unset(ctrl[name], value, controller);
            }
            if (isObjectEmpty(ctrl[name])) {
                ctrl[name] = undefined;
            }
        }
        function cachedToggleClass(className, switchValue) {
            if (switchValue && !classCache[className]) {
                $animate.addClass($element, className);
                classCache[className] = true;
            } else if (!switchValue && classCache[className]) {
                $animate.removeClass($element, className);
                classCache[className] = false;
            }
        }
        function toggleValidationCss(validationErrorKey, isValid) {
            validationErrorKey = validationErrorKey ? "-" + snake_case(validationErrorKey, "-") : "";
            cachedToggleClass(VALID_CLASS + validationErrorKey, isValid === true);
            cachedToggleClass(INVALID_CLASS + validationErrorKey, isValid === false);
        }
    }
    function isObjectEmpty(obj) {
        if (obj) {
            for (var prop in obj) {
                if (obj.hasOwnProperty(prop)) {
                    return false;
                }
            }
        }
        return true;
    }
    var ngNonBindableDirective = ngDirective({
        terminal: true,
        priority: 1e3
    });
    var ngOptionsMinErr = minErr("ngOptions");
    var NG_OPTIONS_REGEXP = /^\s*([\s\S]+?)(?:\s+as\s+([\s\S]+?))?(?:\s+group\s+by\s+([\s\S]+?))?(?:\s+disable\s+when\s+([\s\S]+?))?\s+for\s+(?:([$\w][$\w]*)|(?:\(\s*([$\w][$\w]*)\s*,\s*([$\w][$\w]*)\s*\)))\s+in\s+([\s\S]+?)(?:\s+track\s+by\s+([\s\S]+?))?$/;
    var ngOptionsDirective = [ "$compile", "$document", "$parse", function($compile, $document, $parse) {
        function parseOptionsExpression(optionsExp, selectElement, scope) {
            var match = optionsExp.match(NG_OPTIONS_REGEXP);
            if (!match) {
                throw ngOptionsMinErr("iexp", "Expected expression in form of " + "'_select_ (as _label_)? for (_key_,)?_value_ in _collection_'" + " but got '{0}'. Element: {1}", optionsExp, startingTag(selectElement));
            }
            var valueName = match[5] || match[7];
            var keyName = match[6];
            var selectAs = / as /.test(match[0]) && match[1];
            var trackBy = match[9];
            var valueFn = $parse(match[2] ? match[1] : valueName);
            var selectAsFn = selectAs && $parse(selectAs);
            var viewValueFn = selectAsFn || valueFn;
            var trackByFn = trackBy && $parse(trackBy);
            var getTrackByValueFn = trackBy ? function(value, locals) {
                return trackByFn(scope, locals);
            } : function getHashOfValue(value) {
                return hashKey(value);
            };
            var getTrackByValue = function(value, key) {
                return getTrackByValueFn(value, getLocals(value, key));
            };
            var displayFn = $parse(match[2] || match[1]);
            var groupByFn = $parse(match[3] || "");
            var disableWhenFn = $parse(match[4] || "");
            var valuesFn = $parse(match[8]);
            var locals = {};
            var getLocals = keyName ? function(value, key) {
                locals[keyName] = key;
                locals[valueName] = value;
                return locals;
            } : function(value) {
                locals[valueName] = value;
                return locals;
            };
            function Option(selectValue, viewValue, label, group, disabled) {
                this.selectValue = selectValue;
                this.viewValue = viewValue;
                this.label = label;
                this.group = group;
                this.disabled = disabled;
            }
            function getOptionValuesKeys(optionValues) {
                var optionValuesKeys;
                if (!keyName && isArrayLike(optionValues)) {
                    optionValuesKeys = optionValues;
                } else {
                    optionValuesKeys = [];
                    for (var itemKey in optionValues) {
                        if (optionValues.hasOwnProperty(itemKey) && itemKey.charAt(0) !== "$") {
                            optionValuesKeys.push(itemKey);
                        }
                    }
                }
                return optionValuesKeys;
            }
            return {
                trackBy: trackBy,
                getTrackByValue: getTrackByValue,
                getWatchables: $parse(valuesFn, function(optionValues) {
                    var watchedArray = [];
                    optionValues = optionValues || [];
                    var optionValuesKeys = getOptionValuesKeys(optionValues);
                    var optionValuesLength = optionValuesKeys.length;
                    for (var index = 0; index < optionValuesLength; index++) {
                        var key = optionValues === optionValuesKeys ? index : optionValuesKeys[index];
                        var value = optionValues[key];
                        var locals = getLocals(value, key);
                        var selectValue = getTrackByValueFn(value, locals);
                        watchedArray.push(selectValue);
                        if (match[2] || match[1]) {
                            var label = displayFn(scope, locals);
                            watchedArray.push(label);
                        }
                        if (match[4]) {
                            var disableWhen = disableWhenFn(scope, locals);
                            watchedArray.push(disableWhen);
                        }
                    }
                    return watchedArray;
                }),
                getOptions: function() {
                    var optionItems = [];
                    var selectValueMap = {};
                    var optionValues = valuesFn(scope) || [];
                    var optionValuesKeys = getOptionValuesKeys(optionValues);
                    var optionValuesLength = optionValuesKeys.length;
                    for (var index = 0; index < optionValuesLength; index++) {
                        var key = optionValues === optionValuesKeys ? index : optionValuesKeys[index];
                        var value = optionValues[key];
                        var locals = getLocals(value, key);
                        var viewValue = viewValueFn(scope, locals);
                        var selectValue = getTrackByValueFn(viewValue, locals);
                        var label = displayFn(scope, locals);
                        var group = groupByFn(scope, locals);
                        var disabled = disableWhenFn(scope, locals);
                        var optionItem = new Option(selectValue, viewValue, label, group, disabled);
                        optionItems.push(optionItem);
                        selectValueMap[selectValue] = optionItem;
                    }
                    return {
                        items: optionItems,
                        selectValueMap: selectValueMap,
                        getOptionFromViewValue: function(value) {
                            return selectValueMap[getTrackByValue(value)];
                        },
                        getViewValueFromOption: function(option) {
                            return trackBy ? copy(option.viewValue) : option.viewValue;
                        }
                    };
                }
            };
        }
        var optionTemplate = window.document.createElement("option"), optGroupTemplate = window.document.createElement("optgroup");
        function ngOptionsPostLink(scope, selectElement, attr, ctrls) {
            var selectCtrl = ctrls[0];
            var ngModelCtrl = ctrls[1];
            var multiple = attr.multiple;
            var emptyOption;
            for (var i = 0, children = selectElement.children(), ii = children.length; i < ii; i++) {
                if (children[i].value === "") {
                    emptyOption = children.eq(i);
                    break;
                }
            }
            var providedEmptyOption = !!emptyOption;
            var emptyOptionRendered = false;
            var unknownOption = jqLite(optionTemplate.cloneNode(false));
            unknownOption.val("?");
            var options;
            var ngOptions = parseOptionsExpression(attr.ngOptions, selectElement, scope);
            var listFragment = $document[0].createDocumentFragment();
            var renderEmptyOption = function() {
                if (!providedEmptyOption) {
                    selectElement.prepend(emptyOption);
                }
                selectElement.val("");
                if (emptyOptionRendered) {
                    emptyOption.prop("selected", true);
                    emptyOption.attr("selected", true);
                }
            };
            var removeEmptyOption = function() {
                if (!providedEmptyOption) {
                    emptyOption.remove();
                } else if (emptyOptionRendered) {
                    emptyOption.removeAttr("selected");
                }
            };
            var renderUnknownOption = function() {
                selectElement.prepend(unknownOption);
                selectElement.val("?");
                unknownOption.prop("selected", true);
                unknownOption.attr("selected", true);
            };
            var removeUnknownOption = function() {
                unknownOption.remove();
            };
            if (!multiple) {
                selectCtrl.writeValue = function writeNgOptionsValue(value) {
                    var selectedOption = options.selectValueMap[selectElement.val()];
                    var option = options.getOptionFromViewValue(value);
                    if (selectedOption) selectedOption.element.removeAttribute("selected");
                    if (option) {
                        if (selectElement[0].value !== option.selectValue) {
                            removeUnknownOption();
                            removeEmptyOption();
                            selectElement[0].value = option.selectValue;
                            option.element.selected = true;
                        }
                        option.element.setAttribute("selected", "selected");
                    } else {
                        if (value === null || providedEmptyOption) {
                            removeUnknownOption();
                            renderEmptyOption();
                        } else {
                            removeEmptyOption();
                            renderUnknownOption();
                        }
                    }
                };
                selectCtrl.readValue = function readNgOptionsValue() {
                    var selectedOption = options.selectValueMap[selectElement.val()];
                    if (selectedOption && !selectedOption.disabled) {
                        removeEmptyOption();
                        removeUnknownOption();
                        return options.getViewValueFromOption(selectedOption);
                    }
                    return null;
                };
                if (ngOptions.trackBy) {
                    scope.$watch(function() {
                        return ngOptions.getTrackByValue(ngModelCtrl.$viewValue);
                    }, function() {
                        ngModelCtrl.$render();
                    });
                }
            } else {
                ngModelCtrl.$isEmpty = function(value) {
                    return !value || value.length === 0;
                };
                selectCtrl.writeValue = function writeNgOptionsMultiple(value) {
                    options.items.forEach(function(option) {
                        option.element.selected = false;
                    });
                    if (value) {
                        value.forEach(function(item) {
                            var option = options.getOptionFromViewValue(item);
                            if (option) option.element.selected = true;
                        });
                    }
                };
                selectCtrl.readValue = function readNgOptionsMultiple() {
                    var selectedValues = selectElement.val() || [], selections = [];
                    forEach(selectedValues, function(value) {
                        var option = options.selectValueMap[value];
                        if (option && !option.disabled) selections.push(options.getViewValueFromOption(option));
                    });
                    return selections;
                };
                if (ngOptions.trackBy) {
                    scope.$watchCollection(function() {
                        if (isArray(ngModelCtrl.$viewValue)) {
                            return ngModelCtrl.$viewValue.map(function(value) {
                                return ngOptions.getTrackByValue(value);
                            });
                        }
                    }, function() {
                        ngModelCtrl.$render();
                    });
                }
            }
            if (providedEmptyOption) {
                emptyOption.remove();
                $compile(emptyOption)(scope);
                if (emptyOption[0].nodeType === NODE_TYPE_COMMENT) {
                    emptyOptionRendered = false;
                    selectCtrl.registerOption = function(optionScope, optionEl) {
                        if (optionEl.val() === "") {
                            emptyOptionRendered = true;
                            emptyOption = optionEl;
                            emptyOption.removeClass("ng-scope");
                            ngModelCtrl.$render();
                            optionEl.on("$destroy", function() {
                                emptyOption = undefined;
                                emptyOptionRendered = false;
                            });
                        }
                    };
                } else {
                    emptyOption.removeClass("ng-scope");
                    emptyOptionRendered = true;
                }
            } else {
                emptyOption = jqLite(optionTemplate.cloneNode(false));
            }
            selectElement.empty();
            updateOptions();
            scope.$watchCollection(ngOptions.getWatchables, updateOptions);
            function addOptionElement(option, parent) {
                var optionElement = optionTemplate.cloneNode(false);
                parent.appendChild(optionElement);
                updateOptionElement(option, optionElement);
            }
            function updateOptionElement(option, element) {
                option.element = element;
                element.disabled = option.disabled;
                if (option.label !== element.label) {
                    element.label = option.label;
                    element.textContent = option.label;
                }
                element.value = option.selectValue;
            }
            function updateOptions() {
                var previousValue = options && selectCtrl.readValue();
                if (options) {
                    for (var i = options.items.length - 1; i >= 0; i--) {
                        var option = options.items[i];
                        if (isDefined(option.group)) {
                            jqLiteRemove(option.element.parentNode);
                        } else {
                            jqLiteRemove(option.element);
                        }
                    }
                }
                options = ngOptions.getOptions();
                var groupElementMap = {};
                if (providedEmptyOption) {
                    selectElement.prepend(emptyOption);
                }
                options.items.forEach(function addOption(option) {
                    var groupElement;
                    if (isDefined(option.group)) {
                        groupElement = groupElementMap[option.group];
                        if (!groupElement) {
                            groupElement = optGroupTemplate.cloneNode(false);
                            listFragment.appendChild(groupElement);
                            groupElement.label = option.group === null ? "null" : option.group;
                            groupElementMap[option.group] = groupElement;
                        }
                        addOptionElement(option, groupElement);
                    } else {
                        addOptionElement(option, listFragment);
                    }
                });
                selectElement[0].appendChild(listFragment);
                ngModelCtrl.$render();
                if (!ngModelCtrl.$isEmpty(previousValue)) {
                    var nextValue = selectCtrl.readValue();
                    var isNotPrimitive = ngOptions.trackBy || multiple;
                    if (isNotPrimitive ? !equals(previousValue, nextValue) : previousValue !== nextValue) {
                        ngModelCtrl.$setViewValue(nextValue);
                        ngModelCtrl.$render();
                    }
                }
            }
        }
        return {
            restrict: "A",
            terminal: true,
            require: [ "select", "ngModel" ],
            link: {
                pre: function ngOptionsPreLink(scope, selectElement, attr, ctrls) {
                    ctrls[0].registerOption = noop;
                },
                post: ngOptionsPostLink
            }
        };
    } ];
    var ngPluralizeDirective = [ "$locale", "$interpolate", "$log", function($locale, $interpolate, $log) {
        var BRACE = /{}/g, IS_WHEN = /^when(Minus)?(.+)$/;
        return {
            link: function(scope, element, attr) {
                var numberExp = attr.count, whenExp = attr.$attr.when && element.attr(attr.$attr.when), offset = attr.offset || 0, whens = scope.$eval(whenExp) || {}, whensExpFns = {}, startSymbol = $interpolate.startSymbol(), endSymbol = $interpolate.endSymbol(), braceReplacement = startSymbol + numberExp + "-" + offset + endSymbol, watchRemover = angular.noop, lastCount;
                forEach(attr, function(expression, attributeName) {
                    var tmpMatch = IS_WHEN.exec(attributeName);
                    if (tmpMatch) {
                        var whenKey = (tmpMatch[1] ? "-" : "") + lowercase(tmpMatch[2]);
                        whens[whenKey] = element.attr(attr.$attr[attributeName]);
                    }
                });
                forEach(whens, function(expression, key) {
                    whensExpFns[key] = $interpolate(expression.replace(BRACE, braceReplacement));
                });
                scope.$watch(numberExp, function ngPluralizeWatchAction(newVal) {
                    var count = parseFloat(newVal);
                    var countIsNaN = isNumberNaN(count);
                    if (!countIsNaN && !(count in whens)) {
                        count = $locale.pluralCat(count - offset);
                    }
                    if (count !== lastCount && !(countIsNaN && isNumberNaN(lastCount))) {
                        watchRemover();
                        var whenExpFn = whensExpFns[count];
                        if (isUndefined(whenExpFn)) {
                            if (newVal != null) {
                                $log.debug("ngPluralize: no rule defined for '" + count + "' in " + whenExp);
                            }
                            watchRemover = noop;
                            updateElementText();
                        } else {
                            watchRemover = scope.$watch(whenExpFn, updateElementText);
                        }
                        lastCount = count;
                    }
                });
                function updateElementText(newText) {
                    element.text(newText || "");
                }
            }
        };
    } ];
    var ngRepeatDirective = [ "$parse", "$animate", "$compile", function($parse, $animate, $compile) {
        var NG_REMOVED = "$$NG_REMOVED";
        var ngRepeatMinErr = minErr("ngRepeat");
        var updateScope = function(scope, index, valueIdentifier, value, keyIdentifier, key, arrayLength) {
            scope[valueIdentifier] = value;
            if (keyIdentifier) scope[keyIdentifier] = key;
            scope.$index = index;
            scope.$first = index === 0;
            scope.$last = index === arrayLength - 1;
            scope.$middle = !(scope.$first || scope.$last);
            scope.$odd = !(scope.$even = (index & 1) === 0);
        };
        var getBlockStart = function(block) {
            return block.clone[0];
        };
        var getBlockEnd = function(block) {
            return block.clone[block.clone.length - 1];
        };
        return {
            restrict: "A",
            multiElement: true,
            transclude: "element",
            priority: 1e3,
            terminal: true,
            $$tlb: true,
            compile: function ngRepeatCompile($element, $attr) {
                var expression = $attr.ngRepeat;
                var ngRepeatEndComment = $compile.$$createComment("end ngRepeat", expression);
                var match = expression.match(/^\s*([\s\S]+?)\s+in\s+([\s\S]+?)(?:\s+as\s+([\s\S]+?))?(?:\s+track\s+by\s+([\s\S]+?))?\s*$/);
                if (!match) {
                    throw ngRepeatMinErr("iexp", "Expected expression in form of '_item_ in _collection_[ track by _id_]' but got '{0}'.", expression);
                }
                var lhs = match[1];
                var rhs = match[2];
                var aliasAs = match[3];
                var trackByExp = match[4];
                match = lhs.match(/^(?:(\s*[$\w]+)|\(\s*([$\w]+)\s*,\s*([$\w]+)\s*\))$/);
                if (!match) {
                    throw ngRepeatMinErr("iidexp", "'_item_' in '_item_ in _collection_' should be an identifier or '(_key_, _value_)' expression, but got '{0}'.", lhs);
                }
                var valueIdentifier = match[3] || match[1];
                var keyIdentifier = match[2];
                if (aliasAs && (!/^[$a-zA-Z_][$a-zA-Z0-9_]*$/.test(aliasAs) || /^(null|undefined|this|\$index|\$first|\$middle|\$last|\$even|\$odd|\$parent|\$root|\$id)$/.test(aliasAs))) {
                    throw ngRepeatMinErr("badident", "alias '{0}' is invalid --- must be a valid JS identifier which is not a reserved name.", aliasAs);
                }
                var trackByExpGetter, trackByIdExpFn, trackByIdArrayFn, trackByIdObjFn;
                var hashFnLocals = {
                    $id: hashKey
                };
                if (trackByExp) {
                    trackByExpGetter = $parse(trackByExp);
                } else {
                    trackByIdArrayFn = function(key, value) {
                        return hashKey(value);
                    };
                    trackByIdObjFn = function(key) {
                        return key;
                    };
                }
                return function ngRepeatLink($scope, $element, $attr, ctrl, $transclude) {
                    if (trackByExpGetter) {
                        trackByIdExpFn = function(key, value, index) {
                            if (keyIdentifier) hashFnLocals[keyIdentifier] = key;
                            hashFnLocals[valueIdentifier] = value;
                            hashFnLocals.$index = index;
                            return trackByExpGetter($scope, hashFnLocals);
                        };
                    }
                    var lastBlockMap = createMap();
                    $scope.$watchCollection(rhs, function ngRepeatAction(collection) {
                        var index, length, previousNode = $element[0], nextNode, nextBlockMap = createMap(), collectionLength, key, value, trackById, trackByIdFn, collectionKeys, block, nextBlockOrder, elementsToRemove;
                        if (aliasAs) {
                            $scope[aliasAs] = collection;
                        }
                        if (isArrayLike(collection)) {
                            collectionKeys = collection;
                            trackByIdFn = trackByIdExpFn || trackByIdArrayFn;
                        } else {
                            trackByIdFn = trackByIdExpFn || trackByIdObjFn;
                            collectionKeys = [];
                            for (var itemKey in collection) {
                                if (hasOwnProperty.call(collection, itemKey) && itemKey.charAt(0) !== "$") {
                                    collectionKeys.push(itemKey);
                                }
                            }
                        }
                        collectionLength = collectionKeys.length;
                        nextBlockOrder = new Array(collectionLength);
                        for (index = 0; index < collectionLength; index++) {
                            key = collection === collectionKeys ? index : collectionKeys[index];
                            value = collection[key];
                            trackById = trackByIdFn(key, value, index);
                            if (lastBlockMap[trackById]) {
                                block = lastBlockMap[trackById];
                                delete lastBlockMap[trackById];
                                nextBlockMap[trackById] = block;
                                nextBlockOrder[index] = block;
                            } else if (nextBlockMap[trackById]) {
                                forEach(nextBlockOrder, function(block) {
                                    if (block && block.scope) lastBlockMap[block.id] = block;
                                });
                                throw ngRepeatMinErr("dupes", "Duplicates in a repeater are not allowed. Use 'track by' expression to specify unique keys. Repeater: {0}, Duplicate key: {1}, Duplicate value: {2}", expression, trackById, value);
                            } else {
                                nextBlockOrder[index] = {
                                    id: trackById,
                                    scope: undefined,
                                    clone: undefined
                                };
                                nextBlockMap[trackById] = true;
                            }
                        }
                        for (var blockKey in lastBlockMap) {
                            block = lastBlockMap[blockKey];
                            elementsToRemove = getBlockNodes(block.clone);
                            $animate.leave(elementsToRemove);
                            if (elementsToRemove[0].parentNode) {
                                for (index = 0, length = elementsToRemove.length; index < length; index++) {
                                    elementsToRemove[index][NG_REMOVED] = true;
                                }
                            }
                            block.scope.$destroy();
                        }
                        for (index = 0; index < collectionLength; index++) {
                            key = collection === collectionKeys ? index : collectionKeys[index];
                            value = collection[key];
                            block = nextBlockOrder[index];
                            if (block.scope) {
                                nextNode = previousNode;
                                do {
                                    nextNode = nextNode.nextSibling;
                                } while (nextNode && nextNode[NG_REMOVED]);
                                if (getBlockStart(block) !== nextNode) {
                                    $animate.move(getBlockNodes(block.clone), null, previousNode);
                                }
                                previousNode = getBlockEnd(block);
                                updateScope(block.scope, index, valueIdentifier, value, keyIdentifier, key, collectionLength);
                            } else {
                                $transclude(function ngRepeatTransclude(clone, scope) {
                                    block.scope = scope;
                                    var endNode = ngRepeatEndComment.cloneNode(false);
                                    clone[clone.length++] = endNode;
                                    $animate.enter(clone, null, previousNode);
                                    previousNode = endNode;
                                    block.clone = clone;
                                    nextBlockMap[block.id] = block;
                                    updateScope(block.scope, index, valueIdentifier, value, keyIdentifier, key, collectionLength);
                                });
                            }
                        }
                        lastBlockMap = nextBlockMap;
                    });
                };
            }
        };
    } ];
    var NG_HIDE_CLASS = "ng-hide";
    var NG_HIDE_IN_PROGRESS_CLASS = "ng-hide-animate";
    var ngShowDirective = [ "$animate", function($animate) {
        return {
            restrict: "A",
            multiElement: true,
            link: function(scope, element, attr) {
                scope.$watch(attr.ngShow, function ngShowWatchAction(value) {
                    $animate[value ? "removeClass" : "addClass"](element, NG_HIDE_CLASS, {
                        tempClasses: NG_HIDE_IN_PROGRESS_CLASS
                    });
                });
            }
        };
    } ];
    var ngHideDirective = [ "$animate", function($animate) {
        return {
            restrict: "A",
            multiElement: true,
            link: function(scope, element, attr) {
                scope.$watch(attr.ngHide, function ngHideWatchAction(value) {
                    $animate[value ? "addClass" : "removeClass"](element, NG_HIDE_CLASS, {
                        tempClasses: NG_HIDE_IN_PROGRESS_CLASS
                    });
                });
            }
        };
    } ];
    var ngStyleDirective = ngDirective(function(scope, element, attr) {
        scope.$watch(attr.ngStyle, function ngStyleWatchAction(newStyles, oldStyles) {
            if (oldStyles && newStyles !== oldStyles) {
                forEach(oldStyles, function(val, style) {
                    element.css(style, "");
                });
            }
            if (newStyles) element.css(newStyles);
        }, true);
    });
    var ngSwitchDirective = [ "$animate", "$compile", function($animate, $compile) {
        return {
            require: "ngSwitch",
            controller: [ "$scope", function NgSwitchController() {
                this.cases = {};
            } ],
            link: function(scope, element, attr, ngSwitchController) {
                var watchExpr = attr.ngSwitch || attr.on, selectedTranscludes = [], selectedElements = [], previousLeaveAnimations = [], selectedScopes = [];
                var spliceFactory = function(array, index) {
                    return function(response) {
                        if (response !== false) array.splice(index, 1);
                    };
                };
                scope.$watch(watchExpr, function ngSwitchWatchAction(value) {
                    var i, ii;
                    while (previousLeaveAnimations.length) {
                        $animate.cancel(previousLeaveAnimations.pop());
                    }
                    for (i = 0, ii = selectedScopes.length; i < ii; ++i) {
                        var selected = getBlockNodes(selectedElements[i].clone);
                        selectedScopes[i].$destroy();
                        var runner = previousLeaveAnimations[i] = $animate.leave(selected);
                        runner.done(spliceFactory(previousLeaveAnimations, i));
                    }
                    selectedElements.length = 0;
                    selectedScopes.length = 0;
                    if (selectedTranscludes = ngSwitchController.cases["!" + value] || ngSwitchController.cases["?"]) {
                        forEach(selectedTranscludes, function(selectedTransclude) {
                            selectedTransclude.transclude(function(caseElement, selectedScope) {
                                selectedScopes.push(selectedScope);
                                var anchor = selectedTransclude.element;
                                caseElement[caseElement.length++] = $compile.$$createComment("end ngSwitchWhen");
                                var block = {
                                    clone: caseElement
                                };
                                selectedElements.push(block);
                                $animate.enter(caseElement, anchor.parent(), anchor);
                            });
                        });
                    }
                });
            }
        };
    } ];
    var ngSwitchWhenDirective = ngDirective({
        transclude: "element",
        priority: 1200,
        require: "^ngSwitch",
        multiElement: true,
        link: function(scope, element, attrs, ctrl, $transclude) {
            var cases = attrs.ngSwitchWhen.split(attrs.ngSwitchWhenSeparator).sort().filter(function(element, index, array) {
                return array[index - 1] !== element;
            });
            forEach(cases, function(whenCase) {
                ctrl.cases["!" + whenCase] = ctrl.cases["!" + whenCase] || [];
                ctrl.cases["!" + whenCase].push({
                    transclude: $transclude,
                    element: element
                });
            });
        }
    });
    var ngSwitchDefaultDirective = ngDirective({
        transclude: "element",
        priority: 1200,
        require: "^ngSwitch",
        multiElement: true,
        link: function(scope, element, attr, ctrl, $transclude) {
            ctrl.cases["?"] = ctrl.cases["?"] || [];
            ctrl.cases["?"].push({
                transclude: $transclude,
                element: element
            });
        }
    });
    var ngTranscludeMinErr = minErr("ngTransclude");
    var ngTranscludeDirective = [ "$compile", function($compile) {
        return {
            restrict: "EAC",
            terminal: true,
            compile: function ngTranscludeCompile(tElement) {
                var fallbackLinkFn = $compile(tElement.contents());
                tElement.empty();
                return function ngTranscludePostLink($scope, $element, $attrs, controller, $transclude) {
                    if (!$transclude) {
                        throw ngTranscludeMinErr("orphan", "Illegal use of ngTransclude directive in the template! " + "No parent directive that requires a transclusion found. " + "Element: {0}", startingTag($element));
                    }
                    if ($attrs.ngTransclude === $attrs.$attr.ngTransclude) {
                        $attrs.ngTransclude = "";
                    }
                    var slotName = $attrs.ngTransclude || $attrs.ngTranscludeSlot;
                    $transclude(ngTranscludeCloneAttachFn, null, slotName);
                    if (slotName && !$transclude.isSlotFilled(slotName)) {
                        useFallbackContent();
                    }
                    function ngTranscludeCloneAttachFn(clone, transcludedScope) {
                        if (clone.length) {
                            $element.append(clone);
                        } else {
                            useFallbackContent();
                            transcludedScope.$destroy();
                        }
                    }
                    function useFallbackContent() {
                        fallbackLinkFn($scope, function(clone) {
                            $element.append(clone);
                        });
                    }
                };
            }
        };
    } ];
    var scriptDirective = [ "$templateCache", function($templateCache) {
        return {
            restrict: "E",
            terminal: true,
            compile: function(element, attr) {
                if (attr.type === "text/ng-template") {
                    var templateUrl = attr.id, text = element[0].text;
                    $templateCache.put(templateUrl, text);
                }
            }
        };
    } ];
    var noopNgModelController = {
        $setViewValue: noop,
        $render: noop
    };
    function chromeHack(optionElement) {
        if (optionElement[0].hasAttribute("selected")) {
            optionElement[0].selected = true;
        }
    }
    var SelectController = [ "$element", "$scope", function($element, $scope) {
        var self = this, optionsMap = new HashMap();
        self.ngModelCtrl = noopNgModelController;
        self.unknownOption = jqLite(window.document.createElement("option"));
        self.renderUnknownOption = function(val) {
            var unknownVal = "? " + hashKey(val) + " ?";
            self.unknownOption.val(unknownVal);
            $element.prepend(self.unknownOption);
            $element.val(unknownVal);
        };
        $scope.$on("$destroy", function() {
            self.renderUnknownOption = noop;
        });
        self.removeUnknownOption = function() {
            if (self.unknownOption.parent()) self.unknownOption.remove();
        };
        self.readValue = function readSingleValue() {
            self.removeUnknownOption();
            return $element.val();
        };
        self.writeValue = function writeSingleValue(value) {
            if (self.hasOption(value)) {
                self.removeUnknownOption();
                $element.val(value);
                if (value === "") self.emptyOption.prop("selected", true);
            } else {
                if (value == null && self.emptyOption) {
                    self.removeUnknownOption();
                    $element.val("");
                } else {
                    self.renderUnknownOption(value);
                }
            }
        };
        self.addOption = function(value, element) {
            if (element[0].nodeType === NODE_TYPE_COMMENT) return;
            assertNotHasOwnProperty(value, '"option value"');
            if (value === "") {
                self.emptyOption = element;
            }
            var count = optionsMap.get(value) || 0;
            optionsMap.put(value, count + 1);
            self.ngModelCtrl.$render();
            chromeHack(element);
        };
        self.removeOption = function(value) {
            var count = optionsMap.get(value);
            if (count) {
                if (count === 1) {
                    optionsMap.remove(value);
                    if (value === "") {
                        self.emptyOption = undefined;
                    }
                } else {
                    optionsMap.put(value, count - 1);
                }
            }
        };
        self.hasOption = function(value) {
            return !!optionsMap.get(value);
        };
        self.registerOption = function(optionScope, optionElement, optionAttrs, hasDynamicValueAttr, interpolateTextFn) {
            if (hasDynamicValueAttr) {
                var oldVal;
                optionAttrs.$observe("value", function valueAttributeObserveAction(newVal) {
                    if (isDefined(oldVal)) {
                        self.removeOption(oldVal);
                    }
                    oldVal = newVal;
                    self.addOption(newVal, optionElement);
                });
            } else if (interpolateTextFn) {
                optionScope.$watch(interpolateTextFn, function interpolateWatchAction(newVal, oldVal) {
                    optionAttrs.$set("value", newVal);
                    if (oldVal !== newVal) {
                        self.removeOption(oldVal);
                    }
                    self.addOption(newVal, optionElement);
                });
            } else {
                self.addOption(optionAttrs.value, optionElement);
            }
            optionElement.on("$destroy", function() {
                self.removeOption(optionAttrs.value);
                self.ngModelCtrl.$render();
            });
        };
    } ];
    var selectDirective = function() {
        return {
            restrict: "E",
            require: [ "select", "?ngModel" ],
            controller: SelectController,
            priority: 1,
            link: {
                pre: selectPreLink,
                post: selectPostLink
            }
        };
        function selectPreLink(scope, element, attr, ctrls) {
            var ngModelCtrl = ctrls[1];
            if (!ngModelCtrl) return;
            var selectCtrl = ctrls[0];
            selectCtrl.ngModelCtrl = ngModelCtrl;
            element.on("change", function() {
                scope.$apply(function() {
                    ngModelCtrl.$setViewValue(selectCtrl.readValue());
                });
            });
            if (attr.multiple) {
                selectCtrl.readValue = function readMultipleValue() {
                    var array = [];
                    forEach(element.find("option"), function(option) {
                        if (option.selected) {
                            array.push(option.value);
                        }
                    });
                    return array;
                };
                selectCtrl.writeValue = function writeMultipleValue(value) {
                    var items = new HashMap(value);
                    forEach(element.find("option"), function(option) {
                        option.selected = isDefined(items.get(option.value));
                    });
                };
                var lastView, lastViewRef = NaN;
                scope.$watch(function selectMultipleWatch() {
                    if (lastViewRef === ngModelCtrl.$viewValue && !equals(lastView, ngModelCtrl.$viewValue)) {
                        lastView = shallowCopy(ngModelCtrl.$viewValue);
                        ngModelCtrl.$render();
                    }
                    lastViewRef = ngModelCtrl.$viewValue;
                });
                ngModelCtrl.$isEmpty = function(value) {
                    return !value || value.length === 0;
                };
            }
        }
        function selectPostLink(scope, element, attrs, ctrls) {
            var ngModelCtrl = ctrls[1];
            if (!ngModelCtrl) return;
            var selectCtrl = ctrls[0];
            ngModelCtrl.$render = function() {
                selectCtrl.writeValue(ngModelCtrl.$viewValue);
            };
        }
    };
    var optionDirective = [ "$interpolate", function($interpolate) {
        return {
            restrict: "E",
            priority: 100,
            compile: function(element, attr) {
                var hasDynamicValueAttr, interpolateTextFn;
                if (isDefined(attr.ngValue)) {
                    hasDynamicValueAttr = true;
                } else if (isDefined(attr.value)) {
                    hasDynamicValueAttr = $interpolate(attr.value, true);
                } else {
                    interpolateTextFn = $interpolate(element.text(), true);
                    if (!interpolateTextFn) {
                        attr.$set("value", element.text());
                    }
                }
                return function(scope, element, attr) {
                    var selectCtrlName = "$selectController", parent = element.parent(), selectCtrl = parent.data(selectCtrlName) || parent.parent().data(selectCtrlName);
                    if (selectCtrl) {
                        selectCtrl.registerOption(scope, element, attr, hasDynamicValueAttr, interpolateTextFn);
                    }
                };
            }
        };
    } ];
    var requiredDirective = function() {
        return {
            restrict: "A",
            require: "?ngModel",
            link: function(scope, elm, attr, ctrl) {
                if (!ctrl) return;
                attr.required = true;
                ctrl.$validators.required = function(modelValue, viewValue) {
                    return !attr.required || !ctrl.$isEmpty(viewValue);
                };
                attr.$observe("required", function() {
                    ctrl.$validate();
                });
            }
        };
    };
    var patternDirective = function() {
        return {
            restrict: "A",
            require: "?ngModel",
            link: function(scope, elm, attr, ctrl) {
                if (!ctrl) return;
                var regexp, patternExp = attr.ngPattern || attr.pattern;
                attr.$observe("pattern", function(regex) {
                    if (isString(regex) && regex.length > 0) {
                        regex = new RegExp("^" + regex + "$");
                    }
                    if (regex && !regex.test) {
                        throw minErr("ngPattern")("noregexp", "Expected {0} to be a RegExp but was {1}. Element: {2}", patternExp, regex, startingTag(elm));
                    }
                    regexp = regex || undefined;
                    ctrl.$validate();
                });
                ctrl.$validators.pattern = function(modelValue, viewValue) {
                    return ctrl.$isEmpty(viewValue) || isUndefined(regexp) || regexp.test(viewValue);
                };
            }
        };
    };
    var maxlengthDirective = function() {
        return {
            restrict: "A",
            require: "?ngModel",
            link: function(scope, elm, attr, ctrl) {
                if (!ctrl) return;
                var maxlength = -1;
                attr.$observe("maxlength", function(value) {
                    var intVal = toInt(value);
                    maxlength = isNumberNaN(intVal) ? -1 : intVal;
                    ctrl.$validate();
                });
                ctrl.$validators.maxlength = function(modelValue, viewValue) {
                    return maxlength < 0 || ctrl.$isEmpty(viewValue) || viewValue.length <= maxlength;
                };
            }
        };
    };
    var minlengthDirective = function() {
        return {
            restrict: "A",
            require: "?ngModel",
            link: function(scope, elm, attr, ctrl) {
                if (!ctrl) return;
                var minlength = 0;
                attr.$observe("minlength", function(value) {
                    minlength = toInt(value) || 0;
                    ctrl.$validate();
                });
                ctrl.$validators.minlength = function(modelValue, viewValue) {
                    return ctrl.$isEmpty(viewValue) || viewValue.length >= minlength;
                };
            }
        };
    };
    if (window.angular.bootstrap) {
        if (window.console) {
            console.log("WARNING: Tried to load angular more than once.");
        }
        return;
    }
    bindJQuery();
    publishExternalAPI(angular);
    angular.module("ngLocale", [], [ "$provide", function($provide) {
        var PLURAL_CATEGORY = {
            ZERO: "zero",
            ONE: "one",
            TWO: "two",
            FEW: "few",
            MANY: "many",
            OTHER: "other"
        };
        function getDecimals(n) {
            n = n + "";
            var i = n.indexOf(".");
            return i == -1 ? 0 : n.length - i - 1;
        }
        function getVF(n, opt_precision) {
            var v = opt_precision;
            if (undefined === v) {
                v = Math.min(getDecimals(n), 3);
            }
            var base = Math.pow(10, v);
            var f = (n * base | 0) % base;
            return {
                v: v,
                f: f
            };
        }
        $provide.value("$locale", {
            DATETIME_FORMATS: {
                AMPMS: [ "AM", "PM" ],
                DAY: [ "Sunday", "Monday", "Tuesday", "Wednesday", "Thursday", "Friday", "Saturday" ],
                ERANAMES: [ "Before Christ", "Anno Domini" ],
                ERAS: [ "BC", "AD" ],
                FIRSTDAYOFWEEK: 6,
                MONTH: [ "January", "February", "March", "April", "May", "June", "July", "August", "September", "October", "November", "December" ],
                SHORTDAY: [ "Sun", "Mon", "Tue", "Wed", "Thu", "Fri", "Sat" ],
                SHORTMONTH: [ "Jan", "Feb", "Mar", "Apr", "May", "Jun", "Jul", "Aug", "Sep", "Oct", "Nov", "Dec" ],
                STANDALONEMONTH: [ "January", "February", "March", "April", "May", "June", "July", "August", "September", "October", "November", "December" ],
                WEEKENDRANGE: [ 5, 6 ],
                fullDate: "EEEE, MMMM d, y",
                longDate: "MMMM d, y",
                medium: "MMM d, y h:mm:ss a",
                mediumDate: "MMM d, y",
                mediumTime: "h:mm:ss a",
                "short": "M/d/yy h:mm a",
                shortDate: "M/d/yy",
                shortTime: "h:mm a"
            },
            NUMBER_FORMATS: {
                CURRENCY_SYM: "$",
                DECIMAL_SEP: ".",
                GROUP_SEP: ",",
                PATTERNS: [ {
                    gSize: 3,
                    lgSize: 3,
                    maxFrac: 3,
                    minFrac: 0,
                    minInt: 1,
                    negPre: "-",
                    negSuf: "",
                    posPre: "",
                    posSuf: ""
                }, {
                    gSize: 3,
                    lgSize: 3,
                    maxFrac: 2,
                    minFrac: 2,
                    minInt: 1,
                    negPre: "-Â¤",
                    negSuf: "",
                    posPre: "Â¤",
                    posSuf: ""
                } ]
            },
            id: "en-us",
            localeID: "en_US",
            pluralCat: function(n, opt_precision) {
                var i = n | 0;
                var vf = getVF(n, opt_precision);
                if (i == 1 && vf.v == 0) {
                    return PLURAL_CATEGORY.ONE;
                }
                return PLURAL_CATEGORY.OTHER;
            }
        });
    } ]);
    jqLite(window.document).ready(function() {
        angularInit(window.document, bootstrap);
    });
})(window);

!window.angular.$$csp().noInlineStyle && window.angular.element(document.head).prepend('<style type="text/css">@charset "UTF-8";[ng\\:cloak],[ng-cloak],[data-ng-cloak],[x-ng-cloak],.ng-cloak,.x-ng-cloak,.ng-hide:not(.ng-hide-animate){display:none !important;}ng\\:form{display:block;}.ng-animate-shim{visibility:hidden;}.ng-anchor{position:absolute;}</style>');

(function(window, angular) {
    "use strict";
    var ELEMENT_NODE = 1;
    var COMMENT_NODE = 8;
    var ADD_CLASS_SUFFIX = "-add";
    var REMOVE_CLASS_SUFFIX = "-remove";
    var EVENT_CLASS_PREFIX = "ng-";
    var ACTIVE_CLASS_SUFFIX = "-active";
    var PREPARE_CLASS_SUFFIX = "-prepare";
    var NG_ANIMATE_CLASSNAME = "ng-animate";
    var NG_ANIMATE_CHILDREN_DATA = "$$ngAnimateChildren";
    var CSS_PREFIX = "", TRANSITION_PROP, TRANSITIONEND_EVENT, ANIMATION_PROP, ANIMATIONEND_EVENT;
    if (window.ontransitionend === undefined && window.onwebkittransitionend !== undefined) {
        CSS_PREFIX = "-webkit-";
        TRANSITION_PROP = "WebkitTransition";
        TRANSITIONEND_EVENT = "webkitTransitionEnd transitionend";
    } else {
        TRANSITION_PROP = "transition";
        TRANSITIONEND_EVENT = "transitionend";
    }
    if (window.onanimationend === undefined && window.onwebkitanimationend !== undefined) {
        CSS_PREFIX = "-webkit-";
        ANIMATION_PROP = "WebkitAnimation";
        ANIMATIONEND_EVENT = "webkitAnimationEnd animationend";
    } else {
        ANIMATION_PROP = "animation";
        ANIMATIONEND_EVENT = "animationend";
    }
    var DURATION_KEY = "Duration";
    var PROPERTY_KEY = "Property";
    var DELAY_KEY = "Delay";
    var TIMING_KEY = "TimingFunction";
    var ANIMATION_ITERATION_COUNT_KEY = "IterationCount";
    var ANIMATION_PLAYSTATE_KEY = "PlayState";
    var SAFE_FAST_FORWARD_DURATION_VALUE = 9999;
    var ANIMATION_DELAY_PROP = ANIMATION_PROP + DELAY_KEY;
    var ANIMATION_DURATION_PROP = ANIMATION_PROP + DURATION_KEY;
    var TRANSITION_DELAY_PROP = TRANSITION_PROP + DELAY_KEY;
    var TRANSITION_DURATION_PROP = TRANSITION_PROP + DURATION_KEY;
    var ngMinErr = angular.$$minErr("ng");
    function assertArg(arg, name, reason) {
        if (!arg) {
            throw ngMinErr("areq", "Argument '{0}' is {1}", name || "?", reason || "required");
        }
        return arg;
    }
    function mergeClasses(a, b) {
        if (!a && !b) return "";
        if (!a) return b;
        if (!b) return a;
        if (isArray(a)) a = a.join(" ");
        if (isArray(b)) b = b.join(" ");
        return a + " " + b;
    }
    function packageStyles(options) {
        var styles = {};
        if (options && (options.to || options.from)) {
            styles.to = options.to;
            styles.from = options.from;
        }
        return styles;
    }
    function pendClasses(classes, fix, isPrefix) {
        var className = "";
        classes = isArray(classes) ? classes : classes && isString(classes) && classes.length ? classes.split(/\s+/) : [];
        forEach(classes, function(klass, i) {
            if (klass && klass.length > 0) {
                className += i > 0 ? " " : "";
                className += isPrefix ? fix + klass : klass + fix;
            }
        });
        return className;
    }
    function removeFromArray(arr, val) {
        var index = arr.indexOf(val);
        if (val >= 0) {
            arr.splice(index, 1);
        }
    }
    function stripCommentsFromElement(element) {
        if (element instanceof jqLite) {
            switch (element.length) {
              case 0:
                return element;

              case 1:
                if (element[0].nodeType === ELEMENT_NODE) {
                    return element;
                }
                break;

              default:
                return jqLite(extractElementNode(element));
            }
        }
        if (element.nodeType === ELEMENT_NODE) {
            return jqLite(element);
        }
    }
    function extractElementNode(element) {
        if (!element[0]) return element;
        for (var i = 0; i < element.length; i++) {
            var elm = element[i];
            if (elm.nodeType === ELEMENT_NODE) {
                return elm;
            }
        }
    }
    function $$addClass($$jqLite, element, className) {
        forEach(element, function(elm) {
            $$jqLite.addClass(elm, className);
        });
    }
    function $$removeClass($$jqLite, element, className) {
        forEach(element, function(elm) {
            $$jqLite.removeClass(elm, className);
        });
    }
    function applyAnimationClassesFactory($$jqLite) {
        return function(element, options) {
            if (options.addClass) {
                $$addClass($$jqLite, element, options.addClass);
                options.addClass = null;
            }
            if (options.removeClass) {
                $$removeClass($$jqLite, element, options.removeClass);
                options.removeClass = null;
            }
        };
    }
    function prepareAnimationOptions(options) {
        options = options || {};
        if (!options.$$prepared) {
            var domOperation = options.domOperation || noop;
            options.domOperation = function() {
                options.$$domOperationFired = true;
                domOperation();
                domOperation = noop;
            };
            options.$$prepared = true;
        }
        return options;
    }
    function applyAnimationStyles(element, options) {
        applyAnimationFromStyles(element, options);
        applyAnimationToStyles(element, options);
    }
    function applyAnimationFromStyles(element, options) {
        if (options.from) {
            element.css(options.from);
            options.from = null;
        }
    }
    function applyAnimationToStyles(element, options) {
        if (options.to) {
            element.css(options.to);
            options.to = null;
        }
    }
    function mergeAnimationDetails(element, oldAnimation, newAnimation) {
        var target = oldAnimation.options || {};
        var newOptions = newAnimation.options || {};
        var toAdd = (target.addClass || "") + " " + (newOptions.addClass || "");
        var toRemove = (target.removeClass || "") + " " + (newOptions.removeClass || "");
        var classes = resolveElementClasses(element.attr("class"), toAdd, toRemove);
        if (newOptions.preparationClasses) {
            target.preparationClasses = concatWithSpace(newOptions.preparationClasses, target.preparationClasses);
            delete newOptions.preparationClasses;
        }
        var realDomOperation = target.domOperation !== noop ? target.domOperation : null;
        extend(target, newOptions);
        if (realDomOperation) {
            target.domOperation = realDomOperation;
        }
        if (classes.addClass) {
            target.addClass = classes.addClass;
        } else {
            target.addClass = null;
        }
        if (classes.removeClass) {
            target.removeClass = classes.removeClass;
        } else {
            target.removeClass = null;
        }
        oldAnimation.addClass = target.addClass;
        oldAnimation.removeClass = target.removeClass;
        return target;
    }
    function resolveElementClasses(existing, toAdd, toRemove) {
        var ADD_CLASS = 1;
        var REMOVE_CLASS = -1;
        var flags = {};
        existing = splitClassesToLookup(existing);
        toAdd = splitClassesToLookup(toAdd);
        forEach(toAdd, function(value, key) {
            flags[key] = ADD_CLASS;
        });
        toRemove = splitClassesToLookup(toRemove);
        forEach(toRemove, function(value, key) {
            flags[key] = flags[key] === ADD_CLASS ? null : REMOVE_CLASS;
        });
        var classes = {
            addClass: "",
            removeClass: ""
        };
        forEach(flags, function(val, klass) {
            var prop, allow;
            if (val === ADD_CLASS) {
                prop = "addClass";
                allow = !existing[klass] || existing[klass + REMOVE_CLASS_SUFFIX];
            } else if (val === REMOVE_CLASS) {
                prop = "removeClass";
                allow = existing[klass] || existing[klass + ADD_CLASS_SUFFIX];
            }
            if (allow) {
                if (classes[prop].length) {
                    classes[prop] += " ";
                }
                classes[prop] += klass;
            }
        });
        function splitClassesToLookup(classes) {
            if (isString(classes)) {
                classes = classes.split(" ");
            }
            var obj = {};
            forEach(classes, function(klass) {
                if (klass.length) {
                    obj[klass] = true;
                }
            });
            return obj;
        }
        return classes;
    }
    function getDomNode(element) {
        return element instanceof jqLite ? element[0] : element;
    }
    function applyGeneratedPreparationClasses(element, event, options) {
        var classes = "";
        if (event) {
            classes = pendClasses(event, EVENT_CLASS_PREFIX, true);
        }
        if (options.addClass) {
            classes = concatWithSpace(classes, pendClasses(options.addClass, ADD_CLASS_SUFFIX));
        }
        if (options.removeClass) {
            classes = concatWithSpace(classes, pendClasses(options.removeClass, REMOVE_CLASS_SUFFIX));
        }
        if (classes.length) {
            options.preparationClasses = classes;
            element.addClass(classes);
        }
    }
    function clearGeneratedClasses(element, options) {
        if (options.preparationClasses) {
            element.removeClass(options.preparationClasses);
            options.preparationClasses = null;
        }
        if (options.activeClasses) {
            element.removeClass(options.activeClasses);
            options.activeClasses = null;
        }
    }
    function blockTransitions(node, duration) {
        var value = duration ? "-" + duration + "s" : "";
        applyInlineStyle(node, [ TRANSITION_DELAY_PROP, value ]);
        return [ TRANSITION_DELAY_PROP, value ];
    }
    function blockKeyframeAnimations(node, applyBlock) {
        var value = applyBlock ? "paused" : "";
        var key = ANIMATION_PROP + ANIMATION_PLAYSTATE_KEY;
        applyInlineStyle(node, [ key, value ]);
        return [ key, value ];
    }
    function applyInlineStyle(node, styleTuple) {
        var prop = styleTuple[0];
        var value = styleTuple[1];
        node.style[prop] = value;
    }
    function concatWithSpace(a, b) {
        if (!a) return b;
        if (!b) return a;
        return a + " " + b;
    }
    var $$rAFSchedulerFactory = [ "$$rAF", function($$rAF) {
        var queue, cancelFn;
        function scheduler(tasks) {
            queue = queue.concat(tasks);
            nextTick();
        }
        queue = scheduler.queue = [];
        scheduler.waitUntilQuiet = function(fn) {
            if (cancelFn) cancelFn();
            cancelFn = $$rAF(function() {
                cancelFn = null;
                fn();
                nextTick();
            });
        };
        return scheduler;
        function nextTick() {
            if (!queue.length) return;
            var items = queue.shift();
            for (var i = 0; i < items.length; i++) {
                items[i]();
            }
            if (!cancelFn) {
                $$rAF(function() {
                    if (!cancelFn) nextTick();
                });
            }
        }
    } ];
    var $$AnimateChildrenDirective = [ "$interpolate", function($interpolate) {
        return {
            link: function(scope, element, attrs) {
                var val = attrs.ngAnimateChildren;
                if (isString(val) && val.length === 0) {
                    element.data(NG_ANIMATE_CHILDREN_DATA, true);
                } else {
                    setData($interpolate(val)(scope));
                    attrs.$observe("ngAnimateChildren", setData);
                }
                function setData(value) {
                    value = value === "on" || value === "true";
                    element.data(NG_ANIMATE_CHILDREN_DATA, value);
                }
            }
        };
    } ];
    var ANIMATE_TIMER_KEY = "$$animateCss";
    var ONE_SECOND = 1e3;
    var ELAPSED_TIME_MAX_DECIMAL_PLACES = 3;
    var CLOSING_TIME_BUFFER = 1.5;
    var DETECT_CSS_PROPERTIES = {
        transitionDuration: TRANSITION_DURATION_PROP,
        transitionDelay: TRANSITION_DELAY_PROP,
        transitionProperty: TRANSITION_PROP + PROPERTY_KEY,
        animationDuration: ANIMATION_DURATION_PROP,
        animationDelay: ANIMATION_DELAY_PROP,
        animationIterationCount: ANIMATION_PROP + ANIMATION_ITERATION_COUNT_KEY
    };
    var DETECT_STAGGER_CSS_PROPERTIES = {
        transitionDuration: TRANSITION_DURATION_PROP,
        transitionDelay: TRANSITION_DELAY_PROP,
        animationDuration: ANIMATION_DURATION_PROP,
        animationDelay: ANIMATION_DELAY_PROP
    };
    function getCssKeyframeDurationStyle(duration) {
        return [ ANIMATION_DURATION_PROP, duration + "s" ];
    }
    function getCssDelayStyle(delay, isKeyframeAnimation) {
        var prop = isKeyframeAnimation ? ANIMATION_DELAY_PROP : TRANSITION_DELAY_PROP;
        return [ prop, delay + "s" ];
    }
    function computeCssStyles($window, element, properties) {
        var styles = Object.create(null);
        var detectedStyles = $window.getComputedStyle(element) || {};
        forEach(properties, function(formalStyleName, actualStyleName) {
            var val = detectedStyles[formalStyleName];
            if (val) {
                var c = val.charAt(0);
                if (c === "-" || c === "+" || c >= 0) {
                    val = parseMaxTime(val);
                }
                if (val === 0) {
                    val = null;
                }
                styles[actualStyleName] = val;
            }
        });
        return styles;
    }
    function parseMaxTime(str) {
        var maxValue = 0;
        var values = str.split(/\s*,\s*/);
        forEach(values, function(value) {
            if (value.charAt(value.length - 1) === "s") {
                value = value.substring(0, value.length - 1);
            }
            value = parseFloat(value) || 0;
            maxValue = maxValue ? Math.max(value, maxValue) : value;
        });
        return maxValue;
    }
    function truthyTimingValue(val) {
        return val === 0 || val != null;
    }
    function getCssTransitionDurationStyle(duration, applyOnlyDuration) {
        var style = TRANSITION_PROP;
        var value = duration + "s";
        if (applyOnlyDuration) {
            style += DURATION_KEY;
        } else {
            value += " linear all";
        }
        return [ style, value ];
    }
    function createLocalCacheLookup() {
        var cache = Object.create(null);
        return {
            flush: function() {
                cache = Object.create(null);
            },
            count: function(key) {
                var entry = cache[key];
                return entry ? entry.total : 0;
            },
            get: function(key) {
                var entry = cache[key];
                return entry && entry.value;
            },
            put: function(key, value) {
                if (!cache[key]) {
                    cache[key] = {
                        total: 1,
                        value: value
                    };
                } else {
                    cache[key].total++;
                }
            }
        };
    }
    function registerRestorableStyles(backup, node, properties) {
        forEach(properties, function(prop) {
            backup[prop] = isDefined(backup[prop]) ? backup[prop] : node.style.getPropertyValue(prop);
        });
    }
    var $AnimateCssProvider = [ "$animateProvider", function($animateProvider) {
        var gcsLookup = createLocalCacheLookup();
        var gcsStaggerLookup = createLocalCacheLookup();
        this.$get = [ "$window", "$$jqLite", "$$AnimateRunner", "$timeout", "$$forceReflow", "$sniffer", "$$rAFScheduler", "$$animateQueue", function($window, $$jqLite, $$AnimateRunner, $timeout, $$forceReflow, $sniffer, $$rAFScheduler, $$animateQueue) {
            var applyAnimationClasses = applyAnimationClassesFactory($$jqLite);
            var parentCounter = 0;
            function gcsHashFn(node, extraClasses) {
                var KEY = "$$ngAnimateParentKey";
                var parentNode = node.parentNode;
                var parentID = parentNode[KEY] || (parentNode[KEY] = ++parentCounter);
                return parentID + "-" + node.getAttribute("class") + "-" + extraClasses;
            }
            function computeCachedCssStyles(node, className, cacheKey, properties) {
                var timings = gcsLookup.get(cacheKey);
                if (!timings) {
                    timings = computeCssStyles($window, node, properties);
                    if (timings.animationIterationCount === "infinite") {
                        timings.animationIterationCount = 1;
                    }
                }
                gcsLookup.put(cacheKey, timings);
                return timings;
            }
            function computeCachedCssStaggerStyles(node, className, cacheKey, properties) {
                var stagger;
                if (gcsLookup.count(cacheKey) > 0) {
                    stagger = gcsStaggerLookup.get(cacheKey);
                    if (!stagger) {
                        var staggerClassName = pendClasses(className, "-stagger");
                        $$jqLite.addClass(node, staggerClassName);
                        stagger = computeCssStyles($window, node, properties);
                        stagger.animationDuration = Math.max(stagger.animationDuration, 0);
                        stagger.transitionDuration = Math.max(stagger.transitionDuration, 0);
                        $$jqLite.removeClass(node, staggerClassName);
                        gcsStaggerLookup.put(cacheKey, stagger);
                    }
                }
                return stagger || {};
            }
            var rafWaitQueue = [];
            function waitUntilQuiet(callback) {
                rafWaitQueue.push(callback);
                $$rAFScheduler.waitUntilQuiet(function() {
                    gcsLookup.flush();
                    gcsStaggerLookup.flush();
                    var pageWidth = $$forceReflow();
                    for (var i = 0; i < rafWaitQueue.length; i++) {
                        rafWaitQueue[i](pageWidth);
                    }
                    rafWaitQueue.length = 0;
                });
            }
            function computeTimings(node, className, cacheKey) {
                var timings = computeCachedCssStyles(node, className, cacheKey, DETECT_CSS_PROPERTIES);
                var aD = timings.animationDelay;
                var tD = timings.transitionDelay;
                timings.maxDelay = aD && tD ? Math.max(aD, tD) : aD || tD;
                timings.maxDuration = Math.max(timings.animationDuration * timings.animationIterationCount, timings.transitionDuration);
                return timings;
            }
            return function init(element, initialOptions) {
                var options = initialOptions || {};
                if (!options.$$prepared) {
                    options = prepareAnimationOptions(copy(options));
                }
                var restoreStyles = {};
                var node = getDomNode(element);
                if (!node || !node.parentNode || !$$animateQueue.enabled()) {
                    return closeAndReturnNoopAnimator();
                }
                var temporaryStyles = [];
                var classes = element.attr("class");
                var styles = packageStyles(options);
                var animationClosed;
                var animationPaused;
                var animationCompleted;
                var runner;
                var runnerHost;
                var maxDelay;
                var maxDelayTime;
                var maxDuration;
                var maxDurationTime;
                var startTime;
                var events = [];
                if (options.duration === 0 || !$sniffer.animations && !$sniffer.transitions) {
                    return closeAndReturnNoopAnimator();
                }
                var method = options.event && isArray(options.event) ? options.event.join(" ") : options.event;
                var isStructural = method && options.structural;
                var structuralClassName = "";
                var addRemoveClassName = "";
                if (isStructural) {
                    structuralClassName = pendClasses(method, EVENT_CLASS_PREFIX, true);
                } else if (method) {
                    structuralClassName = method;
                }
                if (options.addClass) {
                    addRemoveClassName += pendClasses(options.addClass, ADD_CLASS_SUFFIX);
                }
                if (options.removeClass) {
                    if (addRemoveClassName.length) {
                        addRemoveClassName += " ";
                    }
                    addRemoveClassName += pendClasses(options.removeClass, REMOVE_CLASS_SUFFIX);
                }
                if (options.applyClassesEarly && addRemoveClassName.length) {
                    applyAnimationClasses(element, options);
                }
                var preparationClasses = [ structuralClassName, addRemoveClassName ].join(" ").trim();
                var fullClassName = classes + " " + preparationClasses;
                var activeClasses = pendClasses(preparationClasses, ACTIVE_CLASS_SUFFIX);
                var hasToStyles = styles.to && Object.keys(styles.to).length > 0;
                var containsKeyframeAnimation = (options.keyframeStyle || "").length > 0;
                if (!containsKeyframeAnimation && !hasToStyles && !preparationClasses) {
                    return closeAndReturnNoopAnimator();
                }
                var cacheKey, stagger;
                if (options.stagger > 0) {
                    var staggerVal = parseFloat(options.stagger);
                    stagger = {
                        transitionDelay: staggerVal,
                        animationDelay: staggerVal,
                        transitionDuration: 0,
                        animationDuration: 0
                    };
                } else {
                    cacheKey = gcsHashFn(node, fullClassName);
                    stagger = computeCachedCssStaggerStyles(node, preparationClasses, cacheKey, DETECT_STAGGER_CSS_PROPERTIES);
                }
                if (!options.$$skipPreparationClasses) {
                    $$jqLite.addClass(element, preparationClasses);
                }
                var applyOnlyDuration;
                if (options.transitionStyle) {
                    var transitionStyle = [ TRANSITION_PROP, options.transitionStyle ];
                    applyInlineStyle(node, transitionStyle);
                    temporaryStyles.push(transitionStyle);
                }
                if (options.duration >= 0) {
                    applyOnlyDuration = node.style[TRANSITION_PROP].length > 0;
                    var durationStyle = getCssTransitionDurationStyle(options.duration, applyOnlyDuration);
                    applyInlineStyle(node, durationStyle);
                    temporaryStyles.push(durationStyle);
                }
                if (options.keyframeStyle) {
                    var keyframeStyle = [ ANIMATION_PROP, options.keyframeStyle ];
                    applyInlineStyle(node, keyframeStyle);
                    temporaryStyles.push(keyframeStyle);
                }
                var itemIndex = stagger ? options.staggerIndex >= 0 ? options.staggerIndex : gcsLookup.count(cacheKey) : 0;
                var isFirst = itemIndex === 0;
                if (isFirst && !options.skipBlocking) {
                    blockTransitions(node, SAFE_FAST_FORWARD_DURATION_VALUE);
                }
                var timings = computeTimings(node, fullClassName, cacheKey);
                var relativeDelay = timings.maxDelay;
                maxDelay = Math.max(relativeDelay, 0);
                maxDuration = timings.maxDuration;
                var flags = {};
                flags.hasTransitions = timings.transitionDuration > 0;
                flags.hasAnimations = timings.animationDuration > 0;
                flags.hasTransitionAll = flags.hasTransitions && timings.transitionProperty === "all";
                flags.applyTransitionDuration = hasToStyles && (flags.hasTransitions && !flags.hasTransitionAll || flags.hasAnimations && !flags.hasTransitions);
                flags.applyAnimationDuration = options.duration && flags.hasAnimations;
                flags.applyTransitionDelay = truthyTimingValue(options.delay) && (flags.applyTransitionDuration || flags.hasTransitions);
                flags.applyAnimationDelay = truthyTimingValue(options.delay) && flags.hasAnimations;
                flags.recalculateTimingStyles = addRemoveClassName.length > 0;
                if (flags.applyTransitionDuration || flags.applyAnimationDuration) {
                    maxDuration = options.duration ? parseFloat(options.duration) : maxDuration;
                    if (flags.applyTransitionDuration) {
                        flags.hasTransitions = true;
                        timings.transitionDuration = maxDuration;
                        applyOnlyDuration = node.style[TRANSITION_PROP + PROPERTY_KEY].length > 0;
                        temporaryStyles.push(getCssTransitionDurationStyle(maxDuration, applyOnlyDuration));
                    }
                    if (flags.applyAnimationDuration) {
                        flags.hasAnimations = true;
                        timings.animationDuration = maxDuration;
                        temporaryStyles.push(getCssKeyframeDurationStyle(maxDuration));
                    }
                }
                if (maxDuration === 0 && !flags.recalculateTimingStyles) {
                    return closeAndReturnNoopAnimator();
                }
                if (options.delay != null) {
                    var delayStyle;
                    if (typeof options.delay !== "boolean") {
                        delayStyle = parseFloat(options.delay);
                        maxDelay = Math.max(delayStyle, 0);
                    }
                    if (flags.applyTransitionDelay) {
                        temporaryStyles.push(getCssDelayStyle(delayStyle));
                    }
                    if (flags.applyAnimationDelay) {
                        temporaryStyles.push(getCssDelayStyle(delayStyle, true));
                    }
                }
                if (options.duration == null && timings.transitionDuration > 0) {
                    flags.recalculateTimingStyles = flags.recalculateTimingStyles || isFirst;
                }
                maxDelayTime = maxDelay * ONE_SECOND;
                maxDurationTime = maxDuration * ONE_SECOND;
                if (!options.skipBlocking) {
                    flags.blockTransition = timings.transitionDuration > 0;
                    flags.blockKeyframeAnimation = timings.animationDuration > 0 && stagger.animationDelay > 0 && stagger.animationDuration === 0;
                }
                if (options.from) {
                    if (options.cleanupStyles) {
                        registerRestorableStyles(restoreStyles, node, Object.keys(options.from));
                    }
                    applyAnimationFromStyles(element, options);
                }
                if (flags.blockTransition || flags.blockKeyframeAnimation) {
                    applyBlocking(maxDuration);
                } else if (!options.skipBlocking) {
                    blockTransitions(node, false);
                }
                return {
                    $$willAnimate: true,
                    end: endFn,
                    start: function() {
                        if (animationClosed) return;
                        runnerHost = {
                            end: endFn,
                            cancel: cancelFn,
                            resume: null,
                            pause: null
                        };
                        runner = new $$AnimateRunner(runnerHost);
                        waitUntilQuiet(start);
                        return runner;
                    }
                };
                function endFn() {
                    close();
                }
                function cancelFn() {
                    close(true);
                }
                function close(rejected) {
                    if (animationClosed || animationCompleted && animationPaused) return;
                    animationClosed = true;
                    animationPaused = false;
                    if (!options.$$skipPreparationClasses) {
                        $$jqLite.removeClass(element, preparationClasses);
                    }
                    $$jqLite.removeClass(element, activeClasses);
                    blockKeyframeAnimations(node, false);
                    blockTransitions(node, false);
                    forEach(temporaryStyles, function(entry) {
                        node.style[entry[0]] = "";
                    });
                    applyAnimationClasses(element, options);
                    applyAnimationStyles(element, options);
                    if (Object.keys(restoreStyles).length) {
                        forEach(restoreStyles, function(value, prop) {
                            if (value) {
                                node.style.setProperty(prop, value);
                            } else {
                                node.style.removeProperty(prop);
                            }
                        });
                    }
                    if (options.onDone) {
                        options.onDone();
                    }
                    if (events && events.length) {
                        element.off(events.join(" "), onAnimationProgress);
                    }
                    var animationTimerData = element.data(ANIMATE_TIMER_KEY);
                    if (animationTimerData) {
                        $timeout.cancel(animationTimerData[0].timer);
                        element.removeData(ANIMATE_TIMER_KEY);
                    }
                    if (runner) {
                        runner.complete(!rejected);
                    }
                }
                function applyBlocking(duration) {
                    if (flags.blockTransition) {
                        blockTransitions(node, duration);
                    }
                    if (flags.blockKeyframeAnimation) {
                        blockKeyframeAnimations(node, !!duration);
                    }
                }
                function closeAndReturnNoopAnimator() {
                    runner = new $$AnimateRunner({
                        end: endFn,
                        cancel: cancelFn
                    });
                    waitUntilQuiet(noop);
                    close();
                    return {
                        $$willAnimate: false,
                        start: function() {
                            return runner;
                        },
                        end: endFn
                    };
                }
                function onAnimationProgress(event) {
                    event.stopPropagation();
                    var ev = event.originalEvent || event;
                    var timeStamp = ev.$manualTimeStamp || Date.now();
                    var elapsedTime = parseFloat(ev.elapsedTime.toFixed(ELAPSED_TIME_MAX_DECIMAL_PLACES));
                    if (Math.max(timeStamp - startTime, 0) >= maxDelayTime && elapsedTime >= maxDuration) {
                        animationCompleted = true;
                        close();
                    }
                }
                function start() {
                    if (animationClosed) return;
                    if (!node.parentNode) {
                        close();
                        return;
                    }
                    var playPause = function(playAnimation) {
                        if (!animationCompleted) {
                            animationPaused = !playAnimation;
                            if (timings.animationDuration) {
                                var value = blockKeyframeAnimations(node, animationPaused);
                                if (animationPaused) {
                                    temporaryStyles.push(value);
                                } else {
                                    removeFromArray(temporaryStyles, value);
                                }
                            }
                        } else if (animationPaused && playAnimation) {
                            animationPaused = false;
                            close();
                        }
                    };
                    var maxStagger = itemIndex > 0 && (timings.transitionDuration && stagger.transitionDuration === 0 || timings.animationDuration && stagger.animationDuration === 0) && Math.max(stagger.animationDelay, stagger.transitionDelay);
                    if (maxStagger) {
                        $timeout(triggerAnimationStart, Math.floor(maxStagger * itemIndex * ONE_SECOND), false);
                    } else {
                        triggerAnimationStart();
                    }
                    runnerHost.resume = function() {
                        playPause(true);
                    };
                    runnerHost.pause = function() {
                        playPause(false);
                    };
                    function triggerAnimationStart() {
                        if (animationClosed) return;
                        applyBlocking(false);
                        forEach(temporaryStyles, function(entry) {
                            var key = entry[0];
                            var value = entry[1];
                            node.style[key] = value;
                        });
                        applyAnimationClasses(element, options);
                        $$jqLite.addClass(element, activeClasses);
                        if (flags.recalculateTimingStyles) {
                            fullClassName = node.className + " " + preparationClasses;
                            cacheKey = gcsHashFn(node, fullClassName);
                            timings = computeTimings(node, fullClassName, cacheKey);
                            relativeDelay = timings.maxDelay;
                            maxDelay = Math.max(relativeDelay, 0);
                            maxDuration = timings.maxDuration;
                            if (maxDuration === 0) {
                                close();
                                return;
                            }
                            flags.hasTransitions = timings.transitionDuration > 0;
                            flags.hasAnimations = timings.animationDuration > 0;
                        }
                        if (flags.applyAnimationDelay) {
                            relativeDelay = typeof options.delay !== "boolean" && truthyTimingValue(options.delay) ? parseFloat(options.delay) : relativeDelay;
                            maxDelay = Math.max(relativeDelay, 0);
                            timings.animationDelay = relativeDelay;
                            delayStyle = getCssDelayStyle(relativeDelay, true);
                            temporaryStyles.push(delayStyle);
                            node.style[delayStyle[0]] = delayStyle[1];
                        }
                        maxDelayTime = maxDelay * ONE_SECOND;
                        maxDurationTime = maxDuration * ONE_SECOND;
                        if (options.easing) {
                            var easeProp, easeVal = options.easing;
                            if (flags.hasTransitions) {
                                easeProp = TRANSITION_PROP + TIMING_KEY;
                                temporaryStyles.push([ easeProp, easeVal ]);
                                node.style[easeProp] = easeVal;
                            }
                            if (flags.hasAnimations) {
                                easeProp = ANIMATION_PROP + TIMING_KEY;
                                temporaryStyles.push([ easeProp, easeVal ]);
                                node.style[easeProp] = easeVal;
                            }
                        }
                        if (timings.transitionDuration) {
                            events.push(TRANSITIONEND_EVENT);
                        }
                        if (timings.animationDuration) {
                            events.push(ANIMATIONEND_EVENT);
                        }
                        startTime = Date.now();
                        var timerTime = maxDelayTime + CLOSING_TIME_BUFFER * maxDurationTime;
                        var endTime = startTime + timerTime;
                        var animationsData = element.data(ANIMATE_TIMER_KEY) || [];
                        var setupFallbackTimer = true;
                        if (animationsData.length) {
                            var currentTimerData = animationsData[0];
                            setupFallbackTimer = endTime > currentTimerData.expectedEndTime;
                            if (setupFallbackTimer) {
                                $timeout.cancel(currentTimerData.timer);
                            } else {
                                animationsData.push(close);
                            }
                        }
                        if (setupFallbackTimer) {
                            var timer = $timeout(onAnimationExpired, timerTime, false);
                            animationsData[0] = {
                                timer: timer,
                                expectedEndTime: endTime
                            };
                            animationsData.push(close);
                            element.data(ANIMATE_TIMER_KEY, animationsData);
                        }
                        if (events.length) {
                            element.on(events.join(" "), onAnimationProgress);
                        }
                        if (options.to) {
                            if (options.cleanupStyles) {
                                registerRestorableStyles(restoreStyles, node, Object.keys(options.to));
                            }
                            applyAnimationToStyles(element, options);
                        }
                    }
                    function onAnimationExpired() {
                        var animationsData = element.data(ANIMATE_TIMER_KEY);
                        if (animationsData) {
                            for (var i = 1; i < animationsData.length; i++) {
                                animationsData[i]();
                            }
                            element.removeData(ANIMATE_TIMER_KEY);
                        }
                    }
                }
            };
        } ];
    } ];
    var $$AnimateCssDriverProvider = [ "$$animationProvider", function($$animationProvider) {
        $$animationProvider.drivers.push("$$animateCssDriver");
        var NG_ANIMATE_SHIM_CLASS_NAME = "ng-animate-shim";
        var NG_ANIMATE_ANCHOR_CLASS_NAME = "ng-anchor";
        var NG_OUT_ANCHOR_CLASS_NAME = "ng-anchor-out";
        var NG_IN_ANCHOR_CLASS_NAME = "ng-anchor-in";
        function isDocumentFragment(node) {
            return node.parentNode && node.parentNode.nodeType === 11;
        }
        this.$get = [ "$animateCss", "$rootScope", "$$AnimateRunner", "$rootElement", "$sniffer", "$$jqLite", "$document", function($animateCss, $rootScope, $$AnimateRunner, $rootElement, $sniffer, $$jqLite, $document) {
            if (!$sniffer.animations && !$sniffer.transitions) return noop;
            var bodyNode = $document[0].body;
            var rootNode = getDomNode($rootElement);
            var rootBodyElement = jqLite(isDocumentFragment(rootNode) || bodyNode.contains(rootNode) ? rootNode : bodyNode);
            return function initDriverFn(animationDetails) {
                return animationDetails.from && animationDetails.to ? prepareFromToAnchorAnimation(animationDetails.from, animationDetails.to, animationDetails.classes, animationDetails.anchors) : prepareRegularAnimation(animationDetails);
            };
            function filterCssClasses(classes) {
                return classes.replace(/\bng-\S+\b/g, "");
            }
            function getUniqueValues(a, b) {
                if (isString(a)) a = a.split(" ");
                if (isString(b)) b = b.split(" ");
                return a.filter(function(val) {
                    return b.indexOf(val) === -1;
                }).join(" ");
            }
            function prepareAnchoredAnimation(classes, outAnchor, inAnchor) {
                var clone = jqLite(getDomNode(outAnchor).cloneNode(true));
                var startingClasses = filterCssClasses(getClassVal(clone));
                outAnchor.addClass(NG_ANIMATE_SHIM_CLASS_NAME);
                inAnchor.addClass(NG_ANIMATE_SHIM_CLASS_NAME);
                clone.addClass(NG_ANIMATE_ANCHOR_CLASS_NAME);
                rootBodyElement.append(clone);
                var animatorIn, animatorOut = prepareOutAnimation();
                if (!animatorOut) {
                    animatorIn = prepareInAnimation();
                    if (!animatorIn) {
                        return end();
                    }
                }
                var startingAnimator = animatorOut || animatorIn;
                return {
                    start: function() {
                        var runner;
                        var currentAnimation = startingAnimator.start();
                        currentAnimation.done(function() {
                            currentAnimation = null;
                            if (!animatorIn) {
                                animatorIn = prepareInAnimation();
                                if (animatorIn) {
                                    currentAnimation = animatorIn.start();
                                    currentAnimation.done(function() {
                                        currentAnimation = null;
                                        end();
                                        runner.complete();
                                    });
                                    return currentAnimation;
                                }
                            }
                            end();
                            runner.complete();
                        });
                        runner = new $$AnimateRunner({
                            end: endFn,
                            cancel: endFn
                        });
                        return runner;
                        function endFn() {
                            if (currentAnimation) {
                                currentAnimation.end();
                            }
                        }
                    }
                };
                function calculateAnchorStyles(anchor) {
                    var styles = {};
                    var coords = getDomNode(anchor).getBoundingClientRect();
                    forEach([ "width", "height", "top", "left" ], function(key) {
                        var value = coords[key];
                        switch (key) {
                          case "top":
                            value += bodyNode.scrollTop;
                            break;

                          case "left":
                            value += bodyNode.scrollLeft;
                            break;
                        }
                        styles[key] = Math.floor(value) + "px";
                    });
                    return styles;
                }
                function prepareOutAnimation() {
                    var animator = $animateCss(clone, {
                        addClass: NG_OUT_ANCHOR_CLASS_NAME,
                        delay: true,
                        from: calculateAnchorStyles(outAnchor)
                    });
                    return animator.$$willAnimate ? animator : null;
                }
                function getClassVal(element) {
                    return element.attr("class") || "";
                }
                function prepareInAnimation() {
                    var endingClasses = filterCssClasses(getClassVal(inAnchor));
                    var toAdd = getUniqueValues(endingClasses, startingClasses);
                    var toRemove = getUniqueValues(startingClasses, endingClasses);
                    var animator = $animateCss(clone, {
                        to: calculateAnchorStyles(inAnchor),
                        addClass: NG_IN_ANCHOR_CLASS_NAME + " " + toAdd,
                        removeClass: NG_OUT_ANCHOR_CLASS_NAME + " " + toRemove,
                        delay: true
                    });
                    return animator.$$willAnimate ? animator : null;
                }
                function end() {
                    clone.remove();
                    outAnchor.removeClass(NG_ANIMATE_SHIM_CLASS_NAME);
                    inAnchor.removeClass(NG_ANIMATE_SHIM_CLASS_NAME);
                }
            }
            function prepareFromToAnchorAnimation(from, to, classes, anchors) {
                var fromAnimation = prepareRegularAnimation(from, noop);
                var toAnimation = prepareRegularAnimation(to, noop);
                var anchorAnimations = [];
                forEach(anchors, function(anchor) {
                    var outElement = anchor["out"];
                    var inElement = anchor["in"];
                    var animator = prepareAnchoredAnimation(classes, outElement, inElement);
                    if (animator) {
                        anchorAnimations.push(animator);
                    }
                });
                if (!fromAnimation && !toAnimation && anchorAnimations.length === 0) return;
                return {
                    start: function() {
                        var animationRunners = [];
                        if (fromAnimation) {
                            animationRunners.push(fromAnimation.start());
                        }
                        if (toAnimation) {
                            animationRunners.push(toAnimation.start());
                        }
                        forEach(anchorAnimations, function(animation) {
                            animationRunners.push(animation.start());
                        });
                        var runner = new $$AnimateRunner({
                            end: endFn,
                            cancel: endFn
                        });
                        $$AnimateRunner.all(animationRunners, function(status) {
                            runner.complete(status);
                        });
                        return runner;
                        function endFn() {
                            forEach(animationRunners, function(runner) {
                                runner.end();
                            });
                        }
                    }
                };
            }
            function prepareRegularAnimation(animationDetails) {
                var element = animationDetails.element;
                var options = animationDetails.options || {};
                if (animationDetails.structural) {
                    options.event = animationDetails.event;
                    options.structural = true;
                    options.applyClassesEarly = true;
                    if (animationDetails.event === "leave") {
                        options.onDone = options.domOperation;
                    }
                }
                if (options.preparationClasses) {
                    options.event = concatWithSpace(options.event, options.preparationClasses);
                }
                var animator = $animateCss(element, options);
                return animator.$$willAnimate ? animator : null;
            }
        } ];
    } ];
    var $$AnimateJsProvider = [ "$animateProvider", function($animateProvider) {
        this.$get = [ "$injector", "$$AnimateRunner", "$$jqLite", function($injector, $$AnimateRunner, $$jqLite) {
            var applyAnimationClasses = applyAnimationClassesFactory($$jqLite);
            return function(element, event, classes, options) {
                var animationClosed = false;
                if (arguments.length === 3 && isObject(classes)) {
                    options = classes;
                    classes = null;
                }
                options = prepareAnimationOptions(options);
                if (!classes) {
                    classes = element.attr("class") || "";
                    if (options.addClass) {
                        classes += " " + options.addClass;
                    }
                    if (options.removeClass) {
                        classes += " " + options.removeClass;
                    }
                }
                var classesToAdd = options.addClass;
                var classesToRemove = options.removeClass;
                var animations = lookupAnimations(classes);
                var before, after;
                if (animations.length) {
                    var afterFn, beforeFn;
                    if (event === "leave") {
                        beforeFn = "leave";
                        afterFn = "afterLeave";
                    } else {
                        beforeFn = "before" + event.charAt(0).toUpperCase() + event.substr(1);
                        afterFn = event;
                    }
                    if (event !== "enter" && event !== "move") {
                        before = packageAnimations(element, event, options, animations, beforeFn);
                    }
                    after = packageAnimations(element, event, options, animations, afterFn);
                }
                if (!before && !after) return;
                function applyOptions() {
                    options.domOperation();
                    applyAnimationClasses(element, options);
                }
                function close() {
                    animationClosed = true;
                    applyOptions();
                    applyAnimationStyles(element, options);
                }
                var runner;
                return {
                    $$willAnimate: true,
                    end: function() {
                        if (runner) {
                            runner.end();
                        } else {
                            close();
                            runner = new $$AnimateRunner();
                            runner.complete(true);
                        }
                        return runner;
                    },
                    start: function() {
                        if (runner) {
                            return runner;
                        }
                        runner = new $$AnimateRunner();
                        var closeActiveAnimations;
                        var chain = [];
                        if (before) {
                            chain.push(function(fn) {
                                closeActiveAnimations = before(fn);
                            });
                        }
                        if (chain.length) {
                            chain.push(function(fn) {
                                applyOptions();
                                fn(true);
                            });
                        } else {
                            applyOptions();
                        }
                        if (after) {
                            chain.push(function(fn) {
                                closeActiveAnimations = after(fn);
                            });
                        }
                        runner.setHost({
                            end: function() {
                                endAnimations();
                            },
                            cancel: function() {
                                endAnimations(true);
                            }
                        });
                        $$AnimateRunner.chain(chain, onComplete);
                        return runner;
                        function onComplete(success) {
                            close(success);
                            runner.complete(success);
                        }
                        function endAnimations(cancelled) {
                            if (!animationClosed) {
                                (closeActiveAnimations || noop)(cancelled);
                                onComplete(cancelled);
                            }
                        }
                    }
                };
                function executeAnimationFn(fn, element, event, options, onDone) {
                    var args;
                    switch (event) {
                      case "animate":
                        args = [ element, options.from, options.to, onDone ];
                        break;

                      case "setClass":
                        args = [ element, classesToAdd, classesToRemove, onDone ];
                        break;

                      case "addClass":
                        args = [ element, classesToAdd, onDone ];
                        break;

                      case "removeClass":
                        args = [ element, classesToRemove, onDone ];
                        break;

                      default:
                        args = [ element, onDone ];
                        break;
                    }
                    args.push(options);
                    var value = fn.apply(fn, args);
                    if (value) {
                        if (isFunction(value.start)) {
                            value = value.start();
                        }
                        if (value instanceof $$AnimateRunner) {
                            value.done(onDone);
                        } else if (isFunction(value)) {
                            return value;
                        }
                    }
                    return noop;
                }
                function groupEventedAnimations(element, event, options, animations, fnName) {
                    var operations = [];
                    forEach(animations, function(ani) {
                        var animation = ani[fnName];
                        if (!animation) return;
                        operations.push(function() {
                            var runner;
                            var endProgressCb;
                            var resolved = false;
                            var onAnimationComplete = function(rejected) {
                                if (!resolved) {
                                    resolved = true;
                                    (endProgressCb || noop)(rejected);
                                    runner.complete(!rejected);
                                }
                            };
                            runner = new $$AnimateRunner({
                                end: function() {
                                    onAnimationComplete();
                                },
                                cancel: function() {
                                    onAnimationComplete(true);
                                }
                            });
                            endProgressCb = executeAnimationFn(animation, element, event, options, function(result) {
                                var cancelled = result === false;
                                onAnimationComplete(cancelled);
                            });
                            return runner;
                        });
                    });
                    return operations;
                }
                function packageAnimations(element, event, options, animations, fnName) {
                    var operations = groupEventedAnimations(element, event, options, animations, fnName);
                    if (operations.length === 0) {
                        var a, b;
                        if (fnName === "beforeSetClass") {
                            a = groupEventedAnimations(element, "removeClass", options, animations, "beforeRemoveClass");
                            b = groupEventedAnimations(element, "addClass", options, animations, "beforeAddClass");
                        } else if (fnName === "setClass") {
                            a = groupEventedAnimations(element, "removeClass", options, animations, "removeClass");
                            b = groupEventedAnimations(element, "addClass", options, animations, "addClass");
                        }
                        if (a) {
                            operations = operations.concat(a);
                        }
                        if (b) {
                            operations = operations.concat(b);
                        }
                    }
                    if (operations.length === 0) return;
                    return function startAnimation(callback) {
                        var runners = [];
                        if (operations.length) {
                            forEach(operations, function(animateFn) {
                                runners.push(animateFn());
                            });
                        }
                        if (runners.length) {
                            $$AnimateRunner.all(runners, callback);
                        } else {
                            callback();
                        }
                        return function endFn(reject) {
                            forEach(runners, function(runner) {
                                if (reject) {
                                    runner.cancel();
                                } else {
                                    runner.end();
                                }
                            });
                        };
                    };
                }
            };
            function lookupAnimations(classes) {
                classes = isArray(classes) ? classes : classes.split(" ");
                var matches = [], flagMap = {};
                for (var i = 0; i < classes.length; i++) {
                    var klass = classes[i], animationFactory = $animateProvider.$$registeredAnimations[klass];
                    if (animationFactory && !flagMap[klass]) {
                        matches.push($injector.get(animationFactory));
                        flagMap[klass] = true;
                    }
                }
                return matches;
            }
        } ];
    } ];
    var $$AnimateJsDriverProvider = [ "$$animationProvider", function($$animationProvider) {
        $$animationProvider.drivers.push("$$animateJsDriver");
        this.$get = [ "$$animateJs", "$$AnimateRunner", function($$animateJs, $$AnimateRunner) {
            return function initDriverFn(animationDetails) {
                if (animationDetails.from && animationDetails.to) {
                    var fromAnimation = prepareAnimation(animationDetails.from);
                    var toAnimation = prepareAnimation(animationDetails.to);
                    if (!fromAnimation && !toAnimation) return;
                    return {
                        start: function() {
                            var animationRunners = [];
                            if (fromAnimation) {
                                animationRunners.push(fromAnimation.start());
                            }
                            if (toAnimation) {
                                animationRunners.push(toAnimation.start());
                            }
                            $$AnimateRunner.all(animationRunners, done);
                            var runner = new $$AnimateRunner({
                                end: endFnFactory(),
                                cancel: endFnFactory()
                            });
                            return runner;
                            function endFnFactory() {
                                return function() {
                                    forEach(animationRunners, function(runner) {
                                        runner.end();
                                    });
                                };
                            }
                            function done(status) {
                                runner.complete(status);
                            }
                        }
                    };
                } else {
                    return prepareAnimation(animationDetails);
                }
            };
            function prepareAnimation(animationDetails) {
                var element = animationDetails.element;
                var event = animationDetails.event;
                var options = animationDetails.options;
                var classes = animationDetails.classes;
                return $$animateJs(element, event, classes, options);
            }
        } ];
    } ];
    var NG_ANIMATE_ATTR_NAME = "data-ng-animate";
    var NG_ANIMATE_PIN_DATA = "$ngAnimatePin";
    var $$AnimateQueueProvider = [ "$animateProvider", function($animateProvider) {
        var PRE_DIGEST_STATE = 1;
        var RUNNING_STATE = 2;
        var ONE_SPACE = " ";
        var rules = this.rules = {
            skip: [],
            cancel: [],
            join: []
        };
        function makeTruthyCssClassMap(classString) {
            if (!classString) {
                return null;
            }
            var keys = classString.split(ONE_SPACE);
            var map = Object.create(null);
            forEach(keys, function(key) {
                map[key] = true;
            });
            return map;
        }
        function hasMatchingClasses(newClassString, currentClassString) {
            if (newClassString && currentClassString) {
                var currentClassMap = makeTruthyCssClassMap(currentClassString);
                return newClassString.split(ONE_SPACE).some(function(className) {
                    return currentClassMap[className];
                });
            }
        }
        function isAllowed(ruleType, element, currentAnimation, previousAnimation) {
            return rules[ruleType].some(function(fn) {
                return fn(element, currentAnimation, previousAnimation);
            });
        }
        function hasAnimationClasses(animation, and) {
            var a = (animation.addClass || "").length > 0;
            var b = (animation.removeClass || "").length > 0;
            return and ? a && b : a || b;
        }
        rules.join.push(function(element, newAnimation, currentAnimation) {
            return !newAnimation.structural && hasAnimationClasses(newAnimation);
        });
        rules.skip.push(function(element, newAnimation, currentAnimation) {
            return !newAnimation.structural && !hasAnimationClasses(newAnimation);
        });
        rules.skip.push(function(element, newAnimation, currentAnimation) {
            return currentAnimation.event === "leave" && newAnimation.structural;
        });
        rules.skip.push(function(element, newAnimation, currentAnimation) {
            return currentAnimation.structural && currentAnimation.state === RUNNING_STATE && !newAnimation.structural;
        });
        rules.cancel.push(function(element, newAnimation, currentAnimation) {
            return currentAnimation.structural && newAnimation.structural;
        });
        rules.cancel.push(function(element, newAnimation, currentAnimation) {
            return currentAnimation.state === RUNNING_STATE && newAnimation.structural;
        });
        rules.cancel.push(function(element, newAnimation, currentAnimation) {
            if (currentAnimation.structural) return false;
            var nA = newAnimation.addClass;
            var nR = newAnimation.removeClass;
            var cA = currentAnimation.addClass;
            var cR = currentAnimation.removeClass;
            if (isUndefined(nA) && isUndefined(nR) || isUndefined(cA) && isUndefined(cR)) {
                return false;
            }
            return hasMatchingClasses(nA, cR) || hasMatchingClasses(nR, cA);
        });
        this.$get = [ "$$rAF", "$rootScope", "$rootElement", "$document", "$$HashMap", "$$animation", "$$AnimateRunner", "$templateRequest", "$$jqLite", "$$forceReflow", function($$rAF, $rootScope, $rootElement, $document, $$HashMap, $$animation, $$AnimateRunner, $templateRequest, $$jqLite, $$forceReflow) {
            var activeAnimationsLookup = new $$HashMap();
            var disabledElementsLookup = new $$HashMap();
            var animationsEnabled = null;
            function postDigestTaskFactory() {
                var postDigestCalled = false;
                return function(fn) {
                    if (postDigestCalled) {
                        fn();
                    } else {
                        $rootScope.$$postDigest(function() {
                            postDigestCalled = true;
                            fn();
                        });
                    }
                };
            }
            var deregisterWatch = $rootScope.$watch(function() {
                return $templateRequest.totalPendingRequests === 0;
            }, function(isEmpty) {
                if (!isEmpty) return;
                deregisterWatch();
                $rootScope.$$postDigest(function() {
                    $rootScope.$$postDigest(function() {
                        if (animationsEnabled === null) {
                            animationsEnabled = true;
                        }
                    });
                });
            });
            var callbackRegistry = Object.create(null);
            var classNameFilter = $animateProvider.classNameFilter();
            var isAnimatableClassName = !classNameFilter ? function() {
                return true;
            } : function(className) {
                return classNameFilter.test(className);
            };
            var applyAnimationClasses = applyAnimationClassesFactory($$jqLite);
            function normalizeAnimationDetails(element, animation) {
                return mergeAnimationDetails(element, animation, {});
            }
            var contains = window.Node.prototype.contains || function(arg) {
                return this === arg || !!(this.compareDocumentPosition(arg) & 16);
            };
            function findCallbacks(parent, element, event) {
                var targetNode = getDomNode(element);
                var targetParentNode = getDomNode(parent);
                var matches = [];
                var entries = callbackRegistry[event];
                if (entries) {
                    forEach(entries, function(entry) {
                        if (contains.call(entry.node, targetNode)) {
                            matches.push(entry.callback);
                        } else if (event === "leave" && contains.call(entry.node, targetParentNode)) {
                            matches.push(entry.callback);
                        }
                    });
                }
                return matches;
            }
            function filterFromRegistry(list, matchContainer, matchCallback) {
                var containerNode = extractElementNode(matchContainer);
                return list.filter(function(entry) {
                    var isMatch = entry.node === containerNode && (!matchCallback || entry.callback === matchCallback);
                    return !isMatch;
                });
            }
            function cleanupEventListeners(phase, element) {
                if (phase === "close" && !element[0].parentNode) {
                    $animate.off(element);
                }
            }
            var $animate = {
                on: function(event, container, callback) {
                    var node = extractElementNode(container);
                    callbackRegistry[event] = callbackRegistry[event] || [];
                    callbackRegistry[event].push({
                        node: node,
                        callback: callback
                    });
                    jqLite(container).on("$destroy", function() {
                        var animationDetails = activeAnimationsLookup.get(node);
                        if (!animationDetails) {
                            $animate.off(event, container, callback);
                        }
                    });
                },
                off: function(event, container, callback) {
                    if (arguments.length === 1 && !isString(arguments[0])) {
                        container = arguments[0];
                        for (var eventType in callbackRegistry) {
                            callbackRegistry[eventType] = filterFromRegistry(callbackRegistry[eventType], container);
                        }
                        return;
                    }
                    var entries = callbackRegistry[event];
                    if (!entries) return;
                    callbackRegistry[event] = arguments.length === 1 ? null : filterFromRegistry(entries, container, callback);
                },
                pin: function(element, parentElement) {
                    assertArg(isElement(element), "element", "not an element");
                    assertArg(isElement(parentElement), "parentElement", "not an element");
                    element.data(NG_ANIMATE_PIN_DATA, parentElement);
                },
                push: function(element, event, options, domOperation) {
                    options = options || {};
                    options.domOperation = domOperation;
                    return queueAnimation(element, event, options);
                },
                enabled: function(element, bool) {
                    var argCount = arguments.length;
                    if (argCount === 0) {
                        bool = !!animationsEnabled;
                    } else {
                        var hasElement = isElement(element);
                        if (!hasElement) {
                            bool = animationsEnabled = !!element;
                        } else {
                            var node = getDomNode(element);
                            if (argCount === 1) {
                                bool = !disabledElementsLookup.get(node);
                            } else {
                                disabledElementsLookup.put(node, !bool);
                            }
                        }
                    }
                    return bool;
                }
            };
            return $animate;
            function queueAnimation(element, event, initialOptions) {
                var options = copy(initialOptions);
                var node, parent;
                element = stripCommentsFromElement(element);
                if (element) {
                    node = getDomNode(element);
                    parent = element.parent();
                }
                options = prepareAnimationOptions(options);
                var runner = new $$AnimateRunner();
                var runInNextPostDigestOrNow = postDigestTaskFactory();
                if (isArray(options.addClass)) {
                    options.addClass = options.addClass.join(" ");
                }
                if (options.addClass && !isString(options.addClass)) {
                    options.addClass = null;
                }
                if (isArray(options.removeClass)) {
                    options.removeClass = options.removeClass.join(" ");
                }
                if (options.removeClass && !isString(options.removeClass)) {
                    options.removeClass = null;
                }
                if (options.from && !isObject(options.from)) {
                    options.from = null;
                }
                if (options.to && !isObject(options.to)) {
                    options.to = null;
                }
                if (!node) {
                    close();
                    return runner;
                }
                var className = [ node.className, options.addClass, options.removeClass ].join(" ");
                if (!isAnimatableClassName(className)) {
                    close();
                    return runner;
                }
                var isStructural = [ "enter", "move", "leave" ].indexOf(event) >= 0;
                var documentHidden = $document[0].hidden;
                var skipAnimations = !animationsEnabled || documentHidden || disabledElementsLookup.get(node);
                var existingAnimation = !skipAnimations && activeAnimationsLookup.get(node) || {};
                var hasExistingAnimation = !!existingAnimation.state;
                if (!skipAnimations && (!hasExistingAnimation || existingAnimation.state !== PRE_DIGEST_STATE)) {
                    skipAnimations = !areAnimationsAllowed(element, parent, event);
                }
                if (skipAnimations) {
                    if (documentHidden) notifyProgress(runner, event, "start");
                    close();
                    if (documentHidden) notifyProgress(runner, event, "close");
                    return runner;
                }
                if (isStructural) {
                    closeChildAnimations(element);
                }
                var newAnimation = {
                    structural: isStructural,
                    element: element,
                    event: event,
                    addClass: options.addClass,
                    removeClass: options.removeClass,
                    close: close,
                    options: options,
                    runner: runner
                };
                if (hasExistingAnimation) {
                    var skipAnimationFlag = isAllowed("skip", element, newAnimation, existingAnimation);
                    if (skipAnimationFlag) {
                        if (existingAnimation.state === RUNNING_STATE) {
                            close();
                            return runner;
                        } else {
                            mergeAnimationDetails(element, existingAnimation, newAnimation);
                            return existingAnimation.runner;
                        }
                    }
                    var cancelAnimationFlag = isAllowed("cancel", element, newAnimation, existingAnimation);
                    if (cancelAnimationFlag) {
                        if (existingAnimation.state === RUNNING_STATE) {
                            existingAnimation.runner.end();
                        } else if (existingAnimation.structural) {
                            existingAnimation.close();
                        } else {
                            mergeAnimationDetails(element, existingAnimation, newAnimation);
                            return existingAnimation.runner;
                        }
                    } else {
                        var joinAnimationFlag = isAllowed("join", element, newAnimation, existingAnimation);
                        if (joinAnimationFlag) {
                            if (existingAnimation.state === RUNNING_STATE) {
                                normalizeAnimationDetails(element, newAnimation);
                            } else {
                                applyGeneratedPreparationClasses(element, isStructural ? event : null, options);
                                event = newAnimation.event = existingAnimation.event;
                                options = mergeAnimationDetails(element, existingAnimation, newAnimation);
                                return existingAnimation.runner;
                            }
                        }
                    }
                } else {
                    normalizeAnimationDetails(element, newAnimation);
                }
                var isValidAnimation = newAnimation.structural;
                if (!isValidAnimation) {
                    isValidAnimation = newAnimation.event === "animate" && Object.keys(newAnimation.options.to || {}).length > 0 || hasAnimationClasses(newAnimation);
                }
                if (!isValidAnimation) {
                    close();
                    clearElementAnimationState(element);
                    return runner;
                }
                var counter = (existingAnimation.counter || 0) + 1;
                newAnimation.counter = counter;
                markElementAnimationState(element, PRE_DIGEST_STATE, newAnimation);
                $rootScope.$$postDigest(function() {
                    var animationDetails = activeAnimationsLookup.get(node);
                    var animationCancelled = !animationDetails;
                    animationDetails = animationDetails || {};
                    var parentElement = element.parent() || [];
                    var isValidAnimation = parentElement.length > 0 && (animationDetails.event === "animate" || animationDetails.structural || hasAnimationClasses(animationDetails));
                    if (animationCancelled || animationDetails.counter !== counter || !isValidAnimation) {
                        if (animationCancelled) {
                            applyAnimationClasses(element, options);
                            applyAnimationStyles(element, options);
                        }
                        if (animationCancelled || isStructural && animationDetails.event !== event) {
                            options.domOperation();
                            runner.end();
                        }
                        if (!isValidAnimation) {
                            clearElementAnimationState(element);
                        }
                        return;
                    }
                    event = !animationDetails.structural && hasAnimationClasses(animationDetails, true) ? "setClass" : animationDetails.event;
                    markElementAnimationState(element, RUNNING_STATE);
                    var realRunner = $$animation(element, event, animationDetails.options);
                    runner.setHost(realRunner);
                    notifyProgress(runner, event, "start", {});
                    realRunner.done(function(status) {
                        close(!status);
                        var animationDetails = activeAnimationsLookup.get(node);
                        if (animationDetails && animationDetails.counter === counter) {
                            clearElementAnimationState(getDomNode(element));
                        }
                        notifyProgress(runner, event, "close", {});
                    });
                });
                return runner;
                function notifyProgress(runner, event, phase, data) {
                    runInNextPostDigestOrNow(function() {
                        var callbacks = findCallbacks(parent, element, event);
                        if (callbacks.length) {
                            $$rAF(function() {
                                forEach(callbacks, function(callback) {
                                    callback(element, phase, data);
                                });
                                cleanupEventListeners(phase, element);
                            });
                        } else {
                            cleanupEventListeners(phase, element);
                        }
                    });
                    runner.progress(event, phase, data);
                }
                function close(reject) {
                    clearGeneratedClasses(element, options);
                    applyAnimationClasses(element, options);
                    applyAnimationStyles(element, options);
                    options.domOperation();
                    runner.complete(!reject);
                }
            }
            function closeChildAnimations(element) {
                var node = getDomNode(element);
                var children = node.querySelectorAll("[" + NG_ANIMATE_ATTR_NAME + "]");
                forEach(children, function(child) {
                    var state = parseInt(child.getAttribute(NG_ANIMATE_ATTR_NAME), 10);
                    var animationDetails = activeAnimationsLookup.get(child);
                    if (animationDetails) {
                        switch (state) {
                          case RUNNING_STATE:
                            animationDetails.runner.end();

                          case PRE_DIGEST_STATE:
                            activeAnimationsLookup.remove(child);
                            break;
                        }
                    }
                });
            }
            function clearElementAnimationState(element) {
                var node = getDomNode(element);
                node.removeAttribute(NG_ANIMATE_ATTR_NAME);
                activeAnimationsLookup.remove(node);
            }
            function isMatchingElement(nodeOrElmA, nodeOrElmB) {
                return getDomNode(nodeOrElmA) === getDomNode(nodeOrElmB);
            }
            function areAnimationsAllowed(element, parentElement, event) {
                var bodyElement = jqLite($document[0].body);
                var bodyElementDetected = isMatchingElement(element, bodyElement) || element[0].nodeName === "HTML";
                var rootElementDetected = isMatchingElement(element, $rootElement);
                var parentAnimationDetected = false;
                var animateChildren;
                var elementDisabled = disabledElementsLookup.get(getDomNode(element));
                var parentHost = jqLite.data(element[0], NG_ANIMATE_PIN_DATA);
                if (parentHost) {
                    parentElement = parentHost;
                }
                parentElement = getDomNode(parentElement);
                while (parentElement) {
                    if (!rootElementDetected) {
                        rootElementDetected = isMatchingElement(parentElement, $rootElement);
                    }
                    if (parentElement.nodeType !== ELEMENT_NODE) {
                        break;
                    }
                    var details = activeAnimationsLookup.get(parentElement) || {};
                    if (!parentAnimationDetected) {
                        var parentElementDisabled = disabledElementsLookup.get(parentElement);
                        if (parentElementDisabled === true && elementDisabled !== false) {
                            elementDisabled = true;
                            break;
                        } else if (parentElementDisabled === false) {
                            elementDisabled = false;
                        }
                        parentAnimationDetected = details.structural;
                    }
                    if (isUndefined(animateChildren) || animateChildren === true) {
                        var value = jqLite.data(parentElement, NG_ANIMATE_CHILDREN_DATA);
                        if (isDefined(value)) {
                            animateChildren = value;
                        }
                    }
                    if (parentAnimationDetected && animateChildren === false) break;
                    if (!bodyElementDetected) {
                        bodyElementDetected = isMatchingElement(parentElement, bodyElement);
                    }
                    if (bodyElementDetected && rootElementDetected) {
                        break;
                    }
                    if (!rootElementDetected) {
                        parentHost = jqLite.data(parentElement, NG_ANIMATE_PIN_DATA);
                        if (parentHost) {
                            parentElement = getDomNode(parentHost);
                            continue;
                        }
                    }
                    parentElement = parentElement.parentNode;
                }
                var allowAnimation = (!parentAnimationDetected || animateChildren) && elementDisabled !== true;
                return allowAnimation && rootElementDetected && bodyElementDetected;
            }
            function markElementAnimationState(element, state, details) {
                details = details || {};
                details.state = state;
                var node = getDomNode(element);
                node.setAttribute(NG_ANIMATE_ATTR_NAME, state);
                var oldValue = activeAnimationsLookup.get(node);
                var newValue = oldValue ? extend(oldValue, details) : details;
                activeAnimationsLookup.put(node, newValue);
            }
        } ];
    } ];
    var $$AnimationProvider = [ "$animateProvider", function($animateProvider) {
        var NG_ANIMATE_REF_ATTR = "ng-animate-ref";
        var drivers = this.drivers = [];
        var RUNNER_STORAGE_KEY = "$$animationRunner";
        function setRunner(element, runner) {
            element.data(RUNNER_STORAGE_KEY, runner);
        }
        function removeRunner(element) {
            element.removeData(RUNNER_STORAGE_KEY);
        }
        function getRunner(element) {
            return element.data(RUNNER_STORAGE_KEY);
        }
        this.$get = [ "$$jqLite", "$rootScope", "$injector", "$$AnimateRunner", "$$HashMap", "$$rAFScheduler", function($$jqLite, $rootScope, $injector, $$AnimateRunner, $$HashMap, $$rAFScheduler) {
            var animationQueue = [];
            var applyAnimationClasses = applyAnimationClassesFactory($$jqLite);
            function sortAnimations(animations) {
                var tree = {
                    children: []
                };
                var i, lookup = new $$HashMap();
                for (i = 0; i < animations.length; i++) {
                    var animation = animations[i];
                    lookup.put(animation.domNode, animations[i] = {
                        domNode: animation.domNode,
                        fn: animation.fn,
                        children: []
                    });
                }
                for (i = 0; i < animations.length; i++) {
                    processNode(animations[i]);
                }
                return flatten(tree);
                function processNode(entry) {
                    if (entry.processed) return entry;
                    entry.processed = true;
                    var elementNode = entry.domNode;
                    var parentNode = elementNode.parentNode;
                    lookup.put(elementNode, entry);
                    var parentEntry;
                    while (parentNode) {
                        parentEntry = lookup.get(parentNode);
                        if (parentEntry) {
                            if (!parentEntry.processed) {
                                parentEntry = processNode(parentEntry);
                            }
                            break;
                        }
                        parentNode = parentNode.parentNode;
                    }
                    (parentEntry || tree).children.push(entry);
                    return entry;
                }
                function flatten(tree) {
                    var result = [];
                    var queue = [];
                    var i;
                    for (i = 0; i < tree.children.length; i++) {
                        queue.push(tree.children[i]);
                    }
                    var remainingLevelEntries = queue.length;
                    var nextLevelEntries = 0;
                    var row = [];
                    for (i = 0; i < queue.length; i++) {
                        var entry = queue[i];
                        if (remainingLevelEntries <= 0) {
                            remainingLevelEntries = nextLevelEntries;
                            nextLevelEntries = 0;
                            result.push(row);
                            row = [];
                        }
                        row.push(entry.fn);
                        entry.children.forEach(function(childEntry) {
                            nextLevelEntries++;
                            queue.push(childEntry);
                        });
                        remainingLevelEntries--;
                    }
                    if (row.length) {
                        result.push(row);
                    }
                    return result;
                }
            }
            return function(element, event, options) {
                options = prepareAnimationOptions(options);
                var isStructural = [ "enter", "move", "leave" ].indexOf(event) >= 0;
                var runner = new $$AnimateRunner({
                    end: function() {
                        close();
                    },
                    cancel: function() {
                        close(true);
                    }
                });
                if (!drivers.length) {
                    close();
                    return runner;
                }
                setRunner(element, runner);
                var classes = mergeClasses(element.attr("class"), mergeClasses(options.addClass, options.removeClass));
                var tempClasses = options.tempClasses;
                if (tempClasses) {
                    classes += " " + tempClasses;
                    options.tempClasses = null;
                }
                var prepareClassName;
                if (isStructural) {
                    prepareClassName = "ng-" + event + PREPARE_CLASS_SUFFIX;
                    $$jqLite.addClass(element, prepareClassName);
                }
                animationQueue.push({
                    element: element,
                    classes: classes,
                    event: event,
                    structural: isStructural,
                    options: options,
                    beforeStart: beforeStart,
                    close: close
                });
                element.on("$destroy", handleDestroyedElement);
                if (animationQueue.length > 1) return runner;
                $rootScope.$$postDigest(function() {
                    var animations = [];
                    forEach(animationQueue, function(entry) {
                        if (getRunner(entry.element)) {
                            animations.push(entry);
                        } else {
                            entry.close();
                        }
                    });
                    animationQueue.length = 0;
                    var groupedAnimations = groupAnimations(animations);
                    var toBeSortedAnimations = [];
                    forEach(groupedAnimations, function(animationEntry) {
                        toBeSortedAnimations.push({
                            domNode: getDomNode(animationEntry.from ? animationEntry.from.element : animationEntry.element),
                            fn: function triggerAnimationStart() {
                                animationEntry.beforeStart();
                                var startAnimationFn, closeFn = animationEntry.close;
                                var targetElement = animationEntry.anchors ? animationEntry.from.element || animationEntry.to.element : animationEntry.element;
                                if (getRunner(targetElement)) {
                                    var operation = invokeFirstDriver(animationEntry);
                                    if (operation) {
                                        startAnimationFn = operation.start;
                                    }
                                }
                                if (!startAnimationFn) {
                                    closeFn();
                                } else {
                                    var animationRunner = startAnimationFn();
                                    animationRunner.done(function(status) {
                                        closeFn(!status);
                                    });
                                    updateAnimationRunners(animationEntry, animationRunner);
                                }
                            }
                        });
                    });
                    $$rAFScheduler(sortAnimations(toBeSortedAnimations));
                });
                return runner;
                function getAnchorNodes(node) {
                    var SELECTOR = "[" + NG_ANIMATE_REF_ATTR + "]";
                    var items = node.hasAttribute(NG_ANIMATE_REF_ATTR) ? [ node ] : node.querySelectorAll(SELECTOR);
                    var anchors = [];
                    forEach(items, function(node) {
                        var attr = node.getAttribute(NG_ANIMATE_REF_ATTR);
                        if (attr && attr.length) {
                            anchors.push(node);
                        }
                    });
                    return anchors;
                }
                function groupAnimations(animations) {
                    var preparedAnimations = [];
                    var refLookup = {};
                    forEach(animations, function(animation, index) {
                        var element = animation.element;
                        var node = getDomNode(element);
                        var event = animation.event;
                        var enterOrMove = [ "enter", "move" ].indexOf(event) >= 0;
                        var anchorNodes = animation.structural ? getAnchorNodes(node) : [];
                        if (anchorNodes.length) {
                            var direction = enterOrMove ? "to" : "from";
                            forEach(anchorNodes, function(anchor) {
                                var key = anchor.getAttribute(NG_ANIMATE_REF_ATTR);
                                refLookup[key] = refLookup[key] || {};
                                refLookup[key][direction] = {
                                    animationID: index,
                                    element: jqLite(anchor)
                                };
                            });
                        } else {
                            preparedAnimations.push(animation);
                        }
                    });
                    var usedIndicesLookup = {};
                    var anchorGroups = {};
                    forEach(refLookup, function(operations, key) {
                        var from = operations.from;
                        var to = operations.to;
                        if (!from || !to) {
                            var index = from ? from.animationID : to.animationID;
                            var indexKey = index.toString();
                            if (!usedIndicesLookup[indexKey]) {
                                usedIndicesLookup[indexKey] = true;
                                preparedAnimations.push(animations[index]);
                            }
                            return;
                        }
                        var fromAnimation = animations[from.animationID];
                        var toAnimation = animations[to.animationID];
                        var lookupKey = from.animationID.toString();
                        if (!anchorGroups[lookupKey]) {
                            var group = anchorGroups[lookupKey] = {
                                structural: true,
                                beforeStart: function() {
                                    fromAnimation.beforeStart();
                                    toAnimation.beforeStart();
                                },
                                close: function() {
                                    fromAnimation.close();
                                    toAnimation.close();
                                },
                                classes: cssClassesIntersection(fromAnimation.classes, toAnimation.classes),
                                from: fromAnimation,
                                to: toAnimation,
                                anchors: []
                            };
                            if (group.classes.length) {
                                preparedAnimations.push(group);
                            } else {
                                preparedAnimations.push(fromAnimation);
                                preparedAnimations.push(toAnimation);
                            }
                        }
                        anchorGroups[lookupKey].anchors.push({
                            out: from.element,
                            "in": to.element
                        });
                    });
                    return preparedAnimations;
                }
                function cssClassesIntersection(a, b) {
                    a = a.split(" ");
                    b = b.split(" ");
                    var matches = [];
                    for (var i = 0; i < a.length; i++) {
                        var aa = a[i];
                        if (aa.substring(0, 3) === "ng-") continue;
                        for (var j = 0; j < b.length; j++) {
                            if (aa === b[j]) {
                                matches.push(aa);
                                break;
                            }
                        }
                    }
                    return matches.join(" ");
                }
                function invokeFirstDriver(animationDetails) {
                    for (var i = drivers.length - 1; i >= 0; i--) {
                        var driverName = drivers[i];
                        var factory = $injector.get(driverName);
                        var driver = factory(animationDetails);
                        if (driver) {
                            return driver;
                        }
                    }
                }
                function beforeStart() {
                    element.addClass(NG_ANIMATE_CLASSNAME);
                    if (tempClasses) {
                        $$jqLite.addClass(element, tempClasses);
                    }
                    if (prepareClassName) {
                        $$jqLite.removeClass(element, prepareClassName);
                        prepareClassName = null;
                    }
                }
                function updateAnimationRunners(animation, newRunner) {
                    if (animation.from && animation.to) {
                        update(animation.from.element);
                        update(animation.to.element);
                    } else {
                        update(animation.element);
                    }
                    function update(element) {
                        var runner = getRunner(element);
                        if (runner) runner.setHost(newRunner);
                    }
                }
                function handleDestroyedElement() {
                    var runner = getRunner(element);
                    if (runner && (event !== "leave" || !options.$$domOperationFired)) {
                        runner.end();
                    }
                }
                function close(rejected) {
                    element.off("$destroy", handleDestroyedElement);
                    removeRunner(element);
                    applyAnimationClasses(element, options);
                    applyAnimationStyles(element, options);
                    options.domOperation();
                    if (tempClasses) {
                        $$jqLite.removeClass(element, tempClasses);
                    }
                    element.removeClass(NG_ANIMATE_CLASSNAME);
                    runner.complete(!rejected);
                }
            };
        } ];
    } ];
    var ngAnimateSwapDirective = [ "$animate", "$rootScope", function($animate, $rootScope) {
        return {
            restrict: "A",
            transclude: "element",
            terminal: true,
            priority: 600,
            link: function(scope, $element, attrs, ctrl, $transclude) {
                var previousElement, previousScope;
                scope.$watchCollection(attrs.ngAnimateSwap || attrs["for"], function(value) {
                    if (previousElement) {
                        $animate.leave(previousElement);
                    }
                    if (previousScope) {
                        previousScope.$destroy();
                        previousScope = null;
                    }
                    if (value || value === 0) {
                        previousScope = scope.$new();
                        $transclude(previousScope, function(element) {
                            previousElement = element;
                            $animate.enter(element, null, $element);
                        });
                    }
                });
            }
        };
    } ];
    var copy;
    var extend;
    var forEach;
    var isArray;
    var isDefined;
    var isElement;
    var isFunction;
    var isObject;
    var isString;
    var isUndefined;
    var jqLite;
    var noop;
    angular.module("ngAnimate", [], function initAngularHelpers() {
        noop = angular.noop;
        copy = angular.copy;
        extend = angular.extend;
        jqLite = angular.element;
        forEach = angular.forEach;
        isArray = angular.isArray;
        isString = angular.isString;
        isObject = angular.isObject;
        isUndefined = angular.isUndefined;
        isDefined = angular.isDefined;
        isFunction = angular.isFunction;
        isElement = angular.isElement;
    }).directive("ngAnimateSwap", ngAnimateSwapDirective).directive("ngAnimateChildren", $$AnimateChildrenDirective).factory("$$rAFScheduler", $$rAFSchedulerFactory).provider("$$animateQueue", $$AnimateQueueProvider).provider("$$animation", $$AnimationProvider).provider("$animateCss", $AnimateCssProvider).provider("$$animateCssDriver", $$AnimateCssDriverProvider).provider("$$animateJs", $$AnimateJsProvider).provider("$$animateJsDriver", $$AnimateJsDriverProvider);
})(window, window.angular);

(function(window, angular) {
    "use strict";
    angular.module("ngCookies", [ "ng" ]).provider("$cookies", function $CookiesProvider() {
        var defaults = this.defaults = {};
        function calcOptions(options) {
            return options ? angular.extend({}, defaults, options) : defaults;
        }
        this.$get = [ "$$cookieReader", "$$cookieWriter", function($$cookieReader, $$cookieWriter) {
            return {
                get: function(key) {
                    return $$cookieReader()[key];
                },
                getObject: function(key) {
                    var value = this.get(key);
                    return value ? angular.fromJson(value) : value;
                },
                getAll: function() {
                    return $$cookieReader();
                },
                put: function(key, value, options) {
                    $$cookieWriter(key, value, calcOptions(options));
                },
                putObject: function(key, value, options) {
                    this.put(key, angular.toJson(value), options);
                },
                remove: function(key, options) {
                    $$cookieWriter(key, undefined, calcOptions(options));
                }
            };
        } ];
    });
    angular.module("ngCookies").factory("$cookieStore", [ "$cookies", function($cookies) {
        return {
            get: function(key) {
                return $cookies.getObject(key);
            },
            put: function(key, value) {
                $cookies.putObject(key, value);
            },
            remove: function(key) {
                $cookies.remove(key);
            }
        };
    } ]);
    function $$CookieWriter($document, $log, $browser) {
        var cookiePath = $browser.baseHref();
        var rawDocument = $document[0];
        function buildCookieString(name, value, options) {
            var path, expires;
            options = options || {};
            expires = options.expires;
            path = angular.isDefined(options.path) ? options.path : cookiePath;
            if (angular.isUndefined(value)) {
                expires = "Thu, 01 Jan 1970 00:00:00 GMT";
                value = "";
            }
            if (angular.isString(expires)) {
                expires = new Date(expires);
            }
            var str = encodeURIComponent(name) + "=" + encodeURIComponent(value);
            str += path ? ";path=" + path : "";
            str += options.domain ? ";domain=" + options.domain : "";
            str += expires ? ";expires=" + expires.toUTCString() : "";
            str += options.secure ? ";secure" : "";
            var cookieLength = str.length + 1;
            if (cookieLength > 4096) {
                $log.warn("Cookie '" + name + "' possibly not set or overflowed because it was too large (" + cookieLength + " > 4096 bytes)!");
            }
            return str;
        }
        return function(name, value, options) {
            rawDocument.cookie = buildCookieString(name, value, options);
        };
    }
    $$CookieWriter.$inject = [ "$document", "$log", "$browser" ];
    angular.module("ngCookies").provider("$$cookieWriter", function $$CookieWriterProvider() {
        this.$get = $$CookieWriter;
    });
})(window, window.angular);

(function(window, angular) {
    "use strict";
    var forEach;
    var isArray;
    var isString;
    var jqLite;
    angular.module("ngMessages", [], function initAngularHelpers() {
        forEach = angular.forEach;
        isArray = angular.isArray;
        isString = angular.isString;
        jqLite = angular.element;
    }).directive("ngMessages", [ "$animate", function($animate) {
        var ACTIVE_CLASS = "ng-active";
        var INACTIVE_CLASS = "ng-inactive";
        return {
            require: "ngMessages",
            restrict: "AE",
            controller: [ "$element", "$scope", "$attrs", function NgMessagesCtrl($element, $scope, $attrs) {
                var ctrl = this;
                var latestKey = 0;
                var nextAttachId = 0;
                this.getAttachId = function getAttachId() {
                    return nextAttachId++;
                };
                var messages = this.messages = {};
                var renderLater, cachedCollection;
                this.render = function(collection) {
                    collection = collection || {};
                    renderLater = false;
                    cachedCollection = collection;
                    var multiple = isAttrTruthy($scope, $attrs.ngMessagesMultiple) || isAttrTruthy($scope, $attrs.multiple);
                    var unmatchedMessages = [];
                    var matchedKeys = {};
                    var messageItem = ctrl.head;
                    var messageFound = false;
                    var totalMessages = 0;
                    while (messageItem != null) {
                        totalMessages++;
                        var messageCtrl = messageItem.message;
                        var messageUsed = false;
                        if (!messageFound) {
                            forEach(collection, function(value, key) {
                                if (!messageUsed && truthy(value) && messageCtrl.test(key)) {
                                    if (matchedKeys[key]) return;
                                    matchedKeys[key] = true;
                                    messageUsed = true;
                                    messageCtrl.attach();
                                }
                            });
                        }
                        if (messageUsed) {
                            messageFound = !multiple;
                        } else {
                            unmatchedMessages.push(messageCtrl);
                        }
                        messageItem = messageItem.next;
                    }
                    forEach(unmatchedMessages, function(messageCtrl) {
                        messageCtrl.detach();
                    });
                    if (unmatchedMessages.length !== totalMessages) {
                        $animate.setClass($element, ACTIVE_CLASS, INACTIVE_CLASS);
                    } else {
                        $animate.setClass($element, INACTIVE_CLASS, ACTIVE_CLASS);
                    }
                };
                $scope.$watchCollection($attrs.ngMessages || $attrs["for"], ctrl.render);
                $element.on("$destroy", function() {
                    forEach(messages, function(item) {
                        item.message.detach();
                    });
                });
                this.reRender = function() {
                    if (!renderLater) {
                        renderLater = true;
                        $scope.$evalAsync(function() {
                            if (renderLater && cachedCollection) {
                                ctrl.render(cachedCollection);
                            }
                        });
                    }
                };
                this.register = function(comment, messageCtrl) {
                    var nextKey = latestKey.toString();
                    messages[nextKey] = {
                        message: messageCtrl
                    };
                    insertMessageNode($element[0], comment, nextKey);
                    comment.$$ngMessageNode = nextKey;
                    latestKey++;
                    ctrl.reRender();
                };
                this.deregister = function(comment) {
                    var key = comment.$$ngMessageNode;
                    delete comment.$$ngMessageNode;
                    removeMessageNode($element[0], comment, key);
                    delete messages[key];
                    ctrl.reRender();
                };
                function findPreviousMessage(parent, comment) {
                    var prevNode = comment;
                    var parentLookup = [];
                    while (prevNode && prevNode !== parent) {
                        var prevKey = prevNode.$$ngMessageNode;
                        if (prevKey && prevKey.length) {
                            return messages[prevKey];
                        }
                        if (prevNode.childNodes.length && parentLookup.indexOf(prevNode) === -1) {
                            parentLookup.push(prevNode);
                            prevNode = prevNode.childNodes[prevNode.childNodes.length - 1];
                        } else if (prevNode.previousSibling) {
                            prevNode = prevNode.previousSibling;
                        } else {
                            prevNode = prevNode.parentNode;
                            parentLookup.push(prevNode);
                        }
                    }
                }
                function insertMessageNode(parent, comment, key) {
                    var messageNode = messages[key];
                    if (!ctrl.head) {
                        ctrl.head = messageNode;
                    } else {
                        var match = findPreviousMessage(parent, comment);
                        if (match) {
                            messageNode.next = match.next;
                            match.next = messageNode;
                        } else {
                            messageNode.next = ctrl.head;
                            ctrl.head = messageNode;
                        }
                    }
                }
                function removeMessageNode(parent, comment, key) {
                    var messageNode = messages[key];
                    var match = findPreviousMessage(parent, comment);
                    if (match) {
                        match.next = messageNode.next;
                    } else {
                        ctrl.head = messageNode.next;
                    }
                }
            } ]
        };
        function isAttrTruthy(scope, attr) {
            return isString(attr) && attr.length === 0 || truthy(scope.$eval(attr));
        }
        function truthy(val) {
            return isString(val) ? val.length : !!val;
        }
    } ]).directive("ngMessagesInclude", [ "$templateRequest", "$document", "$compile", function($templateRequest, $document, $compile) {
        return {
            restrict: "AE",
            require: "^^ngMessages",
            link: function($scope, element, attrs) {
                var src = attrs.ngMessagesInclude || attrs.src;
                $templateRequest(src).then(function(html) {
                    if ($scope.$$destroyed) return;
                    if (isString(html) && !html.trim()) {
                        replaceElementWithMarker(element, src);
                    } else {
                        $compile(html)($scope, function(contents) {
                            element.after(contents);
                            replaceElementWithMarker(element, src);
                        });
                    }
                });
            }
        };
        function replaceElementWithMarker(element, src) {
            var comment = $compile.$$createComment ? $compile.$$createComment("ngMessagesInclude", src) : $document[0].createComment(" ngMessagesInclude: " + src + " ");
            var marker = jqLite(comment);
            element.after(marker);
            element.remove();
        }
    } ]).directive("ngMessage", ngMessageDirectiveFactory()).directive("ngMessageExp", ngMessageDirectiveFactory());
    function ngMessageDirectiveFactory() {
        return [ "$animate", function($animate) {
            return {
                restrict: "AE",
                transclude: "element",
                priority: 1,
                terminal: true,
                require: "^^ngMessages",
                link: function(scope, element, attrs, ngMessagesCtrl, $transclude) {
                    var commentNode = element[0];
                    var records;
                    var staticExp = attrs.ngMessage || attrs.when;
                    var dynamicExp = attrs.ngMessageExp || attrs.whenExp;
                    var assignRecords = function(items) {
                        records = items ? isArray(items) ? items : items.split(/[\s,]+/) : null;
                        ngMessagesCtrl.reRender();
                    };
                    if (dynamicExp) {
                        assignRecords(scope.$eval(dynamicExp));
                        scope.$watchCollection(dynamicExp, assignRecords);
                    } else {
                        assignRecords(staticExp);
                    }
                    var currentElement, messageCtrl;
                    ngMessagesCtrl.register(commentNode, messageCtrl = {
                        test: function(name) {
                            return contains(records, name);
                        },
                        attach: function() {
                            if (!currentElement) {
                                $transclude(function(elm, newScope) {
                                    $animate.enter(elm, null, element);
                                    currentElement = elm;
                                    var $$attachId = currentElement.$$attachId = ngMessagesCtrl.getAttachId();
                                    currentElement.on("$destroy", function() {
                                        if (currentElement && currentElement.$$attachId === $$attachId) {
                                            ngMessagesCtrl.deregister(commentNode);
                                            messageCtrl.detach();
                                        }
                                        newScope.$destroy();
                                    });
                                });
                            }
                        },
                        detach: function() {
                            if (currentElement) {
                                var elm = currentElement;
                                currentElement = null;
                                $animate.leave(elm);
                            }
                        }
                    });
                }
            };
        } ];
        function contains(collection, key) {
            if (collection) {
                return isArray(collection) ? collection.indexOf(key) >= 0 : collection.hasOwnProperty(key);
            }
        }
    }
})(window, window.angular);

(function(window, angular) {
    "use strict";
    var $resourceMinErr = angular.$$minErr("$resource");
    var MEMBER_NAME_REGEX = /^(\.[a-zA-Z_$@][0-9a-zA-Z_$@]*)+$/;
    function isValidDottedPath(path) {
        return path != null && path !== "" && path !== "hasOwnProperty" && MEMBER_NAME_REGEX.test("." + path);
    }
    function lookupDottedPath(obj, path) {
        if (!isValidDottedPath(path)) {
            throw $resourceMinErr("badmember", 'Dotted member path "@{0}" is invalid.', path);
        }
        var keys = path.split(".");
        for (var i = 0, ii = keys.length; i < ii && angular.isDefined(obj); i++) {
            var key = keys[i];
            obj = obj !== null ? obj[key] : undefined;
        }
        return obj;
    }
    function shallowClearAndCopy(src, dst) {
        dst = dst || {};
        angular.forEach(dst, function(value, key) {
            delete dst[key];
        });
        for (var key in src) {
            if (src.hasOwnProperty(key) && !(key.charAt(0) === "$" && key.charAt(1) === "$")) {
                dst[key] = src[key];
            }
        }
        return dst;
    }
    angular.module("ngResource", [ "ng" ]).provider("$resource", function ResourceProvider() {
        var PROTOCOL_AND_DOMAIN_REGEX = /^https?:\/\/[^\/]*/;
        var provider = this;
        this.defaults = {
            stripTrailingSlashes: true,
            cancellable: false,
            actions: {
                get: {
                    method: "GET"
                },
                save: {
                    method: "POST"
                },
                query: {
                    method: "GET",
                    isArray: true
                },
                remove: {
                    method: "DELETE"
                },
                "delete": {
                    method: "DELETE"
                }
            }
        };
        this.$get = [ "$http", "$log", "$q", "$timeout", function($http, $log, $q, $timeout) {
            var noop = angular.noop, forEach = angular.forEach, extend = angular.extend, copy = angular.copy, isArray = angular.isArray, isDefined = angular.isDefined, isFunction = angular.isFunction, isNumber = angular.isNumber;
            function encodeUriSegment(val) {
                return encodeUriQuery(val, true).replace(/%26/gi, "&").replace(/%3D/gi, "=").replace(/%2B/gi, "+");
            }
            function encodeUriQuery(val, pctEncodeSpaces) {
                return encodeURIComponent(val).replace(/%40/gi, "@").replace(/%3A/gi, ":").replace(/%24/g, "$").replace(/%2C/gi, ",").replace(/%20/g, pctEncodeSpaces ? "%20" : "+");
            }
            function Route(template, defaults) {
                this.template = template;
                this.defaults = extend({}, provider.defaults, defaults);
                this.urlParams = {};
            }
            Route.prototype = {
                setUrlParams: function(config, params, actionUrl) {
                    var self = this, url = actionUrl || self.template, val, encodedVal, protocolAndDomain = "";
                    var urlParams = self.urlParams = {};
                    forEach(url.split(/\W/), function(param) {
                        if (param === "hasOwnProperty") {
                            throw $resourceMinErr("badname", "hasOwnProperty is not a valid parameter name.");
                        }
                        if (!new RegExp("^\\d+$").test(param) && param && new RegExp("(^|[^\\\\]):" + param + "(\\W|$)").test(url)) {
                            urlParams[param] = {
                                isQueryParamValue: new RegExp("\\?.*=:" + param + "(?:\\W|$)").test(url)
                            };
                        }
                    });
                    url = url.replace(/\\:/g, ":");
                    url = url.replace(PROTOCOL_AND_DOMAIN_REGEX, function(match) {
                        protocolAndDomain = match;
                        return "";
                    });
                    params = params || {};
                    forEach(self.urlParams, function(paramInfo, urlParam) {
                        val = params.hasOwnProperty(urlParam) ? params[urlParam] : self.defaults[urlParam];
                        if (isDefined(val) && val !== null) {
                            if (paramInfo.isQueryParamValue) {
                                encodedVal = encodeUriQuery(val, true);
                            } else {
                                encodedVal = encodeUriSegment(val);
                            }
                            url = url.replace(new RegExp(":" + urlParam + "(\\W|$)", "g"), function(match, p1) {
                                return encodedVal + p1;
                            });
                        } else {
                            url = url.replace(new RegExp("(/?):" + urlParam + "(\\W|$)", "g"), function(match, leadingSlashes, tail) {
                                if (tail.charAt(0) === "/") {
                                    return tail;
                                } else {
                                    return leadingSlashes + tail;
                                }
                            });
                        }
                    });
                    if (self.defaults.stripTrailingSlashes) {
                        url = url.replace(/\/+$/, "") || "/";
                    }
                    url = url.replace(/\/\.(?=\w+($|\?))/, ".");
                    config.url = protocolAndDomain + url.replace(/\/\\\./, "/.");
                    forEach(params, function(value, key) {
                        if (!self.urlParams[key]) {
                            config.params = config.params || {};
                            config.params[key] = value;
                        }
                    });
                }
            };
            function resourceFactory(url, paramDefaults, actions, options) {
                var route = new Route(url, options);
                actions = extend({}, provider.defaults.actions, actions);
                function extractParams(data, actionParams) {
                    var ids = {};
                    actionParams = extend({}, paramDefaults, actionParams);
                    forEach(actionParams, function(value, key) {
                        if (isFunction(value)) {
                            value = value(data);
                        }
                        ids[key] = value && value.charAt && value.charAt(0) === "@" ? lookupDottedPath(data, value.substr(1)) : value;
                    });
                    return ids;
                }
                function defaultResponseInterceptor(response) {
                    return response.resource;
                }
                function Resource(value) {
                    shallowClearAndCopy(value || {}, this);
                }
                Resource.prototype.toJSON = function() {
                    var data = extend({}, this);
                    delete data.$promise;
                    delete data.$resolved;
                    delete data.$cancelRequest;
                    return data;
                };
                forEach(actions, function(action, name) {
                    var hasBody = /^(POST|PUT|PATCH)$/i.test(action.method);
                    var numericTimeout = action.timeout;
                    var cancellable = isDefined(action.cancellable) ? action.cancellable : route.defaults.cancellable;
                    if (numericTimeout && !isNumber(numericTimeout)) {
                        $log.debug("ngResource:\n" + "  Only numeric values are allowed as `timeout`.\n" + "  Promises are not supported in $resource, because the same value would " + "be used for multiple requests. If you are looking for a way to cancel " + "requests, you should use the `cancellable` option.");
                        delete action.timeout;
                        numericTimeout = null;
                    }
                    Resource[name] = function(a1, a2, a3, a4) {
                        var params = {}, data, success, error;
                        switch (arguments.length) {
                          case 4:
                            error = a4;
                            success = a3;

                          case 3:
                          case 2:
                            if (isFunction(a2)) {
                                if (isFunction(a1)) {
                                    success = a1;
                                    error = a2;
                                    break;
                                }
                                success = a2;
                                error = a3;
                            } else {
                                params = a1;
                                data = a2;
                                success = a3;
                                break;
                            }

                          case 1:
                            if (isFunction(a1)) success = a1; else if (hasBody) data = a1; else params = a1;
                            break;

                          case 0:
                            break;

                          default:
                            throw $resourceMinErr("badargs", "Expected up to 4 arguments [params, data, success, error], got {0} arguments", arguments.length);
                        }
                        var isInstanceCall = this instanceof Resource;
                        var value = isInstanceCall ? data : action.isArray ? [] : new Resource(data);
                        var httpConfig = {};
                        var responseInterceptor = action.interceptor && action.interceptor.response || defaultResponseInterceptor;
                        var responseErrorInterceptor = action.interceptor && action.interceptor.responseError || undefined;
                        var timeoutDeferred;
                        var numericTimeoutPromise;
                        forEach(action, function(value, key) {
                            switch (key) {
                              default:
                                httpConfig[key] = copy(value);
                                break;

                              case "params":
                              case "isArray":
                              case "interceptor":
                              case "cancellable":
                                break;
                            }
                        });
                        if (!isInstanceCall && cancellable) {
                            timeoutDeferred = $q.defer();
                            httpConfig.timeout = timeoutDeferred.promise;
                            if (numericTimeout) {
                                numericTimeoutPromise = $timeout(timeoutDeferred.resolve, numericTimeout);
                            }
                        }
                        if (hasBody) httpConfig.data = data;
                        route.setUrlParams(httpConfig, extend({}, extractParams(data, action.params || {}), params), action.url);
                        var promise = $http(httpConfig).then(function(response) {
                            var data = response.data;
                            if (data) {
                                if (isArray(data) !== !!action.isArray) {
                                    throw $resourceMinErr("badcfg", "Error in resource configuration for action `{0}`. Expected response to " + "contain an {1} but got an {2} (Request: {3} {4})", name, action.isArray ? "array" : "object", isArray(data) ? "array" : "object", httpConfig.method, httpConfig.url);
                                }
                                if (action.isArray) {
                                    value.length = 0;
                                    forEach(data, function(item) {
                                        if (typeof item === "object") {
                                            value.push(new Resource(item));
                                        } else {
                                            value.push(item);
                                        }
                                    });
                                } else {
                                    var promise = value.$promise;
                                    shallowClearAndCopy(data, value);
                                    value.$promise = promise;
                                }
                            }
                            response.resource = value;
                            return response;
                        }, function(response) {
                            (error || noop)(response);
                            return $q.reject(response);
                        });
                        promise["finally"](function() {
                            value.$resolved = true;
                            if (!isInstanceCall && cancellable) {
                                value.$cancelRequest = noop;
                                $timeout.cancel(numericTimeoutPromise);
                                timeoutDeferred = numericTimeoutPromise = httpConfig.timeout = null;
                            }
                        });
                        promise = promise.then(function(response) {
                            var value = responseInterceptor(response);
                            (success || noop)(value, response.headers, response.status, response.statusText);
                            return value;
                        }, responseErrorInterceptor);
                        if (!isInstanceCall) {
                            value.$promise = promise;
                            value.$resolved = false;
                            if (cancellable) value.$cancelRequest = timeoutDeferred.resolve;
                            return value;
                        }
                        return promise;
                    };
                    Resource.prototype["$" + name] = function(params, success, error) {
                        if (isFunction(params)) {
                            error = success;
                            success = params;
                            params = {};
                        }
                        var result = Resource[name].call(this, params, this, success, error);
                        return result.$promise || result;
                    };
                });
                Resource.bind = function(additionalParamDefaults) {
                    var extendedParamDefaults = extend({}, paramDefaults, additionalParamDefaults);
                    return resourceFactory(url, extendedParamDefaults, actions, options);
                };
                return Resource;
            }
            return resourceFactory;
        } ];
    });
})(window, window.angular);

(function(window, angular) {
    "use strict";
    function shallowCopy(src, dst) {
        if (isArray(src)) {
            dst = dst || [];
            for (var i = 0, ii = src.length; i < ii; i++) {
                dst[i] = src[i];
            }
        } else if (isObject(src)) {
            dst = dst || {};
            for (var key in src) {
                if (!(key.charAt(0) === "$" && key.charAt(1) === "$")) {
                    dst[key] = src[key];
                }
            }
        }
        return dst || src;
    }
    var isArray;
    var isObject;
    var ngRouteModule = angular.module("ngRoute", [ "ng" ]).provider("$route", $RouteProvider), $routeMinErr = angular.$$minErr("ngRoute");
    function $RouteProvider() {
        isArray = angular.isArray;
        isObject = angular.isObject;
        function inherit(parent, extra) {
            return angular.extend(Object.create(parent), extra);
        }
        var routes = {};
        this.when = function(path, route) {
            var routeCopy = shallowCopy(route);
            if (angular.isUndefined(routeCopy.reloadOnSearch)) {
                routeCopy.reloadOnSearch = true;
            }
            if (angular.isUndefined(routeCopy.caseInsensitiveMatch)) {
                routeCopy.caseInsensitiveMatch = this.caseInsensitiveMatch;
            }
            routes[path] = angular.extend(routeCopy, path && pathRegExp(path, routeCopy));
            if (path) {
                var redirectPath = path[path.length - 1] === "/" ? path.substr(0, path.length - 1) : path + "/";
                routes[redirectPath] = angular.extend({
                    redirectTo: path
                }, pathRegExp(redirectPath, routeCopy));
            }
            return this;
        };
        this.caseInsensitiveMatch = false;
        function pathRegExp(path, opts) {
            var insensitive = opts.caseInsensitiveMatch, ret = {
                originalPath: path,
                regexp: path
            }, keys = ret.keys = [];
            path = path.replace(/([().])/g, "\\$1").replace(/(\/)?:(\w+)(\*\?|[?*])?/g, function(_, slash, key, option) {
                var optional = option === "?" || option === "*?" ? "?" : null;
                var star = option === "*" || option === "*?" ? "*" : null;
                keys.push({
                    name: key,
                    optional: !!optional
                });
                slash = slash || "";
                return "" + (optional ? "" : slash) + "(?:" + (optional ? slash : "") + (star && "(.+?)" || "([^/]+)") + (optional || "") + ")" + (optional || "");
            }).replace(/([\/$*])/g, "\\$1");
            ret.regexp = new RegExp("^" + path + "$", insensitive ? "i" : "");
            return ret;
        }
        this.otherwise = function(params) {
            if (typeof params === "string") {
                params = {
                    redirectTo: params
                };
            }
            this.when(null, params);
            return this;
        };
        this.$get = [ "$rootScope", "$location", "$routeParams", "$q", "$injector", "$templateRequest", "$sce", function($rootScope, $location, $routeParams, $q, $injector, $templateRequest, $sce) {
            var forceReload = false, preparedRoute, preparedRouteIsUpdateOnly, $route = {
                routes: routes,
                reload: function() {
                    forceReload = true;
                    var fakeLocationEvent = {
                        defaultPrevented: false,
                        preventDefault: function fakePreventDefault() {
                            this.defaultPrevented = true;
                            forceReload = false;
                        }
                    };
                    $rootScope.$evalAsync(function() {
                        prepareRoute(fakeLocationEvent);
                        if (!fakeLocationEvent.defaultPrevented) commitRoute();
                    });
                },
                updateParams: function(newParams) {
                    if (this.current && this.current.$$route) {
                        newParams = angular.extend({}, this.current.params, newParams);
                        $location.path(interpolate(this.current.$$route.originalPath, newParams));
                        $location.search(newParams);
                    } else {
                        throw $routeMinErr("norout", "Tried updating route when with no current route");
                    }
                }
            };
            $rootScope.$on("$locationChangeStart", prepareRoute);
            $rootScope.$on("$locationChangeSuccess", commitRoute);
            return $route;
            function switchRouteMatcher(on, route) {
                var keys = route.keys, params = {};
                if (!route.regexp) return null;
                var m = route.regexp.exec(on);
                if (!m) return null;
                for (var i = 1, len = m.length; i < len; ++i) {
                    var key = keys[i - 1];
                    var val = m[i];
                    if (key && val) {
                        params[key.name] = val;
                    }
                }
                return params;
            }
            function prepareRoute($locationEvent) {
                var lastRoute = $route.current;
                preparedRoute = parseRoute();
                preparedRouteIsUpdateOnly = preparedRoute && lastRoute && preparedRoute.$$route === lastRoute.$$route && angular.equals(preparedRoute.pathParams, lastRoute.pathParams) && !preparedRoute.reloadOnSearch && !forceReload;
                if (!preparedRouteIsUpdateOnly && (lastRoute || preparedRoute)) {
                    if ($rootScope.$broadcast("$routeChangeStart", preparedRoute, lastRoute).defaultPrevented) {
                        if ($locationEvent) {
                            $locationEvent.preventDefault();
                        }
                    }
                }
            }
            function commitRoute() {
                var lastRoute = $route.current;
                var nextRoute = preparedRoute;
                if (preparedRouteIsUpdateOnly) {
                    lastRoute.params = nextRoute.params;
                    angular.copy(lastRoute.params, $routeParams);
                    $rootScope.$broadcast("$routeUpdate", lastRoute);
                } else if (nextRoute || lastRoute) {
                    forceReload = false;
                    $route.current = nextRoute;
                    if (nextRoute) {
                        if (nextRoute.redirectTo) {
                            if (angular.isString(nextRoute.redirectTo)) {
                                $location.path(interpolate(nextRoute.redirectTo, nextRoute.params)).search(nextRoute.params).replace();
                            } else {
                                $location.url(nextRoute.redirectTo(nextRoute.pathParams, $location.path(), $location.search())).replace();
                            }
                        }
                    }
                    $q.when(nextRoute).then(resolveLocals).then(function(locals) {
                        if (nextRoute === $route.current) {
                            if (nextRoute) {
                                nextRoute.locals = locals;
                                angular.copy(nextRoute.params, $routeParams);
                            }
                            $rootScope.$broadcast("$routeChangeSuccess", nextRoute, lastRoute);
                        }
                    }, function(error) {
                        if (nextRoute === $route.current) {
                            $rootScope.$broadcast("$routeChangeError", nextRoute, lastRoute, error);
                        }
                    });
                }
            }
            function resolveLocals(route) {
                if (route) {
                    var locals = angular.extend({}, route.resolve);
                    angular.forEach(locals, function(value, key) {
                        locals[key] = angular.isString(value) ? $injector.get(value) : $injector.invoke(value, null, null, key);
                    });
                    var template = getTemplateFor(route);
                    if (angular.isDefined(template)) {
                        locals["$template"] = template;
                    }
                    return $q.all(locals);
                }
            }
            function getTemplateFor(route) {
                var template, templateUrl;
                if (angular.isDefined(template = route.template)) {
                    if (angular.isFunction(template)) {
                        template = template(route.params);
                    }
                } else if (angular.isDefined(templateUrl = route.templateUrl)) {
                    if (angular.isFunction(templateUrl)) {
                        templateUrl = templateUrl(route.params);
                    }
                    if (angular.isDefined(templateUrl)) {
                        route.loadedTemplateUrl = $sce.valueOf(templateUrl);
                        template = $templateRequest(templateUrl);
                    }
                }
                return template;
            }
            function parseRoute() {
                var params, match;
                angular.forEach(routes, function(route, path) {
                    if (!match && (params = switchRouteMatcher($location.path(), route))) {
                        match = inherit(route, {
                            params: angular.extend({}, $location.search(), params),
                            pathParams: params
                        });
                        match.$$route = route;
                    }
                });
                return match || routes[null] && inherit(routes[null], {
                    params: {},
                    pathParams: {}
                });
            }
            function interpolate(string, params) {
                var result = [];
                angular.forEach((string || "").split(":"), function(segment, i) {
                    if (i === 0) {
                        result.push(segment);
                    } else {
                        var segmentMatch = segment.match(/(\w+)(?:[?*])?(.*)/);
                        var key = segmentMatch[1];
                        result.push(params[key]);
                        result.push(segmentMatch[2] || "");
                        delete params[key];
                    }
                });
                return result.join("");
            }
        } ];
    }
    ngRouteModule.provider("$routeParams", $RouteParamsProvider);
    function $RouteParamsProvider() {
        this.$get = function() {
            return {};
        };
    }
    ngRouteModule.directive("ngView", ngViewFactory);
    ngRouteModule.directive("ngView", ngViewFillContentFactory);
    ngViewFactory.$inject = [ "$route", "$anchorScroll", "$animate" ];
    function ngViewFactory($route, $anchorScroll, $animate) {
        return {
            restrict: "ECA",
            terminal: true,
            priority: 400,
            transclude: "element",
            link: function(scope, $element, attr, ctrl, $transclude) {
                var currentScope, currentElement, previousLeaveAnimation, autoScrollExp = attr.autoscroll, onloadExp = attr.onload || "";
                scope.$on("$routeChangeSuccess", update);
                update();
                function cleanupLastView() {
                    if (previousLeaveAnimation) {
                        $animate.cancel(previousLeaveAnimation);
                        previousLeaveAnimation = null;
                    }
                    if (currentScope) {
                        currentScope.$destroy();
                        currentScope = null;
                    }
                    if (currentElement) {
                        previousLeaveAnimation = $animate.leave(currentElement);
                        previousLeaveAnimation.done(function(response) {
                            if (response !== false) previousLeaveAnimation = null;
                        });
                        currentElement = null;
                    }
                }
                function update() {
                    var locals = $route.current && $route.current.locals, template = locals && locals.$template;
                    if (angular.isDefined(template)) {
                        var newScope = scope.$new();
                        var current = $route.current;
                        var clone = $transclude(newScope, function(clone) {
                            $animate.enter(clone, null, currentElement || $element).done(function onNgViewEnter(response) {
                                if (response !== false && angular.isDefined(autoScrollExp) && (!autoScrollExp || scope.$eval(autoScrollExp))) {
                                    $anchorScroll();
                                }
                            });
                            cleanupLastView();
                        });
                        currentElement = clone;
                        currentScope = current.scope = newScope;
                        currentScope.$emit("$viewContentLoaded");
                        currentScope.$eval(onloadExp);
                    } else {
                        cleanupLastView();
                    }
                }
            }
        };
    }
    ngViewFillContentFactory.$inject = [ "$compile", "$controller", "$route" ];
    function ngViewFillContentFactory($compile, $controller, $route) {
        return {
            restrict: "ECA",
            priority: -400,
            link: function(scope, $element) {
                var current = $route.current, locals = current.locals;
                $element.html(locals.$template);
                var link = $compile($element.contents());
                if (current.controller) {
                    locals.$scope = scope;
                    var controller = $controller(current.controller, locals);
                    if (current.controllerAs) {
                        scope[current.controllerAs] = controller;
                    }
                    $element.data("$ngControllerController", controller);
                    $element.children().data("$ngControllerController", controller);
                }
                scope[current.resolveAs || "$resolve"] = locals;
                link(scope);
            }
        };
    }
})(window, window.angular);

(function(window, angular) {
    "use strict";
    var $sanitizeMinErr = angular.$$minErr("$sanitize");
    var bind;
    var extend;
    var forEach;
    var isDefined;
    var lowercase;
    var noop;
    var htmlParser;
    var htmlSanitizeWriter;
    function $SanitizeProvider() {
        var svgEnabled = false;
        this.$get = [ "$$sanitizeUri", function($$sanitizeUri) {
            if (svgEnabled) {
                extend(validElements, svgElements);
            }
            return function(html) {
                var buf = [];
                htmlParser(html, htmlSanitizeWriter(buf, function(uri, isImage) {
                    return !/^unsafe:/.test($$sanitizeUri(uri, isImage));
                }));
                return buf.join("");
            };
        } ];
        this.enableSvg = function(enableSvg) {
            if (isDefined(enableSvg)) {
                svgEnabled = enableSvg;
                return this;
            } else {
                return svgEnabled;
            }
        };
        bind = angular.bind;
        extend = angular.extend;
        forEach = angular.forEach;
        isDefined = angular.isDefined;
        lowercase = angular.lowercase;
        noop = angular.noop;
        htmlParser = htmlParserImpl;
        htmlSanitizeWriter = htmlSanitizeWriterImpl;
        var SURROGATE_PAIR_REGEXP = /[\uD800-\uDBFF][\uDC00-\uDFFF]/g, NON_ALPHANUMERIC_REGEXP = /([^#-~ |!])/g;
        var voidElements = toMap("area,br,col,hr,img,wbr");
        var optionalEndTagBlockElements = toMap("colgroup,dd,dt,li,p,tbody,td,tfoot,th,thead,tr"), optionalEndTagInlineElements = toMap("rp,rt"), optionalEndTagElements = extend({}, optionalEndTagInlineElements, optionalEndTagBlockElements);
        var blockElements = extend({}, optionalEndTagBlockElements, toMap("address,article," + "aside,blockquote,caption,center,del,dir,div,dl,figure,figcaption,footer,h1,h2,h3,h4,h5," + "h6,header,hgroup,hr,ins,map,menu,nav,ol,pre,section,table,ul"));
        var inlineElements = extend({}, optionalEndTagInlineElements, toMap("a,abbr,acronym,b," + "bdi,bdo,big,br,cite,code,del,dfn,em,font,i,img,ins,kbd,label,map,mark,q,ruby,rp,rt,s," + "samp,small,span,strike,strong,sub,sup,time,tt,u,var"));
        var svgElements = toMap("circle,defs,desc,ellipse,font-face,font-face-name,font-face-src,g,glyph," + "hkern,image,linearGradient,line,marker,metadata,missing-glyph,mpath,path,polygon,polyline," + "radialGradient,rect,stop,svg,switch,text,title,tspan");
        var blockedElements = toMap("script,style");
        var validElements = extend({}, voidElements, blockElements, inlineElements, optionalEndTagElements);
        var uriAttrs = toMap("background,cite,href,longdesc,src,xlink:href");
        var htmlAttrs = toMap("abbr,align,alt,axis,bgcolor,border,cellpadding,cellspacing,class,clear," + "color,cols,colspan,compact,coords,dir,face,headers,height,hreflang,hspace," + "ismap,lang,language,nohref,nowrap,rel,rev,rows,rowspan,rules," + "scope,scrolling,shape,size,span,start,summary,tabindex,target,title,type," + "valign,value,vspace,width");
        var svgAttrs = toMap("accent-height,accumulate,additive,alphabetic,arabic-form,ascent," + "baseProfile,bbox,begin,by,calcMode,cap-height,class,color,color-rendering,content," + "cx,cy,d,dx,dy,descent,display,dur,end,fill,fill-rule,font-family,font-size,font-stretch," + "font-style,font-variant,font-weight,from,fx,fy,g1,g2,glyph-name,gradientUnits,hanging," + "height,horiz-adv-x,horiz-origin-x,ideographic,k,keyPoints,keySplines,keyTimes,lang," + "marker-end,marker-mid,marker-start,markerHeight,markerUnits,markerWidth,mathematical," + "max,min,offset,opacity,orient,origin,overline-position,overline-thickness,panose-1," + "path,pathLength,points,preserveAspectRatio,r,refX,refY,repeatCount,repeatDur," + "requiredExtensions,requiredFeatures,restart,rotate,rx,ry,slope,stemh,stemv,stop-color," + "stop-opacity,strikethrough-position,strikethrough-thickness,stroke,stroke-dasharray," + "stroke-dashoffset,stroke-linecap,stroke-linejoin,stroke-miterlimit,stroke-opacity," + "stroke-width,systemLanguage,target,text-anchor,to,transform,type,u1,u2,underline-position," + "underline-thickness,unicode,unicode-range,units-per-em,values,version,viewBox,visibility," + "width,widths,x,x-height,x1,x2,xlink:actuate,xlink:arcrole,xlink:role,xlink:show,xlink:title," + "xlink:type,xml:base,xml:lang,xml:space,xmlns,xmlns:xlink,y,y1,y2,zoomAndPan", true);
        var validAttrs = extend({}, uriAttrs, svgAttrs, htmlAttrs);
        function toMap(str, lowercaseKeys) {
            var obj = {}, items = str.split(","), i;
            for (i = 0; i < items.length; i++) {
                obj[lowercaseKeys ? lowercase(items[i]) : items[i]] = true;
            }
            return obj;
        }
        var inertBodyElement;
        (function(window) {
            var doc;
            if (window.document && window.document.implementation) {
                doc = window.document.implementation.createHTMLDocument("inert");
            } else {
                throw $sanitizeMinErr("noinert", "Can't create an inert html document");
            }
            var docElement = doc.documentElement || doc.getDocumentElement();
            var bodyElements = docElement.getElementsByTagName("body");
            if (bodyElements.length === 1) {
                inertBodyElement = bodyElements[0];
            } else {
                var html = doc.createElement("html");
                inertBodyElement = doc.createElement("body");
                html.appendChild(inertBodyElement);
                doc.appendChild(html);
            }
        })(window);
        function htmlParserImpl(html, handler) {
            if (html === null || html === undefined) {
                html = "";
            } else if (typeof html !== "string") {
                html = "" + html;
            }
            inertBodyElement.innerHTML = html;
            var mXSSAttempts = 5;
            do {
                if (mXSSAttempts === 0) {
                    throw $sanitizeMinErr("uinput", "Failed to sanitize html because the input is unstable");
                }
                mXSSAttempts--;
                if (window.document.documentMode) {
                    stripCustomNsAttrs(inertBodyElement);
                }
                html = inertBodyElement.innerHTML;
                inertBodyElement.innerHTML = html;
            } while (html !== inertBodyElement.innerHTML);
            var node = inertBodyElement.firstChild;
            while (node) {
                switch (node.nodeType) {
                  case 1:
                    handler.start(node.nodeName.toLowerCase(), attrToMap(node.attributes));
                    break;

                  case 3:
                    handler.chars(node.textContent);
                    break;
                }
                var nextNode;
                if (!(nextNode = node.firstChild)) {
                    if (node.nodeType === 1) {
                        handler.end(node.nodeName.toLowerCase());
                    }
                    nextNode = node.nextSibling;
                    if (!nextNode) {
                        while (nextNode == null) {
                            node = node.parentNode;
                            if (node === inertBodyElement) break;
                            nextNode = node.nextSibling;
                            if (node.nodeType === 1) {
                                handler.end(node.nodeName.toLowerCase());
                            }
                        }
                    }
                }
                node = nextNode;
            }
            while (node = inertBodyElement.firstChild) {
                inertBodyElement.removeChild(node);
            }
        }
        function attrToMap(attrs) {
            var map = {};
            for (var i = 0, ii = attrs.length; i < ii; i++) {
                var attr = attrs[i];
                map[attr.name] = attr.value;
            }
            return map;
        }
        function encodeEntities(value) {
            return value.replace(/&/g, "&amp;").replace(SURROGATE_PAIR_REGEXP, function(value) {
                var hi = value.charCodeAt(0);
                var low = value.charCodeAt(1);
                return "&#" + ((hi - 55296) * 1024 + (low - 56320) + 65536) + ";";
            }).replace(NON_ALPHANUMERIC_REGEXP, function(value) {
                return "&#" + value.charCodeAt(0) + ";";
            }).replace(/</g, "&lt;").replace(/>/g, "&gt;");
        }
        function htmlSanitizeWriterImpl(buf, uriValidator) {
            var ignoreCurrentElement = false;
            var out = bind(buf, buf.push);
            return {
                start: function(tag, attrs) {
                    tag = lowercase(tag);
                    if (!ignoreCurrentElement && blockedElements[tag]) {
                        ignoreCurrentElement = tag;
                    }
                    if (!ignoreCurrentElement && validElements[tag] === true) {
                        out("<");
                        out(tag);
                        forEach(attrs, function(value, key) {
                            var lkey = lowercase(key);
                            var isImage = tag === "img" && lkey === "src" || lkey === "background";
                            if (validAttrs[lkey] === true && (uriAttrs[lkey] !== true || uriValidator(value, isImage))) {
                                out(" ");
                                out(key);
                                out('="');
                                out(encodeEntities(value));
                                out('"');
                            }
                        });
                        out(">");
                    }
                },
                end: function(tag) {
                    tag = lowercase(tag);
                    if (!ignoreCurrentElement && validElements[tag] === true && voidElements[tag] !== true) {
                        out("</");
                        out(tag);
                        out(">");
                    }
                    if (tag == ignoreCurrentElement) {
                        ignoreCurrentElement = false;
                    }
                },
                chars: function(chars) {
                    if (!ignoreCurrentElement) {
                        out(encodeEntities(chars));
                    }
                }
            };
        }
        function stripCustomNsAttrs(node) {
            while (node) {
                if (node.nodeType === window.Node.ELEMENT_NODE) {
                    var attrs = node.attributes;
                    for (var i = 0, l = attrs.length; i < l; i++) {
                        var attrNode = attrs[i];
                        var attrName = attrNode.name.toLowerCase();
                        if (attrName === "xmlns:ns1" || attrName.lastIndexOf("ns1:", 0) === 0) {
                            node.removeAttributeNode(attrNode);
                            i--;
                            l--;
                        }
                    }
                }
                var nextNode = node.firstChild;
                if (nextNode) {
                    stripCustomNsAttrs(nextNode);
                }
                node = node.nextSibling;
            }
        }
    }
    function sanitizeText(chars) {
        var buf = [];
        var writer = htmlSanitizeWriter(buf, noop);
        writer.chars(chars);
        return buf.join("");
    }
    angular.module("ngSanitize", []).provider("$sanitize", $SanitizeProvider);
    angular.module("ngSanitize").filter("linky", [ "$sanitize", function($sanitize) {
        var LINKY_URL_REGEXP = /((ftp|https?):\/\/|(www\.)|(mailto:)?[A-Za-z0-9._%+-]+@)\S*[^\s.;,(){}<>"\u201d\u2019]/i, MAILTO_REGEXP = /^mailto:/i;
        var linkyMinErr = angular.$$minErr("linky");
        var isDefined = angular.isDefined;
        var isFunction = angular.isFunction;
        var isObject = angular.isObject;
        var isString = angular.isString;
        return function(text, target, attributes) {
            if (text == null || text === "") return text;
            if (!isString(text)) throw linkyMinErr("notstring", "Expected string but received: {0}", text);
            var attributesFn = isFunction(attributes) ? attributes : isObject(attributes) ? function getAttributesObject() {
                return attributes;
            } : function getEmptyAttributesObject() {
                return {};
            };
            var match;
            var raw = text;
            var html = [];
            var url;
            var i;
            while (match = raw.match(LINKY_URL_REGEXP)) {
                url = match[0];
                if (!match[2] && !match[4]) {
                    url = (match[3] ? "http://" : "mailto:") + url;
                }
                i = match.index;
                addText(raw.substr(0, i));
                addLink(url, match[0].replace(MAILTO_REGEXP, ""));
                raw = raw.substring(i + match[0].length);
            }
            addText(raw);
            return $sanitize(html.join(""));
            function addText(text) {
                if (!text) {
                    return;
                }
                html.push(sanitizeText(text));
            }
            function addLink(url, text) {
                var key, linkAttributes = attributesFn(url);
                html.push("<a ");
                for (key in linkAttributes) {
                    html.push(key + '="' + linkAttributes[key] + '" ');
                }
                if (isDefined(target) && !("target" in linkAttributes)) {
                    html.push('target="', target, '" ');
                }
                html.push('href="', url.replace(/"/g, "&quot;"), '">');
                addText(text);
                html.push("</a>");
            }
        };
    } ]);
})(window, window.angular);

(function(window, angular) {
    "use strict";
    var ngTouch = angular.module("ngTouch", []);
    ngTouch.provider("$touch", $TouchProvider);
    function nodeName_(element) {
        return angular.lowercase(element.nodeName || element[0] && element[0].nodeName);
    }
    $TouchProvider.$inject = [ "$provide", "$compileProvider" ];
    function $TouchProvider($provide, $compileProvider) {
        var ngClickOverrideEnabled = false;
        var ngClickDirectiveAdded = false;
        this.ngClickOverrideEnabled = function(enabled) {
            if (angular.isDefined(enabled)) {
                if (enabled && !ngClickDirectiveAdded) {
                    ngClickDirectiveAdded = true;
                    ngTouchClickDirectiveFactory.$$moduleName = "ngTouch";
                    $compileProvider.directive("ngClick", ngTouchClickDirectiveFactory);
                    $provide.decorator("ngClickDirective", [ "$delegate", function($delegate) {
                        if (ngClickOverrideEnabled) {
                            $delegate.shift();
                        } else {
                            var i = $delegate.length - 1;
                            while (i >= 0) {
                                if ($delegate[i].$$moduleName === "ngTouch") {
                                    $delegate.splice(i, 1);
                                    break;
                                }
                                i--;
                            }
                        }
                        return $delegate;
                    } ]);
                }
                ngClickOverrideEnabled = enabled;
                return this;
            }
            return ngClickOverrideEnabled;
        };
        this.$get = function() {
            return {
                ngClickOverrideEnabled: function() {
                    return ngClickOverrideEnabled;
                }
            };
        };
    }
    ngTouch.factory("$swipe", function() {
        var MOVE_BUFFER_RADIUS = 10;
        var POINTER_EVENTS = {
            mouse: {
                start: "mousedown",
                move: "mousemove",
                end: "mouseup"
            },
            touch: {
                start: "touchstart",
                move: "touchmove",
                end: "touchend",
                cancel: "touchcancel"
            },
            pointer: {
                start: "pointerdown",
                move: "pointermove",
                end: "pointerup",
                cancel: "pointercancel"
            }
        };
        function getCoordinates(event) {
            var originalEvent = event.originalEvent || event;
            var touches = originalEvent.touches && originalEvent.touches.length ? originalEvent.touches : [ originalEvent ];
            var e = originalEvent.changedTouches && originalEvent.changedTouches[0] || touches[0];
            return {
                x: e.clientX,
                y: e.clientY
            };
        }
        function getEvents(pointerTypes, eventType) {
            var res = [];
            angular.forEach(pointerTypes, function(pointerType) {
                var eventName = POINTER_EVENTS[pointerType][eventType];
                if (eventName) {
                    res.push(eventName);
                }
            });
            return res.join(" ");
        }
        return {
            bind: function(element, eventHandlers, pointerTypes) {
                var totalX, totalY;
                var startCoords;
                var lastPos;
                var active = false;
                pointerTypes = pointerTypes || [ "mouse", "touch", "pointer" ];
                element.on(getEvents(pointerTypes, "start"), function(event) {
                    startCoords = getCoordinates(event);
                    active = true;
                    totalX = 0;
                    totalY = 0;
                    lastPos = startCoords;
                    if (eventHandlers["start"]) {
                        eventHandlers["start"](startCoords, event);
                    }
                });
                var events = getEvents(pointerTypes, "cancel");
                if (events) {
                    element.on(events, function(event) {
                        active = false;
                        if (eventHandlers["cancel"]) {
                            eventHandlers["cancel"](event);
                        }
                    });
                }
                element.on(getEvents(pointerTypes, "move"), function(event) {
                    if (!active) return;
                    if (!startCoords) return;
                    var coords = getCoordinates(event);
                    totalX += Math.abs(coords.x - lastPos.x);
                    totalY += Math.abs(coords.y - lastPos.y);
                    lastPos = coords;
                    if (totalX < MOVE_BUFFER_RADIUS && totalY < MOVE_BUFFER_RADIUS) {
                        return;
                    }
                    if (totalY > totalX) {
                        active = false;
                        if (eventHandlers["cancel"]) {
                            eventHandlers["cancel"](event);
                        }
                        return;
                    } else {
                        event.preventDefault();
                        if (eventHandlers["move"]) {
                            eventHandlers["move"](coords, event);
                        }
                    }
                });
                element.on(getEvents(pointerTypes, "end"), function(event) {
                    if (!active) return;
                    active = false;
                    if (eventHandlers["end"]) {
                        eventHandlers["end"](getCoordinates(event), event);
                    }
                });
            }
        };
    });
    var ngTouchClickDirectiveFactory = [ "$parse", "$timeout", "$rootElement", function($parse, $timeout, $rootElement) {
        var TAP_DURATION = 750;
        var MOVE_TOLERANCE = 12;
        var PREVENT_DURATION = 2500;
        var CLICKBUSTER_THRESHOLD = 25;
        var ACTIVE_CLASS_NAME = "ng-click-active";
        var lastPreventedTime;
        var touchCoordinates;
        var lastLabelClickCoordinates;
        function hit(x1, y1, x2, y2) {
            return Math.abs(x1 - x2) < CLICKBUSTER_THRESHOLD && Math.abs(y1 - y2) < CLICKBUSTER_THRESHOLD;
        }
        function checkAllowableRegions(touchCoordinates, x, y) {
            for (var i = 0; i < touchCoordinates.length; i += 2) {
                if (hit(touchCoordinates[i], touchCoordinates[i + 1], x, y)) {
                    touchCoordinates.splice(i, i + 2);
                    return true;
                }
            }
            return false;
        }
        function onClick(event) {
            if (Date.now() - lastPreventedTime > PREVENT_DURATION) {
                return;
            }
            var touches = event.touches && event.touches.length ? event.touches : [ event ];
            var x = touches[0].clientX;
            var y = touches[0].clientY;
            if (x < 1 && y < 1) {
                return;
            }
            if (lastLabelClickCoordinates && lastLabelClickCoordinates[0] === x && lastLabelClickCoordinates[1] === y) {
                return;
            }
            if (lastLabelClickCoordinates) {
                lastLabelClickCoordinates = null;
            }
            if (nodeName_(event.target) === "label") {
                lastLabelClickCoordinates = [ x, y ];
            }
            if (checkAllowableRegions(touchCoordinates, x, y)) {
                return;
            }
            event.stopPropagation();
            event.preventDefault();
            if (event.target && event.target.blur) {
                event.target.blur();
            }
        }
        function onTouchStart(event) {
            var touches = event.touches && event.touches.length ? event.touches : [ event ];
            var x = touches[0].clientX;
            var y = touches[0].clientY;
            touchCoordinates.push(x, y);
            $timeout(function() {
                for (var i = 0; i < touchCoordinates.length; i += 2) {
                    if (touchCoordinates[i] === x && touchCoordinates[i + 1] === y) {
                        touchCoordinates.splice(i, i + 2);
                        return;
                    }
                }
            }, PREVENT_DURATION, false);
        }
        function preventGhostClick(x, y) {
            if (!touchCoordinates) {
                $rootElement[0].addEventListener("click", onClick, true);
                $rootElement[0].addEventListener("touchstart", onTouchStart, true);
                touchCoordinates = [];
            }
            lastPreventedTime = Date.now();
            checkAllowableRegions(touchCoordinates, x, y);
        }
        return function(scope, element, attr) {
            var clickHandler = $parse(attr.ngClick), tapping = false, tapElement, startTime, touchStartX, touchStartY;
            function resetState() {
                tapping = false;
                element.removeClass(ACTIVE_CLASS_NAME);
            }
            element.on("touchstart", function(event) {
                tapping = true;
                tapElement = event.target ? event.target : event.srcElement;
                if (tapElement.nodeType === 3) {
                    tapElement = tapElement.parentNode;
                }
                element.addClass(ACTIVE_CLASS_NAME);
                startTime = Date.now();
                var originalEvent = event.originalEvent || event;
                var touches = originalEvent.touches && originalEvent.touches.length ? originalEvent.touches : [ originalEvent ];
                var e = touches[0];
                touchStartX = e.clientX;
                touchStartY = e.clientY;
            });
            element.on("touchcancel", function(event) {
                resetState();
            });
            element.on("touchend", function(event) {
                var diff = Date.now() - startTime;
                var originalEvent = event.originalEvent || event;
                var touches = originalEvent.changedTouches && originalEvent.changedTouches.length ? originalEvent.changedTouches : originalEvent.touches && originalEvent.touches.length ? originalEvent.touches : [ originalEvent ];
                var e = touches[0];
                var x = e.clientX;
                var y = e.clientY;
                var dist = Math.sqrt(Math.pow(x - touchStartX, 2) + Math.pow(y - touchStartY, 2));
                if (tapping && diff < TAP_DURATION && dist < MOVE_TOLERANCE) {
                    preventGhostClick(x, y);
                    if (tapElement) {
                        tapElement.blur();
                    }
                    if (!angular.isDefined(attr.disabled) || attr.disabled === false) {
                        element.triggerHandler("click", [ event ]);
                    }
                }
                resetState();
            });
            element.onclick = function(event) {};
            element.on("click", function(event, touchend) {
                scope.$apply(function() {
                    clickHandler(scope, {
                        $event: touchend || event
                    });
                });
            });
            element.on("mousedown", function(event) {
                element.addClass(ACTIVE_CLASS_NAME);
            });
            element.on("mousemove mouseup", function(event) {
                element.removeClass(ACTIVE_CLASS_NAME);
            });
        };
    } ];
    function makeSwipeDirective(directiveName, direction, eventName) {
        ngTouch.directive(directiveName, [ "$parse", "$swipe", function($parse, $swipe) {
            var MAX_VERTICAL_DISTANCE = 75;
            var MAX_VERTICAL_RATIO = .3;
            var MIN_HORIZONTAL_DISTANCE = 30;
            return function(scope, element, attr) {
                var swipeHandler = $parse(attr[directiveName]);
                var startCoords, valid;
                function validSwipe(coords) {
                    if (!startCoords) return false;
                    var deltaY = Math.abs(coords.y - startCoords.y);
                    var deltaX = (coords.x - startCoords.x) * direction;
                    return valid && deltaY < MAX_VERTICAL_DISTANCE && deltaX > 0 && deltaX > MIN_HORIZONTAL_DISTANCE && deltaY / deltaX < MAX_VERTICAL_RATIO;
                }
                var pointerTypes = [ "touch" ];
                if (!angular.isDefined(attr["ngSwipeDisableMouse"])) {
                    pointerTypes.push("mouse");
                }
                $swipe.bind(element, {
                    start: function(coords, event) {
                        startCoords = coords;
                        valid = true;
                    },
                    cancel: function(event) {
                        valid = false;
                    },
                    end: function(coords, event) {
                        if (validSwipe(coords)) {
                            scope.$apply(function() {
                                element.triggerHandler(eventName);
                                swipeHandler(scope, {
                                    $event: event
                                });
                            });
                        }
                    }
                }, pointerTypes);
            };
        } ]);
    }
    makeSwipeDirective("ngSwipeLeft", -1, "swipeleft");
    makeSwipeDirective("ngSwipeRight", 1, "swiperight");
})(window, window.angular);

(function webpackUniversalModuleDefinition(root, factory) {
    if (typeof exports === "object" && typeof module === "object") module.exports = factory(); else if (typeof define === "function" && define.amd) define([], factory); else if (typeof exports === "object") exports["angular-file-upload"] = factory(); else root["angular-file-upload"] = factory();
})(this, function() {
    return function(modules) {
        var installedModules = {};
        function __webpack_require__(moduleId) {
            if (installedModules[moduleId]) return installedModules[moduleId].exports;
            var module = installedModules[moduleId] = {
                exports: {},
                id: moduleId,
                loaded: false
            };
            modules[moduleId].call(module.exports, module, module.exports, __webpack_require__);
            module.loaded = true;
            return module.exports;
        }
        __webpack_require__.m = modules;
        __webpack_require__.c = installedModules;
        __webpack_require__.p = "";
        return __webpack_require__(0);
    }([ function(module, exports, __webpack_require__) {
        "use strict";
        var _interopRequire = function(obj) {
            return obj && obj.__esModule ? obj["default"] : obj;
        };
        var CONFIG = _interopRequire(__webpack_require__(1));
        var options = _interopRequire(__webpack_require__(2));
        var serviceFileUploader = _interopRequire(__webpack_require__(3));
        var serviceFileLikeObject = _interopRequire(__webpack_require__(4));
        var serviceFileItem = _interopRequire(__webpack_require__(5));
        var serviceFileDirective = _interopRequire(__webpack_require__(6));
        var serviceFileSelect = _interopRequire(__webpack_require__(7));
        var serviceFileDrop = _interopRequire(__webpack_require__(8));
        var serviceFileOver = _interopRequire(__webpack_require__(9));
        var directiveFileSelect = _interopRequire(__webpack_require__(10));
        var directiveFileDrop = _interopRequire(__webpack_require__(11));
        var directiveFileOver = _interopRequire(__webpack_require__(12));
        angular.module(CONFIG.name, []).value("fileUploaderOptions", options).factory("FileUploader", serviceFileUploader).factory("FileLikeObject", serviceFileLikeObject).factory("FileItem", serviceFileItem).factory("FileDirective", serviceFileDirective).factory("FileSelect", serviceFileSelect).factory("FileDrop", serviceFileDrop).factory("FileOver", serviceFileOver).directive("nvFileSelect", directiveFileSelect).directive("nvFileDrop", directiveFileDrop).directive("nvFileOver", directiveFileOver).run([ "FileUploader", "FileLikeObject", "FileItem", "FileDirective", "FileSelect", "FileDrop", "FileOver", function(FileUploader, FileLikeObject, FileItem, FileDirective, FileSelect, FileDrop, FileOver) {
            FileUploader.FileLikeObject = FileLikeObject;
            FileUploader.FileItem = FileItem;
            FileUploader.FileDirective = FileDirective;
            FileUploader.FileSelect = FileSelect;
            FileUploader.FileDrop = FileDrop;
            FileUploader.FileOver = FileOver;
        } ]);
    }, function(module, exports) {
        module.exports = {
            name: "angularFileUpload"
        };
    }, function(module, exports) {
        "use strict";
        module.exports = {
            url: "/",
            alias: "file",
            headers: {},
            queue: [],
            progress: 0,
            autoUpload: false,
            removeAfterUpload: false,
            method: "POST",
            filters: [],
            formData: [],
            queueLimit: Number.MAX_VALUE,
            withCredentials: false
        };
    }, function(module, exports, __webpack_require__) {
        "use strict";
        var _interopRequire = function(obj) {
            return obj && obj.__esModule ? obj["default"] : obj;
        };
        var _createClass = function() {
            function defineProperties(target, props) {
                for (var key in props) {
                    var prop = props[key];
                    prop.configurable = true;
                    if (prop.value) prop.writable = true;
                }
                Object.defineProperties(target, props);
            }
            return function(Constructor, protoProps, staticProps) {
                if (protoProps) defineProperties(Constructor.prototype, protoProps);
                if (staticProps) defineProperties(Constructor, staticProps);
                return Constructor;
            };
        }();
        var _classCallCheck = function(instance, Constructor) {
            if (!(instance instanceof Constructor)) {
                throw new TypeError("Cannot call a class as a function");
            }
        };
        var CONFIG = _interopRequire(__webpack_require__(1));
        var copy = angular.copy;
        var extend = angular.extend;
        var forEach = angular.forEach;
        var isObject = angular.isObject;
        var isNumber = angular.isNumber;
        var isDefined = angular.isDefined;
        var isArray = angular.isArray;
        var element = angular.element;
        module.exports = function(fileUploaderOptions, $rootScope, $http, $window, FileLikeObject, FileItem) {
            var File = $window.File;
            var FormData = $window.FormData;
            var FileUploader = function() {
                function FileUploader(options) {
                    _classCallCheck(this, FileUploader);
                    var settings = copy(fileUploaderOptions);
                    extend(this, settings, options, {
                        isUploading: false,
                        _nextIndex: 0,
                        _failFilterIndex: -1,
                        _directives: {
                            select: [],
                            drop: [],
                            over: []
                        }
                    });
                    this.filters.unshift({
                        name: "queueLimit",
                        fn: this._queueLimitFilter
                    });
                    this.filters.unshift({
                        name: "folder",
                        fn: this._folderFilter
                    });
                }
                _createClass(FileUploader, {
                    addToQueue: {
                        value: function addToQueue(files, options, filters) {
                            var _this = this;
                            var list = this.isArrayLikeObject(files) ? files : [ files ];
                            var arrayOfFilters = this._getFilters(filters);
                            var count = this.queue.length;
                            var addedFileItems = [];
                            forEach(list, function(some) {
                                var temp = new FileLikeObject(some);
                                if (_this._isValidFile(temp, arrayOfFilters, options)) {
                                    var fileItem = new FileItem(_this, some, options);
                                    addedFileItems.push(fileItem);
                                    _this.queue.push(fileItem);
                                    _this._onAfterAddingFile(fileItem);
                                } else {
                                    var filter = arrayOfFilters[_this._failFilterIndex];
                                    _this._onWhenAddingFileFailed(temp, filter, options);
                                }
                            });
                            if (this.queue.length !== count) {
                                this._onAfterAddingAll(addedFileItems);
                                this.progress = this._getTotalProgress();
                            }
                            this._render();
                            if (this.autoUpload) this.uploadAll();
                        }
                    },
                    removeFromQueue: {
                        value: function removeFromQueue(value) {
                            var index = this.getIndexOfItem(value);
                            var item = this.queue[index];
                            if (item.isUploading) item.cancel();
                            this.queue.splice(index, 1);
                            item._destroy();
                            this.progress = this._getTotalProgress();
                        }
                    },
                    clearQueue: {
                        value: function clearQueue() {
                            while (this.queue.length) {
                                this.queue[0].remove();
                            }
                            this.progress = 0;
                        }
                    },
                    uploadItem: {
                        value: function uploadItem(value) {
                            var index = this.getIndexOfItem(value);
                            var item = this.queue[index];
                            var transport = this.isHTML5 ? "_xhrTransport" : "_iframeTransport";
                            item._prepareToUploading();
                            if (this.isUploading) {
                                return;
                            }
                            this.isUploading = true;
                            this[transport](item);
                        }
                    },
                    cancelItem: {
                        value: function cancelItem(value) {
                            var index = this.getIndexOfItem(value);
                            var item = this.queue[index];
                            var prop = this.isHTML5 ? "_xhr" : "_form";
                            if (item && item.isUploading) item[prop].abort();
                        }
                    },
                    uploadAll: {
                        value: function uploadAll() {
                            var items = this.getNotUploadedItems().filter(function(item) {
                                return !item.isUploading;
                            });
                            if (!items.length) {
                                return;
                            }
                            forEach(items, function(item) {
                                return item._prepareToUploading();
                            });
                            items[0].upload();
                        }
                    },
                    cancelAll: {
                        value: function cancelAll() {
                            var items = this.getNotUploadedItems();
                            forEach(items, function(item) {
                                return item.cancel();
                            });
                        }
                    },
                    isFile: {
                        value: function isFile(value) {
                            return this.constructor.isFile(value);
                        }
                    },
                    isFileLikeObject: {
                        value: function isFileLikeObject(value) {
                            return this.constructor.isFileLikeObject(value);
                        }
                    },
                    isArrayLikeObject: {
                        value: function isArrayLikeObject(value) {
                            return this.constructor.isArrayLikeObject(value);
                        }
                    },
                    getIndexOfItem: {
                        value: function getIndexOfItem(value) {
                            return isNumber(value) ? value : this.queue.indexOf(value);
                        }
                    },
                    getNotUploadedItems: {
                        value: function getNotUploadedItems() {
                            return this.queue.filter(function(item) {
                                return !item.isUploaded;
                            });
                        }
                    },
                    getReadyItems: {
                        value: function getReadyItems() {
                            return this.queue.filter(function(item) {
                                return item.isReady && !item.isUploading;
                            }).sort(function(item1, item2) {
                                return item1.index - item2.index;
                            });
                        }
                    },
                    destroy: {
                        value: function destroy() {
                            var _this = this;
                            forEach(this._directives, function(key) {
                                forEach(_this._directives[key], function(object) {
                                    object.destroy();
                                });
                            });
                        }
                    },
                    onAfterAddingAll: {
                        value: function onAfterAddingAll(fileItems) {}
                    },
                    onAfterAddingFile: {
                        value: function onAfterAddingFile(fileItem) {}
                    },
                    onWhenAddingFileFailed: {
                        value: function onWhenAddingFileFailed(item, filter, options) {}
                    },
                    onBeforeUploadItem: {
                        value: function onBeforeUploadItem(fileItem) {}
                    },
                    onProgressItem: {
                        value: function onProgressItem(fileItem, progress) {}
                    },
                    onProgressAll: {
                        value: function onProgressAll(progress) {}
                    },
                    onSuccessItem: {
                        value: function onSuccessItem(item, response, status, headers) {}
                    },
                    onErrorItem: {
                        value: function onErrorItem(item, response, status, headers) {}
                    },
                    onCancelItem: {
                        value: function onCancelItem(item, response, status, headers) {}
                    },
                    onCompleteItem: {
                        value: function onCompleteItem(item, response, status, headers) {}
                    },
                    onCompleteAll: {
                        value: function onCompleteAll() {}
                    },
                    _getTotalProgress: {
                        value: function _getTotalProgress(value) {
                            if (this.removeAfterUpload) {
                                return value || 0;
                            }
                            var notUploaded = this.getNotUploadedItems().length;
                            var uploaded = notUploaded ? this.queue.length - notUploaded : this.queue.length;
                            var ratio = 100 / this.queue.length;
                            var current = (value || 0) * ratio / 100;
                            return Math.round(uploaded * ratio + current);
                        }
                    },
                    _getFilters: {
                        value: function _getFilters(filters) {
                            if (!filters) {
                                return this.filters;
                            }
                            if (isArray(filters)) {
                                return filters;
                            }
                            var names = filters.match(/[^\s,]+/g);
                            return this.filters.filter(function(filter) {
                                return names.indexOf(filter.name) !== -1;
                            });
                        }
                    },
                    _render: {
                        value: function _render() {
                            if (!$rootScope.$$phase) $rootScope.$apply();
                        }
                    },
                    _folderFilter: {
                        value: function _folderFilter(item) {
                            return !!(item.size || item.type);
                        }
                    },
                    _queueLimitFilter: {
                        value: function _queueLimitFilter() {
                            return this.queue.length < this.queueLimit;
                        }
                    },
                    _isValidFile: {
                        value: function _isValidFile(file, filters, options) {
                            var _this = this;
                            this._failFilterIndex = -1;
                            return !filters.length ? true : filters.every(function(filter) {
                                _this._failFilterIndex++;
                                return filter.fn.call(_this, file, options);
                            });
                        }
                    },
                    _isSuccessCode: {
                        value: function _isSuccessCode(status) {
                            return status >= 200 && status < 300 || status === 304;
                        }
                    },
                    _transformResponse: {
                        value: function _transformResponse(response, headers) {
                            var headersGetter = this._headersGetter(headers);
                            forEach($http.defaults.transformResponse, function(transformFn) {
                                response = transformFn(response, headersGetter);
                            });
                            return response;
                        }
                    },
                    _parseHeaders: {
                        value: function _parseHeaders(headers) {
                            var parsed = {}, key, val, i;
                            if (!headers) {
                                return parsed;
                            }
                            forEach(headers.split("\n"), function(line) {
                                i = line.indexOf(":");
                                key = line.slice(0, i).trim().toLowerCase();
                                val = line.slice(i + 1).trim();
                                if (key) {
                                    parsed[key] = parsed[key] ? parsed[key] + ", " + val : val;
                                }
                            });
                            return parsed;
                        }
                    },
                    _headersGetter: {
                        value: function _headersGetter(parsedHeaders) {
                            return function(name) {
                                if (name) {
                                    return parsedHeaders[name.toLowerCase()] || null;
                                }
                                return parsedHeaders;
                            };
                        }
                    },
                    _xhrTransport: {
                        value: function _xhrTransport(item) {
                            var _this = this;
                            var xhr = item._xhr = new XMLHttpRequest();
                            var form = new FormData();
                            this._onBeforeUploadItem(item);
                            forEach(item.formData, function(obj) {
                                forEach(obj, function(value, key) {
                                    form.append(key, value);
                                });
                            });
                            if (typeof item._file.size != "number") {
                                throw new TypeError("The file specified is no longer valid");
                            }
                            form.append(item.alias, item._file, item.file.name);
                            xhr.upload.onprogress = function(event) {
                                var progress = Math.round(event.lengthComputable ? event.loaded * 100 / event.total : 0);
                                _this._onProgressItem(item, progress);
                            };
                            xhr.onload = function() {
                                var headers = _this._parseHeaders(xhr.getAllResponseHeaders());
                                var response = _this._transformResponse(xhr.response, headers);
                                var gist = _this._isSuccessCode(xhr.status) ? "Success" : "Error";
                                var method = "_on" + gist + "Item";
                                _this[method](item, response, xhr.status, headers);
                                _this._onCompleteItem(item, response, xhr.status, headers);
                            };
                            xhr.onerror = function() {
                                var headers = _this._parseHeaders(xhr.getAllResponseHeaders());
                                var response = _this._transformResponse(xhr.response, headers);
                                _this._onErrorItem(item, response, xhr.status, headers);
                                _this._onCompleteItem(item, response, xhr.status, headers);
                            };
                            xhr.onabort = function() {
                                var headers = _this._parseHeaders(xhr.getAllResponseHeaders());
                                var response = _this._transformResponse(xhr.response, headers);
                                _this._onCancelItem(item, response, xhr.status, headers);
                                _this._onCompleteItem(item, response, xhr.status, headers);
                            };
                            xhr.open(item.method, item.url, true);
                            xhr.withCredentials = item.withCredentials;
                            forEach(item.headers, function(value, name) {
                                xhr.setRequestHeader(name, value);
                            });
                            xhr.send(form);
                            this._render();
                        }
                    },
                    _iframeTransport: {
                        value: function _iframeTransport(item) {
                            var _this = this;
                            var form = element('<form style="display: none;" />');
                            var iframe = element('<iframe name="iframeTransport' + Date.now() + '">');
                            var input = item._input;
                            if (item._form) item._form.replaceWith(input);
                            item._form = form;
                            this._onBeforeUploadItem(item);
                            input.prop("name", item.alias);
                            forEach(item.formData, function(obj) {
                                forEach(obj, function(value, key) {
                                    var element_ = element('<input type="hidden" name="' + key + '" />');
                                    element_.val(value);
                                    form.append(element_);
                                });
                            });
                            form.prop({
                                action: item.url,
                                method: "POST",
                                target: iframe.prop("name"),
                                enctype: "multipart/form-data",
                                encoding: "multipart/form-data"
                            });
                            iframe.bind("load", function() {
                                var html = "";
                                var status = 200;
                                try {
                                    html = iframe[0].contentDocument.body.innerHTML;
                                } catch (e) {
                                    status = 500;
                                }
                                var xhr = {
                                    response: html,
                                    status: status,
                                    dummy: true
                                };
                                var headers = {};
                                var response = _this._transformResponse(xhr.response, headers);
                                _this._onSuccessItem(item, response, xhr.status, headers);
                                _this._onCompleteItem(item, response, xhr.status, headers);
                            });
                            form.abort = function() {
                                var xhr = {
                                    status: 0,
                                    dummy: true
                                };
                                var headers = {};
                                var response;
                                iframe.unbind("load").prop("src", "javascript:false;");
                                form.replaceWith(input);
                                _this._onCancelItem(item, response, xhr.status, headers);
                                _this._onCompleteItem(item, response, xhr.status, headers);
                            };
                            input.after(form);
                            form.append(input).append(iframe);
                            form[0].submit();
                            this._render();
                        }
                    },
                    _onWhenAddingFileFailed: {
                        value: function _onWhenAddingFileFailed(item, filter, options) {
                            this.onWhenAddingFileFailed(item, filter, options);
                        }
                    },
                    _onAfterAddingFile: {
                        value: function _onAfterAddingFile(item) {
                            this.onAfterAddingFile(item);
                        }
                    },
                    _onAfterAddingAll: {
                        value: function _onAfterAddingAll(items) {
                            this.onAfterAddingAll(items);
                        }
                    },
                    _onBeforeUploadItem: {
                        value: function _onBeforeUploadItem(item) {
                            item._onBeforeUpload();
                            this.onBeforeUploadItem(item);
                        }
                    },
                    _onProgressItem: {
                        value: function _onProgressItem(item, progress) {
                            var total = this._getTotalProgress(progress);
                            this.progress = total;
                            item._onProgress(progress);
                            this.onProgressItem(item, progress);
                            this.onProgressAll(total);
                            this._render();
                        }
                    },
                    _onSuccessItem: {
                        value: function _onSuccessItem(item, response, status, headers) {
                            item._onSuccess(response, status, headers);
                            this.onSuccessItem(item, response, status, headers);
                        }
                    },
                    _onErrorItem: {
                        value: function _onErrorItem(item, response, status, headers) {
                            item._onError(response, status, headers);
                            this.onErrorItem(item, response, status, headers);
                        }
                    },
                    _onCancelItem: {
                        value: function _onCancelItem(item, response, status, headers) {
                            item._onCancel(response, status, headers);
                            this.onCancelItem(item, response, status, headers);
                        }
                    },
                    _onCompleteItem: {
                        value: function _onCompleteItem(item, response, status, headers) {
                            item._onComplete(response, status, headers);
                            this.onCompleteItem(item, response, status, headers);
                            var nextItem = this.getReadyItems()[0];
                            this.isUploading = false;
                            if (isDefined(nextItem)) {
                                nextItem.upload();
                                return;
                            }
                            this.onCompleteAll();
                            this.progress = this._getTotalProgress();
                            this._render();
                        }
                    }
                }, {
                    isFile: {
                        value: function isFile(value) {
                            return File && value instanceof File;
                        }
                    },
                    isFileLikeObject: {
                        value: function isFileLikeObject(value) {
                            return value instanceof FileLikeObject;
                        }
                    },
                    isArrayLikeObject: {
                        value: function isArrayLikeObject(value) {
                            return isObject(value) && "length" in value;
                        }
                    },
                    inherit: {
                        value: function inherit(target, source) {
                            target.prototype = Object.create(source.prototype);
                            target.prototype.constructor = target;
                            target.super_ = source;
                        }
                    }
                });
                return FileUploader;
            }();
            FileUploader.prototype.isHTML5 = !!(File && FormData);
            FileUploader.isHTML5 = FileUploader.prototype.isHTML5;
            return FileUploader;
        };
        module.exports.$inject = [ "fileUploaderOptions", "$rootScope", "$http", "$window", "FileLikeObject", "FileItem" ];
    }, function(module, exports, __webpack_require__) {
        "use strict";
        var _interopRequire = function(obj) {
            return obj && obj.__esModule ? obj["default"] : obj;
        };
        var _createClass = function() {
            function defineProperties(target, props) {
                for (var key in props) {
                    var prop = props[key];
                    prop.configurable = true;
                    if (prop.value) prop.writable = true;
                }
                Object.defineProperties(target, props);
            }
            return function(Constructor, protoProps, staticProps) {
                if (protoProps) defineProperties(Constructor.prototype, protoProps);
                if (staticProps) defineProperties(Constructor, staticProps);
                return Constructor;
            };
        }();
        var _classCallCheck = function(instance, Constructor) {
            if (!(instance instanceof Constructor)) {
                throw new TypeError("Cannot call a class as a function");
            }
        };
        var CONFIG = _interopRequire(__webpack_require__(1));
        var copy = angular.copy;
        var isElement = angular.isElement;
        var isString = angular.isString;
        module.exports = function() {
            var FileLikeObject = function() {
                function FileLikeObject(fileOrInput) {
                    _classCallCheck(this, FileLikeObject);
                    var isInput = isElement(fileOrInput);
                    var fakePathOrObject = isInput ? fileOrInput.value : fileOrInput;
                    var postfix = isString(fakePathOrObject) ? "FakePath" : "Object";
                    var method = "_createFrom" + postfix;
                    this[method](fakePathOrObject);
                }
                _createClass(FileLikeObject, {
                    _createFromFakePath: {
                        value: function _createFromFakePath(path) {
                            this.lastModifiedDate = null;
                            this.size = null;
                            this.type = "like/" + path.slice(path.lastIndexOf(".") + 1).toLowerCase();
                            this.name = path.slice(path.lastIndexOf("/") + path.lastIndexOf("\\") + 2);
                        }
                    },
                    _createFromObject: {
                        value: function _createFromObject(object) {
                            this.lastModifiedDate = copy(object.lastModifiedDate);
                            this.size = object.size;
                            this.type = object.type;
                            this.name = object.name;
                        }
                    }
                });
                return FileLikeObject;
            }();
            return FileLikeObject;
        };
        module.exports.$inject = [];
    }, function(module, exports, __webpack_require__) {
        "use strict";
        var _interopRequire = function(obj) {
            return obj && obj.__esModule ? obj["default"] : obj;
        };
        var _createClass = function() {
            function defineProperties(target, props) {
                for (var key in props) {
                    var prop = props[key];
                    prop.configurable = true;
                    if (prop.value) prop.writable = true;
                }
                Object.defineProperties(target, props);
            }
            return function(Constructor, protoProps, staticProps) {
                if (protoProps) defineProperties(Constructor.prototype, protoProps);
                if (staticProps) defineProperties(Constructor, staticProps);
                return Constructor;
            };
        }();
        var _classCallCheck = function(instance, Constructor) {
            if (!(instance instanceof Constructor)) {
                throw new TypeError("Cannot call a class as a function");
            }
        };
        var CONFIG = _interopRequire(__webpack_require__(1));
        var copy = angular.copy;
        var extend = angular.extend;
        var element = angular.element;
        var isElement = angular.isElement;
        module.exports = function($compile, FileLikeObject) {
            var FileItem = function() {
                function FileItem(uploader, some, options) {
                    _classCallCheck(this, FileItem);
                    var isInput = isElement(some);
                    var input = isInput ? element(some) : null;
                    var file = !isInput ? some : null;
                    extend(this, {
                        url: uploader.url,
                        alias: uploader.alias,
                        headers: copy(uploader.headers),
                        formData: copy(uploader.formData),
                        removeAfterUpload: uploader.removeAfterUpload,
                        withCredentials: uploader.withCredentials,
                        method: uploader.method
                    }, options, {
                        uploader: uploader,
                        file: new FileLikeObject(some),
                        isReady: false,
                        isUploading: false,
                        isUploaded: false,
                        isSuccess: false,
                        isCancel: false,
                        isError: false,
                        progress: 0,
                        index: null,
                        _file: file,
                        _input: input
                    });
                    if (input) this._replaceNode(input);
                }
                _createClass(FileItem, {
                    upload: {
                        value: function upload() {
                            try {
                                this.uploader.uploadItem(this);
                            } catch (e) {
                                this.uploader._onCompleteItem(this, "", 0, []);
                                this.uploader._onErrorItem(this, "", 0, []);
                            }
                        }
                    },
                    cancel: {
                        value: function cancel() {
                            this.uploader.cancelItem(this);
                        }
                    },
                    remove: {
                        value: function remove() {
                            this.uploader.removeFromQueue(this);
                        }
                    },
                    onBeforeUpload: {
                        value: function onBeforeUpload() {}
                    },
                    onProgress: {
                        value: function onProgress(progress) {}
                    },
                    onSuccess: {
                        value: function onSuccess(response, status, headers) {}
                    },
                    onError: {
                        value: function onError(response, status, headers) {}
                    },
                    onCancel: {
                        value: function onCancel(response, status, headers) {}
                    },
                    onComplete: {
                        value: function onComplete(response, status, headers) {}
                    },
                    _onBeforeUpload: {
                        value: function _onBeforeUpload() {
                            this.isReady = true;
                            this.isUploading = true;
                            this.isUploaded = false;
                            this.isSuccess = false;
                            this.isCancel = false;
                            this.isError = false;
                            this.progress = 0;
                            this.onBeforeUpload();
                        }
                    },
                    _onProgress: {
                        value: function _onProgress(progress) {
                            this.progress = progress;
                            this.onProgress(progress);
                        }
                    },
                    _onSuccess: {
                        value: function _onSuccess(response, status, headers) {
                            this.isReady = false;
                            this.isUploading = false;
                            this.isUploaded = true;
                            this.isSuccess = true;
                            this.isCancel = false;
                            this.isError = false;
                            this.progress = 100;
                            this.index = null;
                            this.onSuccess(response, status, headers);
                        }
                    },
                    _onError: {
                        value: function _onError(response, status, headers) {
                            this.isReady = false;
                            this.isUploading = false;
                            this.isUploaded = true;
                            this.isSuccess = false;
                            this.isCancel = false;
                            this.isError = true;
                            this.progress = 0;
                            this.index = null;
                            this.onError(response, status, headers);
                        }
                    },
                    _onCancel: {
                        value: function _onCancel(response, status, headers) {
                            this.isReady = false;
                            this.isUploading = false;
                            this.isUploaded = false;
                            this.isSuccess = false;
                            this.isCancel = true;
                            this.isError = false;
                            this.progress = 0;
                            this.index = null;
                            this.onCancel(response, status, headers);
                        }
                    },
                    _onComplete: {
                        value: function _onComplete(response, status, headers) {
                            this.onComplete(response, status, headers);
                            if (this.removeAfterUpload) this.remove();
                        }
                    },
                    _destroy: {
                        value: function _destroy() {
                            if (this._input) this._input.remove();
                            if (this._form) this._form.remove();
                            delete this._form;
                            delete this._input;
                        }
                    },
                    _prepareToUploading: {
                        value: function _prepareToUploading() {
                            this.index = this.index || ++this.uploader._nextIndex;
                            this.isReady = true;
                        }
                    },
                    _replaceNode: {
                        value: function _replaceNode(input) {
                            var clone = $compile(input.clone())(input.scope());
                            clone.prop("value", null);
                            input.css("display", "none");
                            input.after(clone);
                        }
                    }
                });
                return FileItem;
            }();
            return FileItem;
        };
        module.exports.$inject = [ "$compile", "FileLikeObject" ];
    }, function(module, exports, __webpack_require__) {
        "use strict";
        var _interopRequire = function(obj) {
            return obj && obj.__esModule ? obj["default"] : obj;
        };
        var _createClass = function() {
            function defineProperties(target, props) {
                for (var key in props) {
                    var prop = props[key];
                    prop.configurable = true;
                    if (prop.value) prop.writable = true;
                }
                Object.defineProperties(target, props);
            }
            return function(Constructor, protoProps, staticProps) {
                if (protoProps) defineProperties(Constructor.prototype, protoProps);
                if (staticProps) defineProperties(Constructor, staticProps);
                return Constructor;
            };
        }();
        var _classCallCheck = function(instance, Constructor) {
            if (!(instance instanceof Constructor)) {
                throw new TypeError("Cannot call a class as a function");
            }
        };
        var CONFIG = _interopRequire(__webpack_require__(1));
        var extend = angular.extend;
        module.exports = function() {
            var FileDirective = function() {
                function FileDirective(options) {
                    _classCallCheck(this, FileDirective);
                    extend(this, options);
                    this.uploader._directives[this.prop].push(this);
                    this._saveLinks();
                    this.bind();
                }
                _createClass(FileDirective, {
                    bind: {
                        value: function bind() {
                            for (var key in this.events) {
                                var prop = this.events[key];
                                this.element.bind(key, this[prop]);
                            }
                        }
                    },
                    unbind: {
                        value: function unbind() {
                            for (var key in this.events) {
                                this.element.unbind(key, this.events[key]);
                            }
                        }
                    },
                    destroy: {
                        value: function destroy() {
                            var index = this.uploader._directives[this.prop].indexOf(this);
                            this.uploader._directives[this.prop].splice(index, 1);
                            this.unbind();
                        }
                    },
                    _saveLinks: {
                        value: function _saveLinks() {
                            for (var key in this.events) {
                                var prop = this.events[key];
                                this[prop] = this[prop].bind(this);
                            }
                        }
                    }
                });
                return FileDirective;
            }();
            FileDirective.prototype.events = {};
            return FileDirective;
        };
        module.exports.$inject = [];
    }, function(module, exports, __webpack_require__) {
        "use strict";
        var _interopRequire = function(obj) {
            return obj && obj.__esModule ? obj["default"] : obj;
        };
        var _createClass = function() {
            function defineProperties(target, props) {
                for (var key in props) {
                    var prop = props[key];
                    prop.configurable = true;
                    if (prop.value) prop.writable = true;
                }
                Object.defineProperties(target, props);
            }
            return function(Constructor, protoProps, staticProps) {
                if (protoProps) defineProperties(Constructor.prototype, protoProps);
                if (staticProps) defineProperties(Constructor, staticProps);
                return Constructor;
            };
        }();
        var _get = function get(object, property, receiver) {
            var desc = Object.getOwnPropertyDescriptor(object, property);
            if (desc === undefined) {
                var parent = Object.getPrototypeOf(object);
                if (parent === null) {
                    return undefined;
                } else {
                    return get(parent, property, receiver);
                }
            } else if ("value" in desc && desc.writable) {
                return desc.value;
            } else {
                var getter = desc.get;
                if (getter === undefined) {
                    return undefined;
                }
                return getter.call(receiver);
            }
        };
        var _inherits = function(subClass, superClass) {
            if (typeof superClass !== "function" && superClass !== null) {
                throw new TypeError("Super expression must either be null or a function, not " + typeof superClass);
            }
            subClass.prototype = Object.create(superClass && superClass.prototype, {
                constructor: {
                    value: subClass,
                    enumerable: false,
                    writable: true,
                    configurable: true
                }
            });
            if (superClass) subClass.__proto__ = superClass;
        };
        var _classCallCheck = function(instance, Constructor) {
            if (!(instance instanceof Constructor)) {
                throw new TypeError("Cannot call a class as a function");
            }
        };
        var CONFIG = _interopRequire(__webpack_require__(1));
        var extend = angular.extend;
        module.exports = function(FileDirective) {
            var FileSelect = function(_FileDirective) {
                function FileSelect(options) {
                    _classCallCheck(this, FileSelect);
                    var extendedOptions = extend(options, {
                        events: {
                            $destroy: "destroy",
                            change: "onChange"
                        },
                        prop: "select"
                    });
                    _get(Object.getPrototypeOf(FileSelect.prototype), "constructor", this).call(this, extendedOptions);
                    if (!this.uploader.isHTML5) {
                        this.element.removeAttr("multiple");
                    }
                    this.element.prop("value", null);
                }
                _inherits(FileSelect, _FileDirective);
                _createClass(FileSelect, {
                    getOptions: {
                        value: function getOptions() {}
                    },
                    getFilters: {
                        value: function getFilters() {}
                    },
                    isEmptyAfterSelection: {
                        value: function isEmptyAfterSelection() {
                            return !!this.element.attr("multiple");
                        }
                    },
                    onChange: {
                        value: function onChange() {
                            var files = this.uploader.isHTML5 ? this.element[0].files : this.element[0];
                            var options = this.getOptions();
                            var filters = this.getFilters();
                            if (!this.uploader.isHTML5) this.destroy();
                            this.uploader.addToQueue(files, options, filters);
                            if (this.isEmptyAfterSelection()) {
                                this.element.prop("value", null);
                                this.element.replaceWith(this.element = this.element.clone(true));
                            }
                        }
                    }
                });
                return FileSelect;
            }(FileDirective);
            return FileSelect;
        };
        module.exports.$inject = [ "FileDirective" ];
    }, function(module, exports, __webpack_require__) {
        "use strict";
        var _interopRequire = function(obj) {
            return obj && obj.__esModule ? obj["default"] : obj;
        };
        var _createClass = function() {
            function defineProperties(target, props) {
                for (var key in props) {
                    var prop = props[key];
                    prop.configurable = true;
                    if (prop.value) prop.writable = true;
                }
                Object.defineProperties(target, props);
            }
            return function(Constructor, protoProps, staticProps) {
                if (protoProps) defineProperties(Constructor.prototype, protoProps);
                if (staticProps) defineProperties(Constructor, staticProps);
                return Constructor;
            };
        }();
        var _get = function get(object, property, receiver) {
            var desc = Object.getOwnPropertyDescriptor(object, property);
            if (desc === undefined) {
                var parent = Object.getPrototypeOf(object);
                if (parent === null) {
                    return undefined;
                } else {
                    return get(parent, property, receiver);
                }
            } else if ("value" in desc && desc.writable) {
                return desc.value;
            } else {
                var getter = desc.get;
                if (getter === undefined) {
                    return undefined;
                }
                return getter.call(receiver);
            }
        };
        var _inherits = function(subClass, superClass) {
            if (typeof superClass !== "function" && superClass !== null) {
                throw new TypeError("Super expression must either be null or a function, not " + typeof superClass);
            }
            subClass.prototype = Object.create(superClass && superClass.prototype, {
                constructor: {
                    value: subClass,
                    enumerable: false,
                    writable: true,
                    configurable: true
                }
            });
            if (superClass) subClass.__proto__ = superClass;
        };
        var _classCallCheck = function(instance, Constructor) {
            if (!(instance instanceof Constructor)) {
                throw new TypeError("Cannot call a class as a function");
            }
        };
        var CONFIG = _interopRequire(__webpack_require__(1));
        var extend = angular.extend;
        var forEach = angular.forEach;
        module.exports = function(FileDirective) {
            var FileDrop = function(_FileDirective) {
                function FileDrop(options) {
                    _classCallCheck(this, FileDrop);
                    var extendedOptions = extend(options, {
                        events: {
                            $destroy: "destroy",
                            drop: "onDrop",
                            dragover: "onDragOver",
                            dragleave: "onDragLeave"
                        },
                        prop: "drop"
                    });
                    _get(Object.getPrototypeOf(FileDrop.prototype), "constructor", this).call(this, extendedOptions);
                }
                _inherits(FileDrop, _FileDirective);
                _createClass(FileDrop, {
                    getOptions: {
                        value: function getOptions() {}
                    },
                    getFilters: {
                        value: function getFilters() {}
                    },
                    onDrop: {
                        value: function onDrop(event) {
                            var transfer = this._getTransfer(event);
                            if (!transfer) {
                                return;
                            }
                            var options = this.getOptions();
                            var filters = this.getFilters();
                            this._preventAndStop(event);
                            forEach(this.uploader._directives.over, this._removeOverClass, this);
                            this.uploader.addToQueue(transfer.files, options, filters);
                        }
                    },
                    onDragOver: {
                        value: function onDragOver(event) {
                            var transfer = this._getTransfer(event);
                            if (!this._haveFiles(transfer.types)) {
                                return;
                            }
                            transfer.dropEffect = "copy";
                            this._preventAndStop(event);
                            forEach(this.uploader._directives.over, this._addOverClass, this);
                        }
                    },
                    onDragLeave: {
                        value: function onDragLeave(event) {
                            if (event.currentTarget === this.element[0]) {
                                return;
                            }
                            this._preventAndStop(event);
                            forEach(this.uploader._directives.over, this._removeOverClass, this);
                        }
                    },
                    _getTransfer: {
                        value: function _getTransfer(event) {
                            return event.dataTransfer ? event.dataTransfer : event.originalEvent.dataTransfer;
                        }
                    },
                    _preventAndStop: {
                        value: function _preventAndStop(event) {
                            event.preventDefault();
                            event.stopPropagation();
                        }
                    },
                    _haveFiles: {
                        value: function _haveFiles(types) {
                            if (!types) {
                                return false;
                            }
                            if (types.indexOf) {
                                return types.indexOf("Files") !== -1;
                            } else if (types.contains) {
                                return types.contains("Files");
                            } else {
                                return false;
                            }
                        }
                    },
                    _addOverClass: {
                        value: function _addOverClass(item) {
                            item.addOverClass();
                        }
                    },
                    _removeOverClass: {
                        value: function _removeOverClass(item) {
                            item.removeOverClass();
                        }
                    }
                });
                return FileDrop;
            }(FileDirective);
            return FileDrop;
        };
        module.exports.$inject = [ "FileDirective" ];
    }, function(module, exports, __webpack_require__) {
        "use strict";
        var _interopRequire = function(obj) {
            return obj && obj.__esModule ? obj["default"] : obj;
        };
        var _createClass = function() {
            function defineProperties(target, props) {
                for (var key in props) {
                    var prop = props[key];
                    prop.configurable = true;
                    if (prop.value) prop.writable = true;
                }
                Object.defineProperties(target, props);
            }
            return function(Constructor, protoProps, staticProps) {
                if (protoProps) defineProperties(Constructor.prototype, protoProps);
                if (staticProps) defineProperties(Constructor, staticProps);
                return Constructor;
            };
        }();
        var _get = function get(object, property, receiver) {
            var desc = Object.getOwnPropertyDescriptor(object, property);
            if (desc === undefined) {
                var parent = Object.getPrototypeOf(object);
                if (parent === null) {
                    return undefined;
                } else {
                    return get(parent, property, receiver);
                }
            } else if ("value" in desc && desc.writable) {
                return desc.value;
            } else {
                var getter = desc.get;
                if (getter === undefined) {
                    return undefined;
                }
                return getter.call(receiver);
            }
        };
        var _inherits = function(subClass, superClass) {
            if (typeof superClass !== "function" && superClass !== null) {
                throw new TypeError("Super expression must either be null or a function, not " + typeof superClass);
            }
            subClass.prototype = Object.create(superClass && superClass.prototype, {
                constructor: {
                    value: subClass,
                    enumerable: false,
                    writable: true,
                    configurable: true
                }
            });
            if (superClass) subClass.__proto__ = superClass;
        };
        var _classCallCheck = function(instance, Constructor) {
            if (!(instance instanceof Constructor)) {
                throw new TypeError("Cannot call a class as a function");
            }
        };
        var CONFIG = _interopRequire(__webpack_require__(1));
        var extend = angular.extend;
        module.exports = function(FileDirective) {
            var FileOver = function(_FileDirective) {
                function FileOver(options) {
                    _classCallCheck(this, FileOver);
                    var extendedOptions = extend(options, {
                        events: {
                            $destroy: "destroy"
                        },
                        prop: "over",
                        overClass: "nv-file-over"
                    });
                    _get(Object.getPrototypeOf(FileOver.prototype), "constructor", this).call(this, extendedOptions);
                }
                _inherits(FileOver, _FileDirective);
                _createClass(FileOver, {
                    addOverClass: {
                        value: function addOverClass() {
                            this.element.addClass(this.getOverClass());
                        }
                    },
                    removeOverClass: {
                        value: function removeOverClass() {
                            this.element.removeClass(this.getOverClass());
                        }
                    },
                    getOverClass: {
                        value: function getOverClass() {
                            return this.overClass;
                        }
                    }
                });
                return FileOver;
            }(FileDirective);
            return FileOver;
        };
        module.exports.$inject = [ "FileDirective" ];
    }, function(module, exports, __webpack_require__) {
        "use strict";
        var _interopRequire = function(obj) {
            return obj && obj.__esModule ? obj["default"] : obj;
        };
        var CONFIG = _interopRequire(__webpack_require__(1));
        module.exports = function($parse, FileUploader, FileSelect) {
            return {
                link: function(scope, element, attributes) {
                    var uploader = scope.$eval(attributes.uploader);
                    if (!(uploader instanceof FileUploader)) {
                        throw new TypeError('"Uploader" must be an instance of FileUploader');
                    }
                    var object = new FileSelect({
                        uploader: uploader,
                        element: element
                    });
                    object.getOptions = $parse(attributes.options).bind(object, scope);
                    object.getFilters = function() {
                        return attributes.filters;
                    };
                }
            };
        };
        module.exports.$inject = [ "$parse", "FileUploader", "FileSelect" ];
    }, function(module, exports, __webpack_require__) {
        "use strict";
        var _interopRequire = function(obj) {
            return obj && obj.__esModule ? obj["default"] : obj;
        };
        var CONFIG = _interopRequire(__webpack_require__(1));
        module.exports = function($parse, FileUploader, FileDrop) {
            return {
                link: function(scope, element, attributes) {
                    var uploader = scope.$eval(attributes.uploader);
                    if (!(uploader instanceof FileUploader)) {
                        throw new TypeError('"Uploader" must be an instance of FileUploader');
                    }
                    if (!uploader.isHTML5) return;
                    var object = new FileDrop({
                        uploader: uploader,
                        element: element
                    });
                    object.getOptions = $parse(attributes.options).bind(object, scope);
                    object.getFilters = function() {
                        return attributes.filters;
                    };
                }
            };
        };
        module.exports.$inject = [ "$parse", "FileUploader", "FileDrop" ];
    }, function(module, exports, __webpack_require__) {
        "use strict";
        var _interopRequire = function(obj) {
            return obj && obj.__esModule ? obj["default"] : obj;
        };
        var CONFIG = _interopRequire(__webpack_require__(1));
        module.exports = function(FileUploader, FileOver) {
            return {
                link: function(scope, element, attributes) {
                    var uploader = scope.$eval(attributes.uploader);
                    if (!(uploader instanceof FileUploader)) {
                        throw new TypeError('"Uploader" must be an instance of FileUploader');
                    }
                    var object = new FileOver({
                        uploader: uploader,
                        element: element
                    });
                    object.getOverClass = function() {
                        return attributes.overClass || object.overClass;
                    };
                }
            };
        };
        module.exports.$inject = [ "FileUploader", "FileOver" ];
    } ]);
});

"use strict";

var directiveModule = angular.module("angularjs-dropdown-multiselect", []);

directiveModule.directive("ngDropdownMultiselect", [ "$filter", "$document", "$compile", "$parse", function($filter, $document, $compile, $parse) {
    return {
        restrict: "AE",
        scope: {
            selectedModel: "=",
            options: "=",
            extraSettings: "=",
            events: "=",
            searchFilter: "=?",
            translationTexts: "=",
            groupBy: "@"
        },
        template: function(element, attrs) {
            var checkboxes = attrs.checkboxes ? true : false;
            var groups = attrs.groupBy ? true : false;
            var template = '<div class="multiselect-parent btn-group dropdown-multiselect">';
            template += '<button type="button" class="dropdown-toggle" ng-class="settings.buttonClasses" ng-click="toggleDropdown()">{{getButtonText()}}&nbsp;<span class="caret"></span></button>';
            template += "<ul class=\"dropdown-menu dropdown-menu-form\" ng-style=\"{display: open ? 'block' : 'none', height : settings.scrollable ? settings.scrollableHeight : 'auto' }\" style=\"overflow: scroll\" >";
            template += '<li ng-hide="!settings.showCheckAll || settings.selectionLimit > 0"><a data-ng-click="selectAll()"><span class="glyphicon glyphicon-ok"></span>  {{texts.checkAll}}</a>';
            template += '<li ng-show="settings.showUncheckAll"><a data-ng-click="deselectAll();"><span class="glyphicon glyphicon-remove"></span>   {{texts.uncheckAll}}</a></li>';
            template += '<li ng-hide="(!settings.showCheckAll || settings.selectionLimit > 0) && !settings.showUncheckAll" class="divider"></li>';
            template += '<li ng-show="settings.enableSearch"><div class="dropdown-header"><input type="text" class="form-control" style="width: 100%;" ng-model="searchFilter" placeholder="{{texts.searchPlaceholder}}" /></li>';
            template += '<li ng-show="settings.enableSearch" class="divider"></li>';
            if (groups) {
                template += '<li ng-repeat-start="option in orderedItems | filter: searchFilter" ng-show="getPropertyForObject(option, settings.groupBy) !== getPropertyForObject(orderedItems[$index - 1], settings.groupBy)" role="presentation" class="dropdown-header">{{ getGroupTitle(getPropertyForObject(option, settings.groupBy)) }}</li>';
                template += '<li ng-repeat-end role="presentation">';
            } else {
                template += '<li role="presentation" ng-repeat="option in options | filter: searchFilter">';
            }
            template += '<a role="menuitem" tabindex="-1" ng-click="setSelectedItem(getPropertyForObject(option,settings.idProp))">';
            if (checkboxes) {
                template += '<div class="checkbox"><label><input class="checkboxInput" type="checkbox" ng-click="checkboxClick($event, getPropertyForObject(option,settings.idProp))" ng-checked="isChecked(getPropertyForObject(option,settings.idProp))" /> {{getPropertyForObject(option, settings.displayProp)}}</label></div></a>';
            } else {
                template += "<span data-ng-class=\"{'glyphicon glyphicon-ok': isChecked(getPropertyForObject(option,settings.idProp))}\"></span> {{getPropertyForObject(option, settings.displayProp)}}</a>";
            }
            template += "</li>";
            template += '<li class="divider" ng-show="settings.selectionLimit > 1"></li>';
            template += '<li role="presentation" ng-show="settings.selectionLimit > 1"><a role="menuitem">{{selectedModel.length}} {{texts.selectionOf}} {{settings.selectionLimit}} {{texts.selectionCount}}</a></li>';
            template += "</ul>";
            template += "</div>";
            element.html(template);
        },
        link: function($scope, $element, $attrs) {
            var $dropdownTrigger = $element.children()[0];
            $scope.toggleDropdown = function() {
                $scope.open = !$scope.open;
            };
            $scope.checkboxClick = function($event, id) {
                $scope.setSelectedItem(id);
                $event.stopImmediatePropagation();
            };
            $scope.externalEvents = {
                onItemSelect: angular.noop,
                onItemDeselect: angular.noop,
                onSelectAll: angular.noop,
                onDeselectAll: angular.noop,
                onInitDone: angular.noop,
                onMaxSelectionReached: angular.noop
            };
            $scope.settings = {
                dynamicTitle: true,
                scrollable: false,
                scrollableHeight: "300px",
                closeOnBlur: true,
                displayProp: "label",
                idProp: "id",
                externalIdProp: "id",
                enableSearch: false,
                selectionLimit: 0,
                showCheckAll: true,
                showUncheckAll: true,
                closeOnSelect: false,
                buttonClasses: "btn btn-default",
                closeOnDeselect: false,
                groupBy: $attrs.groupBy || undefined,
                groupByTextProvider: null,
                smartButtonMaxItems: 0,
                smartButtonTextConverter: angular.noop
            };
            $scope.texts = {
                checkAll: "Check All",
                uncheckAll: "Uncheck All",
                selectionCount: "checked",
                selectionOf: "/",
                searchPlaceholder: "Search...",
                buttonDefaultText: "Select",
                dynamicButtonTextSuffix: "checked"
            };
            $scope.searchFilter = $scope.searchFilter || "";
            if (angular.isDefined($scope.settings.groupBy)) {
                $scope.$watch("options", function(newValue) {
                    if (angular.isDefined(newValue)) {
                        $scope.orderedItems = $filter("orderBy")(newValue, $scope.settings.groupBy);
                    }
                });
            }
            angular.extend($scope.settings, $scope.extraSettings || []);
            angular.extend($scope.externalEvents, $scope.events || []);
            angular.extend($scope.texts, $scope.translationTexts);
            $scope.singleSelection = $scope.settings.selectionLimit === 1;
            function getFindObj(id) {
                var findObj = {};
                if ($scope.settings.externalIdProp === "") {
                    findObj[$scope.settings.idProp] = id;
                } else {
                    findObj[$scope.settings.externalIdProp] = id;
                }
                return findObj;
            }
            function clearObject(object) {
                for (var prop in object) {
                    delete object[prop];
                }
            }
            if ($scope.singleSelection) {
                if (angular.isArray($scope.selectedModel) && $scope.selectedModel.length === 0) {
                    clearObject($scope.selectedModel);
                }
            }
            if ($scope.settings.closeOnBlur) {
                $document.on("click", function(e) {
                    var target = e.target.parentElement;
                    var parentFound = false;
                    while (angular.isDefined(target) && target !== null && !parentFound) {
                        if (_.contains(target.className.split(" "), "multiselect-parent") && !parentFound) {
                            if (target === $dropdownTrigger) {
                                parentFound = true;
                            }
                        }
                        target = target.parentElement;
                    }
                    if (!parentFound) {
                        $scope.$apply(function() {
                            $scope.open = false;
                        });
                    }
                });
            }
            $scope.getGroupTitle = function(groupValue) {
                if ($scope.settings.groupByTextProvider !== null) {
                    return $scope.settings.groupByTextProvider(groupValue);
                }
                return groupValue;
            };
            $scope.getButtonText = function() {
                if ($scope.settings.dynamicTitle && ($scope.selectedModel.length > 0 || angular.isObject($scope.selectedModel) && _.keys($scope.selectedModel).length > 0)) {
                    if ($scope.settings.smartButtonMaxItems > 0) {
                        var itemsText = [];
                        angular.forEach($scope.options, function(optionItem) {
                            if ($scope.isChecked($scope.getPropertyForObject(optionItem, $scope.settings.idProp))) {
                                var displayText = $scope.getPropertyForObject(optionItem, $scope.settings.displayProp);
                                var converterResponse = $scope.settings.smartButtonTextConverter(displayText, optionItem);
                                itemsText.push(converterResponse ? converterResponse : displayText);
                            }
                        });
                        if ($scope.selectedModel.length > $scope.settings.smartButtonMaxItems) {
                            itemsText = itemsText.slice(0, $scope.settings.smartButtonMaxItems);
                            itemsText.push("...");
                        }
                        return itemsText.join(", ");
                    } else {
                        var totalSelected;
                        if ($scope.singleSelection) {
                            totalSelected = $scope.selectedModel !== null && angular.isDefined($scope.selectedModel[$scope.settings.idProp]) ? 1 : 0;
                        } else {
                            totalSelected = angular.isDefined($scope.selectedModel) ? $scope.selectedModel.length : 0;
                        }
                        if (totalSelected === 0) {
                            return $scope.texts.buttonDefaultText;
                        } else {
                            return totalSelected + " " + $scope.texts.dynamicButtonTextSuffix;
                        }
                    }
                } else {
                    return $scope.texts.buttonDefaultText;
                }
            };
            $scope.getPropertyForObject = function(object, property) {
                if (angular.isDefined(object) && object.hasOwnProperty(property)) {
                    return object[property];
                }
                return "";
            };
            $scope.selectAll = function() {
                $scope.deselectAll(false);
                $scope.externalEvents.onSelectAll();
                angular.forEach($scope.options, function(value) {
                    $scope.setSelectedItem(value[$scope.settings.idProp], true);
                });
            };
            $scope.deselectAll = function(sendEvent) {
                sendEvent = sendEvent || true;
                if (sendEvent) {
                    $scope.externalEvents.onDeselectAll();
                }
                if ($scope.singleSelection) {
                    clearObject($scope.selectedModel);
                } else {
                    $scope.selectedModel.splice(0, $scope.selectedModel.length);
                }
            };
            $scope.setSelectedItem = function(id, dontRemove) {
                var findObj = getFindObj(id);
                var finalObj = null;
                if ($scope.settings.externalIdProp === "") {
                    finalObj = _.find($scope.options, findObj);
                } else {
                    finalObj = findObj;
                }
                if ($scope.singleSelection) {
                    clearObject($scope.selectedModel);
                    angular.extend($scope.selectedModel, finalObj);
                    $scope.externalEvents.onItemSelect(finalObj);
                    return;
                }
                dontRemove = dontRemove || false;
                var exists = _.findIndex($scope.selectedModel, findObj) !== -1;
                if (!dontRemove && exists) {
                    $scope.selectedModel.splice(_.findIndex($scope.selectedModel, findObj), 1);
                    $scope.externalEvents.onItemDeselect(findObj);
                } else if (!exists && ($scope.settings.selectionLimit === 0 || $scope.selectedModel.length < $scope.settings.selectionLimit)) {
                    $scope.selectedModel.push(finalObj);
                    $scope.externalEvents.onItemSelect(finalObj);
                }
            };
            $scope.isChecked = function(id) {
                if ($scope.singleSelection) {
                    return $scope.selectedModel !== null && angular.isDefined($scope.selectedModel[$scope.settings.idProp]) && $scope.selectedModel[$scope.settings.idProp] === getFindObj(id)[$scope.settings.idProp];
                }
                return _.findIndex($scope.selectedModel, getFindObj(id)) !== -1;
            };
            $scope.externalEvents.onInitDone();
        }
    };
} ]);

(function(window, angular) {
    var isDefined = angular.isDefined, isUndefined = angular.isUndefined, isNumber = angular.isNumber, isObject = angular.isObject, isArray = angular.isArray, extend = angular.extend, toJson = angular.toJson;
    angular.module("LocalStorageModule", []).provider("localStorageService", function() {
        this.prefix = "ls";
        this.storageType = "localStorage";
        this.cookie = {
            expiry: 30,
            path: "/"
        };
        this.notify = {
            setItem: true,
            removeItem: false
        };
        this.setPrefix = function(prefix) {
            this.prefix = prefix;
            return this;
        };
        this.setStorageType = function(storageType) {
            this.storageType = storageType;
            return this;
        };
        this.setStorageCookie = function(exp, path) {
            this.cookie.expiry = exp;
            this.cookie.path = path;
            return this;
        };
        this.setStorageCookieDomain = function(domain) {
            this.cookie.domain = domain;
            return this;
        };
        this.setNotify = function(itemSet, itemRemove) {
            this.notify = {
                setItem: itemSet,
                removeItem: itemRemove
            };
            return this;
        };
        this.$get = [ "$rootScope", "$window", "$document", "$parse", function($rootScope, $window, $document, $parse) {
            var self = this;
            var prefix = self.prefix;
            var cookie = self.cookie;
            var notify = self.notify;
            var storageType = self.storageType;
            var webStorage;
            if (!$document) {
                $document = document;
            } else if ($document[0]) {
                $document = $document[0];
            }
            if (prefix.substr(-1) !== ".") {
                prefix = !!prefix ? prefix + "." : "";
            }
            var deriveQualifiedKey = function(key) {
                return prefix + key;
            };
            var browserSupportsLocalStorage = function() {
                try {
                    var supported = storageType in $window && $window[storageType] !== null;
                    var key = deriveQualifiedKey("__" + Math.round(Math.random() * 1e7));
                    if (supported) {
                        webStorage = $window[storageType];
                        webStorage.setItem(key, "");
                        webStorage.removeItem(key);
                    }
                    return supported;
                } catch (e) {
                    storageType = "cookie";
                    $rootScope.$broadcast("LocalStorageModule.notification.error", e.message);
                    return false;
                }
            }();
            var addToLocalStorage = function(key, value) {
                if (isUndefined(value)) {
                    value = null;
                } else {
                    value = toJson(value);
                }
                if (!browserSupportsLocalStorage || self.storageType === "cookie") {
                    if (!browserSupportsLocalStorage) {
                        $rootScope.$broadcast("LocalStorageModule.notification.warning", "LOCAL_STORAGE_NOT_SUPPORTED");
                    }
                    if (notify.setItem) {
                        $rootScope.$broadcast("LocalStorageModule.notification.setitem", {
                            key: key,
                            newvalue: value,
                            storageType: "cookie"
                        });
                    }
                    return addToCookies(key, value);
                }
                try {
                    if (webStorage) {
                        webStorage.setItem(deriveQualifiedKey(key), value);
                    }
                    if (notify.setItem) {
                        $rootScope.$broadcast("LocalStorageModule.notification.setitem", {
                            key: key,
                            newvalue: value,
                            storageType: self.storageType
                        });
                    }
                } catch (e) {
                    $rootScope.$broadcast("LocalStorageModule.notification.error", e.message);
                    return addToCookies(key, value);
                }
                return true;
            };
            var getFromLocalStorage = function(key) {
                if (!browserSupportsLocalStorage || self.storageType === "cookie") {
                    if (!browserSupportsLocalStorage) {
                        $rootScope.$broadcast("LocalStorageModule.notification.warning", "LOCAL_STORAGE_NOT_SUPPORTED");
                    }
                    return getFromCookies(key);
                }
                var item = webStorage ? webStorage.getItem(deriveQualifiedKey(key)) : null;
                if (!item || item === "null") {
                    return null;
                }
                try {
                    return JSON.parse(item);
                } catch (e) {
                    return item;
                }
            };
            var removeFromLocalStorage = function() {
                var i, key;
                for (i = 0; i < arguments.length; i++) {
                    key = arguments[i];
                    if (!browserSupportsLocalStorage || self.storageType === "cookie") {
                        if (!browserSupportsLocalStorage) {
                            $rootScope.$broadcast("LocalStorageModule.notification.warning", "LOCAL_STORAGE_NOT_SUPPORTED");
                        }
                        if (notify.removeItem) {
                            $rootScope.$broadcast("LocalStorageModule.notification.removeitem", {
                                key: key,
                                storageType: "cookie"
                            });
                        }
                        removeFromCookies(key);
                    } else {
                        try {
                            webStorage.removeItem(deriveQualifiedKey(key));
                            if (notify.removeItem) {
                                $rootScope.$broadcast("LocalStorageModule.notification.removeitem", {
                                    key: key,
                                    storageType: self.storageType
                                });
                            }
                        } catch (e) {
                            $rootScope.$broadcast("LocalStorageModule.notification.error", e.message);
                            removeFromCookies(key);
                        }
                    }
                }
            };
            var getKeysForLocalStorage = function() {
                if (!browserSupportsLocalStorage) {
                    $rootScope.$broadcast("LocalStorageModule.notification.warning", "LOCAL_STORAGE_NOT_SUPPORTED");
                    return [];
                }
                var prefixLength = prefix.length;
                var keys = [];
                for (var key in webStorage) {
                    if (key.substr(0, prefixLength) === prefix) {
                        try {
                            keys.push(key.substr(prefixLength));
                        } catch (e) {
                            $rootScope.$broadcast("LocalStorageModule.notification.error", e.Description);
                            return [];
                        }
                    }
                }
                return keys;
            };
            var clearAllFromLocalStorage = function(regularExpression) {
                var prefixRegex = !!prefix ? new RegExp("^" + prefix) : new RegExp();
                var testRegex = !!regularExpression ? new RegExp(regularExpression) : new RegExp();
                if (!browserSupportsLocalStorage || self.storageType === "cookie") {
                    if (!browserSupportsLocalStorage) {
                        $rootScope.$broadcast("LocalStorageModule.notification.warning", "LOCAL_STORAGE_NOT_SUPPORTED");
                    }
                    return clearAllFromCookies();
                }
                var prefixLength = prefix.length;
                for (var key in webStorage) {
                    if (prefixRegex.test(key) && testRegex.test(key.substr(prefixLength))) {
                        try {
                            removeFromLocalStorage(key.substr(prefixLength));
                        } catch (e) {
                            $rootScope.$broadcast("LocalStorageModule.notification.error", e.message);
                            return clearAllFromCookies();
                        }
                    }
                }
                return true;
            };
            var browserSupportsCookies = function() {
                try {
                    return $window.navigator.cookieEnabled || "cookie" in $document && ($document.cookie.length > 0 || ($document.cookie = "test").indexOf.call($document.cookie, "test") > -1);
                } catch (e) {
                    $rootScope.$broadcast("LocalStorageModule.notification.error", e.message);
                    return false;
                }
            }();
            var addToCookies = function(key, value, daysToExpiry) {
                if (isUndefined(value)) {
                    return false;
                } else if (isArray(value) || isObject(value)) {
                    value = toJson(value);
                }
                if (!browserSupportsCookies) {
                    $rootScope.$broadcast("LocalStorageModule.notification.error", "COOKIES_NOT_SUPPORTED");
                    return false;
                }
                try {
                    var expiry = "", expiryDate = new Date(), cookieDomain = "";
                    if (value === null) {
                        expiryDate.setTime(expiryDate.getTime() + -1 * 24 * 60 * 60 * 1e3);
                        expiry = "; expires=" + expiryDate.toGMTString();
                        value = "";
                    } else if (isNumber(daysToExpiry) && daysToExpiry !== 0) {
                        expiryDate.setTime(expiryDate.getTime() + daysToExpiry * 24 * 60 * 60 * 1e3);
                        expiry = "; expires=" + expiryDate.toGMTString();
                    } else if (cookie.expiry !== 0) {
                        expiryDate.setTime(expiryDate.getTime() + cookie.expiry * 24 * 60 * 60 * 1e3);
                        expiry = "; expires=" + expiryDate.toGMTString();
                    }
                    if (!!key) {
                        var cookiePath = "; path=" + cookie.path;
                        if (cookie.domain) {
                            cookieDomain = "; domain=" + cookie.domain;
                        }
                        $document.cookie = deriveQualifiedKey(key) + "=" + encodeURIComponent(value) + expiry + cookiePath + cookieDomain;
                    }
                } catch (e) {
                    $rootScope.$broadcast("LocalStorageModule.notification.error", e.message);
                    return false;
                }
                return true;
            };
            var getFromCookies = function(key) {
                if (!browserSupportsCookies) {
                    $rootScope.$broadcast("LocalStorageModule.notification.error", "COOKIES_NOT_SUPPORTED");
                    return false;
                }
                var cookies = $document.cookie && $document.cookie.split(";") || [];
                for (var i = 0; i < cookies.length; i++) {
                    var thisCookie = cookies[i];
                    while (thisCookie.charAt(0) === " ") {
                        thisCookie = thisCookie.substring(1, thisCookie.length);
                    }
                    if (thisCookie.indexOf(deriveQualifiedKey(key) + "=") === 0) {
                        var storedValues = decodeURIComponent(thisCookie.substring(prefix.length + key.length + 1, thisCookie.length));
                        try {
                            return JSON.parse(storedValues);
                        } catch (e) {
                            return storedValues;
                        }
                    }
                }
                return null;
            };
            var removeFromCookies = function(key) {
                addToCookies(key, null);
            };
            var clearAllFromCookies = function() {
                var thisCookie = null, thisKey = null;
                var prefixLength = prefix.length;
                var cookies = $document.cookie.split(";");
                for (var i = 0; i < cookies.length; i++) {
                    thisCookie = cookies[i];
                    while (thisCookie.charAt(0) === " ") {
                        thisCookie = thisCookie.substring(1, thisCookie.length);
                    }
                    var key = thisCookie.substring(prefixLength, thisCookie.indexOf("="));
                    removeFromCookies(key);
                }
            };
            var getStorageType = function() {
                return storageType;
            };
            var bindToScope = function(scope, key, def, lsKey) {
                lsKey = lsKey || key;
                var value = getFromLocalStorage(lsKey);
                if (value === null && isDefined(def)) {
                    value = def;
                } else if (isObject(value) && isObject(def)) {
                    value = extend(value, def);
                }
                $parse(key).assign(scope, value);
                return scope.$watch(key, function(newVal) {
                    addToLocalStorage(lsKey, newVal);
                }, isObject(scope[key]));
            };
            var lengthOfLocalStorage = function() {
                var count = 0;
                var storage = $window[storageType];
                for (var i = 0; i < storage.length; i++) {
                    if (storage.key(i).indexOf(prefix) === 0) {
                        count++;
                    }
                }
                return count;
            };
            return {
                isSupported: browserSupportsLocalStorage,
                getStorageType: getStorageType,
                set: addToLocalStorage,
                add: addToLocalStorage,
                get: getFromLocalStorage,
                keys: getKeysForLocalStorage,
                remove: removeFromLocalStorage,
                clearAll: clearAllFromLocalStorage,
                bind: bindToScope,
                deriveKey: deriveQualifiedKey,
                length: lengthOfLocalStorage,
                cookie: {
                    isSupported: browserSupportsCookies,
                    set: addToCookies,
                    add: addToCookies,
                    get: getFromCookies,
                    remove: removeFromCookies,
                    clearAll: clearAllFromCookies
                }
            };
        } ];
    });
})(window, window.angular);

(function(window, angular) {
    "use strict";
    function stringify(value) {
        if (value == null) {
            return "";
        }
        switch (typeof value) {
          case "string":
            return value;

          case "number":
            return "" + value;

          default:
            return toJson(value);
        }
    }
    function indexToLineAndColumn(text, index) {
        var lines = text.split(/\n/g);
        for (var i = 0; i < lines.length; i++) {
            var line = lines[i];
            if (index >= line.length) {
                index -= line.length;
            } else {
                return {
                    line: i + 1,
                    column: index + 1
                };
            }
        }
    }
    var PARSE_CACHE_FOR_TEXT_LITERALS = Object.create(null);
    function parseTextLiteral(text) {
        var cachedFn = PARSE_CACHE_FOR_TEXT_LITERALS[text];
        if (cachedFn != null) {
            return cachedFn;
        }
        function parsedFn(context) {
            return text;
        }
        parsedFn["$$watchDelegate"] = function watchDelegate(scope, listener, objectEquality) {
            var unwatch = scope["$watch"](noop, function textLiteralWatcher() {
                if (isFunction(listener)) {
                    listener(text, text, scope);
                }
                unwatch();
            }, objectEquality);
            return unwatch;
        };
        PARSE_CACHE_FOR_TEXT_LITERALS[text] = parsedFn;
        parsedFn["exp"] = text;
        parsedFn["expressions"] = [];
        return parsedFn;
    }
    function subtractOffset(expressionFn, offset) {
        if (offset === 0) {
            return expressionFn;
        }
        function minusOffset(value) {
            return value == null ? value : value - offset;
        }
        function parsedFn(context) {
            return minusOffset(expressionFn(context));
        }
        var unwatch;
        parsedFn["$$watchDelegate"] = function watchDelegate(scope, listener, objectEquality) {
            unwatch = scope["$watch"](expressionFn, function pluralExpressionWatchListener(newValue, oldValue) {
                if (isFunction(listener)) {
                    listener(minusOffset(newValue), minusOffset(oldValue), scope);
                }
            }, objectEquality);
            return unwatch;
        };
        return parsedFn;
    }
    function MessageSelectorBase(expressionFn, choices) {
        var self = this;
        this.expressionFn = expressionFn;
        this.choices = choices;
        if (choices["other"] === undefined) {
            throw $interpolateMinErr("reqother", "âotherâ is a required option.");
        }
        this.parsedFn = function(context) {
            return self.getResult(context);
        };
        this.parsedFn["$$watchDelegate"] = function $$watchDelegate(scope, listener, objectEquality) {
            return self.watchDelegate(scope, listener, objectEquality);
        };
        this.parsedFn["exp"] = expressionFn["exp"];
        this.parsedFn["expressions"] = expressionFn["expressions"];
    }
    MessageSelectorBase.prototype.getMessageFn = function getMessageFn(value) {
        return this.choices[this.categorizeValue(value)];
    };
    MessageSelectorBase.prototype.getResult = function getResult(context) {
        return this.getMessageFn(this.expressionFn(context))(context);
    };
    MessageSelectorBase.prototype.watchDelegate = function watchDelegate(scope, listener, objectEquality) {
        var watchers = new MessageSelectorWatchers(this, scope, listener, objectEquality);
        return function() {
            watchers.cancelWatch();
        };
    };
    function MessageSelectorWatchers(msgSelector, scope, listener, objectEquality) {
        var self = this;
        this.scope = scope;
        this.msgSelector = msgSelector;
        this.listener = listener;
        this.objectEquality = objectEquality;
        this.lastMessage = undefined;
        this.messageFnWatcher = noop;
        var expressionFnListener = function(newValue, oldValue) {
            return self.expressionFnListener(newValue, oldValue);
        };
        this.expressionFnWatcher = scope["$watch"](msgSelector.expressionFn, expressionFnListener, objectEquality);
    }
    MessageSelectorWatchers.prototype.expressionFnListener = function expressionFnListener(newValue, oldValue) {
        var self = this;
        this.messageFnWatcher();
        var messageFnListener = function(newMessage, oldMessage) {
            return self.messageFnListener(newMessage, oldMessage);
        };
        var messageFn = this.msgSelector.getMessageFn(newValue);
        this.messageFnWatcher = this.scope["$watch"](messageFn, messageFnListener, this.objectEquality);
    };
    MessageSelectorWatchers.prototype.messageFnListener = function messageFnListener(newMessage, oldMessage) {
        if (isFunction(this.listener)) {
            this.listener.call(null, newMessage, newMessage === oldMessage ? newMessage : this.lastMessage, this.scope);
        }
        this.lastMessage = newMessage;
    };
    MessageSelectorWatchers.prototype.cancelWatch = function cancelWatch() {
        this.expressionFnWatcher();
        this.messageFnWatcher();
    };
    function SelectMessage(expressionFn, choices) {
        MessageSelectorBase.call(this, expressionFn, choices);
    }
    function SelectMessageProto() {}
    SelectMessageProto.prototype = MessageSelectorBase.prototype;
    SelectMessage.prototype = new SelectMessageProto();
    SelectMessage.prototype.categorizeValue = function categorizeSelectValue(value) {
        return this.choices[value] !== undefined ? value : "other";
    };
    function PluralMessage(expressionFn, choices, offset, pluralCat) {
        MessageSelectorBase.call(this, expressionFn, choices);
        this.offset = offset;
        this.pluralCat = pluralCat;
    }
    function PluralMessageProto() {}
    PluralMessageProto.prototype = MessageSelectorBase.prototype;
    PluralMessage.prototype = new PluralMessageProto();
    PluralMessage.prototype.categorizeValue = function categorizePluralValue(value) {
        if (isNaN(value)) {
            return "other";
        } else if (this.choices[value] !== undefined) {
            return value;
        } else {
            var category = this.pluralCat(value - this.offset);
            return this.choices[category] !== undefined ? category : "other";
        }
    };
    function InterpolationParts(trustedContext, allOrNothing) {
        this.trustedContext = trustedContext;
        this.allOrNothing = allOrNothing;
        this.textParts = [];
        this.expressionFns = [];
        this.expressionIndices = [];
        this.partialText = "";
        this.concatParts = null;
    }
    InterpolationParts.prototype.flushPartialText = function flushPartialText() {
        if (this.partialText) {
            if (this.concatParts == null) {
                this.textParts.push(this.partialText);
            } else {
                this.textParts.push(this.concatParts.join(""));
                this.concatParts = null;
            }
            this.partialText = "";
        }
    };
    InterpolationParts.prototype.addText = function addText(text) {
        if (text.length) {
            if (!this.partialText) {
                this.partialText = text;
            } else if (this.concatParts) {
                this.concatParts.push(text);
            } else {
                this.concatParts = [ this.partialText, text ];
            }
        }
    };
    InterpolationParts.prototype.addExpressionFn = function addExpressionFn(expressionFn) {
        this.flushPartialText();
        this.expressionIndices.push(this.textParts.length);
        this.expressionFns.push(expressionFn);
        this.textParts.push("");
    };
    InterpolationParts.prototype.getExpressionValues = function getExpressionValues(context) {
        var expressionValues = new Array(this.expressionFns.length);
        for (var i = 0; i < this.expressionFns.length; i++) {
            expressionValues[i] = this.expressionFns[i](context);
        }
        return expressionValues;
    };
    InterpolationParts.prototype.getResult = function getResult(expressionValues) {
        for (var i = 0; i < this.expressionIndices.length; i++) {
            var expressionValue = expressionValues[i];
            if (this.allOrNothing && expressionValue === undefined) return;
            this.textParts[this.expressionIndices[i]] = expressionValue;
        }
        return this.textParts.join("");
    };
    InterpolationParts.prototype.toParsedFn = function toParsedFn(mustHaveExpression, originalText) {
        var self = this;
        this.flushPartialText();
        if (mustHaveExpression && this.expressionFns.length === 0) {
            return undefined;
        }
        if (this.textParts.length === 0) {
            return parseTextLiteral("");
        }
        if (this.trustedContext && this.textParts.length > 1) {
            $interpolateMinErr["throwNoconcat"](originalText);
        }
        if (this.expressionFns.length === 0) {
            if (this.textParts.length !== 1) {
                this.errorInParseLogic();
            }
            return parseTextLiteral(this.textParts[0]);
        }
        var parsedFn = function(context) {
            return self.getResult(self.getExpressionValues(context));
        };
        parsedFn["$$watchDelegate"] = function $$watchDelegate(scope, listener, objectEquality) {
            return self.watchDelegate(scope, listener, objectEquality);
        };
        parsedFn["exp"] = originalText;
        parsedFn["expressions"] = new Array(this.expressionFns.length);
        for (var i = 0; i < this.expressionFns.length; i++) {
            parsedFn["expressions"][i] = this.expressionFns[i]["exp"];
        }
        return parsedFn;
    };
    InterpolationParts.prototype.watchDelegate = function watchDelegate(scope, listener, objectEquality) {
        var watcher = new InterpolationPartsWatcher(this, scope, listener, objectEquality);
        return function() {
            watcher.cancelWatch();
        };
    };
    function InterpolationPartsWatcher(interpolationParts, scope, listener, objectEquality) {
        this.interpolationParts = interpolationParts;
        this.scope = scope;
        this.previousResult = undefined;
        this.listener = listener;
        var self = this;
        this.expressionFnsWatcher = scope["$watchGroup"](interpolationParts.expressionFns, function(newExpressionValues, oldExpressionValues) {
            self.watchListener(newExpressionValues, oldExpressionValues);
        });
    }
    InterpolationPartsWatcher.prototype.watchListener = function watchListener(newExpressionValues, oldExpressionValues) {
        var result = this.interpolationParts.getResult(newExpressionValues);
        if (isFunction(this.listener)) {
            this.listener.call(null, result, newExpressionValues === oldExpressionValues ? result : this.previousResult, this.scope);
        }
        this.previousResult = result;
    };
    InterpolationPartsWatcher.prototype.cancelWatch = function cancelWatch() {
        this.expressionFnsWatcher();
    };
    function copyNestedParserState(src, dst) {
        dst.expressionFn = src.expressionFn;
        dst.expressionMinusOffsetFn = src.expressionMinusOffsetFn;
        dst.pluralOffset = src.pluralOffset;
        dst.choices = src.choices;
        dst.choiceKey = src.choiceKey;
        dst.interpolationParts = src.interpolationParts;
        dst.ruleChoiceKeyword = src.ruleChoiceKeyword;
        dst.msgStartIndex = src.msgStartIndex;
        dst.expressionStartIndex = src.expressionStartIndex;
    }
    function NestedParserState(parser) {
        copyNestedParserState(parser, this);
    }
    function MessageFormatParser(text, startIndex, $parse, pluralCat, stringifier, mustHaveExpression, trustedContext, allOrNothing) {
        this.text = text;
        this.index = startIndex || 0;
        this.$parse = $parse;
        this.pluralCat = pluralCat;
        this.stringifier = stringifier;
        this.mustHaveExpression = !!mustHaveExpression;
        this.trustedContext = trustedContext;
        this.allOrNothing = !!allOrNothing;
        this.expressionFn = null;
        this.expressionMinusOffsetFn = null;
        this.pluralOffset = null;
        this.choices = null;
        this.choiceKey = null;
        this.interpolationParts = null;
        this.msgStartIndex = null;
        this.nestedStateStack = [];
        this.parsedFn = null;
        this.rule = null;
        this.ruleStack = null;
        this.ruleChoiceKeyword = null;
        this.interpNestLevel = null;
        this.expressionStartIndex = null;
        this.stringStartIndex = null;
        this.stringQuote = null;
        this.stringInterestsRe = null;
        this.angularOperatorStack = null;
        this.textPart = null;
    }
    var EMPTY_STATE = new NestedParserState(new MessageFormatParser("", 0, null, null, null, false, null, false));
    MessageFormatParser.prototype.pushState = function pushState() {
        this.nestedStateStack.push(new NestedParserState(this));
        copyNestedParserState(EMPTY_STATE, this);
    };
    MessageFormatParser.prototype.popState = function popState() {
        if (this.nestedStateStack.length === 0) {
            this.errorInParseLogic();
        }
        var previousState = this.nestedStateStack.pop();
        copyNestedParserState(previousState, this);
    };
    MessageFormatParser.prototype.matchRe = function matchRe(re, search) {
        re.lastIndex = this.index;
        var match = re.exec(this.text);
        if (match != null && (search === true || match.index === this.index)) {
            this.index = re.lastIndex;
            return match;
        }
        return null;
    };
    MessageFormatParser.prototype.searchRe = function searchRe(re) {
        return this.matchRe(re, true);
    };
    MessageFormatParser.prototype.consumeRe = function consumeRe(re) {
        return !!this.matchRe(re);
    };
    MessageFormatParser.prototype.run = function run(initialRule) {
        this.ruleStack = [ initialRule ];
        do {
            this.rule = this.ruleStack.pop();
            while (this.rule) {
                this.rule();
            }
            this.assertRuleOrNull(this.rule);
        } while (this.ruleStack.length > 0);
    };
    MessageFormatParser.prototype.errorInParseLogic = function errorInParseLogic() {
        throw $interpolateMinErr("logicbug", "The messageformat parser has encountered an internal error.  Please file a github issue against the AngularJS project and provide this message text that triggers the bug.  Text: â{0}â", this.text);
    };
    MessageFormatParser.prototype.assertRuleOrNull = function assertRuleOrNull(rule) {
        if (rule === undefined) {
            this.errorInParseLogic();
        }
    };
    var NEXT_WORD_RE = /\s*(\w+)\s*/g;
    MessageFormatParser.prototype.errorExpecting = function errorExpecting() {
        var match = this.matchRe(NEXT_WORD_RE), position;
        if (match == null) {
            position = indexToLineAndColumn(this.text, this.index);
            throw $interpolateMinErr("reqarg", "Expected one of âpluralâ or âselectâ at line {0}, column {1} of text â{2}â", position.line, position.column, this.text);
        }
        var word = match[1];
        if (word === "select" || word === "plural") {
            position = indexToLineAndColumn(this.text, this.index);
            throw $interpolateMinErr("reqcomma", "Expected a comma after the keyword â{0}â at line {1}, column {2} of text â{3}â", word, position.line, position.column, this.text);
        } else {
            position = indexToLineAndColumn(this.text, this.index);
            throw $interpolateMinErr("unknarg", "Unsupported keyword â{0}â at line {0}, column {1}. Only âpluralâ and âselectâ are currently supported.  Text: â{3}â", word, position.line, position.column, this.text);
        }
    };
    var STRING_START_RE = /['"]/g;
    MessageFormatParser.prototype.ruleString = function ruleString() {
        var match = this.matchRe(STRING_START_RE);
        if (match == null) {
            var position = indexToLineAndColumn(this.text, this.index);
            throw $interpolateMinErr("wantstring", "Expected the beginning of a string at line {0}, column {1} in text â{2}â", position.line, position.column, this.text);
        }
        this.startStringAtMatch(match);
    };
    MessageFormatParser.prototype.startStringAtMatch = function startStringAtMatch(match) {
        this.stringStartIndex = match.index;
        this.stringQuote = match[0];
        this.stringInterestsRe = this.stringQuote === "'" ? SQUOTED_STRING_INTEREST_RE : DQUOTED_STRING_INTEREST_RE;
        this.rule = this.ruleInsideString;
    };
    var SQUOTED_STRING_INTEREST_RE = /\\(?:\\|'|u[0-9A-Fa-f]{4}|x[0-9A-Fa-f]{2}|[0-7]{3}|\r\n|\n|[\s\S])|'/g;
    var DQUOTED_STRING_INTEREST_RE = /\\(?:\\|"|u[0-9A-Fa-f]{4}|x[0-9A-Fa-f]{2}|[0-7]{3}|\r\n|\n|[\s\S])|"/g;
    MessageFormatParser.prototype.ruleInsideString = function ruleInsideString() {
        var match = this.searchRe(this.stringInterestsRe);
        if (match == null) {
            var position = indexToLineAndColumn(this.text, this.stringStartIndex);
            throw $interpolateMinErr("untermstr", "The string beginning at line {0}, column {1} is unterminated in text â{2}â", position.line, position.column, this.text);
        }
        if (match[0] === this.stringQuote) {
            this.rule = null;
        }
    };
    var PLURAL_OR_SELECT_ARG_TYPE_RE = /\s*(plural|select)\s*,\s*/g;
    MessageFormatParser.prototype.rulePluralOrSelect = function rulePluralOrSelect() {
        var match = this.searchRe(PLURAL_OR_SELECT_ARG_TYPE_RE);
        if (match == null) {
            this.errorExpecting();
        }
        var argType = match[1];
        switch (argType) {
          case "plural":
            this.rule = this.rulePluralStyle;
            break;

          case "select":
            this.rule = this.ruleSelectStyle;
            break;

          default:
            this.errorInParseLogic();
        }
    };
    MessageFormatParser.prototype.rulePluralStyle = function rulePluralStyle() {
        this.choices = Object.create(null);
        this.ruleChoiceKeyword = this.rulePluralValueOrKeyword;
        this.rule = this.rulePluralOffset;
    };
    MessageFormatParser.prototype.ruleSelectStyle = function ruleSelectStyle() {
        this.choices = Object.create(null);
        this.ruleChoiceKeyword = this.ruleSelectKeyword;
        this.rule = this.ruleSelectKeyword;
    };
    var NUMBER_RE = /[0]|(?:[1-9][0-9]*)/g;
    var PLURAL_OFFSET_RE = new RegExp("\\s*offset\\s*:\\s*(" + NUMBER_RE.source + ")", "g");
    MessageFormatParser.prototype.rulePluralOffset = function rulePluralOffset() {
        var match = this.matchRe(PLURAL_OFFSET_RE);
        this.pluralOffset = match == null ? 0 : parseInt(match[1], 10);
        this.expressionMinusOffsetFn = subtractOffset(this.expressionFn, this.pluralOffset);
        this.rule = this.rulePluralValueOrKeyword;
    };
    MessageFormatParser.prototype.assertChoiceKeyIsNew = function assertChoiceKeyIsNew(choiceKey, index) {
        if (this.choices[choiceKey] !== undefined) {
            var position = indexToLineAndColumn(this.text, index);
            throw $interpolateMinErr("dupvalue", "The choice â{0}â is specified more than once. Duplicate key is at line {1}, column {2} in text â{3}â", choiceKey, position.line, position.column, this.text);
        }
    };
    var SELECT_KEYWORD = /\s*(\w+)/g;
    MessageFormatParser.prototype.ruleSelectKeyword = function ruleSelectKeyword() {
        var match = this.matchRe(SELECT_KEYWORD);
        if (match == null) {
            this.parsedFn = new SelectMessage(this.expressionFn, this.choices).parsedFn;
            this.rule = null;
            return;
        }
        this.choiceKey = match[1];
        this.assertChoiceKeyIsNew(this.choiceKey, match.index);
        this.rule = this.ruleMessageText;
    };
    var EXPLICIT_VALUE_OR_KEYWORD_RE = new RegExp("\\s*(?:(?:=(" + NUMBER_RE.source + "))|(\\w+))", "g");
    MessageFormatParser.prototype.rulePluralValueOrKeyword = function rulePluralValueOrKeyword() {
        var match = this.matchRe(EXPLICIT_VALUE_OR_KEYWORD_RE);
        if (match == null) {
            this.parsedFn = new PluralMessage(this.expressionFn, this.choices, this.pluralOffset, this.pluralCat).parsedFn;
            this.rule = null;
            return;
        }
        if (match[1] != null) {
            this.choiceKey = parseInt(match[1], 10);
        } else {
            this.choiceKey = match[2];
        }
        this.assertChoiceKeyIsNew(this.choiceKey, match.index);
        this.rule = this.ruleMessageText;
    };
    var BRACE_OPEN_RE = /\s*\{/g;
    var BRACE_CLOSE_RE = /}/g;
    MessageFormatParser.prototype.ruleMessageText = function ruleMessageText() {
        if (!this.consumeRe(BRACE_OPEN_RE)) {
            var position = indexToLineAndColumn(this.text, this.index);
            throw $interpolateMinErr("reqopenbrace", "The plural choice â{0}â must be followed by a message in braces at line {1}, column {2} in text â{3}â", this.choiceKey, position.line, position.column, this.text);
        }
        this.msgStartIndex = this.index;
        this.interpolationParts = new InterpolationParts(this.trustedContext, this.allOrNothing);
        this.rule = this.ruleInInterpolationOrMessageText;
    };
    var INTERP_OR_END_MESSAGE_RE = /\\.|{{|}/g;
    var INTERP_OR_PLURALVALUE_OR_END_MESSAGE_RE = /\\.|{{|#|}/g;
    var ESCAPE_OR_MUSTACHE_BEGIN_RE = /\\.|{{/g;
    MessageFormatParser.prototype.advanceInInterpolationOrMessageText = function advanceInInterpolationOrMessageText() {
        var currentIndex = this.index, match;
        if (this.ruleChoiceKeyword == null) {
            match = this.searchRe(ESCAPE_OR_MUSTACHE_BEGIN_RE);
            if (match == null) {
                this.textPart = this.text.substring(currentIndex);
                this.index = this.text.length;
                return null;
            }
        } else {
            match = this.searchRe(this.ruleChoiceKeyword === this.rulePluralValueOrKeyword ? INTERP_OR_PLURALVALUE_OR_END_MESSAGE_RE : INTERP_OR_END_MESSAGE_RE);
            if (match == null) {
                var position = indexToLineAndColumn(this.text, this.msgStartIndex);
                throw $interpolateMinErr("reqendbrace", "The plural/select choice â{0}â message starting at line {1}, column {2} does not have an ending closing brace. Text â{3}â", this.choiceKey, position.line, position.column, this.text);
            }
        }
        var token = match[0];
        this.textPart = this.text.substring(currentIndex, match.index);
        return token;
    };
    MessageFormatParser.prototype.ruleInInterpolationOrMessageText = function ruleInInterpolationOrMessageText() {
        var currentIndex = this.index;
        var token = this.advanceInInterpolationOrMessageText();
        if (token == null) {
            this.index = this.text.length;
            this.interpolationParts.addText(this.text.substring(currentIndex));
            this.rule = null;
            return;
        }
        if (token[0] === "\\") {
            this.interpolationParts.addText(this.textPart + token[1]);
            return;
        }
        this.interpolationParts.addText(this.textPart);
        if (token === "{{") {
            this.pushState();
            this.ruleStack.push(this.ruleEndMustacheInInterpolationOrMessage);
            this.rule = this.ruleEnteredMustache;
        } else if (token === "}") {
            this.choices[this.choiceKey] = this.interpolationParts.toParsedFn(false, this.text);
            this.rule = this.ruleChoiceKeyword;
        } else if (token === "#") {
            this.interpolationParts.addExpressionFn(this.expressionMinusOffsetFn);
        } else {
            this.errorInParseLogic();
        }
    };
    MessageFormatParser.prototype.ruleInterpolate = function ruleInterpolate() {
        this.interpolationParts = new InterpolationParts(this.trustedContext, this.allOrNothing);
        this.rule = this.ruleInInterpolation;
    };
    MessageFormatParser.prototype.ruleInInterpolation = function ruleInInterpolation() {
        var currentIndex = this.index;
        var match = this.searchRe(ESCAPE_OR_MUSTACHE_BEGIN_RE);
        if (match == null) {
            this.index = this.text.length;
            this.interpolationParts.addText(this.text.substring(currentIndex));
            this.parsedFn = this.interpolationParts.toParsedFn(this.mustHaveExpression, this.text);
            this.rule = null;
            return;
        }
        var token = match[0];
        if (token[0] === "\\") {
            this.interpolationParts.addText(this.text.substring(currentIndex, match.index) + token[1]);
            return;
        }
        this.interpolationParts.addText(this.text.substring(currentIndex, match.index));
        this.pushState();
        this.ruleStack.push(this.ruleInterpolationEndMustache);
        this.rule = this.ruleEnteredMustache;
    };
    MessageFormatParser.prototype.ruleInterpolationEndMustache = function ruleInterpolationEndMustache() {
        var expressionFn = this.parsedFn;
        this.popState();
        this.interpolationParts.addExpressionFn(expressionFn);
        this.rule = this.ruleInInterpolation;
    };
    MessageFormatParser.prototype.ruleEnteredMustache = function ruleEnteredMustache() {
        this.parsedFn = null;
        this.ruleStack.push(this.ruleEndMustache);
        this.rule = this.ruleAngularExpression;
    };
    MessageFormatParser.prototype.ruleEndMustacheInInterpolationOrMessage = function ruleEndMustacheInInterpolationOrMessage() {
        var expressionFn = this.parsedFn;
        this.popState();
        this.interpolationParts.addExpressionFn(expressionFn);
        this.rule = this.ruleInInterpolationOrMessageText;
    };
    var INTERP_END_RE = /\s*}}/g;
    MessageFormatParser.prototype.ruleEndMustache = function ruleEndMustache() {
        var match = this.matchRe(INTERP_END_RE);
        if (match == null) {
            var position = indexToLineAndColumn(this.text, this.index);
            throw $interpolateMinErr("reqendinterp", "Expecting end of interpolation symbol, â{0}â, at line {1}, column {2} in text â{3}â", "}}", position.line, position.column, this.text);
        }
        if (this.parsedFn == null) {
            this.parsedFn = this.$parse(this.expressionFn, this.stringifier);
            this.parsedFn["exp"] = this.expressionFn["exp"];
            this.parsedFn["expressions"] = this.expressionFn["expressions"];
        }
        this.rule = null;
    };
    MessageFormatParser.prototype.ruleAngularExpression = function ruleAngularExpression() {
        this.angularOperatorStack = [];
        this.expressionStartIndex = this.index;
        this.rule = this.ruleInAngularExpression;
    };
    function getEndOperator(opBegin) {
        switch (opBegin) {
          case "{":
            return "}";

          case "[":
            return "]";

          case "(":
            return ")";

          default:
            return null;
        }
    }
    function getBeginOperator(opEnd) {
        switch (opEnd) {
          case "}":
            return "{";

          case "]":
            return "[";

          case ")":
            return "(";

          default:
            return null;
        }
    }
    var INTERESTING_OPERATORS_RE = /[[\]{}()'",]/g;
    MessageFormatParser.prototype.ruleInAngularExpression = function ruleInAngularExpression() {
        var match = this.searchRe(INTERESTING_OPERATORS_RE);
        var position;
        if (match == null) {
            if (this.angularOperatorStack.length === 0) {
                this.index = this.text.length;
                this.expressionFn = this.$parse(this.text.substring(this.expressionStartIndex, this.index));
                this.expressionFn["exp"] = this.text.substring(this.expressionStartIndex, this.index);
                this.expressionFn["expressions"] = this.expressionFn["expressions"];
                this.rule = null;
                return;
            }
            var innermostOperator = this.angularOperatorStack[0];
            throw $interpolateMinErr("badexpr", "Unexpected end of Angular expression.  Expecting operator â{0}â at the end of the text â{1}â", this.getEndOperator(innermostOperator), this.text);
        }
        var operator = match[0];
        if (operator === "'" || operator === '"') {
            this.ruleStack.push(this.ruleInAngularExpression);
            this.startStringAtMatch(match);
            return;
        }
        if (operator === ",") {
            if (this.trustedContext) {
                position = indexToLineAndColumn(this.text, this.index);
                throw $interpolateMinErr("unsafe", "Use of select/plural MessageFormat syntax is currently disallowed in a secure context ({0}).  At line {1}, column {2} of text â{3}â", this.trustedContext, position.line, position.column, this.text);
            }
            if (this.angularOperatorStack.length === 0) {
                this.expressionFn = this.$parse(this.text.substring(this.expressionStartIndex, match.index));
                this.expressionFn["exp"] = this.text.substring(this.expressionStartIndex, match.index);
                this.expressionFn["expressions"] = this.expressionFn["expressions"];
                this.rule = null;
                this.rule = this.rulePluralOrSelect;
            }
            return;
        }
        if (getEndOperator(operator) != null) {
            this.angularOperatorStack.unshift(operator);
            return;
        }
        var beginOperator = getBeginOperator(operator);
        if (beginOperator == null) {
            this.errorInParseLogic();
        }
        if (this.angularOperatorStack.length > 0) {
            if (beginOperator === this.angularOperatorStack[0]) {
                this.angularOperatorStack.shift();
                return;
            }
            position = indexToLineAndColumn(this.text, this.index);
            throw $interpolateMinErr("badexpr", "Unexpected operator â{0}â at line {1}, column {2} in text. Was expecting â{3}â. Text: â{4}â", operator, position.line, position.column, getEndOperator(this.angularOperatorStack[0]), this.text);
        }
        this.index = match.index;
        this.expressionFn = this.$parse(this.text.substring(this.expressionStartIndex, this.index));
        this.expressionFn["exp"] = this.text.substring(this.expressionStartIndex, this.index);
        this.expressionFn["expressions"] = this.expressionFn["expressions"];
        this.rule = null;
    };
    var $$MessageFormatFactory = [ "$parse", "$locale", "$sce", "$exceptionHandler", function $$messageFormat($parse, $locale, $sce, $exceptionHandler) {
        function getStringifier(trustedContext, allOrNothing, text) {
            return function stringifier(value) {
                try {
                    value = trustedContext ? $sce["getTrusted"](trustedContext, value) : $sce["valueOf"](value);
                    return allOrNothing && value === undefined ? value : stringify(value);
                } catch (err) {
                    $exceptionHandler($interpolateMinErr["interr"](text, err));
                }
            };
        }
        function interpolate(text, mustHaveExpression, trustedContext, allOrNothing) {
            var stringifier = getStringifier(trustedContext, allOrNothing, text);
            var parser = new MessageFormatParser(text, 0, $parse, $locale["pluralCat"], stringifier, mustHaveExpression, trustedContext, allOrNothing);
            parser.run(parser.ruleInterpolate);
            return parser.parsedFn;
        }
        return {
            interpolate: interpolate
        };
    } ];
    var $$interpolateDecorator = [ "$$messageFormat", "$delegate", function $$interpolateDecorator($$messageFormat, $interpolate) {
        if ($interpolate["startSymbol"]() !== "{{" || $interpolate["endSymbol"]() !== "}}") {
            throw $interpolateMinErr("nochgmustache", "angular-message-format.js currently does not allow you to use custom start and end symbols for interpolation.");
        }
        var interpolate = $$messageFormat["interpolate"];
        interpolate["startSymbol"] = $interpolate["startSymbol"];
        interpolate["endSymbol"] = $interpolate["endSymbol"];
        return interpolate;
    } ];
    var $interpolateMinErr;
    var isFunction;
    var noop;
    var toJson;
    var module = window["angular"]["module"]("ngMessageFormat", [ "ng" ]);
    module["factory"]("$$messageFormat", $$MessageFormatFactory);
    module["config"]([ "$provide", function($provide) {
        $interpolateMinErr = window["angular"]["$interpolateMinErr"];
        isFunction = window["angular"]["isFunction"];
        noop = window["angular"]["noop"];
        toJson = window["angular"]["toJson"];
        $provide["decorator"]("$interpolate", $$interpolateDecorator);
    } ]);
})(window, window.angular);

(function(ng, undefined) {
    "use strict";
    ng.module("smart-table", []).run([ "$templateCache", function($templateCache) {
        $templateCache.put("template/smart-table/pagination.html", '<nav ng-if="numPages && pages.length >= 2"><ul class="pagination">' + '<li ng-repeat="page in pages" ng-class="{active: page==currentPage}"><a href="javascript: void(0);" ng-click="selectPage(page)">{{page}}</a></li>' + "</ul></nav>");
    } ]);
    ng.module("smart-table").constant("stConfig", {
        pagination: {
            template: "template/smart-table/pagination.html",
            itemsByPage: 10,
            displayedPages: 5
        },
        search: {
            delay: 400,
            inputEvent: "input"
        },
        select: {
            mode: "single",
            selectedClass: "st-selected"
        },
        sort: {
            ascentClass: "st-sort-ascent",
            descentClass: "st-sort-descent",
            descendingFirst: false,
            skipNatural: false,
            delay: 300
        },
        pipe: {
            delay: 100
        }
    });
    ng.module("smart-table").controller("stTableController", [ "$scope", "$parse", "$filter", "$attrs", function StTableController($scope, $parse, $filter, $attrs) {
        var propertyName = $attrs.stTable;
        var displayGetter = $parse(propertyName);
        var displaySetter = displayGetter.assign;
        var safeGetter;
        var orderBy = $filter("orderBy");
        var filter = $filter("filter");
        var safeCopy = copyRefs(displayGetter($scope));
        var tableState = {
            sort: {},
            search: {},
            pagination: {
                start: 0,
                totalItemCount: 0
            }
        };
        var filtered;
        var pipeAfterSafeCopy = true;
        var ctrl = this;
        var lastSelected;
        function copyRefs(src) {
            return src ? [].concat(src) : [];
        }
        function updateSafeCopy() {
            safeCopy = copyRefs(safeGetter($scope));
            if (pipeAfterSafeCopy === true) {
                ctrl.pipe();
            }
        }
        function deepDelete(object, path) {
            if (path.indexOf(".") != -1) {
                var partials = path.split(".");
                var key = partials.pop();
                var parentPath = partials.join(".");
                var parentObject = $parse(parentPath)(object);
                delete parentObject[key];
                if (Object.keys(parentObject).length == 0) {
                    deepDelete(object, parentPath);
                }
            } else {
                delete object[path];
            }
        }
        if ($attrs.stSafeSrc) {
            safeGetter = $parse($attrs.stSafeSrc);
            $scope.$watch(function() {
                var safeSrc = safeGetter($scope);
                return safeSrc && safeSrc.length ? safeSrc[0] : undefined;
            }, function(newValue, oldValue) {
                if (newValue !== oldValue) {
                    updateSafeCopy();
                }
            });
            $scope.$watch(function() {
                var safeSrc = safeGetter($scope);
                return safeSrc ? safeSrc.length : 0;
            }, function(newValue, oldValue) {
                if (newValue !== safeCopy.length) {
                    updateSafeCopy();
                }
            });
            $scope.$watch(function() {
                return safeGetter($scope);
            }, function(newValue, oldValue) {
                if (newValue !== oldValue) {
                    tableState.pagination.start = 0;
                    updateSafeCopy();
                }
            });
        }
        this.sortBy = function sortBy(predicate, reverse) {
            tableState.sort.predicate = predicate;
            tableState.sort.reverse = reverse === true;
            if (ng.isFunction(predicate)) {
                tableState.sort.functionName = predicate.name;
            } else {
                delete tableState.sort.functionName;
            }
            tableState.pagination.start = 0;
            return this.pipe();
        };
        this.search = function search(input, predicate) {
            var predicateObject = tableState.search.predicateObject || {};
            var prop = predicate ? predicate : "$";
            input = ng.isString(input) ? input.trim() : input;
            $parse(prop).assign(predicateObject, input);
            if (!input) {
                deepDelete(predicateObject, prop);
            }
            tableState.search.predicateObject = predicateObject;
            tableState.pagination.start = 0;
            return this.pipe();
        };
        this.pipe = function pipe() {
            var pagination = tableState.pagination;
            var output;
            filtered = tableState.search.predicateObject ? filter(safeCopy, tableState.search.predicateObject) : safeCopy;
            if (tableState.sort.predicate) {
                filtered = orderBy(filtered, tableState.sort.predicate, tableState.sort.reverse);
            }
            pagination.totalItemCount = filtered.length;
            if (pagination.number !== undefined) {
                pagination.numberOfPages = filtered.length > 0 ? Math.ceil(filtered.length / pagination.number) : 1;
                pagination.start = pagination.start >= filtered.length ? (pagination.numberOfPages - 1) * pagination.number : pagination.start;
                output = filtered.slice(pagination.start, pagination.start + parseInt(pagination.number));
            }
            displaySetter($scope, output || filtered);
        };
        this.select = function select(row, mode) {
            var rows = copyRefs(displayGetter($scope));
            var index = rows.indexOf(row);
            if (index !== -1) {
                if (mode === "single") {
                    row.isSelected = row.isSelected !== true;
                    if (lastSelected) {
                        lastSelected.isSelected = false;
                    }
                    lastSelected = row.isSelected === true ? row : undefined;
                } else {
                    rows[index].isSelected = !rows[index].isSelected;
                }
            }
        };
        this.slice = function splice(start, number) {
            tableState.pagination.start = start;
            tableState.pagination.number = number;
            return this.pipe();
        };
        this.tableState = function getTableState() {
            return tableState;
        };
        this.getFilteredCollection = function getFilteredCollection() {
            return filtered || safeCopy;
        };
        this.setFilterFunction = function setFilterFunction(filterName) {
            filter = $filter(filterName);
        };
        this.setSortFunction = function setSortFunction(sortFunctionName) {
            orderBy = $filter(sortFunctionName);
        };
        this.preventPipeOnWatch = function preventPipe() {
            pipeAfterSafeCopy = false;
        };
    } ]).directive("stTable", function() {
        return {
            restrict: "A",
            controller: "stTableController",
            link: function(scope, element, attr, ctrl) {
                if (attr.stSetFilter) {
                    ctrl.setFilterFunction(attr.stSetFilter);
                }
                if (attr.stSetSort) {
                    ctrl.setSortFunction(attr.stSetSort);
                }
            }
        };
    });
    ng.module("smart-table").directive("stSearch", [ "stConfig", "$timeout", "$parse", function(stConfig, $timeout, $parse) {
        return {
            require: "^stTable",
            link: function(scope, element, attr, ctrl) {
                var tableCtrl = ctrl;
                var promise = null;
                var throttle = attr.stDelay || stConfig.search.delay;
                var event = attr.stInputEvent || stConfig.search.inputEvent;
                attr.$observe("stSearch", function(newValue, oldValue) {
                    var input = element[0].value;
                    if (newValue !== oldValue && input) {
                        ctrl.tableState().search = {};
                        tableCtrl.search(input, newValue);
                    }
                });
                scope.$watch(function() {
                    return ctrl.tableState().search;
                }, function(newValue, oldValue) {
                    var predicateExpression = attr.stSearch || "$";
                    if (newValue.predicateObject && $parse(predicateExpression)(newValue.predicateObject) !== element[0].value) {
                        element[0].value = $parse(predicateExpression)(newValue.predicateObject) || "";
                    }
                }, true);
                element.bind(event, function(evt) {
                    evt = evt.originalEvent || evt;
                    if (promise !== null) {
                        $timeout.cancel(promise);
                    }
                    promise = $timeout(function() {
                        tableCtrl.search(evt.target.value, attr.stSearch || "");
                        promise = null;
                    }, throttle);
                });
            }
        };
    } ]);
    ng.module("smart-table").directive("stSelectRow", [ "stConfig", function(stConfig) {
        return {
            restrict: "A",
            require: "^stTable",
            scope: {
                row: "=stSelectRow"
            },
            link: function(scope, element, attr, ctrl) {
                var mode = attr.stSelectMode || stConfig.select.mode;
                element.bind("click", function() {
                    scope.$apply(function() {
                        ctrl.select(scope.row, mode);
                    });
                });
                scope.$watch("row.isSelected", function(newValue) {
                    if (newValue === true) {
                        element.addClass(stConfig.select.selectedClass);
                    } else {
                        element.removeClass(stConfig.select.selectedClass);
                    }
                });
            }
        };
    } ]);
    ng.module("smart-table").directive("stSort", [ "stConfig", "$parse", "$timeout", function(stConfig, $parse, $timeout) {
        return {
            restrict: "A",
            require: "^stTable",
            link: function(scope, element, attr, ctrl) {
                var predicate = attr.stSort;
                var getter = $parse(predicate);
                var index = 0;
                var classAscent = attr.stClassAscent || stConfig.sort.ascentClass;
                var classDescent = attr.stClassDescent || stConfig.sort.descentClass;
                var stateClasses = [ classAscent, classDescent ];
                var sortDefault;
                var skipNatural = attr.stSkipNatural !== undefined ? attr.stSkipNatural : stConfig.sort.skipNatural;
                var descendingFirst = attr.stDescendingFirst !== undefined ? attr.stDescendingFirst : stConfig.sort.descendingFirst;
                var promise = null;
                var throttle = attr.stDelay || stConfig.sort.delay;
                if (attr.stSortDefault) {
                    sortDefault = scope.$eval(attr.stSortDefault) !== undefined ? scope.$eval(attr.stSortDefault) : attr.stSortDefault;
                }
                function sort() {
                    if (descendingFirst) {
                        index = index === 0 ? 2 : index - 1;
                    } else {
                        index++;
                    }
                    var func;
                    predicate = ng.isFunction(getter(scope)) || ng.isArray(getter(scope)) ? getter(scope) : attr.stSort;
                    if (index % 3 === 0 && !!skipNatural !== true) {
                        index = 0;
                        ctrl.tableState().sort = {};
                        ctrl.tableState().pagination.start = 0;
                        func = ctrl.pipe.bind(ctrl);
                    } else {
                        func = ctrl.sortBy.bind(ctrl, predicate, index % 2 === 0);
                    }
                    if (promise !== null) {
                        $timeout.cancel(promise);
                    }
                    if (throttle < 0) {
                        func();
                    } else {
                        promise = $timeout(func, throttle);
                    }
                }
                element.bind("click", function sortClick() {
                    if (predicate) {
                        scope.$apply(sort);
                    }
                });
                if (sortDefault) {
                    index = sortDefault === "reverse" ? 1 : 0;
                    sort();
                }
                scope.$watch(function() {
                    return ctrl.tableState().sort;
                }, function(newValue) {
                    if (newValue.predicate !== predicate) {
                        index = 0;
                        element.removeClass(classAscent).removeClass(classDescent);
                    } else {
                        index = newValue.reverse === true ? 2 : 1;
                        element.removeClass(stateClasses[index % 2]).addClass(stateClasses[index - 1]);
                    }
                }, true);
            }
        };
    } ]);
    ng.module("smart-table").directive("stPagination", [ "stConfig", function(stConfig) {
        return {
            restrict: "EA",
            require: "^stTable",
            scope: {
                stItemsByPage: "=?",
                stDisplayedPages: "=?",
                stPageChange: "&"
            },
            templateUrl: function(element, attrs) {
                if (attrs.stTemplate) {
                    return attrs.stTemplate;
                }
                return stConfig.pagination.template;
            },
            link: function(scope, element, attrs, ctrl) {
                scope.stItemsByPage = scope.stItemsByPage ? +scope.stItemsByPage : stConfig.pagination.itemsByPage;
                scope.stDisplayedPages = scope.stDisplayedPages ? +scope.stDisplayedPages : stConfig.pagination.displayedPages;
                scope.currentPage = 1;
                scope.pages = [];
                function redraw() {
                    var paginationState = ctrl.tableState().pagination;
                    var start = 1;
                    var end;
                    var i;
                    var prevPage = scope.currentPage;
                    scope.totalItemCount = paginationState.totalItemCount;
                    scope.currentPage = Math.floor(paginationState.start / paginationState.number) + 1;
                    start = Math.max(start, scope.currentPage - Math.abs(Math.floor(scope.stDisplayedPages / 2)));
                    end = start + scope.stDisplayedPages;
                    if (end > paginationState.numberOfPages) {
                        end = paginationState.numberOfPages + 1;
                        start = Math.max(1, end - scope.stDisplayedPages);
                    }
                    scope.pages = [];
                    scope.numPages = paginationState.numberOfPages;
                    for (i = start; i < end; i++) {
                        scope.pages.push(i);
                    }
                    if (prevPage !== scope.currentPage) {
                        scope.stPageChange({
                            newPage: scope.currentPage
                        });
                    }
                }
                scope.$watch(function() {
                    return ctrl.tableState().pagination;
                }, redraw, true);
                scope.$watch("stItemsByPage", function(newValue, oldValue) {
                    if (newValue !== oldValue) {
                        scope.selectPage(1);
                    }
                });
                scope.$watch("stDisplayedPages", redraw);
                scope.selectPage = function(page) {
                    if (page > 0 && page <= scope.numPages) {
                        ctrl.slice((page - 1) * scope.stItemsByPage, scope.stItemsByPage);
                    }
                };
                if (!ctrl.tableState().pagination.number) {
                    ctrl.slice(0, scope.stItemsByPage);
                }
            }
        };
    } ]);
    ng.module("smart-table").directive("stPipe", [ "stConfig", "$timeout", function(config, $timeout) {
        return {
            require: "stTable",
            scope: {
                stPipe: "="
            },
            link: {
                pre: function(scope, element, attrs, ctrl) {
                    var pipePromise = null;
                    if (ng.isFunction(scope.stPipe)) {
                        ctrl.preventPipeOnWatch();
                        ctrl.pipe = function() {
                            if (pipePromise !== null) {
                                $timeout.cancel(pipePromise);
                            }
                            pipePromise = $timeout(function() {
                                scope.stPipe(ctrl.tableState(), ctrl);
                            }, config.pipe.delay);
                            return pipePromise;
                        };
                    }
                },
                post: function(scope, element, attrs, ctrl) {
                    ctrl.pipe();
                }
            }
        };
    } ]);
})(angular);

(function(root, factory) {
    if (typeof define === "function" && define.amd) {
        define([], function() {
            return factory();
        });
    } else if (typeof exports === "object") {
        module.exports = factory();
    } else {
        factory();
    }
})(this, function() {
    angular.module("pascalprecht.translate", [ "ng" ]).run(runTranslate);
    function runTranslate($translate) {
        "use strict";
        var key = $translate.storageKey(), storage = $translate.storage();
        var fallbackFromIncorrectStorageValue = function() {
            var preferred = $translate.preferredLanguage();
            if (angular.isString(preferred)) {
                $translate.use(preferred);
            } else {
                storage.put(key, $translate.use());
            }
        };
        fallbackFromIncorrectStorageValue.displayName = "fallbackFromIncorrectStorageValue";
        if (storage) {
            if (!storage.get(key)) {
                fallbackFromIncorrectStorageValue();
            } else {
                $translate.use(storage.get(key))["catch"](fallbackFromIncorrectStorageValue);
            }
        } else if (angular.isString($translate.preferredLanguage())) {
            $translate.use($translate.preferredLanguage());
        }
    }
    runTranslate.$inject = [ "$translate" ];
    runTranslate.displayName = "runTranslate";
    angular.module("pascalprecht.translate").provider("$translateSanitization", $translateSanitizationProvider);
    function $translateSanitizationProvider() {
        "use strict";
        var $sanitize, currentStrategy = null, hasConfiguredStrategy = false, hasShownNoStrategyConfiguredWarning = false, strategies;
        strategies = {
            sanitize: function(value, mode) {
                if (mode === "text") {
                    value = htmlSanitizeValue(value);
                }
                return value;
            },
            escape: function(value, mode) {
                if (mode === "text") {
                    value = htmlEscapeValue(value);
                }
                return value;
            },
            sanitizeParameters: function(value, mode) {
                if (mode === "params") {
                    value = mapInterpolationParameters(value, htmlSanitizeValue);
                }
                return value;
            },
            escapeParameters: function(value, mode) {
                if (mode === "params") {
                    value = mapInterpolationParameters(value, htmlEscapeValue);
                }
                return value;
            }
        };
        strategies.escaped = strategies.escapeParameters;
        this.addStrategy = function(strategyName, strategyFunction) {
            strategies[strategyName] = strategyFunction;
            return this;
        };
        this.removeStrategy = function(strategyName) {
            delete strategies[strategyName];
            return this;
        };
        this.useStrategy = function(strategy) {
            hasConfiguredStrategy = true;
            currentStrategy = strategy;
            return this;
        };
        this.$get = [ "$injector", "$log", function($injector, $log) {
            var cachedStrategyMap = {};
            var applyStrategies = function(value, mode, selectedStrategies) {
                angular.forEach(selectedStrategies, function(selectedStrategy) {
                    if (angular.isFunction(selectedStrategy)) {
                        value = selectedStrategy(value, mode);
                    } else if (angular.isFunction(strategies[selectedStrategy])) {
                        value = strategies[selectedStrategy](value, mode);
                    } else if (angular.isString(strategies[selectedStrategy])) {
                        if (!cachedStrategyMap[strategies[selectedStrategy]]) {
                            try {
                                cachedStrategyMap[strategies[selectedStrategy]] = $injector.get(strategies[selectedStrategy]);
                            } catch (e) {
                                cachedStrategyMap[strategies[selectedStrategy]] = function() {};
                                throw new Error("pascalprecht.translate.$translateSanitization: Unknown sanitization strategy: '" + selectedStrategy + "'");
                            }
                        }
                        value = cachedStrategyMap[strategies[selectedStrategy]](value, mode);
                    } else {
                        throw new Error("pascalprecht.translate.$translateSanitization: Unknown sanitization strategy: '" + selectedStrategy + "'");
                    }
                });
                return value;
            };
            var showNoStrategyConfiguredWarning = function() {
                if (!hasConfiguredStrategy && !hasShownNoStrategyConfiguredWarning) {
                    $log.warn("pascalprecht.translate.$translateSanitization: No sanitization strategy has been configured. This can have serious security implications. See http://angular-translate.github.io/docs/#/guide/19_security for details.");
                    hasShownNoStrategyConfiguredWarning = true;
                }
            };
            if ($injector.has("$sanitize")) {
                $sanitize = $injector.get("$sanitize");
            }
            return {
                useStrategy: function(self) {
                    return function(strategy) {
                        self.useStrategy(strategy);
                    };
                }(this),
                sanitize: function(value, mode, strategy) {
                    if (!currentStrategy) {
                        showNoStrategyConfiguredWarning();
                    }
                    if (arguments.length < 3) {
                        strategy = currentStrategy;
                    }
                    if (!strategy) {
                        return value;
                    }
                    var selectedStrategies = angular.isArray(strategy) ? strategy : [ strategy ];
                    return applyStrategies(value, mode, selectedStrategies);
                }
            };
        } ];
        var htmlEscapeValue = function(value) {
            var element = angular.element("<div></div>");
            element.text(value);
            return element.html();
        };
        var htmlSanitizeValue = function(value) {
            if (!$sanitize) {
                throw new Error("pascalprecht.translate.$translateSanitization: Error cannot find $sanitize service. Either include the ngSanitize module (https://docs.angularjs.org/api/ngSanitize) or use a sanitization strategy which does not depend on $sanitize, such as 'escape'.");
            }
            return $sanitize(value);
        };
        var mapInterpolationParameters = function(value, iteratee) {
            if (angular.isObject(value)) {
                var result = angular.isArray(value) ? [] : {};
                angular.forEach(value, function(propertyValue, propertyKey) {
                    result[propertyKey] = mapInterpolationParameters(propertyValue, iteratee);
                });
                return result;
            } else if (angular.isNumber(value)) {
                return value;
            } else {
                return iteratee(value);
            }
        };
    }
    angular.module("pascalprecht.translate").constant("pascalprechtTranslateOverrider", {}).provider("$translate", $translate);
    function $translate($STORAGE_KEY, $windowProvider, $translateSanitizationProvider, pascalprechtTranslateOverrider) {
        "use strict";
        var $translationTable = {}, $preferredLanguage, $availableLanguageKeys = [], $languageKeyAliases, $fallbackLanguage, $fallbackWasString, $uses, $nextLang, $storageFactory, $storageKey = $STORAGE_KEY, $storagePrefix, $missingTranslationHandlerFactory, $interpolationFactory, $interpolatorFactories = [], $loaderFactory, $cloakClassName = "translate-cloak", $loaderOptions, $notFoundIndicatorLeft, $notFoundIndicatorRight, $postCompilingEnabled = false, $forceAsyncReloadEnabled = false, $nestedObjectDelimeter = ".", $isReady = false, loaderCache, directivePriority = 0, statefulFilter = true, uniformLanguageTagResolver = "default", languageTagResolver = {
            "default": function(tag) {
                return (tag || "").split("-").join("_");
            },
            java: function(tag) {
                var temp = (tag || "").split("-").join("_");
                var parts = temp.split("_");
                return parts.length > 1 ? parts[0].toLowerCase() + "_" + parts[1].toUpperCase() : temp;
            },
            bcp47: function(tag) {
                var temp = (tag || "").split("_").join("-");
                var parts = temp.split("-");
                return parts.length > 1 ? parts[0].toLowerCase() + "-" + parts[1].toUpperCase() : temp;
            }
        };
        var version = "2.8.1";
        var getFirstBrowserLanguage = function() {
            if (angular.isFunction(pascalprechtTranslateOverrider.getLocale)) {
                return pascalprechtTranslateOverrider.getLocale();
            }
            var nav = $windowProvider.$get().navigator, browserLanguagePropertyKeys = [ "language", "browserLanguage", "systemLanguage", "userLanguage" ], i, language;
            if (angular.isArray(nav.languages)) {
                for (i = 0; i < nav.languages.length; i++) {
                    language = nav.languages[i];
                    if (language && language.length) {
                        return language;
                    }
                }
            }
            for (i = 0; i < browserLanguagePropertyKeys.length; i++) {
                language = nav[browserLanguagePropertyKeys[i]];
                if (language && language.length) {
                    return language;
                }
            }
            return null;
        };
        getFirstBrowserLanguage.displayName = "angular-translate/service: getFirstBrowserLanguage";
        var getLocale = function() {
            var locale = getFirstBrowserLanguage() || "";
            if (languageTagResolver[uniformLanguageTagResolver]) {
                locale = languageTagResolver[uniformLanguageTagResolver](locale);
            }
            return locale;
        };
        getLocale.displayName = "angular-translate/service: getLocale";
        var indexOf = function(array, searchElement) {
            for (var i = 0, len = array.length; i < len; i++) {
                if (array[i] === searchElement) {
                    return i;
                }
            }
            return -1;
        };
        var trim = function() {
            return this.toString().replace(/^\s+|\s+$/g, "");
        };
        var negotiateLocale = function(preferred) {
            var avail = [], locale = angular.lowercase(preferred), i = 0, n = $availableLanguageKeys.length;
            for (;i < n; i++) {
                avail.push(angular.lowercase($availableLanguageKeys[i]));
            }
            if (indexOf(avail, locale) > -1) {
                return preferred;
            }
            if ($languageKeyAliases) {
                var alias;
                for (var langKeyAlias in $languageKeyAliases) {
                    var hasWildcardKey = false;
                    var hasExactKey = Object.prototype.hasOwnProperty.call($languageKeyAliases, langKeyAlias) && angular.lowercase(langKeyAlias) === angular.lowercase(preferred);
                    if (langKeyAlias.slice(-1) === "*") {
                        hasWildcardKey = langKeyAlias.slice(0, -1) === preferred.slice(0, langKeyAlias.length - 1);
                    }
                    if (hasExactKey || hasWildcardKey) {
                        alias = $languageKeyAliases[langKeyAlias];
                        if (indexOf(avail, angular.lowercase(alias)) > -1) {
                            return alias;
                        }
                    }
                }
            }
            if (preferred) {
                var parts = preferred.split("_");
                if (parts.length > 1 && indexOf(avail, angular.lowercase(parts[0])) > -1) {
                    return parts[0];
                }
            }
            return preferred;
        };
        var translations = function(langKey, translationTable) {
            if (!langKey && !translationTable) {
                return $translationTable;
            }
            if (langKey && !translationTable) {
                if (angular.isString(langKey)) {
                    return $translationTable[langKey];
                }
            } else {
                if (!angular.isObject($translationTable[langKey])) {
                    $translationTable[langKey] = {};
                }
                angular.extend($translationTable[langKey], flatObject(translationTable));
            }
            return this;
        };
        this.translations = translations;
        this.cloakClassName = function(name) {
            if (!name) {
                return $cloakClassName;
            }
            $cloakClassName = name;
            return this;
        };
        this.nestedObjectDelimeter = function(delimiter) {
            if (!delimiter) {
                return $nestedObjectDelimeter;
            }
            $nestedObjectDelimeter = delimiter;
            return this;
        };
        var flatObject = function(data, path, result, prevKey) {
            var key, keyWithPath, keyWithShortPath, val;
            if (!path) {
                path = [];
            }
            if (!result) {
                result = {};
            }
            for (key in data) {
                if (!Object.prototype.hasOwnProperty.call(data, key)) {
                    continue;
                }
                val = data[key];
                if (angular.isObject(val)) {
                    flatObject(val, path.concat(key), result, key);
                } else {
                    keyWithPath = path.length ? "" + path.join($nestedObjectDelimeter) + $nestedObjectDelimeter + key : key;
                    if (path.length && key === prevKey) {
                        keyWithShortPath = "" + path.join($nestedObjectDelimeter);
                        result[keyWithShortPath] = "@:" + keyWithPath;
                    }
                    result[keyWithPath] = val;
                }
            }
            return result;
        };
        flatObject.displayName = "flatObject";
        this.addInterpolation = function(factory) {
            $interpolatorFactories.push(factory);
            return this;
        };
        this.useMessageFormatInterpolation = function() {
            return this.useInterpolation("$translateMessageFormatInterpolation");
        };
        this.useInterpolation = function(factory) {
            $interpolationFactory = factory;
            return this;
        };
        this.useSanitizeValueStrategy = function(value) {
            $translateSanitizationProvider.useStrategy(value);
            return this;
        };
        this.preferredLanguage = function(langKey) {
            if (langKey) {
                setupPreferredLanguage(langKey);
                return this;
            }
            return $preferredLanguage;
        };
        var setupPreferredLanguage = function(langKey) {
            if (langKey) {
                $preferredLanguage = langKey;
            }
            return $preferredLanguage;
        };
        this.translationNotFoundIndicator = function(indicator) {
            this.translationNotFoundIndicatorLeft(indicator);
            this.translationNotFoundIndicatorRight(indicator);
            return this;
        };
        this.translationNotFoundIndicatorLeft = function(indicator) {
            if (!indicator) {
                return $notFoundIndicatorLeft;
            }
            $notFoundIndicatorLeft = indicator;
            return this;
        };
        this.translationNotFoundIndicatorRight = function(indicator) {
            if (!indicator) {
                return $notFoundIndicatorRight;
            }
            $notFoundIndicatorRight = indicator;
            return this;
        };
        this.fallbackLanguage = function(langKey) {
            fallbackStack(langKey);
            return this;
        };
        var fallbackStack = function(langKey) {
            if (langKey) {
                if (angular.isString(langKey)) {
                    $fallbackWasString = true;
                    $fallbackLanguage = [ langKey ];
                } else if (angular.isArray(langKey)) {
                    $fallbackWasString = false;
                    $fallbackLanguage = langKey;
                }
                if (angular.isString($preferredLanguage) && indexOf($fallbackLanguage, $preferredLanguage) < 0) {
                    $fallbackLanguage.push($preferredLanguage);
                }
                return this;
            } else {
                if ($fallbackWasString) {
                    return $fallbackLanguage[0];
                } else {
                    return $fallbackLanguage;
                }
            }
        };
        this.use = function(langKey) {
            if (langKey) {
                if (!$translationTable[langKey] && !$loaderFactory) {
                    throw new Error("$translateProvider couldn't find translationTable for langKey: '" + langKey + "'");
                }
                $uses = langKey;
                return this;
            }
            return $uses;
        };
        var storageKey = function(key) {
            if (!key) {
                if ($storagePrefix) {
                    return $storagePrefix + $storageKey;
                }
                return $storageKey;
            }
            $storageKey = key;
            return this;
        };
        this.storageKey = storageKey;
        this.useUrlLoader = function(url, options) {
            return this.useLoader("$translateUrlLoader", angular.extend({
                url: url
            }, options));
        };
        this.useStaticFilesLoader = function(options) {
            return this.useLoader("$translateStaticFilesLoader", options);
        };
        this.useLoader = function(loaderFactory, options) {
            $loaderFactory = loaderFactory;
            $loaderOptions = options || {};
            return this;
        };
        this.useLocalStorage = function() {
            return this.useStorage("$translateLocalStorage");
        };
        this.useCookieStorage = function() {
            return this.useStorage("$translateCookieStorage");
        };
        this.useStorage = function(storageFactory) {
            $storageFactory = storageFactory;
            return this;
        };
        this.storagePrefix = function(prefix) {
            if (!prefix) {
                return prefix;
            }
            $storagePrefix = prefix;
            return this;
        };
        this.useMissingTranslationHandlerLog = function() {
            return this.useMissingTranslationHandler("$translateMissingTranslationHandlerLog");
        };
        this.useMissingTranslationHandler = function(factory) {
            $missingTranslationHandlerFactory = factory;
            return this;
        };
        this.usePostCompiling = function(value) {
            $postCompilingEnabled = !!value;
            return this;
        };
        this.forceAsyncReload = function(value) {
            $forceAsyncReloadEnabled = !!value;
            return this;
        };
        this.uniformLanguageTag = function(options) {
            if (!options) {
                options = {};
            } else if (angular.isString(options)) {
                options = {
                    standard: options
                };
            }
            uniformLanguageTagResolver = options.standard;
            return this;
        };
        this.determinePreferredLanguage = function(fn) {
            var locale = fn && angular.isFunction(fn) ? fn() : getLocale();
            if (!$availableLanguageKeys.length) {
                $preferredLanguage = locale;
            } else {
                $preferredLanguage = negotiateLocale(locale);
            }
            return this;
        };
        this.registerAvailableLanguageKeys = function(languageKeys, aliases) {
            if (languageKeys) {
                $availableLanguageKeys = languageKeys;
                if (aliases) {
                    $languageKeyAliases = aliases;
                }
                return this;
            }
            return $availableLanguageKeys;
        };
        this.useLoaderCache = function(cache) {
            if (cache === false) {
                loaderCache = undefined;
            } else if (cache === true) {
                loaderCache = true;
            } else if (typeof cache === "undefined") {
                loaderCache = "$translationCache";
            } else if (cache) {
                loaderCache = cache;
            }
            return this;
        };
        this.directivePriority = function(priority) {
            if (priority === undefined) {
                return directivePriority;
            } else {
                directivePriority = priority;
                return this;
            }
        };
        this.statefulFilter = function(state) {
            if (state === undefined) {
                return statefulFilter;
            } else {
                statefulFilter = state;
                return this;
            }
        };
        this.$get = [ "$log", "$injector", "$rootScope", "$q", function($log, $injector, $rootScope, $q) {
            var Storage, defaultInterpolator = $injector.get($interpolationFactory || "$translateDefaultInterpolation"), pendingLoader = false, interpolatorHashMap = {}, langPromises = {}, fallbackIndex, startFallbackIteration;
            var $translate = function(translationId, interpolateParams, interpolationId, defaultTranslationText) {
                if (angular.isArray(translationId)) {
                    var translateAll = function(translationIds) {
                        var results = {};
                        var promises = [];
                        var translate = function(translationId) {
                            var deferred = $q.defer();
                            var regardless = function(value) {
                                results[translationId] = value;
                                deferred.resolve([ translationId, value ]);
                            };
                            $translate(translationId, interpolateParams, interpolationId, defaultTranslationText).then(regardless, regardless);
                            return deferred.promise;
                        };
                        for (var i = 0, c = translationIds.length; i < c; i++) {
                            promises.push(translate(translationIds[i]));
                        }
                        return $q.all(promises).then(function() {
                            return results;
                        });
                    };
                    return translateAll(translationId);
                }
                var deferred = $q.defer();
                if (translationId) {
                    translationId = trim.apply(translationId);
                }
                var promiseToWaitFor = function() {
                    var promise = $preferredLanguage ? langPromises[$preferredLanguage] : langPromises[$uses];
                    fallbackIndex = 0;
                    if ($storageFactory && !promise) {
                        var langKey = Storage.get($storageKey);
                        promise = langPromises[langKey];
                        if ($fallbackLanguage && $fallbackLanguage.length) {
                            var index = indexOf($fallbackLanguage, langKey);
                            fallbackIndex = index === 0 ? 1 : 0;
                            if (indexOf($fallbackLanguage, $preferredLanguage) < 0) {
                                $fallbackLanguage.push($preferredLanguage);
                            }
                        }
                    }
                    return promise;
                }();
                if (!promiseToWaitFor) {
                    determineTranslation(translationId, interpolateParams, interpolationId, defaultTranslationText).then(deferred.resolve, deferred.reject);
                } else {
                    var promiseResolved = function() {
                        determineTranslation(translationId, interpolateParams, interpolationId, defaultTranslationText).then(deferred.resolve, deferred.reject);
                    };
                    promiseResolved.displayName = "promiseResolved";
                    promiseToWaitFor["finally"](promiseResolved, deferred.reject);
                }
                return deferred.promise;
            };
            var applyNotFoundIndicators = function(translationId) {
                if ($notFoundIndicatorLeft) {
                    translationId = [ $notFoundIndicatorLeft, translationId ].join(" ");
                }
                if ($notFoundIndicatorRight) {
                    translationId = [ translationId, $notFoundIndicatorRight ].join(" ");
                }
                return translationId;
            };
            var useLanguage = function(key) {
                $uses = key;
                if ($storageFactory) {
                    Storage.put($translate.storageKey(), $uses);
                }
                $rootScope.$emit("$translateChangeSuccess", {
                    language: key
                });
                defaultInterpolator.setLocale($uses);
                var eachInterpolator = function(interpolator, id) {
                    interpolatorHashMap[id].setLocale($uses);
                };
                eachInterpolator.displayName = "eachInterpolatorLocaleSetter";
                angular.forEach(interpolatorHashMap, eachInterpolator);
                $rootScope.$emit("$translateChangeEnd", {
                    language: key
                });
            };
            var loadAsync = function(key) {
                if (!key) {
                    throw "No language key specified for loading.";
                }
                var deferred = $q.defer();
                $rootScope.$emit("$translateLoadingStart", {
                    language: key
                });
                pendingLoader = true;
                var cache = loaderCache;
                if (typeof cache === "string") {
                    cache = $injector.get(cache);
                }
                var loaderOptions = angular.extend({}, $loaderOptions, {
                    key: key,
                    $http: angular.extend({}, {
                        cache: cache
                    }, $loaderOptions.$http)
                });
                var onLoaderSuccess = function(data) {
                    var translationTable = {};
                    $rootScope.$emit("$translateLoadingSuccess", {
                        language: key
                    });
                    if (angular.isArray(data)) {
                        angular.forEach(data, function(table) {
                            angular.extend(translationTable, flatObject(table));
                        });
                    } else {
                        angular.extend(translationTable, flatObject(data));
                    }
                    pendingLoader = false;
                    deferred.resolve({
                        key: key,
                        table: translationTable
                    });
                    $rootScope.$emit("$translateLoadingEnd", {
                        language: key
                    });
                };
                onLoaderSuccess.displayName = "onLoaderSuccess";
                var onLoaderError = function(key) {
                    $rootScope.$emit("$translateLoadingError", {
                        language: key
                    });
                    deferred.reject(key);
                    $rootScope.$emit("$translateLoadingEnd", {
                        language: key
                    });
                };
                onLoaderError.displayName = "onLoaderError";
                $injector.get($loaderFactory)(loaderOptions).then(onLoaderSuccess, onLoaderError);
                return deferred.promise;
            };
            if ($storageFactory) {
                Storage = $injector.get($storageFactory);
                if (!Storage.get || !Storage.put) {
                    throw new Error("Couldn't use storage '" + $storageFactory + "', missing get() or put() method!");
                }
            }
            if ($interpolatorFactories.length) {
                var eachInterpolationFactory = function(interpolatorFactory) {
                    var interpolator = $injector.get(interpolatorFactory);
                    interpolator.setLocale($preferredLanguage || $uses);
                    interpolatorHashMap[interpolator.getInterpolationIdentifier()] = interpolator;
                };
                eachInterpolationFactory.displayName = "interpolationFactoryAdder";
                angular.forEach($interpolatorFactories, eachInterpolationFactory);
            }
            var getTranslationTable = function(langKey) {
                var deferred = $q.defer();
                if (Object.prototype.hasOwnProperty.call($translationTable, langKey)) {
                    deferred.resolve($translationTable[langKey]);
                } else if (langPromises[langKey]) {
                    var onResolve = function(data) {
                        translations(data.key, data.table);
                        deferred.resolve(data.table);
                    };
                    onResolve.displayName = "translationTableResolver";
                    langPromises[langKey].then(onResolve, deferred.reject);
                } else {
                    deferred.reject();
                }
                return deferred.promise;
            };
            var getFallbackTranslation = function(langKey, translationId, interpolateParams, Interpolator) {
                var deferred = $q.defer();
                var onResolve = function(translationTable) {
                    if (Object.prototype.hasOwnProperty.call(translationTable, translationId)) {
                        Interpolator.setLocale(langKey);
                        var translation = translationTable[translationId];
                        if (translation.substr(0, 2) === "@:") {
                            getFallbackTranslation(langKey, translation.substr(2), interpolateParams, Interpolator).then(deferred.resolve, deferred.reject);
                        } else {
                            deferred.resolve(Interpolator.interpolate(translationTable[translationId], interpolateParams));
                        }
                        Interpolator.setLocale($uses);
                    } else {
                        deferred.reject();
                    }
                };
                onResolve.displayName = "fallbackTranslationResolver";
                getTranslationTable(langKey).then(onResolve, deferred.reject);
                return deferred.promise;
            };
            var getFallbackTranslationInstant = function(langKey, translationId, interpolateParams, Interpolator) {
                var result, translationTable = $translationTable[langKey];
                if (translationTable && Object.prototype.hasOwnProperty.call(translationTable, translationId)) {
                    Interpolator.setLocale(langKey);
                    result = Interpolator.interpolate(translationTable[translationId], interpolateParams);
                    if (result.substr(0, 2) === "@:") {
                        return getFallbackTranslationInstant(langKey, result.substr(2), interpolateParams, Interpolator);
                    }
                    Interpolator.setLocale($uses);
                }
                return result;
            };
            var translateByHandler = function(translationId, interpolateParams) {
                if ($missingTranslationHandlerFactory) {
                    var resultString = $injector.get($missingTranslationHandlerFactory)(translationId, $uses, interpolateParams);
                    if (resultString !== undefined) {
                        return resultString;
                    } else {
                        return translationId;
                    }
                } else {
                    return translationId;
                }
            };
            var resolveForFallbackLanguage = function(fallbackLanguageIndex, translationId, interpolateParams, Interpolator, defaultTranslationText) {
                var deferred = $q.defer();
                if (fallbackLanguageIndex < $fallbackLanguage.length) {
                    var langKey = $fallbackLanguage[fallbackLanguageIndex];
                    getFallbackTranslation(langKey, translationId, interpolateParams, Interpolator).then(deferred.resolve, function() {
                        resolveForFallbackLanguage(fallbackLanguageIndex + 1, translationId, interpolateParams, Interpolator, defaultTranslationText).then(deferred.resolve);
                    });
                } else {
                    if (defaultTranslationText) {
                        deferred.resolve(defaultTranslationText);
                    } else {
                        deferred.resolve(translateByHandler(translationId, interpolateParams));
                    }
                }
                return deferred.promise;
            };
            var resolveForFallbackLanguageInstant = function(fallbackLanguageIndex, translationId, interpolateParams, Interpolator) {
                var result;
                if (fallbackLanguageIndex < $fallbackLanguage.length) {
                    var langKey = $fallbackLanguage[fallbackLanguageIndex];
                    result = getFallbackTranslationInstant(langKey, translationId, interpolateParams, Interpolator);
                    if (!result) {
                        result = resolveForFallbackLanguageInstant(fallbackLanguageIndex + 1, translationId, interpolateParams, Interpolator);
                    }
                }
                return result;
            };
            var fallbackTranslation = function(translationId, interpolateParams, Interpolator, defaultTranslationText) {
                return resolveForFallbackLanguage(startFallbackIteration > 0 ? startFallbackIteration : fallbackIndex, translationId, interpolateParams, Interpolator, defaultTranslationText);
            };
            var fallbackTranslationInstant = function(translationId, interpolateParams, Interpolator) {
                return resolveForFallbackLanguageInstant(startFallbackIteration > 0 ? startFallbackIteration : fallbackIndex, translationId, interpolateParams, Interpolator);
            };
            var determineTranslation = function(translationId, interpolateParams, interpolationId, defaultTranslationText) {
                var deferred = $q.defer();
                var table = $uses ? $translationTable[$uses] : $translationTable, Interpolator = interpolationId ? interpolatorHashMap[interpolationId] : defaultInterpolator;
                if (table && Object.prototype.hasOwnProperty.call(table, translationId)) {
                    var translation = table[translationId];
                    if (translation.substr(0, 2) === "@:") {
                        $translate(translation.substr(2), interpolateParams, interpolationId, defaultTranslationText).then(deferred.resolve, deferred.reject);
                    } else {
                        deferred.resolve(Interpolator.interpolate(translation, interpolateParams));
                    }
                } else {
                    var missingTranslationHandlerTranslation;
                    if ($missingTranslationHandlerFactory && !pendingLoader) {
                        missingTranslationHandlerTranslation = translateByHandler(translationId, interpolateParams);
                    }
                    if ($uses && $fallbackLanguage && $fallbackLanguage.length) {
                        fallbackTranslation(translationId, interpolateParams, Interpolator, defaultTranslationText).then(function(translation) {
                            deferred.resolve(translation);
                        }, function(_translationId) {
                            deferred.reject(applyNotFoundIndicators(_translationId));
                        });
                    } else if ($missingTranslationHandlerFactory && !pendingLoader && missingTranslationHandlerTranslation) {
                        if (defaultTranslationText) {
                            deferred.resolve(defaultTranslationText);
                        } else {
                            deferred.resolve(missingTranslationHandlerTranslation);
                        }
                    } else {
                        if (defaultTranslationText) {
                            deferred.resolve(defaultTranslationText);
                        } else {
                            deferred.reject(applyNotFoundIndicators(translationId));
                        }
                    }
                }
                return deferred.promise;
            };
            var determineTranslationInstant = function(translationId, interpolateParams, interpolationId) {
                var result, table = $uses ? $translationTable[$uses] : $translationTable, Interpolator = defaultInterpolator;
                if (interpolatorHashMap && Object.prototype.hasOwnProperty.call(interpolatorHashMap, interpolationId)) {
                    Interpolator = interpolatorHashMap[interpolationId];
                }
                if (table && Object.prototype.hasOwnProperty.call(table, translationId)) {
                    var translation = table[translationId];
                    if (translation.substr(0, 2) === "@:") {
                        result = determineTranslationInstant(translation.substr(2), interpolateParams, interpolationId);
                    } else {
                        result = Interpolator.interpolate(translation, interpolateParams);
                    }
                } else {
                    var missingTranslationHandlerTranslation;
                    if ($missingTranslationHandlerFactory && !pendingLoader) {
                        missingTranslationHandlerTranslation = translateByHandler(translationId, interpolateParams);
                    }
                    if ($uses && $fallbackLanguage && $fallbackLanguage.length) {
                        fallbackIndex = 0;
                        result = fallbackTranslationInstant(translationId, interpolateParams, Interpolator);
                    } else if ($missingTranslationHandlerFactory && !pendingLoader && missingTranslationHandlerTranslation) {
                        result = missingTranslationHandlerTranslation;
                    } else {
                        result = applyNotFoundIndicators(translationId);
                    }
                }
                return result;
            };
            var clearNextLangAndPromise = function(key) {
                if ($nextLang === key) {
                    $nextLang = undefined;
                }
                langPromises[key] = undefined;
            };
            $translate.preferredLanguage = function(langKey) {
                if (langKey) {
                    setupPreferredLanguage(langKey);
                }
                return $preferredLanguage;
            };
            $translate.cloakClassName = function() {
                return $cloakClassName;
            };
            $translate.nestedObjectDelimeter = function() {
                return $nestedObjectDelimeter;
            };
            $translate.fallbackLanguage = function(langKey) {
                if (langKey !== undefined && langKey !== null) {
                    fallbackStack(langKey);
                    if ($loaderFactory) {
                        if ($fallbackLanguage && $fallbackLanguage.length) {
                            for (var i = 0, len = $fallbackLanguage.length; i < len; i++) {
                                if (!langPromises[$fallbackLanguage[i]]) {
                                    langPromises[$fallbackLanguage[i]] = loadAsync($fallbackLanguage[i]);
                                }
                            }
                        }
                    }
                    $translate.use($translate.use());
                }
                if ($fallbackWasString) {
                    return $fallbackLanguage[0];
                } else {
                    return $fallbackLanguage;
                }
            };
            $translate.useFallbackLanguage = function(langKey) {
                if (langKey !== undefined && langKey !== null) {
                    if (!langKey) {
                        startFallbackIteration = 0;
                    } else {
                        var langKeyPosition = indexOf($fallbackLanguage, langKey);
                        if (langKeyPosition > -1) {
                            startFallbackIteration = langKeyPosition;
                        }
                    }
                }
            };
            $translate.proposedLanguage = function() {
                return $nextLang;
            };
            $translate.storage = function() {
                return Storage;
            };
            $translate.use = function(key) {
                if (!key) {
                    return $uses;
                }
                var deferred = $q.defer();
                $rootScope.$emit("$translateChangeStart", {
                    language: key
                });
                var aliasedKey = negotiateLocale(key);
                if (aliasedKey) {
                    key = aliasedKey;
                }
                if (($forceAsyncReloadEnabled || !$translationTable[key]) && $loaderFactory && !langPromises[key]) {
                    $nextLang = key;
                    langPromises[key] = loadAsync(key).then(function(translation) {
                        translations(translation.key, translation.table);
                        deferred.resolve(translation.key);
                        if ($nextLang === key) {
                            useLanguage(translation.key);
                        }
                        return translation;
                    }, function(key) {
                        $rootScope.$emit("$translateChangeError", {
                            language: key
                        });
                        deferred.reject(key);
                        $rootScope.$emit("$translateChangeEnd", {
                            language: key
                        });
                        return $q.reject(key);
                    });
                    langPromises[key]["finally"](function() {
                        clearNextLangAndPromise(key);
                    });
                } else if ($nextLang === key && langPromises[key]) {
                    langPromises[key].then(function(translation) {
                        deferred.resolve(translation.key);
                        return translation;
                    }, function(key) {
                        deferred.reject(key);
                        return $q.reject(key);
                    });
                } else {
                    deferred.resolve(key);
                    useLanguage(key);
                }
                return deferred.promise;
            };
            $translate.storageKey = function() {
                return storageKey();
            };
            $translate.isPostCompilingEnabled = function() {
                return $postCompilingEnabled;
            };
            $translate.isForceAsyncReloadEnabled = function() {
                return $forceAsyncReloadEnabled;
            };
            $translate.refresh = function(langKey) {
                if (!$loaderFactory) {
                    throw new Error("Couldn't refresh translation table, no loader registered!");
                }
                var deferred = $q.defer();
                function resolve() {
                    deferred.resolve();
                    $rootScope.$emit("$translateRefreshEnd", {
                        language: langKey
                    });
                }
                function reject() {
                    deferred.reject();
                    $rootScope.$emit("$translateRefreshEnd", {
                        language: langKey
                    });
                }
                $rootScope.$emit("$translateRefreshStart", {
                    language: langKey
                });
                if (!langKey) {
                    var tables = [], loadingKeys = {};
                    if ($fallbackLanguage && $fallbackLanguage.length) {
                        for (var i = 0, len = $fallbackLanguage.length; i < len; i++) {
                            tables.push(loadAsync($fallbackLanguage[i]));
                            loadingKeys[$fallbackLanguage[i]] = true;
                        }
                    }
                    if ($uses && !loadingKeys[$uses]) {
                        tables.push(loadAsync($uses));
                    }
                    var allTranslationsLoaded = function(tableData) {
                        $translationTable = {};
                        angular.forEach(tableData, function(data) {
                            translations(data.key, data.table);
                        });
                        if ($uses) {
                            useLanguage($uses);
                        }
                        resolve();
                    };
                    allTranslationsLoaded.displayName = "refreshPostProcessor";
                    $q.all(tables).then(allTranslationsLoaded, reject);
                } else if ($translationTable[langKey]) {
                    var oneTranslationsLoaded = function(data) {
                        translations(data.key, data.table);
                        if (langKey === $uses) {
                            useLanguage($uses);
                        }
                        resolve();
                    };
                    oneTranslationsLoaded.displayName = "refreshPostProcessor";
                    loadAsync(langKey).then(oneTranslationsLoaded, reject);
                } else {
                    reject();
                }
                return deferred.promise;
            };
            $translate.instant = function(translationId, interpolateParams, interpolationId) {
                if (translationId === null || angular.isUndefined(translationId)) {
                    return translationId;
                }
                if (angular.isArray(translationId)) {
                    var results = {};
                    for (var i = 0, c = translationId.length; i < c; i++) {
                        results[translationId[i]] = $translate.instant(translationId[i], interpolateParams, interpolationId);
                    }
                    return results;
                }
                if (angular.isString(translationId) && translationId.length < 1) {
                    return translationId;
                }
                if (translationId) {
                    translationId = trim.apply(translationId);
                }
                var result, possibleLangKeys = [];
                if ($preferredLanguage) {
                    possibleLangKeys.push($preferredLanguage);
                }
                if ($uses) {
                    possibleLangKeys.push($uses);
                }
                if ($fallbackLanguage && $fallbackLanguage.length) {
                    possibleLangKeys = possibleLangKeys.concat($fallbackLanguage);
                }
                for (var j = 0, d = possibleLangKeys.length; j < d; j++) {
                    var possibleLangKey = possibleLangKeys[j];
                    if ($translationTable[possibleLangKey]) {
                        if (typeof $translationTable[possibleLangKey][translationId] !== "undefined") {
                            result = determineTranslationInstant(translationId, interpolateParams, interpolationId);
                        } else if ($notFoundIndicatorLeft || $notFoundIndicatorRight) {
                            result = applyNotFoundIndicators(translationId);
                        }
                    }
                    if (typeof result !== "undefined") {
                        break;
                    }
                }
                if (!result && result !== "") {
                    result = defaultInterpolator.interpolate(translationId, interpolateParams);
                    if ($missingTranslationHandlerFactory && !pendingLoader) {
                        result = translateByHandler(translationId, interpolateParams);
                    }
                }
                return result;
            };
            $translate.versionInfo = function() {
                return version;
            };
            $translate.loaderCache = function() {
                return loaderCache;
            };
            $translate.directivePriority = function() {
                return directivePriority;
            };
            $translate.statefulFilter = function() {
                return statefulFilter;
            };
            $translate.isReady = function() {
                return $isReady;
            };
            var $onReadyDeferred = $q.defer();
            $onReadyDeferred.promise.then(function() {
                $isReady = true;
            });
            $translate.onReady = function(fn) {
                var deferred = $q.defer();
                if (angular.isFunction(fn)) {
                    deferred.promise.then(fn);
                }
                if ($isReady) {
                    deferred.resolve();
                } else {
                    $onReadyDeferred.promise.then(deferred.resolve);
                }
                return deferred.promise;
            };
            var globalOnReadyListener = $rootScope.$on("$translateReady", function() {
                $onReadyDeferred.resolve();
                globalOnReadyListener();
                globalOnReadyListener = null;
            });
            var globalOnChangeListener = $rootScope.$on("$translateChangeEnd", function() {
                $onReadyDeferred.resolve();
                globalOnChangeListener();
                globalOnChangeListener = null;
            });
            if ($loaderFactory) {
                if (angular.equals($translationTable, {})) {
                    if ($translate.use()) {
                        $translate.use($translate.use());
                    }
                }
                if ($fallbackLanguage && $fallbackLanguage.length) {
                    var processAsyncResult = function(translation) {
                        translations(translation.key, translation.table);
                        $rootScope.$emit("$translateChangeEnd", {
                            language: translation.key
                        });
                        return translation;
                    };
                    for (var i = 0, len = $fallbackLanguage.length; i < len; i++) {
                        var fallbackLanguageId = $fallbackLanguage[i];
                        if ($forceAsyncReloadEnabled || !$translationTable[fallbackLanguageId]) {
                            langPromises[fallbackLanguageId] = loadAsync(fallbackLanguageId).then(processAsyncResult);
                        }
                    }
                }
            } else {
                $rootScope.$emit("$translateReady", {
                    language: $translate.use()
                });
            }
            return $translate;
        } ];
    }
    $translate.$inject = [ "$STORAGE_KEY", "$windowProvider", "$translateSanitizationProvider", "pascalprechtTranslateOverrider" ];
    $translate.displayName = "displayName";
    angular.module("pascalprecht.translate").factory("$translateDefaultInterpolation", $translateDefaultInterpolation);
    function $translateDefaultInterpolation($interpolate, $translateSanitization) {
        "use strict";
        var $translateInterpolator = {}, $locale, $identifier = "default";
        $translateInterpolator.setLocale = function(locale) {
            $locale = locale;
        };
        $translateInterpolator.getInterpolationIdentifier = function() {
            return $identifier;
        };
        $translateInterpolator.useSanitizeValueStrategy = function(value) {
            $translateSanitization.useStrategy(value);
            return this;
        };
        $translateInterpolator.interpolate = function(string, interpolationParams) {
            interpolationParams = interpolationParams || {};
            interpolationParams = $translateSanitization.sanitize(interpolationParams, "params");
            var interpolatedText = $interpolate(string)(interpolationParams);
            interpolatedText = $translateSanitization.sanitize(interpolatedText, "text");
            return interpolatedText;
        };
        return $translateInterpolator;
    }
    $translateDefaultInterpolation.$inject = [ "$interpolate", "$translateSanitization" ];
    $translateDefaultInterpolation.displayName = "$translateDefaultInterpolation";
    angular.module("pascalprecht.translate").constant("$STORAGE_KEY", "NG_TRANSLATE_LANG_KEY");
    angular.module("pascalprecht.translate").directive("translate", translateDirective);
    function translateDirective($translate, $q, $interpolate, $compile, $parse, $rootScope) {
        "use strict";
        var trim = function() {
            return this.toString().replace(/^\s+|\s+$/g, "");
        };
        return {
            restrict: "AE",
            scope: true,
            priority: $translate.directivePriority(),
            compile: function(tElement, tAttr) {
                var translateValuesExist = tAttr.translateValues ? tAttr.translateValues : undefined;
                var translateInterpolation = tAttr.translateInterpolation ? tAttr.translateInterpolation : undefined;
                var translateValueExist = tElement[0].outerHTML.match(/translate-value-+/i);
                var interpolateRegExp = "^(.*)(" + $interpolate.startSymbol() + ".*" + $interpolate.endSymbol() + ")(.*)", watcherRegExp = "^(.*)" + $interpolate.startSymbol() + "(.*)" + $interpolate.endSymbol() + "(.*)";
                return function linkFn(scope, iElement, iAttr) {
                    scope.interpolateParams = {};
                    scope.preText = "";
                    scope.postText = "";
                    scope.translateNamespace = getTranslateNamespace(scope);
                    var translationIds = {};
                    var initInterpolationParams = function(interpolateParams, iAttr, tAttr) {
                        if (iAttr.translateValues) {
                            angular.extend(interpolateParams, $parse(iAttr.translateValues)(scope.$parent));
                        }
                        if (translateValueExist) {
                            for (var attr in tAttr) {
                                if (Object.prototype.hasOwnProperty.call(iAttr, attr) && attr.substr(0, 14) === "translateValue" && attr !== "translateValues") {
                                    var attributeName = angular.lowercase(attr.substr(14, 1)) + attr.substr(15);
                                    interpolateParams[attributeName] = tAttr[attr];
                                }
                            }
                        }
                    };
                    var observeElementTranslation = function(translationId) {
                        if (angular.isFunction(observeElementTranslation._unwatchOld)) {
                            observeElementTranslation._unwatchOld();
                            observeElementTranslation._unwatchOld = undefined;
                        }
                        if (angular.equals(translationId, "") || !angular.isDefined(translationId)) {
                            var iElementText = trim.apply(iElement.text());
                            var interpolateMatches = iElementText.match(interpolateRegExp);
                            if (angular.isArray(interpolateMatches)) {
                                scope.preText = interpolateMatches[1];
                                scope.postText = interpolateMatches[3];
                                translationIds.translate = $interpolate(interpolateMatches[2])(scope.$parent);
                                var watcherMatches = iElementText.match(watcherRegExp);
                                if (angular.isArray(watcherMatches) && watcherMatches[2] && watcherMatches[2].length) {
                                    observeElementTranslation._unwatchOld = scope.$watch(watcherMatches[2], function(newValue) {
                                        translationIds.translate = newValue;
                                        updateTranslations();
                                    });
                                }
                            } else {
                                translationIds.translate = iElementText;
                            }
                        } else {
                            translationIds.translate = translationId;
                        }
                        updateTranslations();
                    };
                    var observeAttributeTranslation = function(translateAttr) {
                        iAttr.$observe(translateAttr, function(translationId) {
                            translationIds[translateAttr] = translationId;
                            updateTranslations();
                        });
                    };
                    initInterpolationParams(scope.interpolateParams, iAttr, tAttr);
                    var firstAttributeChangedEvent = true;
                    iAttr.$observe("translate", function(translationId) {
                        if (typeof translationId === "undefined") {
                            observeElementTranslation("");
                        } else {
                            if (translationId !== "" || !firstAttributeChangedEvent) {
                                translationIds.translate = translationId;
                                updateTranslations();
                            }
                        }
                        firstAttributeChangedEvent = false;
                    });
                    for (var translateAttr in iAttr) {
                        if (iAttr.hasOwnProperty(translateAttr) && translateAttr.substr(0, 13) === "translateAttr") {
                            observeAttributeTranslation(translateAttr);
                        }
                    }
                    iAttr.$observe("translateDefault", function(value) {
                        scope.defaultText = value;
                    });
                    if (translateValuesExist) {
                        iAttr.$observe("translateValues", function(interpolateParams) {
                            if (interpolateParams) {
                                scope.$parent.$watch(function() {
                                    angular.extend(scope.interpolateParams, $parse(interpolateParams)(scope.$parent));
                                });
                            }
                        });
                    }
                    if (translateValueExist) {
                        var observeValueAttribute = function(attrName) {
                            iAttr.$observe(attrName, function(value) {
                                var attributeName = angular.lowercase(attrName.substr(14, 1)) + attrName.substr(15);
                                scope.interpolateParams[attributeName] = value;
                            });
                        };
                        for (var attr in iAttr) {
                            if (Object.prototype.hasOwnProperty.call(iAttr, attr) && attr.substr(0, 14) === "translateValue" && attr !== "translateValues") {
                                observeValueAttribute(attr);
                            }
                        }
                    }
                    var updateTranslations = function() {
                        for (var key in translationIds) {
                            if (translationIds.hasOwnProperty(key) && translationIds[key] !== undefined) {
                                updateTranslation(key, translationIds[key], scope, scope.interpolateParams, scope.defaultText, scope.translateNamespace);
                            }
                        }
                    };
                    var updateTranslation = function(translateAttr, translationId, scope, interpolateParams, defaultTranslationText, translateNamespace) {
                        if (translationId) {
                            if (translateNamespace && translationId.charAt(0) === ".") {
                                translationId = translateNamespace + translationId;
                            }
                            $translate(translationId, interpolateParams, translateInterpolation, defaultTranslationText).then(function(translation) {
                                applyTranslation(translation, scope, true, translateAttr);
                            }, function(translationId) {
                                applyTranslation(translationId, scope, false, translateAttr);
                            });
                        } else {
                            applyTranslation(translationId, scope, false, translateAttr);
                        }
                    };
                    var applyTranslation = function(value, scope, successful, translateAttr) {
                        if (translateAttr === "translate") {
                            if (!successful && typeof scope.defaultText !== "undefined") {
                                value = scope.defaultText;
                            }
                            iElement.empty().append(scope.preText + value + scope.postText);
                            var globallyEnabled = $translate.isPostCompilingEnabled();
                            var locallyDefined = typeof tAttr.translateCompile !== "undefined";
                            var locallyEnabled = locallyDefined && tAttr.translateCompile !== "false";
                            if (globallyEnabled && !locallyDefined || locallyEnabled) {
                                $compile(iElement.contents())(scope);
                            }
                        } else {
                            if (!successful && typeof scope.defaultText !== "undefined") {
                                value = scope.defaultText;
                            }
                            var attributeName = iAttr.$attr[translateAttr];
                            if (attributeName.substr(0, 5) === "data-") {
                                attributeName = attributeName.substr(5);
                            }
                            attributeName = attributeName.substr(15);
                            iElement.attr(attributeName, value);
                        }
                    };
                    if (translateValuesExist || translateValueExist || iAttr.translateDefault) {
                        scope.$watch("interpolateParams", updateTranslations, true);
                    }
                    var unbind = $rootScope.$on("$translateChangeSuccess", updateTranslations);
                    if (iElement.text().length) {
                        if (iAttr.translate) {
                            observeElementTranslation(iAttr.translate);
                        } else {
                            observeElementTranslation("");
                        }
                    } else if (iAttr.translate) {
                        observeElementTranslation(iAttr.translate);
                    }
                    updateTranslations();
                    scope.$on("$destroy", unbind);
                };
            }
        };
    }
    translateDirective.$inject = [ "$translate", "$q", "$interpolate", "$compile", "$parse", "$rootScope" ];
    function getTranslateNamespace(scope) {
        "use strict";
        if (scope.translateNamespace) {
            return scope.translateNamespace;
        }
        if (scope.$parent) {
            return getTranslateNamespace(scope.$parent);
        }
    }
    translateDirective.displayName = "translateDirective";
    angular.module("pascalprecht.translate").directive("translateCloak", translateCloakDirective);
    function translateCloakDirective($translate) {
        "use strict";
        return {
            compile: function(tElement) {
                var applyCloak = function() {
                    tElement.addClass($translate.cloakClassName());
                }, removeCloak = function() {
                    tElement.removeClass($translate.cloakClassName());
                };
                $translate.onReady(function() {
                    removeCloak();
                });
                applyCloak();
                return function linkFn(scope, iElement, iAttr) {
                    if (iAttr.translateCloak && iAttr.translateCloak.length) {
                        iAttr.$observe("translateCloak", function(translationId) {
                            $translate(translationId).then(removeCloak, applyCloak);
                        });
                    }
                };
            }
        };
    }
    translateCloakDirective.$inject = [ "$translate" ];
    translateCloakDirective.displayName = "translateCloakDirective";
    angular.module("pascalprecht.translate").directive("translateNamespace", translateNamespaceDirective);
    function translateNamespaceDirective() {
        "use strict";
        return {
            restrict: "A",
            scope: true,
            compile: function() {
                return {
                    pre: function(scope, iElement, iAttrs) {
                        scope.translateNamespace = getTranslateNamespace(scope);
                        if (scope.translateNamespace && iAttrs.translateNamespace.charAt(0) === ".") {
                            scope.translateNamespace += iAttrs.translateNamespace;
                        } else {
                            scope.translateNamespace = iAttrs.translateNamespace;
                        }
                    }
                };
            }
        };
    }
    function getTranslateNamespace(scope) {
        "use strict";
        if (scope.translateNamespace) {
            return scope.translateNamespace;
        }
        if (scope.$parent) {
            return getTranslateNamespace(scope.$parent);
        }
    }
    translateNamespaceDirective.displayName = "translateNamespaceDirective";
    angular.module("pascalprecht.translate").filter("translate", translateFilterFactory);
    function translateFilterFactory($parse, $translate) {
        "use strict";
        var translateFilter = function(translationId, interpolateParams, interpolation) {
            if (!angular.isObject(interpolateParams)) {
                interpolateParams = $parse(interpolateParams)(this);
            }
            return $translate.instant(translationId, interpolateParams, interpolation);
        };
        if ($translate.statefulFilter()) {
            translateFilter.$stateful = true;
        }
        return translateFilter;
    }
    translateFilterFactory.$inject = [ "$parse", "$translate" ];
    translateFilterFactory.displayName = "translateFilterFactory";
    angular.module("pascalprecht.translate").factory("$translationCache", $translationCache);
    function $translationCache($cacheFactory) {
        "use strict";
        return $cacheFactory("translations");
    }
    $translationCache.$inject = [ "$cacheFactory" ];
    $translationCache.displayName = "$translationCache";
    return "pascalprecht.translate";
});

angular.module("perfect_scrollbar", []).directive("perfectScrollbar", [ "$parse", "$window", function($parse, $window) {
    var psOptions = [ "wheelSpeed", "wheelPropagation", "minScrollbarLength", "useBothWheelAxes", "useKeyboard", "suppressScrollX", "suppressScrollY", "scrollXMarginOffset", "scrollYMarginOffset", "includePadding" ];
    return {
        restrict: "EA",
        transclude: true,
        template: "<div><div ng-transclude></div></div>",
        replace: true,
        link: function($scope, $elem, $attr) {
            var jqWindow = angular.element($window);
            var options = {};
            for (var i = 0, l = psOptions.length; i < l; i++) {
                var opt = psOptions[i];
                if ($attr[opt] !== undefined) {
                    options[opt] = $parse($attr[opt])();
                }
            }
            $scope.$evalAsync(function() {
                $elem.perfectScrollbar(options);
                var onScrollHandler = $parse($attr.onScroll);
                $elem.scroll(function() {
                    var scrollTop = $elem.scrollTop();
                    var scrollHeight = $elem.prop("scrollHeight") - $elem.height();
                    $scope.$apply(function() {
                        onScrollHandler($scope, {
                            scrollTop: scrollTop,
                            scrollHeight: scrollHeight
                        });
                    });
                });
            });
            function update(event) {
                $scope.$evalAsync(function() {
                    if ($attr.scrollDown == "true" && event != "mouseenter") {
                        setTimeout(function() {
                            $($elem).scrollTop($($elem).prop("scrollHeight"));
                        }, 100);
                    }
                    $elem.perfectScrollbar("update");
                });
            }
            $elem.bind("mouseenter", update("mouseenter"));
            if ($attr.refreshOnChange) {
                $scope.$watchCollection($attr.refreshOnChange, function() {
                    update();
                });
            }
            if ($attr.refreshOnResize) {
                jqWindow.on("resize", update);
            }
            $elem.bind("$destroy", function() {
                jqWindow.off("resize", update);
                $elem.perfectScrollbar("destroy");
            });
        }
    };
} ]);

(function(factory) {
    "use strict";
    if (typeof define === "function" && define.amd) {
        define([ "jquery" ], factory);
    } else if (typeof exports === "object") {
        factory(require("jquery"));
    } else {
        factory(jQuery);
    }
})(function($) {
    "use strict";
    function getInt(x) {
        if (typeof x === "string") {
            return parseInt(x, 10);
        } else {
            return ~~x;
        }
    }
    var defaultSettings = {
        wheelSpeed: 1,
        wheelPropagation: false,
        swipePropagation: true,
        minScrollbarLength: null,
        maxScrollbarLength: null,
        useBothWheelAxes: false,
        useKeyboard: true,
        suppressScrollX: false,
        suppressScrollY: false,
        scrollXMarginOffset: 0,
        scrollYMarginOffset: 0,
        includePadding: false
    };
    var incrementingId = 0;
    var eventClassFactory = function() {
        var id = incrementingId++;
        return function(eventName) {
            var className = ".perfect-scrollbar-" + id;
            if (typeof eventName === "undefined") {
                return className;
            } else {
                return eventName + className;
            }
        };
    };
    var isWebkit = "WebkitAppearance" in document.documentElement.style;
    $.fn.perfectScrollbar = function(suppliedSettings, option) {
        return this.each(function() {
            var settings = $.extend(true, {}, defaultSettings);
            var $this = $(this);
            var isPluginAlive = function() {
                return !!$this;
            };
            if (typeof suppliedSettings === "object") {
                $.extend(true, settings, suppliedSettings);
            } else {
                option = suppliedSettings;
            }
            if (option === "update") {
                if ($this.data("perfect-scrollbar-update")) {
                    $this.data("perfect-scrollbar-update")();
                }
                return $this;
            } else if (option === "destroy") {
                if ($this.data("perfect-scrollbar-destroy")) {
                    $this.data("perfect-scrollbar-destroy")();
                }
                return $this;
            }
            if ($this.data("perfect-scrollbar")) {
                return $this.data("perfect-scrollbar");
            }
            $this.addClass("ps-container");
            var containerWidth;
            var containerHeight;
            var contentWidth;
            var contentHeight;
            var isRtl = $this.css("direction") === "rtl";
            var eventClass = eventClassFactory();
            var ownerDocument = this.ownerDocument || document;
            var $scrollbarXRail = $("<div class='ps-scrollbar-x-rail'>").appendTo($this);
            var $scrollbarX = $("<div class='ps-scrollbar-x'>").appendTo($scrollbarXRail);
            var scrollbarXActive;
            var scrollbarXWidth;
            var scrollbarXLeft;
            var scrollbarXBottom = getInt($scrollbarXRail.css("bottom"));
            var isScrollbarXUsingBottom = scrollbarXBottom === scrollbarXBottom;
            var scrollbarXTop = isScrollbarXUsingBottom ? null : getInt($scrollbarXRail.css("top"));
            var railBorderXWidth = getInt($scrollbarXRail.css("borderLeftWidth")) + getInt($scrollbarXRail.css("borderRightWidth"));
            var railXMarginWidth = getInt($scrollbarXRail.css("marginLeft")) + getInt($scrollbarXRail.css("marginRight"));
            var railXWidth;
            var $scrollbarYRail = $("<div class='ps-scrollbar-y-rail'>").appendTo($this);
            var $scrollbarY = $("<div class='ps-scrollbar-y'>").appendTo($scrollbarYRail);
            var scrollbarYActive;
            var scrollbarYHeight;
            var scrollbarYTop;
            var scrollbarYRight = getInt($scrollbarYRail.css("right"));
            var isScrollbarYUsingRight = scrollbarYRight === scrollbarYRight;
            var scrollbarYLeft = isScrollbarYUsingRight ? null : getInt($scrollbarYRail.css("left"));
            var railBorderYWidth = getInt($scrollbarYRail.css("borderTopWidth")) + getInt($scrollbarYRail.css("borderBottomWidth"));
            var railYMarginHeight = getInt($scrollbarYRail.css("marginTop")) + getInt($scrollbarYRail.css("marginBottom"));
            var railYHeight;
            function updateScrollTop(currentTop, deltaY) {
                var newTop = currentTop + deltaY;
                var maxTop = containerHeight - scrollbarYHeight;
                if (newTop < 0) {
                    scrollbarYTop = 0;
                } else if (newTop > maxTop) {
                    scrollbarYTop = maxTop;
                } else {
                    scrollbarYTop = newTop;
                }
                var scrollTop = getInt(scrollbarYTop * (contentHeight - containerHeight) / (containerHeight - scrollbarYHeight));
                $this.scrollTop(scrollTop);
            }
            function updateScrollLeft(currentLeft, deltaX) {
                var newLeft = currentLeft + deltaX;
                var maxLeft = containerWidth - scrollbarXWidth;
                if (newLeft < 0) {
                    scrollbarXLeft = 0;
                } else if (newLeft > maxLeft) {
                    scrollbarXLeft = maxLeft;
                } else {
                    scrollbarXLeft = newLeft;
                }
                var scrollLeft = getInt(scrollbarXLeft * (contentWidth - containerWidth) / (containerWidth - scrollbarXWidth));
                $this.scrollLeft(scrollLeft);
            }
            function getThumbSize(thumbSize) {
                if (settings.minScrollbarLength) {
                    thumbSize = Math.max(thumbSize, settings.minScrollbarLength);
                }
                if (settings.maxScrollbarLength) {
                    thumbSize = Math.min(thumbSize, settings.maxScrollbarLength);
                }
                return thumbSize;
            }
            function updateCss() {
                var xRailOffset = {
                    width: railXWidth
                };
                if (isRtl) {
                    xRailOffset.left = $this.scrollLeft() + containerWidth - contentWidth;
                } else {
                    xRailOffset.left = $this.scrollLeft();
                }
                if (isScrollbarXUsingBottom) {
                    xRailOffset.bottom = scrollbarXBottom - $this.scrollTop();
                } else {
                    xRailOffset.top = scrollbarXTop + $this.scrollTop();
                }
                $scrollbarXRail.css(xRailOffset);
                var railYOffset = {
                    top: $this.scrollTop(),
                    height: railYHeight
                };
                if (isScrollbarYUsingRight) {
                    if (isRtl) {
                        railYOffset.right = contentWidth - $this.scrollLeft() - scrollbarYRight - $scrollbarY.outerWidth();
                    } else {
                        railYOffset.right = scrollbarYRight - $this.scrollLeft();
                    }
                } else {
                    if (isRtl) {
                        railYOffset.left = $this.scrollLeft() + containerWidth * 2 - contentWidth - scrollbarYLeft - $scrollbarY.outerWidth();
                    } else {
                        railYOffset.left = scrollbarYLeft + $this.scrollLeft();
                    }
                }
                $scrollbarYRail.css(railYOffset);
                $scrollbarX.css({
                    left: scrollbarXLeft,
                    width: scrollbarXWidth - railBorderXWidth
                });
                $scrollbarY.css({
                    top: scrollbarYTop,
                    height: scrollbarYHeight - railBorderYWidth
                });
            }
            function updateGeometry() {
                $this.removeClass("ps-active-x");
                $this.removeClass("ps-active-y");
                containerWidth = settings.includePadding ? $this.innerWidth() : $this.width();
                containerHeight = settings.includePadding ? $this.innerHeight() : $this.height();
                contentWidth = $this.prop("scrollWidth");
                contentHeight = $this.prop("scrollHeight");
                if (!settings.suppressScrollX && containerWidth + settings.scrollXMarginOffset < contentWidth) {
                    scrollbarXActive = true;
                    railXWidth = containerWidth - railXMarginWidth;
                    scrollbarXWidth = getThumbSize(getInt(railXWidth * containerWidth / contentWidth));
                    scrollbarXLeft = getInt($this.scrollLeft() * (railXWidth - scrollbarXWidth) / (contentWidth - containerWidth));
                } else {
                    scrollbarXActive = false;
                    scrollbarXWidth = 0;
                    scrollbarXLeft = 0;
                    $this.scrollLeft(0);
                }
                if (!settings.suppressScrollY && containerHeight + settings.scrollYMarginOffset < contentHeight) {
                    scrollbarYActive = true;
                    railYHeight = containerHeight - railYMarginHeight;
                    scrollbarYHeight = getThumbSize(getInt(railYHeight * containerHeight / contentHeight));
                    scrollbarYTop = getInt($this.scrollTop() * (railYHeight - scrollbarYHeight) / (contentHeight - containerHeight));
                } else {
                    scrollbarYActive = false;
                    scrollbarYHeight = 0;
                    scrollbarYTop = 0;
                    $this.scrollTop(0);
                }
                if (scrollbarXLeft >= railXWidth - scrollbarXWidth) {
                    scrollbarXLeft = railXWidth - scrollbarXWidth;
                }
                if (scrollbarYTop >= railYHeight - scrollbarYHeight) {
                    scrollbarYTop = railYHeight - scrollbarYHeight;
                }
                updateCss();
                if (scrollbarXActive) {
                    $this.addClass("ps-active-x");
                }
                if (scrollbarYActive) {
                    $this.addClass("ps-active-y");
                }
            }
            function bindMouseScrollXHandler() {
                var currentLeft;
                var currentPageX;
                var mouseMoveHandler = function(e) {
                    updateScrollLeft(currentLeft, e.pageX - currentPageX);
                    updateGeometry();
                    e.stopPropagation();
                    e.preventDefault();
                };
                var mouseUpHandler = function(e) {
                    $this.removeClass("ps-in-scrolling");
                    $(ownerDocument).unbind(eventClass("mousemove"), mouseMoveHandler);
                };
                $scrollbarX.bind(eventClass("mousedown"), function(e) {
                    currentPageX = e.pageX;
                    currentLeft = $scrollbarX.position().left;
                    $this.addClass("ps-in-scrolling");
                    $(ownerDocument).bind(eventClass("mousemove"), mouseMoveHandler);
                    $(ownerDocument).one(eventClass("mouseup"), mouseUpHandler);
                    e.stopPropagation();
                    e.preventDefault();
                });
                currentLeft = currentPageX = null;
            }
            function bindMouseScrollYHandler() {
                var currentTop;
                var currentPageY;
                var mouseMoveHandler = function(e) {
                    updateScrollTop(currentTop, e.pageY - currentPageY);
                    updateGeometry();
                    e.stopPropagation();
                    e.preventDefault();
                };
                var mouseUpHandler = function(e) {
                    $this.removeClass("ps-in-scrolling");
                    $(ownerDocument).unbind(eventClass("mousemove"), mouseMoveHandler);
                };
                $scrollbarY.bind(eventClass("mousedown"), function(e) {
                    currentPageY = e.pageY;
                    currentTop = $scrollbarY.position().top;
                    $this.addClass("ps-in-scrolling");
                    $(ownerDocument).bind(eventClass("mousemove"), mouseMoveHandler);
                    $(ownerDocument).one(eventClass("mouseup"), mouseUpHandler);
                    e.stopPropagation();
                    e.preventDefault();
                });
                currentTop = currentPageY = null;
            }
            function shouldPreventWheel(deltaX, deltaY) {
                var scrollTop = $this.scrollTop();
                if (deltaX === 0) {
                    if (!scrollbarYActive) {
                        return false;
                    }
                    if (scrollTop === 0 && deltaY > 0 || scrollTop >= contentHeight - containerHeight && deltaY < 0) {
                        return !settings.wheelPropagation;
                    }
                }
                var scrollLeft = $this.scrollLeft();
                if (deltaY === 0) {
                    if (!scrollbarXActive) {
                        return false;
                    }
                    if (scrollLeft === 0 && deltaX < 0 || scrollLeft >= contentWidth - containerWidth && deltaX > 0) {
                        return !settings.wheelPropagation;
                    }
                }
                return true;
            }
            function shouldPreventSwipe(deltaX, deltaY) {
                var scrollTop = $this.scrollTop();
                var scrollLeft = $this.scrollLeft();
                var magnitudeX = Math.abs(deltaX);
                var magnitudeY = Math.abs(deltaY);
                if (magnitudeY > magnitudeX) {
                    if (deltaY < 0 && scrollTop === contentHeight - containerHeight || deltaY > 0 && scrollTop === 0) {
                        return !settings.swipePropagation;
                    }
                } else if (magnitudeX > magnitudeY) {
                    if (deltaX < 0 && scrollLeft === contentWidth - containerWidth || deltaX > 0 && scrollLeft === 0) {
                        return !settings.swipePropagation;
                    }
                }
                return true;
            }
            function bindMouseWheelHandler() {
                var shouldPrevent = false;
                function getDeltaFromEvent(e) {
                    var deltaX = e.originalEvent.deltaX;
                    var deltaY = -1 * e.originalEvent.deltaY;
                    if (typeof deltaX === "undefined" || typeof deltaY === "undefined") {
                        deltaX = -1 * e.originalEvent.wheelDeltaX / 6;
                        deltaY = e.originalEvent.wheelDeltaY / 6;
                    }
                    if (e.originalEvent.deltaMode && e.originalEvent.deltaMode === 1) {
                        deltaX *= 10;
                        deltaY *= 10;
                    }
                    if (deltaX !== deltaX && deltaY !== deltaY) {
                        deltaX = 0;
                        deltaY = e.originalEvent.wheelDelta;
                    }
                    return [ deltaX, deltaY ];
                }
                function mousewheelHandler(e) {
                    if (!isWebkit && $this.find("select:focus").length > 0) {
                        return;
                    }
                    var delta = getDeltaFromEvent(e);
                    var deltaX = delta[0];
                    var deltaY = delta[1];
                    shouldPrevent = false;
                    if (!settings.useBothWheelAxes) {
                        $this.scrollTop($this.scrollTop() - deltaY * settings.wheelSpeed);
                        $this.scrollLeft($this.scrollLeft() + deltaX * settings.wheelSpeed);
                    } else if (scrollbarYActive && !scrollbarXActive) {
                        if (deltaY) {
                            $this.scrollTop($this.scrollTop() - deltaY * settings.wheelSpeed);
                        } else {
                            $this.scrollTop($this.scrollTop() + deltaX * settings.wheelSpeed);
                        }
                        shouldPrevent = true;
                    } else if (scrollbarXActive && !scrollbarYActive) {
                        if (deltaX) {
                            $this.scrollLeft($this.scrollLeft() + deltaX * settings.wheelSpeed);
                        } else {
                            $this.scrollLeft($this.scrollLeft() - deltaY * settings.wheelSpeed);
                        }
                        shouldPrevent = true;
                    }
                    updateGeometry();
                    shouldPrevent = shouldPrevent || shouldPreventWheel(deltaX, deltaY);
                    if (shouldPrevent) {
                        e.stopPropagation();
                        e.preventDefault();
                    }
                }
                if (typeof window.onwheel !== "undefined") {
                    $this.bind(eventClass("wheel"), mousewheelHandler);
                } else if (typeof window.onmousewheel !== "undefined") {
                    $this.bind(eventClass("mousewheel"), mousewheelHandler);
                }
            }
            function bindKeyboardHandler() {
                var hovered = false;
                $this.bind(eventClass("mouseenter"), function(e) {
                    hovered = true;
                });
                $this.bind(eventClass("mouseleave"), function(e) {
                    hovered = false;
                });
                var shouldPrevent = false;
                $(ownerDocument).bind(eventClass("keydown"), function(e) {
                    if (e.isDefaultPrevented && e.isDefaultPrevented()) {
                        return;
                    }
                    if (!hovered) {
                        return;
                    }
                    var activeElement = document.activeElement ? document.activeElement : ownerDocument.activeElement;
                    if (activeElement) {
                        while (activeElement.shadowRoot) {
                            activeElement = activeElement.shadowRoot.activeElement;
                        }
                        if ($(activeElement).is(":input,[contenteditable]")) {
                            return;
                        }
                    }
                    var deltaX = 0;
                    var deltaY = 0;
                    switch (e.which) {
                      case 37:
                        deltaX = -30;
                        break;

                      case 38:
                        deltaY = 30;
                        break;

                      case 39:
                        deltaX = 30;
                        break;

                      case 40:
                        deltaY = -30;
                        break;

                      case 33:
                        deltaY = 90;
                        break;

                      case 32:
                      case 34:
                        deltaY = -90;
                        break;

                      case 35:
                        if (e.ctrlKey) {
                            deltaY = -contentHeight;
                        } else {
                            deltaY = -containerHeight;
                        }
                        break;

                      case 36:
                        if (e.ctrlKey) {
                            deltaY = $this.scrollTop();
                        } else {
                            deltaY = containerHeight;
                        }
                        break;

                      default:
                        return;
                    }
                    $this.scrollTop($this.scrollTop() - deltaY);
                    $this.scrollLeft($this.scrollLeft() + deltaX);
                    shouldPrevent = shouldPreventWheel(deltaX, deltaY);
                    if (shouldPrevent) {
                        e.preventDefault();
                    }
                });
            }
            function bindRailClickHandler() {
                function stopPropagation(e) {
                    e.stopPropagation();
                }
                $scrollbarY.bind(eventClass("click"), stopPropagation);
                $scrollbarYRail.bind(eventClass("click"), function(e) {
                    var halfOfScrollbarLength = getInt(scrollbarYHeight / 2);
                    var positionTop = e.pageY - $scrollbarYRail.offset().top - halfOfScrollbarLength;
                    var maxPositionTop = containerHeight - scrollbarYHeight;
                    var positionRatio = positionTop / maxPositionTop;
                    if (positionRatio < 0) {
                        positionRatio = 0;
                    } else if (positionRatio > 1) {
                        positionRatio = 1;
                    }
                    $this.scrollTop((contentHeight - containerHeight) * positionRatio);
                });
                $scrollbarX.bind(eventClass("click"), stopPropagation);
                $scrollbarXRail.bind(eventClass("click"), function(e) {
                    var halfOfScrollbarLength = getInt(scrollbarXWidth / 2);
                    var positionLeft = e.pageX - $scrollbarXRail.offset().left - halfOfScrollbarLength;
                    var maxPositionLeft = containerWidth - scrollbarXWidth;
                    var positionRatio = positionLeft / maxPositionLeft;
                    if (positionRatio < 0) {
                        positionRatio = 0;
                    } else if (positionRatio > 1) {
                        positionRatio = 1;
                    }
                    $this.scrollLeft((contentWidth - containerWidth) * positionRatio);
                });
            }
            function bindSelectionHandler() {
                function getRangeNode() {
                    var selection = window.getSelection ? window.getSelection() : document.getSlection ? document.getSlection() : {
                        rangeCount: 0
                    };
                    if (selection.rangeCount === 0) {
                        return null;
                    } else {
                        return selection.getRangeAt(0).commonAncestorContainer;
                    }
                }
                var scrollingLoop = null;
                var scrollDiff = {
                    top: 0,
                    left: 0
                };
                function startScrolling() {
                    if (!scrollingLoop) {
                        scrollingLoop = setInterval(function() {
                            if (!isPluginAlive()) {
                                clearInterval(scrollingLoop);
                                return;
                            }
                            $this.scrollTop($this.scrollTop() + scrollDiff.top);
                            $this.scrollLeft($this.scrollLeft() + scrollDiff.left);
                            updateGeometry();
                        }, 50);
                    }
                }
                function stopScrolling() {
                    if (scrollingLoop) {
                        clearInterval(scrollingLoop);
                        scrollingLoop = null;
                    }
                    $this.removeClass("ps-in-scrolling");
                    $this.removeClass("ps-in-scrolling");
                }
                var isSelected = false;
                $(ownerDocument).bind(eventClass("selectionchange"), function(e) {
                    if ($.contains($this[0], getRangeNode())) {
                        isSelected = true;
                    } else {
                        isSelected = false;
                        stopScrolling();
                    }
                });
                $(window).bind(eventClass("mouseup"), function(e) {
                    if (isSelected) {
                        isSelected = false;
                        stopScrolling();
                    }
                });
                $(window).bind(eventClass("mousemove"), function(e) {
                    if (isSelected) {
                        var mousePosition = {
                            x: e.pageX,
                            y: e.pageY
                        };
                        var containerOffset = $this.offset();
                        var containerGeometry = {
                            left: containerOffset.left,
                            right: containerOffset.left + $this.outerWidth(),
                            top: containerOffset.top,
                            bottom: containerOffset.top + $this.outerHeight()
                        };
                        if (mousePosition.x < containerGeometry.left + 3) {
                            scrollDiff.left = -5;
                            $this.addClass("ps-in-scrolling");
                        } else if (mousePosition.x > containerGeometry.right - 3) {
                            scrollDiff.left = 5;
                            $this.addClass("ps-in-scrolling");
                        } else {
                            scrollDiff.left = 0;
                        }
                        if (mousePosition.y < containerGeometry.top + 3) {
                            if (containerGeometry.top + 3 - mousePosition.y < 5) {
                                scrollDiff.top = -5;
                            } else {
                                scrollDiff.top = -20;
                            }
                            $this.addClass("ps-in-scrolling");
                        } else if (mousePosition.y > containerGeometry.bottom - 3) {
                            if (mousePosition.y - containerGeometry.bottom + 3 < 5) {
                                scrollDiff.top = 5;
                            } else {
                                scrollDiff.top = 20;
                            }
                            $this.addClass("ps-in-scrolling");
                        } else {
                            scrollDiff.top = 0;
                        }
                        if (scrollDiff.top === 0 && scrollDiff.left === 0) {
                            stopScrolling();
                        } else {
                            startScrolling();
                        }
                    }
                });
            }
            function bindTouchHandler(supportsTouch, supportsIePointer) {
                function applyTouchMove(differenceX, differenceY) {
                    $this.scrollTop($this.scrollTop() - differenceY);
                    $this.scrollLeft($this.scrollLeft() - differenceX);
                    updateGeometry();
                }
                var startOffset = {};
                var startTime = 0;
                var speed = {};
                var easingLoop = null;
                var inGlobalTouch = false;
                var inLocalTouch = false;
                function globalTouchStart(e) {
                    inGlobalTouch = true;
                }
                function globalTouchEnd(e) {
                    inGlobalTouch = false;
                }
                function getTouch(e) {
                    if (e.originalEvent.targetTouches) {
                        return e.originalEvent.targetTouches[0];
                    } else {
                        return e.originalEvent;
                    }
                }
                function shouldHandle(e) {
                    var event = e.originalEvent;
                    if (event.targetTouches && event.targetTouches.length === 1) {
                        return true;
                    }
                    if (event.pointerType && event.pointerType !== "mouse" && event.pointerType !== event.MSPOINTER_TYPE_MOUSE) {
                        return true;
                    }
                    return false;
                }
                function touchStart(e) {
                    if (shouldHandle(e)) {
                        inLocalTouch = true;
                        var touch = getTouch(e);
                        startOffset.pageX = touch.pageX;
                        startOffset.pageY = touch.pageY;
                        startTime = new Date().getTime();
                        if (easingLoop !== null) {
                            clearInterval(easingLoop);
                        }
                        e.stopPropagation();
                    }
                }
                function touchMove(e) {
                    if (!inGlobalTouch && inLocalTouch && shouldHandle(e)) {
                        var touch = getTouch(e);
                        var currentOffset = {
                            pageX: touch.pageX,
                            pageY: touch.pageY
                        };
                        var differenceX = currentOffset.pageX - startOffset.pageX;
                        var differenceY = currentOffset.pageY - startOffset.pageY;
                        applyTouchMove(differenceX, differenceY);
                        startOffset = currentOffset;
                        var currentTime = new Date().getTime();
                        var timeGap = currentTime - startTime;
                        if (timeGap > 0) {
                            speed.x = differenceX / timeGap;
                            speed.y = differenceY / timeGap;
                            startTime = currentTime;
                        }
                        if (shouldPreventSwipe(differenceX, differenceY)) {
                            e.stopPropagation();
                            e.preventDefault();
                        }
                    }
                }
                function touchEnd(e) {
                    if (!inGlobalTouch && inLocalTouch) {
                        inLocalTouch = false;
                        clearInterval(easingLoop);
                        easingLoop = setInterval(function() {
                            if (!isPluginAlive()) {
                                clearInterval(easingLoop);
                                return;
                            }
                            if (Math.abs(speed.x) < .01 && Math.abs(speed.y) < .01) {
                                clearInterval(easingLoop);
                                return;
                            }
                            applyTouchMove(speed.x * 30, speed.y * 30);
                            speed.x *= .8;
                            speed.y *= .8;
                        }, 10);
                    }
                }
                if (supportsTouch) {
                    $(window).bind(eventClass("touchstart"), globalTouchStart);
                    $(window).bind(eventClass("touchend"), globalTouchEnd);
                    $this.bind(eventClass("touchstart"), touchStart);
                    $this.bind(eventClass("touchmove"), touchMove);
                    $this.bind(eventClass("touchend"), touchEnd);
                }
                if (supportsIePointer) {
                    if (window.PointerEvent) {
                        $(window).bind(eventClass("pointerdown"), globalTouchStart);
                        $(window).bind(eventClass("pointerup"), globalTouchEnd);
                        $this.bind(eventClass("pointerdown"), touchStart);
                        $this.bind(eventClass("pointermove"), touchMove);
                        $this.bind(eventClass("pointerup"), touchEnd);
                    } else if (window.MSPointerEvent) {
                        $(window).bind(eventClass("MSPointerDown"), globalTouchStart);
                        $(window).bind(eventClass("MSPointerUp"), globalTouchEnd);
                        $this.bind(eventClass("MSPointerDown"), touchStart);
                        $this.bind(eventClass("MSPointerMove"), touchMove);
                        $this.bind(eventClass("MSPointerUp"), touchEnd);
                    }
                }
            }
            function bindScrollHandler() {
                $this.bind(eventClass("scroll"), function(e) {
                    updateGeometry();
                });
            }
            function destroy() {
                $this.unbind(eventClass());
                $(window).unbind(eventClass());
                $(ownerDocument).unbind(eventClass());
                $this.data("perfect-scrollbar", null);
                $this.data("perfect-scrollbar-update", null);
                $this.data("perfect-scrollbar-destroy", null);
                $scrollbarX.remove();
                $scrollbarY.remove();
                $scrollbarXRail.remove();
                $scrollbarYRail.remove();
                $this = $scrollbarXRail = $scrollbarYRail = $scrollbarX = $scrollbarY = scrollbarXActive = scrollbarYActive = containerWidth = containerHeight = contentWidth = contentHeight = scrollbarXWidth = scrollbarXLeft = scrollbarXBottom = isScrollbarXUsingBottom = scrollbarXTop = scrollbarYHeight = scrollbarYTop = scrollbarYRight = isScrollbarYUsingRight = scrollbarYLeft = isRtl = eventClass = null;
            }
            var supportsTouch = "ontouchstart" in window || window.DocumentTouch && document instanceof window.DocumentTouch;
            var supportsIePointer = window.navigator.msMaxTouchPoints !== null;
            function initialize() {
                updateGeometry();
                bindScrollHandler();
                bindMouseScrollXHandler();
                bindMouseScrollYHandler();
                bindRailClickHandler();
                bindSelectionHandler();
                bindMouseWheelHandler();
                if (supportsTouch || supportsIePointer) {
                    bindTouchHandler(supportsTouch, supportsIePointer);
                }
                if (settings.useKeyboard) {
                    bindKeyboardHandler();
                }
                $this.data("perfect-scrollbar", $this);
                $this.data("perfect-scrollbar-update", updateGeometry);
                $this.data("perfect-scrollbar-destroy", destroy);
            }
            initialize();
            return $this;
        });
    };
});

(function(L, a) {
    "object" === typeof module && module.exports ? module.exports = L.document ? a(L) : a : L.Highcharts = a(L);
})("undefined" !== typeof window ? window : this, function(L) {
    L = function() {
        var a = window, B = a.document, A = a.navigator && a.navigator.userAgent || "", H = B && B.createElementNS && !!B.createElementNS("http://www.w3.org/2000/svg", "svg").createSVGRect, G = /(edge|msie|trident)/i.test(A) && !window.opera, r = !H, g = /Firefox/.test(A), f = g && 4 > parseInt(A.split("Firefox/")[1], 10);
        return a.Highcharts ? a.Highcharts.error(16, !0) : {
            product: "Highcharts",
            version: "5.0.7",
            deg2rad: 2 * Math.PI / 360,
            doc: B,
            hasBidiBug: f,
            hasTouch: B && void 0 !== B.documentElement.ontouchstart,
            isMS: G,
            isWebKit: /AppleWebKit/.test(A),
            isFirefox: g,
            isTouchDevice: /(Mobile|Android|Windows Phone)/.test(A),
            SVG_NS: "http://www.w3.org/2000/svg",
            chartCount: 0,
            seriesTypes: {},
            symbolSizes: {},
            svg: H,
            vml: r,
            win: a,
            charts: [],
            marginNames: [ "plotTop", "marginRight", "marginBottom", "plotLeft" ],
            noop: function() {}
        };
    }();
    (function(a) {
        var B = [], A = a.charts, H = a.doc, G = a.win;
        a.error = function(r, g) {
            r = a.isNumber(r) ? "Highcharts error #" + r + ": www.highcharts.com/errors/" + r : r;
            if (g) throw Error(r);
            G.console && console.log(r);
        };
        a.Fx = function(a, g, f) {
            this.options = g;
            this.elem = a;
            this.prop = f;
        };
        a.Fx.prototype = {
            dSetter: function() {
                var a = this.paths[0], g = this.paths[1], f = [], u = this.now, l = a.length, q;
                if (1 === u) f = this.toD; else if (l === g.length && 1 > u) for (;l--; ) q = parseFloat(a[l]), 
                f[l] = isNaN(q) ? a[l] : u * parseFloat(g[l] - q) + q; else f = g;
                this.elem.attr("d", f, null, !0);
            },
            update: function() {
                var a = this.elem, g = this.prop, f = this.now, u = this.options.step;
                if (this[g + "Setter"]) this[g + "Setter"](); else a.attr ? a.element && a.attr(g, f, null, !0) : a.style[g] = f + this.unit;
                u && u.call(a, f, this);
            },
            run: function(a, g, f) {
                var r = this, l = function(a) {
                    return l.stopped ? !1 : r.step(a);
                }, q;
                this.startTime = +new Date();
                this.start = a;
                this.end = g;
                this.unit = f;
                this.now = this.start;
                this.pos = 0;
                l.elem = this.elem;
                l.prop = this.prop;
                l() && 1 === B.push(l) && (l.timerId = setInterval(function() {
                    for (q = 0; q < B.length; q++) B[q]() || B.splice(q--, 1);
                    B.length || clearInterval(l.timerId);
                }, 13));
            },
            step: function(a) {
                var r = +new Date(), f, u = this.options;
                f = this.elem;
                var l = u.complete, q = u.duration, d = u.curAnim, b;
                if (f.attr && !f.element) f = !1; else if (a || r >= q + this.startTime) {
                    this.now = this.end;
                    this.pos = 1;
                    this.update();
                    a = d[this.prop] = !0;
                    for (b in d) !0 !== d[b] && (a = !1);
                    a && l && l.call(f);
                    f = !1;
                } else this.pos = u.easing((r - this.startTime) / q), this.now = this.start + (this.end - this.start) * this.pos, 
                this.update(), f = !0;
                return f;
            },
            initPath: function(r, g, f) {
                function u(a) {
                    var e, b;
                    for (n = a.length; n--; ) e = "M" === a[n] || "L" === a[n], b = /[a-zA-Z]/.test(a[n + 3]), 
                    e && b && a.splice(n + 1, 0, a[n + 1], a[n + 2], a[n + 1], a[n + 2]);
                }
                function l(a, e) {
                    for (;a.length < m; ) {
                        a[0] = e[m - a.length];
                        var b = a.slice(0, t);
                        [].splice.apply(a, [ 0, 0 ].concat(b));
                        E && (b = a.slice(a.length - t), [].splice.apply(a, [ a.length, 0 ].concat(b)), 
                        n--);
                    }
                    a[0] = "M";
                }
                function q(a, e) {
                    for (var b = (m - a.length) / t; 0 < b && b--; ) c = a.slice().splice(a.length / z - t, t * z), 
                    c[0] = e[m - t - b * t], C && (c[t - 6] = c[t - 2], c[t - 5] = c[t - 1]), [].splice.apply(a, [ a.length / z, 0 ].concat(c)), 
                    E && b--;
                }
                g = g || "";
                var d, b = r.startX, p = r.endX, C = -1 < g.indexOf("C"), t = C ? 7 : 3, m, c, n;
                g = g.split(" ");
                f = f.slice();
                var E = r.isArea, z = E ? 2 : 1, e;
                C && (u(g), u(f));
                if (b && p) {
                    for (n = 0; n < b.length; n++) if (b[n] === p[0]) {
                        d = n;
                        break;
                    } else if (b[0] === p[p.length - b.length + n]) {
                        d = n;
                        e = !0;
                        break;
                    }
                    void 0 === d && (g = []);
                }
                g.length && a.isNumber(d) && (m = f.length + d * z * t, e ? (l(g, f), q(f, g)) : (l(f, g), 
                q(g, f)));
                return [ g, f ];
            }
        };
        a.extend = function(a, g) {
            var f;
            a || (a = {});
            for (f in g) a[f] = g[f];
            return a;
        };
        a.merge = function() {
            var r, g = arguments, f, u = {}, l = function(q, d) {
                var b, p;
                "object" !== typeof q && (q = {});
                for (p in d) d.hasOwnProperty(p) && (b = d[p], a.isObject(b, !0) && "renderTo" !== p && "number" !== typeof b.nodeType ? q[p] = l(q[p] || {}, b) : q[p] = d[p]);
                return q;
            };
            !0 === g[0] && (u = g[1], g = Array.prototype.slice.call(g, 2));
            f = g.length;
            for (r = 0; r < f; r++) u = l(u, g[r]);
            return u;
        };
        a.pInt = function(a, g) {
            return parseInt(a, g || 10);
        };
        a.isString = function(a) {
            return "string" === typeof a;
        };
        a.isArray = function(a) {
            a = Object.prototype.toString.call(a);
            return "[object Array]" === a || "[object Array Iterator]" === a;
        };
        a.isObject = function(r, g) {
            return r && "object" === typeof r && (!g || !a.isArray(r));
        };
        a.isNumber = function(a) {
            return "number" === typeof a && !isNaN(a);
        };
        a.erase = function(a, g) {
            for (var f = a.length; f--; ) if (a[f] === g) {
                a.splice(f, 1);
                break;
            }
        };
        a.defined = function(a) {
            return void 0 !== a && null !== a;
        };
        a.attr = function(r, g, f) {
            var u, l;
            if (a.isString(g)) a.defined(f) ? r.setAttribute(g, f) : r && r.getAttribute && (l = r.getAttribute(g)); else if (a.defined(g) && a.isObject(g)) for (u in g) r.setAttribute(u, g[u]);
            return l;
        };
        a.splat = function(r) {
            return a.isArray(r) ? r : [ r ];
        };
        a.syncTimeout = function(a, g, f) {
            if (g) return setTimeout(a, g, f);
            a.call(0, f);
        };
        a.pick = function() {
            var a = arguments, g, f, u = a.length;
            for (g = 0; g < u; g++) if (f = a[g], void 0 !== f && null !== f) return f;
        };
        a.css = function(r, g) {
            a.isMS && !a.svg && g && void 0 !== g.opacity && (g.filter = "alpha(opacity=" + 100 * g.opacity + ")");
            a.extend(r.style, g);
        };
        a.createElement = function(r, g, f, u, l) {
            r = H.createElement(r);
            var q = a.css;
            g && a.extend(r, g);
            l && q(r, {
                padding: 0,
                border: "none",
                margin: 0
            });
            f && q(r, f);
            u && u.appendChild(r);
            return r;
        };
        a.extendClass = function(r, g) {
            var f = function() {};
            f.prototype = new r();
            a.extend(f.prototype, g);
            return f;
        };
        a.pad = function(a, g, f) {
            return Array((g || 2) + 1 - String(a).length).join(f || 0) + a;
        };
        a.relativeLength = function(a, g) {
            return /%$/.test(a) ? g * parseFloat(a) / 100 : parseFloat(a);
        };
        a.wrap = function(a, g, f) {
            var r = a[g];
            a[g] = function() {
                var a = Array.prototype.slice.call(arguments), q = arguments, d = this;
                d.proceed = function() {
                    r.apply(d, arguments.length ? arguments : q);
                };
                a.unshift(r);
                a = f.apply(this, a);
                d.proceed = null;
                return a;
            };
        };
        a.getTZOffset = function(r) {
            var g = a.Date;
            return 6e4 * (g.hcGetTimezoneOffset && g.hcGetTimezoneOffset(r) || g.hcTimezoneOffset || 0);
        };
        a.dateFormat = function(r, g, f) {
            if (!a.defined(g) || isNaN(g)) return a.defaultOptions.lang.invalidDate || "";
            r = a.pick(r, "%Y-%m-%d %H:%M:%S");
            var u = a.Date, l = new u(g - a.getTZOffset(g)), q, d = l[u.hcGetHours](), b = l[u.hcGetDay](), p = l[u.hcGetDate](), C = l[u.hcGetMonth](), t = l[u.hcGetFullYear](), m = a.defaultOptions.lang, c = m.weekdays, n = m.shortWeekdays, E = a.pad, u = a.extend({
                a: n ? n[b] : c[b].substr(0, 3),
                A: c[b],
                d: E(p),
                e: E(p, 2, " "),
                w: b,
                b: m.shortMonths[C],
                B: m.months[C],
                m: E(C + 1),
                y: t.toString().substr(2, 2),
                Y: t,
                H: E(d),
                k: d,
                I: E(d % 12 || 12),
                l: d % 12 || 12,
                M: E(l[u.hcGetMinutes]()),
                p: 12 > d ? "AM" : "PM",
                P: 12 > d ? "am" : "pm",
                S: E(l.getSeconds()),
                L: E(Math.round(g % 1e3), 3)
            }, a.dateFormats);
            for (q in u) for (;-1 !== r.indexOf("%" + q); ) r = r.replace("%" + q, "function" === typeof u[q] ? u[q](g) : u[q]);
            return f ? r.substr(0, 1).toUpperCase() + r.substr(1) : r;
        };
        a.formatSingle = function(r, g) {
            var f = /\.([0-9])/, u = a.defaultOptions.lang;
            /f$/.test(r) ? (f = (f = r.match(f)) ? f[1] : -1, null !== g && (g = a.numberFormat(g, f, u.decimalPoint, -1 < r.indexOf(",") ? u.thousandsSep : ""))) : g = a.dateFormat(r, g);
            return g;
        };
        a.format = function(r, g) {
            for (var f = "{", u = !1, l, q, d, b, p = [], C; r; ) {
                f = r.indexOf(f);
                if (-1 === f) break;
                l = r.slice(0, f);
                if (u) {
                    l = l.split(":");
                    q = l.shift().split(".");
                    b = q.length;
                    C = g;
                    for (d = 0; d < b; d++) C = C[q[d]];
                    l.length && (C = a.formatSingle(l.join(":"), C));
                    p.push(C);
                } else p.push(l);
                r = r.slice(f + 1);
                f = (u = !u) ? "}" : "{";
            }
            p.push(r);
            return p.join("");
        };
        a.getMagnitude = function(a) {
            return Math.pow(10, Math.floor(Math.log(a) / Math.LN10));
        };
        a.normalizeTickInterval = function(r, g, f, u, l) {
            var q, d = r;
            f = a.pick(f, 1);
            q = r / f;
            g || (g = l ? [ 1, 1.2, 1.5, 2, 2.5, 3, 4, 5, 6, 8, 10 ] : [ 1, 2, 2.5, 5, 10 ], 
            !1 === u && (1 === f ? g = a.grep(g, function(a) {
                return 0 === a % 1;
            }) : .1 >= f && (g = [ 1 / f ])));
            for (u = 0; u < g.length && !(d = g[u], l && d * f >= r || !l && q <= (g[u] + (g[u + 1] || g[u])) / 2); u++) ;
            return d = a.correctFloat(d * f, -Math.round(Math.log(.001) / Math.LN10));
        };
        a.stableSort = function(a, g) {
            var f = a.length, r, l;
            for (l = 0; l < f; l++) a[l].safeI = l;
            a.sort(function(a, d) {
                r = g(a, d);
                return 0 === r ? a.safeI - d.safeI : r;
            });
            for (l = 0; l < f; l++) delete a[l].safeI;
        };
        a.arrayMin = function(a) {
            for (var g = a.length, f = a[0]; g--; ) a[g] < f && (f = a[g]);
            return f;
        };
        a.arrayMax = function(a) {
            for (var g = a.length, f = a[0]; g--; ) a[g] > f && (f = a[g]);
            return f;
        };
        a.destroyObjectProperties = function(a, g) {
            for (var f in a) a[f] && a[f] !== g && a[f].destroy && a[f].destroy(), delete a[f];
        };
        a.discardElement = function(r) {
            var g = a.garbageBin;
            g || (g = a.createElement("div"));
            r && g.appendChild(r);
            g.innerHTML = "";
        };
        a.correctFloat = function(a, g) {
            return parseFloat(a.toPrecision(g || 14));
        };
        a.setAnimation = function(r, g) {
            g.renderer.globalAnimation = a.pick(r, g.options.chart.animation, !0);
        };
        a.animObject = function(r) {
            return a.isObject(r) ? a.merge(r) : {
                duration: r ? 500 : 0
            };
        };
        a.timeUnits = {
            millisecond: 1,
            second: 1e3,
            minute: 6e4,
            hour: 36e5,
            day: 864e5,
            week: 6048e5,
            month: 24192e5,
            year: 314496e5
        };
        a.numberFormat = function(r, g, f, u) {
            r = +r || 0;
            g = +g;
            var l = a.defaultOptions.lang, q = (r.toString().split(".")[1] || "").length, d, b;
            -1 === g ? g = Math.min(q, 20) : a.isNumber(g) || (g = 2);
            b = (Math.abs(r) + Math.pow(10, -Math.max(g, q) - 1)).toFixed(g);
            q = String(a.pInt(b));
            d = 3 < q.length ? q.length % 3 : 0;
            f = a.pick(f, l.decimalPoint);
            u = a.pick(u, l.thousandsSep);
            r = (0 > r ? "-" : "") + (d ? q.substr(0, d) + u : "");
            r += q.substr(d).replace(/(\d{3})(?=\d)/g, "$1" + u);
            g && (r += f + b.slice(-g));
            return r;
        };
        Math.easeInOutSine = function(a) {
            return -.5 * (Math.cos(Math.PI * a) - 1);
        };
        a.getStyle = function(r, g) {
            return "width" === g ? Math.min(r.offsetWidth, r.scrollWidth) - a.getStyle(r, "padding-left") - a.getStyle(r, "padding-right") : "height" === g ? Math.min(r.offsetHeight, r.scrollHeight) - a.getStyle(r, "padding-top") - a.getStyle(r, "padding-bottom") : (r = G.getComputedStyle(r, void 0)) && a.pInt(r.getPropertyValue(g));
        };
        a.inArray = function(a, g) {
            return g.indexOf ? g.indexOf(a) : [].indexOf.call(g, a);
        };
        a.grep = function(a, g) {
            return [].filter.call(a, g);
        };
        a.find = function(a, g) {
            return [].find.call(a, g);
        };
        a.map = function(a, g) {
            for (var f = [], u = 0, l = a.length; u < l; u++) f[u] = g.call(a[u], a[u], u, a);
            return f;
        };
        a.offset = function(a) {
            var g = H.documentElement;
            a = a.getBoundingClientRect();
            return {
                top: a.top + (G.pageYOffset || g.scrollTop) - (g.clientTop || 0),
                left: a.left + (G.pageXOffset || g.scrollLeft) - (g.clientLeft || 0)
            };
        };
        a.stop = function(a, g) {
            for (var f = B.length; f--; ) B[f].elem !== a || g && g !== B[f].prop || (B[f].stopped = !0);
        };
        a.each = function(a, g, f) {
            return Array.prototype.forEach.call(a, g, f);
        };
        a.addEvent = function(r, g, f) {
            function u(a) {
                a.target = a.srcElement || G;
                f.call(r, a);
            }
            var l = r.hcEvents = r.hcEvents || {};
            r.addEventListener ? r.addEventListener(g, f, !1) : r.attachEvent && (r.hcEventsIE || (r.hcEventsIE = {}), 
            r.hcEventsIE[f.toString()] = u, r.attachEvent("on" + g, u));
            l[g] || (l[g] = []);
            l[g].push(f);
            return function() {
                a.removeEvent(r, g, f);
            };
        };
        a.removeEvent = function(r, g, f) {
            function u(a, b) {
                r.removeEventListener ? r.removeEventListener(a, b, !1) : r.attachEvent && (b = r.hcEventsIE[b.toString()], 
                r.detachEvent("on" + a, b));
            }
            function l() {
                var a, b;
                if (r.nodeName) for (b in g ? (a = {}, a[g] = !0) : a = d, a) if (d[b]) for (a = d[b].length; a--; ) u(b, d[b][a]);
            }
            var q, d = r.hcEvents, b;
            d && (g ? (q = d[g] || [], f ? (b = a.inArray(f, q), -1 < b && (q.splice(b, 1), 
            d[g] = q), u(g, f)) : (l(), d[g] = [])) : (l(), r.hcEvents = {}));
        };
        a.fireEvent = function(r, g, f, u) {
            var l;
            l = r.hcEvents;
            var q, d;
            f = f || {};
            if (H.createEvent && (r.dispatchEvent || r.fireEvent)) l = H.createEvent("Events"), 
            l.initEvent(g, !0, !0), a.extend(l, f), r.dispatchEvent ? r.dispatchEvent(l) : r.fireEvent(g, l); else if (l) for (l = l[g] || [], 
            q = l.length, f.target || a.extend(f, {
                preventDefault: function() {
                    f.defaultPrevented = !0;
                },
                target: r,
                type: g
            }), g = 0; g < q; g++) (d = l[g]) && !1 === d.call(r, f) && f.preventDefault();
            u && !f.defaultPrevented && u(f);
        };
        a.animate = function(r, g, f) {
            var u, l = "", q, d, b;
            a.isObject(f) || (u = arguments, f = {
                duration: u[2],
                easing: u[3],
                complete: u[4]
            });
            a.isNumber(f.duration) || (f.duration = 400);
            f.easing = "function" === typeof f.easing ? f.easing : Math[f.easing] || Math.easeInOutSine;
            f.curAnim = a.merge(g);
            for (b in g) a.stop(r, b), d = new a.Fx(r, f, b), q = null, "d" === b ? (d.paths = d.initPath(r, r.d, g.d), 
            d.toD = g.d, u = 0, q = 1) : r.attr ? u = r.attr(b) : (u = parseFloat(a.getStyle(r, b)) || 0, 
            "opacity" !== b && (l = "px")), q || (q = g[b]), q.match && q.match("px") && (q = q.replace(/px/g, "")), 
            d.run(u, q, l);
        };
        a.seriesType = function(r, g, f, u, l) {
            var q = a.getOptions(), d = a.seriesTypes;
            q.plotOptions[r] = a.merge(q.plotOptions[g], f);
            d[r] = a.extendClass(d[g] || function() {}, u);
            d[r].prototype.type = r;
            l && (d[r].prototype.pointClass = a.extendClass(a.Point, l));
            return d[r];
        };
        a.uniqueKey = function() {
            var a = Math.random().toString(36).substring(2, 9), g = 0;
            return function() {
                return "highcharts-" + a + "-" + g++;
            };
        }();
        G.jQuery && (G.jQuery.fn.highcharts = function() {
            var r = [].slice.call(arguments);
            if (this[0]) return r[0] ? (new (a[a.isString(r[0]) ? r.shift() : "Chart"])(this[0], r[0], r[1]), 
            this) : A[a.attr(this[0], "data-highcharts-chart")];
        });
        H && !H.defaultView && (a.getStyle = function(r, g) {
            var f = {
                width: "clientWidth",
                height: "clientHeight"
            }[g];
            if (r.style[g]) return a.pInt(r.style[g]);
            "opacity" === g && (g = "filter");
            if (f) return r.style.zoom = 1, Math.max(r[f] - 2 * a.getStyle(r, "padding"), 0);
            r = r.currentStyle[g.replace(/\-(\w)/g, function(a, l) {
                return l.toUpperCase();
            })];
            "filter" === g && (r = r.replace(/alpha\(opacity=([0-9]+)\)/, function(a, l) {
                return l / 100;
            }));
            return "" === r ? 1 : a.pInt(r);
        });
        Array.prototype.forEach || (a.each = function(a, g, f) {
            for (var u = 0, l = a.length; u < l; u++) if (!1 === g.call(f, a[u], u, a)) return u;
        });
        Array.prototype.indexOf || (a.inArray = function(a, g) {
            var f, u = 0;
            if (g) for (f = g.length; u < f; u++) if (g[u] === a) return u;
            return -1;
        });
        Array.prototype.filter || (a.grep = function(a, g) {
            for (var f = [], u = 0, l = a.length; u < l; u++) g(a[u], u) && f.push(a[u]);
            return f;
        });
        Array.prototype.find || (a.find = function(a, g) {
            var f, u = a.length;
            for (f = 0; f < u; f++) if (g(a[f], f)) return a[f];
        });
    })(L);
    (function(a) {
        var B = a.each, A = a.isNumber, H = a.map, G = a.merge, r = a.pInt;
        a.Color = function(g) {
            if (!(this instanceof a.Color)) return new a.Color(g);
            this.init(g);
        };
        a.Color.prototype = {
            parsers: [ {
                regex: /rgba\(\s*([0-9]{1,3})\s*,\s*([0-9]{1,3})\s*,\s*([0-9]{1,3})\s*,\s*([0-9]?(?:\.[0-9]+)?)\s*\)/,
                parse: function(a) {
                    return [ r(a[1]), r(a[2]), r(a[3]), parseFloat(a[4], 10) ];
                }
            }, {
                regex: /#([a-fA-F0-9]{2})([a-fA-F0-9]{2})([a-fA-F0-9]{2})/,
                parse: function(a) {
                    return [ r(a[1], 16), r(a[2], 16), r(a[3], 16), 1 ];
                }
            }, {
                regex: /rgb\(\s*([0-9]{1,3})\s*,\s*([0-9]{1,3})\s*,\s*([0-9]{1,3})\s*\)/,
                parse: function(a) {
                    return [ r(a[1]), r(a[2]), r(a[3]), 1 ];
                }
            } ],
            names: {
                white: "#ffffff",
                black: "#000000"
            },
            init: function(g) {
                var f, u, l, q;
                if ((this.input = g = this.names[g] || g) && g.stops) this.stops = H(g.stops, function(d) {
                    return new a.Color(d[1]);
                }); else for (l = this.parsers.length; l-- && !u; ) q = this.parsers[l], (f = q.regex.exec(g)) && (u = q.parse(f));
                this.rgba = u || [];
            },
            get: function(a) {
                var f = this.input, g = this.rgba, l;
                this.stops ? (l = G(f), l.stops = [].concat(l.stops), B(this.stops, function(f, d) {
                    l.stops[d] = [ l.stops[d][0], f.get(a) ];
                })) : l = g && A(g[0]) ? "rgb" === a || !a && 1 === g[3] ? "rgb(" + g[0] + "," + g[1] + "," + g[2] + ")" : "a" === a ? g[3] : "rgba(" + g.join(",") + ")" : f;
                return l;
            },
            brighten: function(a) {
                var f, g = this.rgba;
                if (this.stops) B(this.stops, function(l) {
                    l.brighten(a);
                }); else if (A(a) && 0 !== a) for (f = 0; 3 > f; f++) g[f] += r(255 * a), 0 > g[f] && (g[f] = 0), 
                255 < g[f] && (g[f] = 255);
                return this;
            },
            setOpacity: function(a) {
                this.rgba[3] = a;
                return this;
            }
        };
        a.color = function(g) {
            return new a.Color(g);
        };
    })(L);
    (function(a) {
        var B, A, H = a.addEvent, G = a.animate, r = a.attr, g = a.charts, f = a.color, u = a.css, l = a.createElement, q = a.defined, d = a.deg2rad, b = a.destroyObjectProperties, p = a.doc, C = a.each, t = a.extend, m = a.erase, c = a.grep, n = a.hasTouch, E = a.inArray, z = a.isArray, e = a.isFirefox, x = a.isMS, F = a.isObject, w = a.isString, h = a.isWebKit, y = a.merge, J = a.noop, K = a.pick, I = a.pInt, k = a.removeEvent, D = a.stop, P = a.svg, N = a.SVG_NS, S = a.symbolSizes, O = a.win;
        B = a.SVGElement = function() {
            return this;
        };
        B.prototype = {
            opacity: 1,
            SVG_NS: N,
            textProps: "direction fontSize fontWeight fontFamily fontStyle color lineHeight width textDecoration textOverflow textOutline".split(" "),
            init: function(a, k) {
                this.element = "span" === k ? l(k) : p.createElementNS(this.SVG_NS, k);
                this.renderer = a;
            },
            animate: function(v, k, e) {
                k = a.animObject(K(k, this.renderer.globalAnimation, !0));
                0 !== k.duration ? (e && (k.complete = e), G(this, v, k)) : this.attr(v, null, e);
                return this;
            },
            colorGradient: function(v, k, e) {
                var b = this.renderer, h, D, c, x, M, m, n, d, F, t, p, w = [], l;
                v.linearGradient ? D = "linearGradient" : v.radialGradient && (D = "radialGradient");
                if (D) {
                    c = v[D];
                    M = b.gradients;
                    n = v.stops;
                    t = e.radialReference;
                    z(c) && (v[D] = c = {
                        x1: c[0],
                        y1: c[1],
                        x2: c[2],
                        y2: c[3],
                        gradientUnits: "userSpaceOnUse"
                    });
                    "radialGradient" === D && t && !q(c.gradientUnits) && (x = c, c = y(c, b.getRadialAttr(t, x), {
                        gradientUnits: "userSpaceOnUse"
                    }));
                    for (p in c) "id" !== p && w.push(p, c[p]);
                    for (p in n) w.push(n[p]);
                    w = w.join(",");
                    M[w] ? t = M[w].attr("id") : (c.id = t = a.uniqueKey(), M[w] = m = b.createElement(D).attr(c).add(b.defs), 
                    m.radAttr = x, m.stops = [], C(n, function(v) {
                        0 === v[1].indexOf("rgba") ? (h = a.color(v[1]), d = h.get("rgb"), F = h.get("a")) : (d = v[1], 
                        F = 1);
                        v = b.createElement("stop").attr({
                            offset: v[0],
                            "stop-color": d,
                            "stop-opacity": F
                        }).add(m);
                        m.stops.push(v);
                    }));
                    l = "url(" + b.url + "#" + t + ")";
                    e.setAttribute(k, l);
                    e.gradient = w;
                    v.toString = function() {
                        return l;
                    };
                }
            },
            applyTextOutline: function(a) {
                var v = this.element, k, e, b, c;
                -1 !== a.indexOf("contrast") && (a = a.replace(/contrast/g, this.renderer.getContrast(v.style.fill)));
                this.fakeTS = !0;
                this.ySetter = this.xSetter;
                k = [].slice.call(v.getElementsByTagName("tspan"));
                a = a.split(" ");
                e = a[a.length - 1];
                (b = a[0]) && "none" !== b && (b = b.replace(/(^[\d\.]+)(.*?)$/g, function(a, v, k) {
                    return 2 * v + k;
                }), C(k, function(a) {
                    "highcharts-text-outline" === a.getAttribute("class") && m(k, v.removeChild(a));
                }), c = v.firstChild, C(k, function(a, k) {
                    0 === k && (a.setAttribute("x", v.getAttribute("x")), k = v.getAttribute("y"), a.setAttribute("y", k || 0), 
                    null === k && v.setAttribute("y", 0));
                    a = a.cloneNode(1);
                    r(a, {
                        "class": "highcharts-text-outline",
                        fill: e,
                        stroke: e,
                        "stroke-width": b,
                        "stroke-linejoin": "round"
                    });
                    v.insertBefore(a, c);
                }));
            },
            attr: function(a, k, e, b) {
                var v, c = this.element, h, x = this, M;
                "string" === typeof a && void 0 !== k && (v = a, a = {}, a[v] = k);
                if ("string" === typeof a) x = (this[a + "Getter"] || this._defaultGetter).call(this, a, c); else {
                    for (v in a) k = a[v], M = !1, b || D(this, v), this.symbolName && /^(x|y|width|height|r|start|end|innerR|anchorX|anchorY)/.test(v) && (h || (this.symbolAttr(a), 
                    h = !0), M = !0), !this.rotation || "x" !== v && "y" !== v || (this.doTransform = !0), 
                    M || (M = this[v + "Setter"] || this._defaultSetter, M.call(this, k, v, c), this.shadows && /^(width|height|visibility|x|y|d|transform|cx|cy|r)$/.test(v) && this.updateShadows(v, k, M));
                    this.doTransform && (this.updateTransform(), this.doTransform = !1);
                }
                e && e();
                return x;
            },
            updateShadows: function(a, k, e) {
                for (var v = this.shadows, b = v.length; b--; ) e.call(v[b], "height" === a ? Math.max(k - (v[b].cutHeight || 0), 0) : "d" === a ? this.d : k, a, v[b]);
            },
            addClass: function(a, k) {
                var v = this.attr("class") || "";
                -1 === v.indexOf(a) && (k || (a = (v + (v ? " " : "") + a).replace("  ", " ")), 
                this.attr("class", a));
                return this;
            },
            hasClass: function(a) {
                return -1 !== r(this.element, "class").indexOf(a);
            },
            removeClass: function(a) {
                r(this.element, "class", (r(this.element, "class") || "").replace(a, ""));
                return this;
            },
            symbolAttr: function(a) {
                var v = this;
                C("x y r start end width height innerR anchorX anchorY".split(" "), function(k) {
                    v[k] = K(a[k], v[k]);
                });
                v.attr({
                    d: v.renderer.symbols[v.symbolName](v.x, v.y, v.width, v.height, v)
                });
            },
            clip: function(a) {
                return this.attr("clip-path", a ? "url(" + this.renderer.url + "#" + a.id + ")" : "none");
            },
            crisp: function(a, k) {
                var v, e = {}, b;
                k = k || a.strokeWidth || 0;
                b = Math.round(k) % 2 / 2;
                a.x = Math.floor(a.x || this.x || 0) + b;
                a.y = Math.floor(a.y || this.y || 0) + b;
                a.width = Math.floor((a.width || this.width || 0) - 2 * b);
                a.height = Math.floor((a.height || this.height || 0) - 2 * b);
                q(a.strokeWidth) && (a.strokeWidth = k);
                for (v in a) this[v] !== a[v] && (this[v] = e[v] = a[v]);
                return e;
            },
            css: function(a) {
                var v = this.styles, k = {}, e = this.element, b, c, h = "";
                b = !v;
                var D = [ "textOverflow", "width" ];
                a && a.color && (a.fill = a.color);
                if (v) for (c in a) a[c] !== v[c] && (k[c] = a[c], b = !0);
                if (b) {
                    b = this.textWidth = a && a.width && "text" === e.nodeName.toLowerCase() && I(a.width) || this.textWidth;
                    v && (a = t(v, k));
                    this.styles = a;
                    b && !P && this.renderer.forExport && delete a.width;
                    if (x && !P) u(this.element, a); else {
                        v = function(a, v) {
                            return "-" + v.toLowerCase();
                        };
                        for (c in a) -1 === E(c, D) && (h += c.replace(/([A-Z])/g, v) + ":" + a[c] + ";");
                        h && r(e, "style", h);
                    }
                    this.added && (b && this.renderer.buildText(this), a && a.textOutline && this.applyTextOutline(a.textOutline));
                }
                return this;
            },
            strokeWidth: function() {
                return this["stroke-width"] || 0;
            },
            on: function(a, k) {
                var v = this, e = v.element;
                n && "click" === a ? (e.ontouchstart = function(a) {
                    v.touchEventFired = Date.now();
                    a.preventDefault();
                    k.call(e, a);
                }, e.onclick = function(a) {
                    (-1 === O.navigator.userAgent.indexOf("Android") || 1100 < Date.now() - (v.touchEventFired || 0)) && k.call(e, a);
                }) : e["on" + a] = k;
                return this;
            },
            setRadialReference: function(a) {
                var v = this.renderer.gradients[this.element.gradient];
                this.element.radialReference = a;
                v && v.radAttr && v.animate(this.renderer.getRadialAttr(a, v.radAttr));
                return this;
            },
            translate: function(a, k) {
                return this.attr({
                    translateX: a,
                    translateY: k
                });
            },
            invert: function(a) {
                this.inverted = a;
                this.updateTransform();
                return this;
            },
            updateTransform: function() {
                var a = this.translateX || 0, k = this.translateY || 0, e = this.scaleX, b = this.scaleY, c = this.inverted, h = this.rotation, D = this.element;
                c && (a += this.width, k += this.height);
                a = [ "translate(" + a + "," + k + ")" ];
                c ? a.push("rotate(90) scale(-1,1)") : h && a.push("rotate(" + h + " " + (D.getAttribute("x") || 0) + " " + (D.getAttribute("y") || 0) + ")");
                (q(e) || q(b)) && a.push("scale(" + K(e, 1) + " " + K(b, 1) + ")");
                a.length && D.setAttribute("transform", a.join(" "));
            },
            toFront: function() {
                var a = this.element;
                a.parentNode.appendChild(a);
                return this;
            },
            align: function(a, k, e) {
                var v, b, c, h, D = {};
                b = this.renderer;
                c = b.alignedObjects;
                var x, y;
                if (a) {
                    if (this.alignOptions = a, this.alignByTranslate = k, !e || w(e)) this.alignTo = v = e || "renderer", 
                    m(c, this), c.push(this), e = null;
                } else a = this.alignOptions, k = this.alignByTranslate, v = this.alignTo;
                e = K(e, b[v], b);
                v = a.align;
                b = a.verticalAlign;
                c = (e.x || 0) + (a.x || 0);
                h = (e.y || 0) + (a.y || 0);
                "right" === v ? x = 1 : "center" === v && (x = 2);
                x && (c += (e.width - (a.width || 0)) / x);
                D[k ? "translateX" : "x"] = Math.round(c);
                "bottom" === b ? y = 1 : "middle" === b && (y = 2);
                y && (h += (e.height - (a.height || 0)) / y);
                D[k ? "translateY" : "y"] = Math.round(h);
                this[this.placed ? "animate" : "attr"](D);
                this.placed = !0;
                this.alignAttr = D;
                return this;
            },
            getBBox: function(a, k) {
                var v, e = this.renderer, b, c = this.element, h = this.styles, D, x = this.textStr, m, y = e.cache, n = e.cacheKeys, F;
                k = K(k, this.rotation);
                b = k * d;
                D = h && h.fontSize;
                void 0 !== x && (F = x.toString(), -1 === F.indexOf("<") && (F = F.replace(/[0-9]/g, "0")), 
                F += [ "", k || 0, D, h && h.width, h && h.textOverflow ].join());
                F && !a && (v = y[F]);
                if (!v) {
                    if (c.namespaceURI === this.SVG_NS || e.forExport) {
                        try {
                            (m = this.fakeTS && function(a) {
                                C(c.querySelectorAll(".highcharts-text-outline"), function(v) {
                                    v.style.display = a;
                                });
                            }) && m("none"), v = c.getBBox ? t({}, c.getBBox()) : {
                                width: c.offsetWidth,
                                height: c.offsetHeight
                            }, m && m("");
                        } catch (W) {}
                        if (!v || 0 > v.width) v = {
                            width: 0,
                            height: 0
                        };
                    } else v = this.htmlGetBBox();
                    e.isSVG && (a = v.width, e = v.height, h && "11px" === h.fontSize && 17 === Math.round(e) && (v.height = e = 14), 
                    k && (v.width = Math.abs(e * Math.sin(b)) + Math.abs(a * Math.cos(b)), v.height = Math.abs(e * Math.cos(b)) + Math.abs(a * Math.sin(b))));
                    if (F && 0 < v.height) {
                        for (;250 < n.length; ) delete y[n.shift()];
                        y[F] || n.push(F);
                        y[F] = v;
                    }
                }
                return v;
            },
            show: function(a) {
                return this.attr({
                    visibility: a ? "inherit" : "visible"
                });
            },
            hide: function() {
                return this.attr({
                    visibility: "hidden"
                });
            },
            fadeOut: function(a) {
                var v = this;
                v.animate({
                    opacity: 0
                }, {
                    duration: a || 150,
                    complete: function() {
                        v.attr({
                            y: -9999
                        });
                    }
                });
            },
            add: function(a) {
                var v = this.renderer, k = this.element, e;
                a && (this.parentGroup = a);
                this.parentInverted = a && a.inverted;
                void 0 !== this.textStr && v.buildText(this);
                this.added = !0;
                if (!a || a.handleZ || this.zIndex) e = this.zIndexSetter();
                e || (a ? a.element : v.box).appendChild(k);
                if (this.onAdd) this.onAdd();
                return this;
            },
            safeRemoveChild: function(a) {
                var v = a.parentNode;
                v && v.removeChild(a);
            },
            destroy: function() {
                var a = this.element || {}, k = this.renderer.isSVG && "SPAN" === a.nodeName && this.parentGroup, e, b;
                a.onclick = a.onmouseout = a.onmouseover = a.onmousemove = a.point = null;
                D(this);
                this.clipPath && (this.clipPath = this.clipPath.destroy());
                if (this.stops) {
                    for (b = 0; b < this.stops.length; b++) this.stops[b] = this.stops[b].destroy();
                    this.stops = null;
                }
                this.safeRemoveChild(a);
                for (this.destroyShadows(); k && k.div && 0 === k.div.childNodes.length; ) a = k.parentGroup, 
                this.safeRemoveChild(k.div), delete k.div, k = a;
                this.alignTo && m(this.renderer.alignedObjects, this);
                for (e in this) delete this[e];
                return null;
            },
            shadow: function(a, k, e) {
                var v = [], b, c, h = this.element, D, x, m, y;
                if (!a) this.destroyShadows(); else if (!this.shadows) {
                    x = K(a.width, 3);
                    m = (a.opacity || .15) / x;
                    y = this.parentInverted ? "(-1,-1)" : "(" + K(a.offsetX, 1) + ", " + K(a.offsetY, 1) + ")";
                    for (b = 1; b <= x; b++) c = h.cloneNode(0), D = 2 * x + 1 - 2 * b, r(c, {
                        isShadow: "true",
                        stroke: a.color || "#000000",
                        "stroke-opacity": m * b,
                        "stroke-width": D,
                        transform: "translate" + y,
                        fill: "none"
                    }), e && (r(c, "height", Math.max(r(c, "height") - D, 0)), c.cutHeight = D), k ? k.element.appendChild(c) : h.parentNode.insertBefore(c, h), 
                    v.push(c);
                    this.shadows = v;
                }
                return this;
            },
            destroyShadows: function() {
                C(this.shadows || [], function(a) {
                    this.safeRemoveChild(a);
                }, this);
                this.shadows = void 0;
            },
            xGetter: function(a) {
                "circle" === this.element.nodeName && ("x" === a ? a = "cx" : "y" === a && (a = "cy"));
                return this._defaultGetter(a);
            },
            _defaultGetter: function(a) {
                a = K(this[a], this.element ? this.element.getAttribute(a) : null, 0);
                /^[\-0-9\.]+$/.test(a) && (a = parseFloat(a));
                return a;
            },
            dSetter: function(a, k, e) {
                a && a.join && (a = a.join(" "));
                /(NaN| {2}|^$)/.test(a) && (a = "M 0 0");
                e.setAttribute(k, a);
                this[k] = a;
            },
            dashstyleSetter: function(a) {
                var v, k = this["stroke-width"];
                "inherit" === k && (k = 1);
                if (a = a && a.toLowerCase()) {
                    a = a.replace("shortdashdotdot", "3,1,1,1,1,1,").replace("shortdashdot", "3,1,1,1").replace("shortdot", "1,1,").replace("shortdash", "3,1,").replace("longdash", "8,3,").replace(/dot/g, "1,3,").replace("dash", "4,3,").replace(/,$/, "").split(",");
                    for (v = a.length; v--; ) a[v] = I(a[v]) * k;
                    a = a.join(",").replace(/NaN/g, "none");
                    this.element.setAttribute("stroke-dasharray", a);
                }
            },
            alignSetter: function(a) {
                this.element.setAttribute("text-anchor", {
                    left: "start",
                    center: "middle",
                    right: "end"
                }[a]);
            },
            opacitySetter: function(a, k, e) {
                this[k] = a;
                e.setAttribute(k, a);
            },
            titleSetter: function(a) {
                var v = this.element.getElementsByTagName("title")[0];
                v || (v = p.createElementNS(this.SVG_NS, "title"), this.element.appendChild(v));
                v.firstChild && v.removeChild(v.firstChild);
                v.appendChild(p.createTextNode(String(K(a), "").replace(/<[^>]*>/g, "")));
            },
            textSetter: function(a) {
                a !== this.textStr && (delete this.bBox, this.textStr = a, this.added && this.renderer.buildText(this));
            },
            fillSetter: function(a, k, e) {
                "string" === typeof a ? e.setAttribute(k, a) : a && this.colorGradient(a, k, e);
            },
            visibilitySetter: function(a, k, e) {
                "inherit" === a ? e.removeAttribute(k) : e.setAttribute(k, a);
            },
            zIndexSetter: function(a, k) {
                var v = this.renderer, e = this.parentGroup, b = (e || v).element || v.box, c, h = this.element, D;
                c = this.added;
                var x;
                q(a) && (h.zIndex = a, a = +a, this[k] === a && (c = !1), this[k] = a);
                if (c) {
                    (a = this.zIndex) && e && (e.handleZ = !0);
                    k = b.childNodes;
                    for (x = 0; x < k.length && !D; x++) e = k[x], c = e.zIndex, e !== h && (I(c) > a || !q(a) && q(c) || 0 > a && !q(c) && b !== v.box) && (b.insertBefore(h, e), 
                    D = !0);
                    D || b.appendChild(h);
                }
                return D;
            },
            _defaultSetter: function(a, k, e) {
                e.setAttribute(k, a);
            }
        };
        B.prototype.yGetter = B.prototype.xGetter;
        B.prototype.translateXSetter = B.prototype.translateYSetter = B.prototype.rotationSetter = B.prototype.verticalAlignSetter = B.prototype.scaleXSetter = B.prototype.scaleYSetter = function(a, k) {
            this[k] = a;
            this.doTransform = !0;
        };
        B.prototype["stroke-widthSetter"] = B.prototype.strokeSetter = function(a, k, e) {
            this[k] = a;
            this.stroke && this["stroke-width"] ? (B.prototype.fillSetter.call(this, this.stroke, "stroke", e), 
            e.setAttribute("stroke-width", this["stroke-width"]), this.hasStroke = !0) : "stroke-width" === k && 0 === a && this.hasStroke && (e.removeAttribute("stroke"), 
            this.hasStroke = !1);
        };
        A = a.SVGRenderer = function() {
            this.init.apply(this, arguments);
        };
        A.prototype = {
            Element: B,
            SVG_NS: N,
            init: function(a, k, b, c, D, x) {
                var v;
                c = this.createElement("svg").attr({
                    version: "1.1",
                    "class": "highcharts-root"
                }).css(this.getStyle(c));
                v = c.element;
                a.appendChild(v);
                -1 === a.innerHTML.indexOf("xmlns") && r(v, "xmlns", this.SVG_NS);
                this.isSVG = !0;
                this.box = v;
                this.boxWrapper = c;
                this.alignedObjects = [];
                this.url = (e || h) && p.getElementsByTagName("base").length ? O.location.href.replace(/#.*?$/, "").replace(/<[^>]*>/g, "").replace(/([\('\)])/g, "\\$1").replace(/ /g, "%20") : "";
                this.createElement("desc").add().element.appendChild(p.createTextNode("Created with Highcharts 5.0.7"));
                this.defs = this.createElement("defs").add();
                this.allowHTML = x;
                this.forExport = D;
                this.gradients = {};
                this.cache = {};
                this.cacheKeys = [];
                this.imgCount = 0;
                this.setSize(k, b, !1);
                var m;
                e && a.getBoundingClientRect && (k = function() {
                    u(a, {
                        left: 0,
                        top: 0
                    });
                    m = a.getBoundingClientRect();
                    u(a, {
                        left: Math.ceil(m.left) - m.left + "px",
                        top: Math.ceil(m.top) - m.top + "px"
                    });
                }, k(), this.unSubPixelFix = H(O, "resize", k));
            },
            getStyle: function(a) {
                return this.style = t({
                    fontFamily: '"Lucida Grande", "Lucida Sans Unicode", Arial, Helvetica, sans-serif',
                    fontSize: "12px"
                }, a);
            },
            setStyle: function(a) {
                this.boxWrapper.css(this.getStyle(a));
            },
            isHidden: function() {
                return !this.boxWrapper.getBBox().width;
            },
            destroy: function() {
                var a = this.defs;
                this.box = null;
                this.boxWrapper = this.boxWrapper.destroy();
                b(this.gradients || {});
                this.gradients = null;
                a && (this.defs = a.destroy());
                this.unSubPixelFix && this.unSubPixelFix();
                return this.alignedObjects = null;
            },
            createElement: function(a) {
                var k = new this.Element();
                k.init(this, a);
                return k;
            },
            draw: J,
            getRadialAttr: function(a, k) {
                return {
                    cx: a[0] - a[2] / 2 + k.cx * a[2],
                    cy: a[1] - a[2] / 2 + k.cy * a[2],
                    r: k.r * a[2]
                };
            },
            buildText: function(a) {
                var k = a.element, v = this, e = v.forExport, b = K(a.textStr, "").toString(), h = -1 !== b.indexOf("<"), D = k.childNodes, x, m, y, n, F = r(k, "x"), d = a.styles, t = a.textWidth, w = d && d.lineHeight, l = d && d.textOutline, z = d && "ellipsis" === d.textOverflow, f = d && "nowrap" === d.whiteSpace, E = d && d.fontSize, q, g = D.length, d = t && !a.added && this.box, J = function(a) {
                    var e;
                    e = /(px|em)$/.test(a && a.style.fontSize) ? a.style.fontSize : E || v.style.fontSize || 12;
                    return w ? I(w) : v.fontMetrics(e, a.getAttribute("style") ? a : k).h;
                };
                q = [ b, z, f, w, l, E, t ].join();
                if (q !== a.textCache) {
                    for (a.textCache = q; g--; ) k.removeChild(D[g]);
                    h || l || z || t || -1 !== b.indexOf(" ") ? (x = /<.*class="([^"]+)".*>/, m = /<.*style="([^"]+)".*>/, 
                    y = /<.*href="(http[^"]+)".*>/, d && d.appendChild(k), b = h ? b.replace(/<(b|strong)>/g, '<span style="font-weight:bold">').replace(/<(i|em)>/g, '<span style="font-style:italic">').replace(/<a/g, "<span").replace(/<\/(b|strong|i|em|a)>/g, "</span>").split(/<br.*?>/g) : [ b ], 
                    b = c(b, function(a) {
                        return "" !== a;
                    }), C(b, function(b, c) {
                        var h, D = 0;
                        b = b.replace(/^\s+|\s+$/g, "").replace(/<span/g, "|||<span").replace(/<\/span>/g, "</span>|||");
                        h = b.split("|||");
                        C(h, function(b) {
                            if ("" !== b || 1 === h.length) {
                                var d = {}, w = p.createElementNS(v.SVG_NS, "tspan"), l, E;
                                x.test(b) && (l = b.match(x)[1], r(w, "class", l));
                                m.test(b) && (E = b.match(m)[1].replace(/(;| |^)color([ :])/, "$1fill$2"), r(w, "style", E));
                                y.test(b) && !e && (r(w, "onclick", 'location.href="' + b.match(y)[1] + '"'), u(w, {
                                    cursor: "pointer"
                                }));
                                b = (b.replace(/<(.|\n)*?>/g, "") || " ").replace(/&lt;/g, "<").replace(/&gt;/g, ">");
                                if (" " !== b) {
                                    w.appendChild(p.createTextNode(b));
                                    D ? d.dx = 0 : c && null !== F && (d.x = F);
                                    r(w, d);
                                    k.appendChild(w);
                                    !D && c && (!P && e && u(w, {
                                        display: "block"
                                    }), r(w, "dy", J(w)));
                                    if (t) {
                                        d = b.replace(/([^\^])-/g, "$1- ").split(" ");
                                        l = 1 < h.length || c || 1 < d.length && !f;
                                        for (var q, g, M = [], C = J(w), K = a.rotation, I = b, Q = I.length; (l || z) && (d.length || M.length); ) a.rotation = 0, 
                                        q = a.getBBox(!0), g = q.width, !P && v.forExport && (g = v.measureSpanWidth(w.firstChild.data, a.styles)), 
                                        q = g > t, void 0 === n && (n = q), z && n ? (Q /= 2, "" === I || !q && .5 > Q ? d = [] : (I = b.substring(0, I.length + (q ? -1 : 1) * Math.ceil(Q)), 
                                        d = [ I + (3 < t ? "â¦" : "") ], w.removeChild(w.firstChild))) : q && 1 !== d.length ? (w.removeChild(w.firstChild), 
                                        M.unshift(d.pop())) : (d = M, M = [], d.length && !f && (w = p.createElementNS(N, "tspan"), 
                                        r(w, {
                                            dy: C,
                                            x: F
                                        }), E && r(w, "style", E), k.appendChild(w)), g > t && (t = g)), d.length && w.appendChild(p.createTextNode(d.join(" ").replace(/- /g, "-")));
                                        a.rotation = K;
                                    }
                                    D++;
                                }
                            }
                        });
                    }), n && a.attr("title", a.textStr), d && d.removeChild(k), l && a.applyTextOutline && a.applyTextOutline(l)) : k.appendChild(p.createTextNode(b.replace(/&lt;/g, "<").replace(/&gt;/g, ">")));
                }
            },
            getContrast: function(a) {
                a = f(a).rgba;
                return 510 < a[0] + a[1] + a[2] ? "#000000" : "#FFFFFF";
            },
            button: function(a, k, e, b, c, h, D, m, d) {
                var v = this.label(a, k, e, d, null, null, null, null, "button"), n = 0;
                v.attr(y({
                    padding: 8,
                    r: 2
                }, c));
                var F, w, p, l;
                c = y({
                    fill: "#f7f7f7",
                    stroke: "#cccccc",
                    "stroke-width": 1,
                    style: {
                        color: "#333333",
                        cursor: "pointer",
                        fontWeight: "normal"
                    }
                }, c);
                F = c.style;
                delete c.style;
                h = y(c, {
                    fill: "#e6e6e6"
                }, h);
                w = h.style;
                delete h.style;
                D = y(c, {
                    fill: "#e6ebf5",
                    style: {
                        color: "#000000",
                        fontWeight: "bold"
                    }
                }, D);
                p = D.style;
                delete D.style;
                m = y(c, {
                    style: {
                        color: "#cccccc"
                    }
                }, m);
                l = m.style;
                delete m.style;
                H(v.element, x ? "mouseover" : "mouseenter", function() {
                    3 !== n && v.setState(1);
                });
                H(v.element, x ? "mouseout" : "mouseleave", function() {
                    3 !== n && v.setState(n);
                });
                v.setState = function(a) {
                    1 !== a && (v.state = n = a);
                    v.removeClass(/highcharts-button-(normal|hover|pressed|disabled)/).addClass("highcharts-button-" + [ "normal", "hover", "pressed", "disabled" ][a || 0]);
                    v.attr([ c, h, D, m ][a || 0]).css([ F, w, p, l ][a || 0]);
                };
                v.attr(c).css(t({
                    cursor: "default"
                }, F));
                return v.on("click", function(a) {
                    3 !== n && b.call(v, a);
                });
            },
            crispLine: function(a, k) {
                a[1] === a[4] && (a[1] = a[4] = Math.round(a[1]) - k % 2 / 2);
                a[2] === a[5] && (a[2] = a[5] = Math.round(a[2]) + k % 2 / 2);
                return a;
            },
            path: function(a) {
                var k = {
                    fill: "none"
                };
                z(a) ? k.d = a : F(a) && t(k, a);
                return this.createElement("path").attr(k);
            },
            circle: function(a, k, e) {
                a = F(a) ? a : {
                    x: a,
                    y: k,
                    r: e
                };
                k = this.createElement("circle");
                k.xSetter = k.ySetter = function(a, k, e) {
                    e.setAttribute("c" + k, a);
                };
                return k.attr(a);
            },
            arc: function(a, k, e, b, c, h) {
                F(a) && (k = a.y, e = a.r, b = a.innerR, c = a.start, h = a.end, a = a.x);
                a = this.symbol("arc", a || 0, k || 0, e || 0, e || 0, {
                    innerR: b || 0,
                    start: c || 0,
                    end: h || 0
                });
                a.r = e;
                return a;
            },
            rect: function(a, k, e, b, c, h) {
                c = F(a) ? a.r : c;
                var v = this.createElement("rect");
                a = F(a) ? a : void 0 === a ? {} : {
                    x: a,
                    y: k,
                    width: Math.max(e, 0),
                    height: Math.max(b, 0)
                };
                void 0 !== h && (a.strokeWidth = h, a = v.crisp(a));
                a.fill = "none";
                c && (a.r = c);
                v.rSetter = function(a, k, e) {
                    r(e, {
                        rx: a,
                        ry: a
                    });
                };
                return v.attr(a);
            },
            setSize: function(a, k, e) {
                var b = this.alignedObjects, v = b.length;
                this.width = a;
                this.height = k;
                for (this.boxWrapper.animate({
                    width: a,
                    height: k
                }, {
                    step: function() {
                        this.attr({
                            viewBox: "0 0 " + this.attr("width") + " " + this.attr("height")
                        });
                    },
                    duration: K(e, !0) ? void 0 : 0
                }); v--; ) b[v].align();
            },
            g: function(a) {
                var k = this.createElement("g");
                return a ? k.attr({
                    "class": "highcharts-" + a
                }) : k;
            },
            image: function(a, k, e, b, c) {
                var v = {
                    preserveAspectRatio: "none"
                };
                1 < arguments.length && t(v, {
                    x: k,
                    y: e,
                    width: b,
                    height: c
                });
                v = this.createElement("image").attr(v);
                v.element.setAttributeNS ? v.element.setAttributeNS("http://www.w3.org/1999/xlink", "href", a) : v.element.setAttribute("hc-svg-href", a);
                return v;
            },
            symbol: function(a, k, e, b, c, h) {
                var v = this, D, x = this.symbols[a], m = q(k) && x && this.symbols[a](Math.round(k), Math.round(e), b, c, h), y = /^url\((.*?)\)$/, d, n;
                x ? (D = this.path(m), D.attr("fill", "none"), t(D, {
                    symbolName: a,
                    x: k,
                    y: e,
                    width: b,
                    height: c
                }), h && t(D, h)) : y.test(a) && (d = a.match(y)[1], D = this.image(d), D.imgwidth = K(S[d] && S[d].width, h && h.width), 
                D.imgheight = K(S[d] && S[d].height, h && h.height), n = function() {
                    D.attr({
                        width: D.width,
                        height: D.height
                    });
                }, C([ "width", "height" ], function(a) {
                    D[a + "Setter"] = function(a, k) {
                        var e = {}, b = this["img" + k], v = "width" === k ? "translateX" : "translateY";
                        this[k] = a;
                        q(b) && (this.element && this.element.setAttribute(k, b), this.alignByTranslate || (e[v] = ((this[k] || 0) - b) / 2, 
                        this.attr(e)));
                    };
                }), q(k) && D.attr({
                    x: k,
                    y: e
                }), D.isImg = !0, q(D.imgwidth) && q(D.imgheight) ? n() : (D.attr({
                    width: 0,
                    height: 0
                }), l("img", {
                    onload: function() {
                        var a = g[v.chartIndex];
                        0 === this.width && (u(this, {
                            position: "absolute",
                            top: "-999em"
                        }), p.body.appendChild(this));
                        S[d] = {
                            width: this.width,
                            height: this.height
                        };
                        D.imgwidth = this.width;
                        D.imgheight = this.height;
                        D.element && n();
                        this.parentNode && this.parentNode.removeChild(this);
                        v.imgCount--;
                        if (!v.imgCount && a && a.onload) a.onload();
                    },
                    src: d
                }), this.imgCount++));
                return D;
            },
            symbols: {
                circle: function(a, k, e, b) {
                    return this.arc(a + e / 2, k + b / 2, e / 2, b / 2, {
                        start: 0,
                        end: 2 * Math.PI,
                        open: !1
                    });
                },
                square: function(a, k, e, b) {
                    return [ "M", a, k, "L", a + e, k, a + e, k + b, a, k + b, "Z" ];
                },
                triangle: function(a, k, e, b) {
                    return [ "M", a + e / 2, k, "L", a + e, k + b, a, k + b, "Z" ];
                },
                "triangle-down": function(a, k, e, b) {
                    return [ "M", a, k, "L", a + e, k, a + e / 2, k + b, "Z" ];
                },
                diamond: function(a, k, e, b) {
                    return [ "M", a + e / 2, k, "L", a + e, k + b / 2, a + e / 2, k + b, a, k + b / 2, "Z" ];
                },
                arc: function(a, k, e, b, c) {
                    var v = c.start, h = c.r || e, D = c.r || b || e, x = c.end - .001;
                    e = c.innerR;
                    b = c.open;
                    var m = Math.cos(v), d = Math.sin(v), y = Math.cos(x), x = Math.sin(x);
                    c = c.end - v < Math.PI ? 0 : 1;
                    h = [ "M", a + h * m, k + D * d, "A", h, D, 0, c, 1, a + h * y, k + D * x ];
                    q(e) && h.push(b ? "M" : "L", a + e * y, k + e * x, "A", e, e, 0, c, 0, a + e * m, k + e * d);
                    h.push(b ? "" : "Z");
                    return h;
                },
                callout: function(a, k, e, b, c) {
                    var h = Math.min(c && c.r || 0, e, b), D = h + 6, v = c && c.anchorX;
                    c = c && c.anchorY;
                    var x;
                    x = [ "M", a + h, k, "L", a + e - h, k, "C", a + e, k, a + e, k, a + e, k + h, "L", a + e, k + b - h, "C", a + e, k + b, a + e, k + b, a + e - h, k + b, "L", a + h, k + b, "C", a, k + b, a, k + b, a, k + b - h, "L", a, k + h, "C", a, k, a, k, a + h, k ];
                    v && v > e ? c > k + D && c < k + b - D ? x.splice(13, 3, "L", a + e, c - 6, a + e + 6, c, a + e, c + 6, a + e, k + b - h) : x.splice(13, 3, "L", a + e, b / 2, v, c, a + e, b / 2, a + e, k + b - h) : v && 0 > v ? c > k + D && c < k + b - D ? x.splice(33, 3, "L", a, c + 6, a - 6, c, a, c - 6, a, k + h) : x.splice(33, 3, "L", a, b / 2, v, c, a, b / 2, a, k + h) : c && c > b && v > a + D && v < a + e - D ? x.splice(23, 3, "L", v + 6, k + b, v, k + b + 6, v - 6, k + b, a + h, k + b) : c && 0 > c && v > a + D && v < a + e - D && x.splice(3, 3, "L", v - 6, k, v, k - 6, v + 6, k, e - h, k);
                    return x;
                }
            },
            clipRect: function(k, e, b, c) {
                var h = a.uniqueKey(), D = this.createElement("clipPath").attr({
                    id: h
                }).add(this.defs);
                k = this.rect(k, e, b, c, 0).add(D);
                k.id = h;
                k.clipPath = D;
                k.count = 0;
                return k;
            },
            text: function(a, k, e, b) {
                var c = !P && this.forExport, h = {};
                if (b && (this.allowHTML || !this.forExport)) return this.html(a, k, e);
                h.x = Math.round(k || 0);
                e && (h.y = Math.round(e));
                if (a || 0 === a) h.text = a;
                a = this.createElement("text").attr(h);
                c && a.css({
                    position: "absolute"
                });
                b || (a.xSetter = function(a, k, e) {
                    var b = e.getElementsByTagName("tspan"), c, h = e.getAttribute(k), D;
                    for (D = 0; D < b.length; D++) c = b[D], c.getAttribute(k) === h && c.setAttribute(k, a);
                    e.setAttribute(k, a);
                });
                return a;
            },
            fontMetrics: function(a, k) {
                a = a || k && k.style && k.style.fontSize || this.style && this.style.fontSize;
                a = /px/.test(a) ? I(a) : /em/.test(a) ? parseFloat(a) * (k ? this.fontMetrics(null, k.parentNode).f : 16) : 12;
                k = 24 > a ? a + 3 : Math.round(1.2 * a);
                return {
                    h: k,
                    b: Math.round(.8 * k),
                    f: a
                };
            },
            rotCorr: function(a, k, e) {
                var b = a;
                k && e && (b = Math.max(b * Math.cos(k * d), 4));
                return {
                    x: -a / 3 * Math.sin(k * d),
                    y: b
                };
            },
            label: function(a, e, b, c, h, D, x, m, d) {
                var v = this, n = v.g("button" !== d && "label"), F = n.text = v.text("", 0, 0, x).attr({
                    zIndex: 1
                }), w, p, l = 0, z = 3, E = 0, f, g, J, K, P, N = {}, I, u, r = /^url\((.*?)\)$/.test(c), M = r, S, Q, R, O;
                d && n.addClass("highcharts-" + d);
                M = r;
                S = function() {
                    return (I || 0) % 2 / 2;
                };
                Q = function() {
                    var a = F.element.style, k = {};
                    p = (void 0 === f || void 0 === g || P) && q(F.textStr) && F.getBBox();
                    n.width = (f || p.width || 0) + 2 * z + E;
                    n.height = (g || p.height || 0) + 2 * z;
                    u = z + v.fontMetrics(a && a.fontSize, F).b;
                    M && (w || (n.box = w = v.symbols[c] || r ? v.symbol(c) : v.rect(), w.addClass(("button" === d ? "" : "highcharts-label-box") + (d ? " highcharts-" + d + "-box" : "")), 
                    w.add(n), a = S(), k.x = a, k.y = (m ? -u : 0) + a), k.width = Math.round(n.width), 
                    k.height = Math.round(n.height), w.attr(t(k, N)), N = {});
                };
                R = function() {
                    var a = E + z, k;
                    k = m ? 0 : u;
                    q(f) && p && ("center" === P || "right" === P) && (a += {
                        center: .5,
                        right: 1
                    }[P] * (f - p.width));
                    if (a !== F.x || k !== F.y) F.attr("x", a), void 0 !== k && F.attr("y", k);
                    F.x = a;
                    F.y = k;
                };
                O = function(a, k) {
                    w ? w.attr(a, k) : N[a] = k;
                };
                n.onAdd = function() {
                    F.add(n);
                    n.attr({
                        text: a || 0 === a ? a : "",
                        x: e,
                        y: b
                    });
                    w && q(h) && n.attr({
                        anchorX: h,
                        anchorY: D
                    });
                };
                n.widthSetter = function(a) {
                    f = a;
                };
                n.heightSetter = function(a) {
                    g = a;
                };
                n["text-alignSetter"] = function(a) {
                    P = a;
                };
                n.paddingSetter = function(a) {
                    q(a) && a !== z && (z = n.padding = a, R());
                };
                n.paddingLeftSetter = function(a) {
                    q(a) && a !== E && (E = a, R());
                };
                n.alignSetter = function(a) {
                    a = {
                        left: 0,
                        center: .5,
                        right: 1
                    }[a];
                    a !== l && (l = a, p && n.attr({
                        x: J
                    }));
                };
                n.textSetter = function(a) {
                    void 0 !== a && F.textSetter(a);
                    Q();
                    R();
                };
                n["stroke-widthSetter"] = function(a, k) {
                    a && (M = !0);
                    I = this["stroke-width"] = a;
                    O(k, a);
                };
                n.strokeSetter = n.fillSetter = n.rSetter = function(a, k) {
                    "fill" === k && a && (M = !0);
                    O(k, a);
                };
                n.anchorXSetter = function(a, k) {
                    h = a;
                    O(k, Math.round(a) - S() - J);
                };
                n.anchorYSetter = function(a, k) {
                    D = a;
                    O(k, a - K);
                };
                n.xSetter = function(a) {
                    n.x = a;
                    l && (a -= l * ((f || p.width) + 2 * z));
                    J = Math.round(a);
                    n.attr("translateX", J);
                };
                n.ySetter = function(a) {
                    K = n.y = Math.round(a);
                    n.attr("translateY", K);
                };
                var V = n.css;
                return t(n, {
                    css: function(a) {
                        if (a) {
                            var k = {};
                            a = y(a);
                            C(n.textProps, function(e) {
                                void 0 !== a[e] && (k[e] = a[e], delete a[e]);
                            });
                            F.css(k);
                        }
                        return V.call(n, a);
                    },
                    getBBox: function() {
                        return {
                            width: p.width + 2 * z,
                            height: p.height + 2 * z,
                            x: p.x - z,
                            y: p.y - z
                        };
                    },
                    shadow: function(a) {
                        a && (Q(), w && w.shadow(a));
                        return n;
                    },
                    destroy: function() {
                        k(n.element, "mouseenter");
                        k(n.element, "mouseleave");
                        F && (F = F.destroy());
                        w && (w = w.destroy());
                        B.prototype.destroy.call(n);
                        n = v = Q = R = O = null;
                    }
                });
            }
        };
        a.Renderer = A;
    })(L);
    (function(a) {
        var B = a.attr, A = a.createElement, H = a.css, G = a.defined, r = a.each, g = a.extend, f = a.isFirefox, u = a.isMS, l = a.isWebKit, q = a.pInt, d = a.SVGRenderer, b = a.win, p = a.wrap;
        g(a.SVGElement.prototype, {
            htmlCss: function(a) {
                var b = this.element;
                if (b = a && "SPAN" === b.tagName && a.width) delete a.width, this.textWidth = b, 
                this.updateTransform();
                a && "ellipsis" === a.textOverflow && (a.whiteSpace = "nowrap", a.overflow = "hidden");
                this.styles = g(this.styles, a);
                H(this.element, a);
                return this;
            },
            htmlGetBBox: function() {
                var a = this.element;
                "text" === a.nodeName && (a.style.position = "absolute");
                return {
                    x: a.offsetLeft,
                    y: a.offsetTop,
                    width: a.offsetWidth,
                    height: a.offsetHeight
                };
            },
            htmlUpdateTransform: function() {
                if (this.added) {
                    var a = this.renderer, b = this.element, m = this.translateX || 0, c = this.translateY || 0, n = this.x || 0, d = this.y || 0, p = this.textAlign || "left", e = {
                        left: 0,
                        center: .5,
                        right: 1
                    }[p], x = this.styles;
                    H(b, {
                        marginLeft: m,
                        marginTop: c
                    });
                    this.shadows && r(this.shadows, function(a) {
                        H(a, {
                            marginLeft: m + 1,
                            marginTop: c + 1
                        });
                    });
                    this.inverted && r(b.childNodes, function(e) {
                        a.invertChild(e, b);
                    });
                    if ("SPAN" === b.tagName) {
                        var F = this.rotation, w = q(this.textWidth), h = x && x.whiteSpace, y = [ F, p, b.innerHTML, this.textWidth, this.textAlign ].join();
                        y !== this.cTT && (x = a.fontMetrics(b.style.fontSize).b, G(F) && this.setSpanRotation(F, e, x), 
                        H(b, {
                            width: "",
                            whiteSpace: h || "nowrap"
                        }), b.offsetWidth > w && /[ \-]/.test(b.textContent || b.innerText) && H(b, {
                            width: w + "px",
                            display: "block",
                            whiteSpace: h || "normal"
                        }), this.getSpanCorrection(b.offsetWidth, x, e, F, p));
                        H(b, {
                            left: n + (this.xCorr || 0) + "px",
                            top: d + (this.yCorr || 0) + "px"
                        });
                        l && (x = b.offsetHeight);
                        this.cTT = y;
                    }
                } else this.alignOnAdd = !0;
            },
            setSpanRotation: function(a, d, m) {
                var c = {}, n = u ? "-ms-transform" : l ? "-webkit-transform" : f ? "MozTransform" : b.opera ? "-o-transform" : "";
                c[n] = c.transform = "rotate(" + a + "deg)";
                c[n + (f ? "Origin" : "-origin")] = c.transformOrigin = 100 * d + "% " + m + "px";
                H(this.element, c);
            },
            getSpanCorrection: function(a, b, m) {
                this.xCorr = -a * m;
                this.yCorr = -b;
            }
        });
        g(d.prototype, {
            html: function(a, b, m) {
                var c = this.createElement("span"), n = c.element, d = c.renderer, l = d.isSVG, e = function(a, e) {
                    r([ "opacity", "visibility" ], function(b) {
                        p(a, b + "Setter", function(a, b, c, x) {
                            a.call(this, b, c, x);
                            e[c] = b;
                        });
                    });
                };
                c.textSetter = function(a) {
                    a !== n.innerHTML && delete this.bBox;
                    n.innerHTML = this.textStr = a;
                    c.htmlUpdateTransform();
                };
                l && e(c, c.element.style);
                c.xSetter = c.ySetter = c.alignSetter = c.rotationSetter = function(a, e) {
                    "align" === e && (e = "textAlign");
                    c[e] = a;
                    c.htmlUpdateTransform();
                };
                c.attr({
                    text: a,
                    x: Math.round(b),
                    y: Math.round(m)
                }).css({
                    fontFamily: this.style.fontFamily,
                    fontSize: this.style.fontSize,
                    position: "absolute"
                });
                n.style.whiteSpace = "nowrap";
                c.css = c.htmlCss;
                l && (c.add = function(a) {
                    var b, x = d.box.parentNode, h = [];
                    if (this.parentGroup = a) {
                        if (b = a.div, !b) {
                            for (;a; ) h.push(a), a = a.parentGroup;
                            r(h.reverse(), function(a) {
                                var n, m = B(a.element, "class");
                                m && (m = {
                                    className: m
                                });
                                b = a.div = a.div || A("div", m, {
                                    position: "absolute",
                                    left: (a.translateX || 0) + "px",
                                    top: (a.translateY || 0) + "px",
                                    display: a.display,
                                    opacity: a.opacity,
                                    pointerEvents: a.styles && a.styles.pointerEvents
                                }, b || x);
                                n = b.style;
                                g(a, {
                                    on: function() {
                                        c.on.apply({
                                            element: h[0].div
                                        }, arguments);
                                        return a;
                                    },
                                    translateXSetter: function(e, k) {
                                        n.left = e + "px";
                                        a[k] = e;
                                        a.doTransform = !0;
                                    },
                                    translateYSetter: function(e, k) {
                                        n.top = e + "px";
                                        a[k] = e;
                                        a.doTransform = !0;
                                    }
                                });
                                e(a, n);
                            });
                        }
                    } else b = x;
                    b.appendChild(n);
                    c.added = !0;
                    c.alignOnAdd && c.htmlUpdateTransform();
                    return c;
                });
                return c;
            }
        });
    })(L);
    (function(a) {
        var B, A, H = a.createElement, G = a.css, r = a.defined, g = a.deg2rad, f = a.discardElement, u = a.doc, l = a.each, q = a.erase, d = a.extend;
        B = a.extendClass;
        var b = a.isArray, p = a.isNumber, C = a.isObject, t = a.merge;
        A = a.noop;
        var m = a.pick, c = a.pInt, n = a.SVGElement, E = a.SVGRenderer, z = a.win;
        a.svg || (A = {
            docMode8: u && 8 === u.documentMode,
            init: function(a, b) {
                var e = [ "<", b, ' filled="f" stroked="f"' ], c = [ "position: ", "absolute", ";" ], h = "div" === b;
                ("shape" === b || h) && c.push("left:0;top:0;width:1px;height:1px;");
                c.push("visibility: ", h ? "hidden" : "visible");
                e.push(' style="', c.join(""), '"/>');
                b && (e = h || "span" === b || "img" === b ? e.join("") : a.prepVML(e), this.element = H(e));
                this.renderer = a;
            },
            add: function(a) {
                var e = this.renderer, b = this.element, c = e.box, h = a && a.inverted, c = a ? a.element || a : c;
                a && (this.parentGroup = a);
                h && e.invertChild(b, c);
                c.appendChild(b);
                this.added = !0;
                this.alignOnAdd && !this.deferUpdateTransform && this.updateTransform();
                if (this.onAdd) this.onAdd();
                this.className && this.attr("class", this.className);
                return this;
            },
            updateTransform: n.prototype.htmlUpdateTransform,
            setSpanRotation: function() {
                var a = this.rotation, b = Math.cos(a * g), c = Math.sin(a * g);
                G(this.element, {
                    filter: a ? [ "progid:DXImageTransform.Microsoft.Matrix(M11=", b, ", M12=", -c, ", M21=", c, ", M22=", b, ", sizingMethod='auto expand')" ].join("") : "none"
                });
            },
            getSpanCorrection: function(a, b, c, n, h) {
                var e = n ? Math.cos(n * g) : 1, x = n ? Math.sin(n * g) : 0, d = m(this.elemHeight, this.element.offsetHeight), F;
                this.xCorr = 0 > e && -a;
                this.yCorr = 0 > x && -d;
                F = 0 > e * x;
                this.xCorr += x * b * (F ? 1 - c : c);
                this.yCorr -= e * b * (n ? F ? c : 1 - c : 1);
                h && "left" !== h && (this.xCorr -= a * c * (0 > e ? -1 : 1), n && (this.yCorr -= d * c * (0 > x ? -1 : 1)), 
                G(this.element, {
                    textAlign: h
                }));
            },
            pathToVML: function(a) {
                for (var b = a.length, e = []; b--; ) p(a[b]) ? e[b] = Math.round(10 * a[b]) - 5 : "Z" === a[b] ? e[b] = "x" : (e[b] = a[b], 
                !a.isArc || "wa" !== a[b] && "at" !== a[b] || (e[b + 5] === e[b + 7] && (e[b + 7] += a[b + 7] > a[b + 5] ? 1 : -1), 
                e[b + 6] === e[b + 8] && (e[b + 8] += a[b + 8] > a[b + 6] ? 1 : -1)));
                return e.join(" ") || "x";
            },
            clip: function(a) {
                var b = this, e;
                a ? (e = a.members, q(e, b), e.push(b), b.destroyClip = function() {
                    q(e, b);
                }, a = a.getCSS(b)) : (b.destroyClip && b.destroyClip(), a = {
                    clip: b.docMode8 ? "inherit" : "rect(auto)"
                });
                return b.css(a);
            },
            css: n.prototype.htmlCss,
            safeRemoveChild: function(a) {
                a.parentNode && f(a);
            },
            destroy: function() {
                this.destroyClip && this.destroyClip();
                return n.prototype.destroy.apply(this);
            },
            on: function(a, b) {
                this.element["on" + a] = function() {
                    var a = z.event;
                    a.target = a.srcElement;
                    b(a);
                };
                return this;
            },
            cutOffPath: function(a, b) {
                var e;
                a = a.split(/[ ,]/);
                e = a.length;
                if (9 === e || 11 === e) a[e - 4] = a[e - 2] = c(a[e - 2]) - 10 * b;
                return a.join(" ");
            },
            shadow: function(a, b, n) {
                var e = [], h, d = this.element, x = this.renderer, p, F = d.style, k, D = d.path, l, t, z, f;
                D && "string" !== typeof D.value && (D = "x");
                t = D;
                if (a) {
                    z = m(a.width, 3);
                    f = (a.opacity || .15) / z;
                    for (h = 1; 3 >= h; h++) l = 2 * z + 1 - 2 * h, n && (t = this.cutOffPath(D.value, l + .5)), 
                    k = [ '<shape isShadow="true" strokeweight="', l, '" filled="false" path="', t, '" coordsize="10 10" style="', d.style.cssText, '" />' ], 
                    p = H(x.prepVML(k), null, {
                        left: c(F.left) + m(a.offsetX, 1),
                        top: c(F.top) + m(a.offsetY, 1)
                    }), n && (p.cutOff = l + 1), k = [ '<stroke color="', a.color || "#000000", '" opacity="', f * h, '"/>' ], 
                    H(x.prepVML(k), null, null, p), b ? b.element.appendChild(p) : d.parentNode.insertBefore(p, d), 
                    e.push(p);
                    this.shadows = e;
                }
                return this;
            },
            updateShadows: A,
            setAttr: function(a, b) {
                this.docMode8 ? this.element[a] = b : this.element.setAttribute(a, b);
            },
            classSetter: function(a) {
                (this.added ? this.element : this).className = a;
            },
            dashstyleSetter: function(a, b, c) {
                (c.getElementsByTagName("stroke")[0] || H(this.renderer.prepVML([ "<stroke/>" ]), null, null, c))[b] = a || "solid";
                this[b] = a;
            },
            dSetter: function(a, b, c) {
                var e = this.shadows;
                a = a || [];
                this.d = a.join && a.join(" ");
                c.path = a = this.pathToVML(a);
                if (e) for (c = e.length; c--; ) e[c].path = e[c].cutOff ? this.cutOffPath(a, e[c].cutOff) : a;
                this.setAttr(b, a);
            },
            fillSetter: function(a, b, c) {
                var e = c.nodeName;
                "SPAN" === e ? c.style.color = a : "IMG" !== e && (c.filled = "none" !== a, this.setAttr("fillcolor", this.renderer.color(a, c, b, this)));
            },
            "fill-opacitySetter": function(a, b, c) {
                H(this.renderer.prepVML([ "<", b.split("-")[0], ' opacity="', a, '"/>' ]), null, null, c);
            },
            opacitySetter: A,
            rotationSetter: function(a, b, c) {
                c = c.style;
                this[b] = c[b] = a;
                c.left = -Math.round(Math.sin(a * g) + 1) + "px";
                c.top = Math.round(Math.cos(a * g)) + "px";
            },
            strokeSetter: function(a, b, c) {
                this.setAttr("strokecolor", this.renderer.color(a, c, b, this));
            },
            "stroke-widthSetter": function(a, b, c) {
                c.stroked = !!a;
                this[b] = a;
                p(a) && (a += "px");
                this.setAttr("strokeweight", a);
            },
            titleSetter: function(a, b) {
                this.setAttr(b, a);
            },
            visibilitySetter: function(a, b, c) {
                "inherit" === a && (a = "visible");
                this.shadows && l(this.shadows, function(c) {
                    c.style[b] = a;
                });
                "DIV" === c.nodeName && (a = "hidden" === a ? "-999em" : 0, this.docMode8 || (c.style[b] = a ? "visible" : "hidden"), 
                b = "top");
                c.style[b] = a;
            },
            xSetter: function(a, b, c) {
                this[b] = a;
                "x" === b ? b = "left" : "y" === b && (b = "top");
                this.updateClipping ? (this[b] = a, this.updateClipping()) : c.style[b] = a;
            },
            zIndexSetter: function(a, b, c) {
                c.style[b] = a;
            }
        }, A["stroke-opacitySetter"] = A["fill-opacitySetter"], a.VMLElement = A = B(n, A), 
        A.prototype.ySetter = A.prototype.widthSetter = A.prototype.heightSetter = A.prototype.xSetter, 
        A = {
            Element: A,
            isIE8: -1 < z.navigator.userAgent.indexOf("MSIE 8.0"),
            init: function(a, b, c) {
                var e, h;
                this.alignedObjects = [];
                e = this.createElement("div").css({
                    position: "relative"
                });
                h = e.element;
                a.appendChild(e.element);
                this.isVML = !0;
                this.box = h;
                this.boxWrapper = e;
                this.gradients = {};
                this.cache = {};
                this.cacheKeys = [];
                this.imgCount = 0;
                this.setSize(b, c, !1);
                if (!u.namespaces.hcv) {
                    u.namespaces.add("hcv", "urn:schemas-microsoft-com:vml");
                    try {
                        u.createStyleSheet().cssText = "hcv\\:fill, hcv\\:path, hcv\\:shape, hcv\\:stroke{ behavior:url(#default#VML); display: inline-block; } ";
                    } catch (y) {
                        u.styleSheets[0].cssText += "hcv\\:fill, hcv\\:path, hcv\\:shape, hcv\\:stroke{ behavior:url(#default#VML); display: inline-block; } ";
                    }
                }
            },
            isHidden: function() {
                return !this.box.offsetWidth;
            },
            clipRect: function(a, b, c, n) {
                var e = this.createElement(), m = C(a);
                return d(e, {
                    members: [],
                    count: 0,
                    left: (m ? a.x : a) + 1,
                    top: (m ? a.y : b) + 1,
                    width: (m ? a.width : c) - 1,
                    height: (m ? a.height : n) - 1,
                    getCSS: function(a) {
                        var b = a.element, c = b.nodeName, k = a.inverted, e = this.top - ("shape" === c ? b.offsetTop : 0), h = this.left, b = h + this.width, n = e + this.height, e = {
                            clip: "rect(" + Math.round(k ? h : e) + "px," + Math.round(k ? n : b) + "px," + Math.round(k ? b : n) + "px," + Math.round(k ? e : h) + "px)"
                        };
                        !k && a.docMode8 && "DIV" === c && d(e, {
                            width: b + "px",
                            height: n + "px"
                        });
                        return e;
                    },
                    updateClipping: function() {
                        l(e.members, function(a) {
                            a.element && a.css(e.getCSS(a));
                        });
                    }
                });
            },
            color: function(b, c, n, m) {
                var e = this, d, x = /^rgba/, p, t, k = "none";
                b && b.linearGradient ? t = "gradient" : b && b.radialGradient && (t = "pattern");
                if (t) {
                    var D, w, z = b.linearGradient || b.radialGradient, f, E, v, q, g, F = "";
                    b = b.stops;
                    var C, u = [], r = function() {
                        p = [ '<fill colors="' + u.join(",") + '" opacity="', v, '" o:opacity2="', E, '" type="', t, '" ', F, 'focus="100%" method="any" />' ];
                        H(e.prepVML(p), null, null, c);
                    };
                    f = b[0];
                    C = b[b.length - 1];
                    0 < f[0] && b.unshift([ 0, f[1] ]);
                    1 > C[0] && b.push([ 1, C[1] ]);
                    l(b, function(k, b) {
                        x.test(k[1]) ? (d = a.color(k[1]), D = d.get("rgb"), w = d.get("a")) : (D = k[1], 
                        w = 1);
                        u.push(100 * k[0] + "% " + D);
                        b ? (v = w, q = D) : (E = w, g = D);
                    });
                    if ("fill" === n) if ("gradient" === t) n = z.x1 || z[0] || 0, b = z.y1 || z[1] || 0, 
                    f = z.x2 || z[2] || 0, z = z.y2 || z[3] || 0, F = 'angle="' + (90 - 180 * Math.atan((z - b) / (f - n)) / Math.PI) + '"', 
                    r(); else {
                        var k = z.r, A = 2 * k, B = 2 * k, G = z.cx, U = z.cy, L = c.radialReference, T, k = function() {
                            L && (T = m.getBBox(), G += (L[0] - T.x) / T.width - .5, U += (L[1] - T.y) / T.height - .5, 
                            A *= L[2] / T.width, B *= L[2] / T.height);
                            F = 'src="' + a.getOptions().global.VMLRadialGradientURL + '" size="' + A + "," + B + '" origin="0.5,0.5" position="' + G + "," + U + '" color2="' + g + '" ';
                            r();
                        };
                        m.added ? k() : m.onAdd = k;
                        k = q;
                    } else k = D;
                } else x.test(b) && "IMG" !== c.tagName ? (d = a.color(b), m[n + "-opacitySetter"](d.get("a"), n, c), 
                k = d.get("rgb")) : (k = c.getElementsByTagName(n), k.length && (k[0].opacity = 1, 
                k[0].type = "solid"), k = b);
                return k;
            },
            prepVML: function(a) {
                var b = this.isIE8;
                a = a.join("");
                b ? (a = a.replace("/>", ' xmlns="urn:schemas-microsoft-com:vml" />'), a = -1 === a.indexOf('style="') ? a.replace("/>", ' style="display:inline-block;behavior:url(#default#VML);" />') : a.replace('style="', 'style="display:inline-block;behavior:url(#default#VML);')) : a = a.replace("<", "<hcv:");
                return a;
            },
            text: E.prototype.html,
            path: function(a) {
                var c = {
                    coordsize: "10 10"
                };
                b(a) ? c.d = a : C(a) && d(c, a);
                return this.createElement("shape").attr(c);
            },
            circle: function(a, b, c) {
                var e = this.symbol("circle");
                C(a) && (c = a.r, b = a.y, a = a.x);
                e.isCircle = !0;
                e.r = c;
                return e.attr({
                    x: a,
                    y: b
                });
            },
            g: function(a) {
                var b;
                a && (b = {
                    className: "highcharts-" + a,
                    "class": "highcharts-" + a
                });
                return this.createElement("div").attr(b);
            },
            image: function(a, b, c, n, h) {
                var e = this.createElement("img").attr({
                    src: a
                });
                1 < arguments.length && e.attr({
                    x: b,
                    y: c,
                    width: n,
                    height: h
                });
                return e;
            },
            createElement: function(a) {
                return "rect" === a ? this.symbol(a) : E.prototype.createElement.call(this, a);
            },
            invertChild: function(a, b) {
                var e = this;
                b = b.style;
                var n = "IMG" === a.tagName && a.style;
                G(a, {
                    flip: "x",
                    left: c(b.width) - (n ? c(n.top) : 1),
                    top: c(b.height) - (n ? c(n.left) : 1),
                    rotation: -90
                });
                l(a.childNodes, function(b) {
                    e.invertChild(b, a);
                });
            },
            symbols: {
                arc: function(a, b, c, n, h) {
                    var e = h.start, m = h.end, d = h.r || c || n;
                    c = h.innerR;
                    n = Math.cos(e);
                    var p = Math.sin(e), k = Math.cos(m), D = Math.sin(m);
                    if (0 === m - e) return [ "x" ];
                    e = [ "wa", a - d, b - d, a + d, b + d, a + d * n, b + d * p, a + d * k, b + d * D ];
                    h.open && !c && e.push("e", "M", a, b);
                    e.push("at", a - c, b - c, a + c, b + c, a + c * k, b + c * D, a + c * n, b + c * p, "x", "e");
                    e.isArc = !0;
                    return e;
                },
                circle: function(a, b, c, n, h) {
                    h && r(h.r) && (c = n = 2 * h.r);
                    h && h.isCircle && (a -= c / 2, b -= n / 2);
                    return [ "wa", a, b, a + c, b + n, a + c, b + n / 2, a + c, b + n / 2, "e" ];
                },
                rect: function(a, b, c, n, h) {
                    return E.prototype.symbols[r(h) && h.r ? "callout" : "square"].call(0, a, b, c, n, h);
                }
            }
        }, a.VMLRenderer = B = function() {
            this.init.apply(this, arguments);
        }, B.prototype = t(E.prototype, A), a.Renderer = B);
        E.prototype.measureSpanWidth = function(a, b) {
            var c = u.createElement("span");
            a = u.createTextNode(a);
            c.appendChild(a);
            G(c, b);
            this.box.appendChild(c);
            b = c.offsetWidth;
            f(c);
            return b;
        };
    })(L);
    (function(a) {
        function B() {
            var l = a.defaultOptions.global, f = u.moment;
            if (l.timezone) {
                if (f) return function(a) {
                    return -f.tz(a, l.timezone).utcOffset();
                };
                a.error(25);
            }
            return l.useUTC && l.getTimezoneOffset;
        }
        function A() {
            var l = a.defaultOptions.global, q, d = l.useUTC, b = d ? "getUTC" : "get", p = d ? "setUTC" : "set";
            a.Date = q = l.Date || u.Date;
            q.hcTimezoneOffset = d && l.timezoneOffset;
            q.hcGetTimezoneOffset = B();
            q.hcMakeTime = function(a, b, m, c, n, p) {
                var l;
                d ? (l = q.UTC.apply(0, arguments), l += r(l)) : l = new q(a, b, f(m, 1), f(c, 0), f(n, 0), f(p, 0)).getTime();
                return l;
            };
            G("Minutes Hours Day Date Month FullYear".split(" "), function(a) {
                q["hcGet" + a] = b + a;
            });
            G("Milliseconds Seconds Minutes Hours Date Month FullYear".split(" "), function(a) {
                q["hcSet" + a] = p + a;
            });
        }
        var H = a.color, G = a.each, r = a.getTZOffset, g = a.merge, f = a.pick, u = a.win;
        a.defaultOptions = {
            colors: "#7cb5ec #434348 #90ed7d #f7a35c #8085e9 #f15c80 #e4d354 #2b908f #f45b5b #91e8e1".split(" "),
            symbols: [ "circle", "diamond", "square", "triangle", "triangle-down" ],
            lang: {
                loading: "Loading...",
                months: "January February March April May June July August September October November December".split(" "),
                shortMonths: "Jan Feb Mar Apr May Jun Jul Aug Sep Oct Nov Dec".split(" "),
                weekdays: "Sunday Monday Tuesday Wednesday Thursday Friday Saturday".split(" "),
                decimalPoint: ".",
                numericSymbols: "kMGTPE".split(""),
                resetZoom: "Reset zoom",
                resetZoomTitle: "Reset zoom level 1:1",
                thousandsSep: " "
            },
            global: {
                useUTC: !0,
                VMLRadialGradientURL: "http://code.highcharts.com/5.0.7/gfx/vml-radial-gradient.png"
            },
            chart: {
                borderRadius: 0,
                defaultSeriesType: "line",
                ignoreHiddenSeries: !0,
                spacing: [ 10, 10, 15, 10 ],
                resetZoomButton: {
                    theme: {
                        zIndex: 20
                    },
                    position: {
                        align: "right",
                        x: -10,
                        y: 10
                    }
                },
                width: null,
                height: null,
                borderColor: "#335cad",
                backgroundColor: "#ffffff",
                plotBorderColor: "#cccccc"
            },
            title: {
                text: "Chart title",
                align: "center",
                margin: 15,
                widthAdjust: -44
            },
            subtitle: {
                text: "",
                align: "center",
                widthAdjust: -44
            },
            plotOptions: {},
            labels: {
                style: {
                    position: "absolute",
                    color: "#333333"
                }
            },
            legend: {
                enabled: !0,
                align: "center",
                layout: "horizontal",
                labelFormatter: function() {
                    return this.name;
                },
                borderColor: "#999999",
                borderRadius: 0,
                navigation: {
                    activeColor: "#003399",
                    inactiveColor: "#cccccc"
                },
                itemStyle: {
                    color: "#333333",
                    fontSize: "12px",
                    fontWeight: "bold"
                },
                itemHoverStyle: {
                    color: "#000000"
                },
                itemHiddenStyle: {
                    color: "#cccccc"
                },
                shadow: !1,
                itemCheckboxStyle: {
                    position: "absolute",
                    width: "13px",
                    height: "13px"
                },
                squareSymbol: !0,
                symbolPadding: 5,
                verticalAlign: "bottom",
                x: 0,
                y: 0,
                title: {
                    style: {
                        fontWeight: "bold"
                    }
                }
            },
            loading: {
                labelStyle: {
                    fontWeight: "bold",
                    position: "relative",
                    top: "45%"
                },
                style: {
                    position: "absolute",
                    backgroundColor: "#ffffff",
                    opacity: .5,
                    textAlign: "center"
                }
            },
            tooltip: {
                enabled: !0,
                animation: a.svg,
                borderRadius: 3,
                dateTimeLabelFormats: {
                    millisecond: "%A, %b %e, %H:%M:%S.%L",
                    second: "%A, %b %e, %H:%M:%S",
                    minute: "%A, %b %e, %H:%M",
                    hour: "%A, %b %e, %H:%M",
                    day: "%A, %b %e, %Y",
                    week: "Week from %A, %b %e, %Y",
                    month: "%B %Y",
                    year: "%Y"
                },
                footerFormat: "",
                padding: 8,
                snap: a.isTouchDevice ? 25 : 10,
                backgroundColor: H("#f7f7f7").setOpacity(.85).get(),
                borderWidth: 1,
                headerFormat: '<span style="font-size: 10px">{point.key}</span><br/>',
                pointFormat: '<span style="color:{point.color}">â</span> {series.name}: <b>{point.y}</b><br/>',
                shadow: !0,
                style: {
                    color: "#333333",
                    cursor: "default",
                    fontSize: "12px",
                    pointerEvents: "none",
                    whiteSpace: "nowrap"
                }
            },
            credits: {
                enabled: !0,
                href: "http://www.highcharts.com",
                position: {
                    align: "right",
                    x: -10,
                    verticalAlign: "bottom",
                    y: -5
                },
                style: {
                    cursor: "pointer",
                    color: "#999999",
                    fontSize: "9px"
                },
                text: "Highcharts.com"
            }
        };
        a.setOptions = function(l) {
            a.defaultOptions = g(!0, a.defaultOptions, l);
            A();
            return a.defaultOptions;
        };
        a.getOptions = function() {
            return a.defaultOptions;
        };
        a.defaultPlotOptions = a.defaultOptions.plotOptions;
        A();
    })(L);
    (function(a) {
        var B = a.arrayMax, A = a.arrayMin, H = a.defined, G = a.destroyObjectProperties, r = a.each, g = a.erase, f = a.merge, u = a.pick;
        a.PlotLineOrBand = function(a, f) {
            this.axis = a;
            f && (this.options = f, this.id = f.id);
        };
        a.PlotLineOrBand.prototype = {
            render: function() {
                var a = this, q = a.axis, d = q.horiz, b = a.options, p = b.label, g = a.label, t = b.to, m = b.from, c = b.value, n = H(m) && H(t), E = H(c), z = a.svgElem, e = !z, x = [], F, w = b.color, h = u(b.zIndex, 0), y = b.events, x = {
                    "class": "highcharts-plot-" + (n ? "band " : "line ") + (b.className || "")
                }, J = {}, K = q.chart.renderer, I = n ? "bands" : "lines", k = q.log2lin;
                q.isLog && (m = k(m), t = k(t), c = k(c));
                E ? (x = {
                    stroke: w,
                    "stroke-width": b.width
                }, b.dashStyle && (x.dashstyle = b.dashStyle)) : n && (w && (x.fill = w), b.borderWidth && (x.stroke = b.borderColor, 
                x["stroke-width"] = b.borderWidth));
                J.zIndex = h;
                I += "-" + h;
                (w = q[I]) || (q[I] = w = K.g("plot-" + I).attr(J).add());
                e && (a.svgElem = z = K.path().attr(x).add(w));
                if (E) x = q.getPlotLinePath(c, z.strokeWidth()); else if (n) x = q.getPlotBandPath(m, t, b); else return;
                if (e && x && x.length) {
                    if (z.attr({
                        d: x
                    }), y) for (F in b = function(b) {
                        z.on(b, function(k) {
                            y[b].apply(a, [ k ]);
                        });
                    }, y) b(F);
                } else z && (x ? (z.show(), z.animate({
                    d: x
                })) : (z.hide(), g && (a.label = g = g.destroy())));
                p && H(p.text) && x && x.length && 0 < q.width && 0 < q.height && !x.flat ? (p = f({
                    align: d && n && "center",
                    x: d ? !n && 4 : 10,
                    verticalAlign: !d && n && "middle",
                    y: d ? n ? 16 : 10 : n ? 6 : -4,
                    rotation: d && !n && 90
                }, p), this.renderLabel(p, x, n, h)) : g && g.hide();
                return a;
            },
            renderLabel: function(a, f, d, b) {
                var p = this.label, l = this.axis.chart.renderer;
                p || (p = {
                    align: a.textAlign || a.align,
                    rotation: a.rotation,
                    "class": "highcharts-plot-" + (d ? "band" : "line") + "-label " + (a.className || "")
                }, p.zIndex = b, this.label = p = l.text(a.text, 0, 0, a.useHTML).attr(p).add(), 
                p.css(a.style));
                b = [ f[1], f[4], d ? f[6] : f[1] ];
                f = [ f[2], f[5], d ? f[7] : f[2] ];
                d = A(b);
                l = A(f);
                p.align(a, !1, {
                    x: d,
                    y: l,
                    width: B(b) - d,
                    height: B(f) - l
                });
                p.show();
            },
            destroy: function() {
                g(this.axis.plotLinesAndBands, this);
                delete this.axis;
                G(this);
            }
        };
        a.AxisPlotLineOrBandExtension = {
            getPlotBandPath: function(a, f) {
                f = this.getPlotLinePath(f, null, null, !0);
                (a = this.getPlotLinePath(a, null, null, !0)) && f ? (a.flat = a.toString() === f.toString(), 
                a.push(f[4], f[5], f[1], f[2], "z")) : a = null;
                return a;
            },
            addPlotBand: function(a) {
                return this.addPlotBandOrLine(a, "plotBands");
            },
            addPlotLine: function(a) {
                return this.addPlotBandOrLine(a, "plotLines");
            },
            addPlotBandOrLine: function(f, g) {
                var d = new a.PlotLineOrBand(this, f).render(), b = this.userOptions;
                d && (g && (b[g] = b[g] || [], b[g].push(f)), this.plotLinesAndBands.push(d));
                return d;
            },
            removePlotBandOrLine: function(a) {
                for (var f = this.plotLinesAndBands, d = this.options, b = this.userOptions, p = f.length; p--; ) f[p].id === a && f[p].destroy();
                r([ d.plotLines || [], b.plotLines || [], d.plotBands || [], b.plotBands || [] ], function(b) {
                    for (p = b.length; p--; ) b[p].id === a && g(b, b[p]);
                });
            }
        };
    })(L);
    (function(a) {
        var B = a.correctFloat, A = a.defined, H = a.destroyObjectProperties, G = a.isNumber, r = a.merge, g = a.pick, f = a.deg2rad;
        a.Tick = function(a, f, g, d) {
            this.axis = a;
            this.pos = f;
            this.type = g || "";
            this.isNew = !0;
            g || d || this.addLabel();
        };
        a.Tick.prototype = {
            addLabel: function() {
                var a = this.axis, f = a.options, q = a.chart, d = a.categories, b = a.names, p = this.pos, C = f.labels, t = a.tickPositions, m = p === t[0], c = p === t[t.length - 1], b = d ? g(d[p], b[p], p) : p, d = this.label, t = t.info, n;
                a.isDatetimeAxis && t && (n = f.dateTimeLabelFormats[t.higherRanks[p] || t.unitName]);
                this.isFirst = m;
                this.isLast = c;
                f = a.labelFormatter.call({
                    axis: a,
                    chart: q,
                    isFirst: m,
                    isLast: c,
                    dateTimeLabelFormat: n,
                    value: a.isLog ? B(a.lin2log(b)) : b
                });
                A(d) ? d && d.attr({
                    text: f
                }) : (this.labelLength = (this.label = d = A(f) && C.enabled ? q.renderer.text(f, 0, 0, C.useHTML).css(r(C.style)).add(a.labelGroup) : null) && d.getBBox().width, 
                this.rotation = 0);
            },
            getLabelSize: function() {
                return this.label ? this.label.getBBox()[this.axis.horiz ? "height" : "width"] : 0;
            },
            handleOverflow: function(a) {
                var l = this.axis, q = a.x, d = l.chart.chartWidth, b = l.chart.spacing, p = g(l.labelLeft, Math.min(l.pos, b[3])), b = g(l.labelRight, Math.max(l.pos + l.len, d - b[1])), C = this.label, t = this.rotation, m = {
                    left: 0,
                    center: .5,
                    right: 1
                }[l.labelAlign], c = C.getBBox().width, n = l.getSlotWidth(), E = n, z = 1, e, x = {};
                if (t) 0 > t && q - m * c < p ? e = Math.round(q / Math.cos(t * f) - p) : 0 < t && q + m * c > b && (e = Math.round((d - q) / Math.cos(t * f))); else if (d = q + (1 - m) * c, 
                q - m * c < p ? E = a.x + E * (1 - m) - p : d > b && (E = b - a.x + E * m, z = -1), 
                E = Math.min(n, E), E < n && "center" === l.labelAlign && (a.x += z * (n - E - m * (n - Math.min(c, E)))), 
                c > E || l.autoRotation && (C.styles || {}).width) e = E;
                e && (x.width = e, (l.options.labels.style || {}).textOverflow || (x.textOverflow = "ellipsis"), 
                C.css(x));
            },
            getPosition: function(a, f, g, d) {
                var b = this.axis, p = b.chart, l = d && p.oldChartHeight || p.chartHeight;
                return {
                    x: a ? b.translate(f + g, null, null, d) + b.transB : b.left + b.offset + (b.opposite ? (d && p.oldChartWidth || p.chartWidth) - b.right - b.left : 0),
                    y: a ? l - b.bottom + b.offset - (b.opposite ? b.height : 0) : l - b.translate(f + g, null, null, d) - b.transB
                };
            },
            getLabelPosition: function(a, g, q, d, b, p, C, t) {
                var m = this.axis, c = m.transA, n = m.reversed, E = m.staggerLines, z = m.tickRotCorr || {
                    x: 0,
                    y: 0
                }, e = b.y;
                A(e) || (e = 0 === m.side ? q.rotation ? -8 : -q.getBBox().height : 2 === m.side ? z.y + 8 : Math.cos(q.rotation * f) * (z.y - q.getBBox(!1, 0).height / 2));
                a = a + b.x + z.x - (p && d ? p * c * (n ? -1 : 1) : 0);
                g = g + e - (p && !d ? p * c * (n ? 1 : -1) : 0);
                E && (q = C / (t || 1) % E, m.opposite && (q = E - q - 1), g += m.labelOffset / E * q);
                return {
                    x: a,
                    y: Math.round(g)
                };
            },
            getMarkPath: function(a, f, g, d, b, p) {
                return p.crispLine([ "M", a, f, "L", a + (b ? 0 : -g), f + (b ? g : 0) ], d);
            },
            render: function(a, f, q) {
                var d = this.axis, b = d.options, p = d.chart.renderer, l = d.horiz, t = this.type, m = this.label, c = this.pos, n = b.labels, E = this.gridLine, z = t ? t + "Tick" : "tick", e = d.tickSize(z), x = this.mark, F = !x, w = n.step, h = {}, y = !0, J = d.tickmarkOffset, K = this.getPosition(l, c, J, f), I = K.x, K = K.y, k = l && I === d.pos + d.len || !l && K === d.pos ? -1 : 1, D = t ? t + "Grid" : "grid", P = b[D + "LineWidth"], N = b[D + "LineColor"], r = b[D + "LineDashStyle"], D = g(b[z + "Width"], !t && d.isXAxis ? 1 : 0), z = b[z + "Color"];
                q = g(q, 1);
                this.isActive = !0;
                E || (h.stroke = N, h["stroke-width"] = P, r && (h.dashstyle = r), t || (h.zIndex = 1), 
                f && (h.opacity = 0), this.gridLine = E = p.path().attr(h).addClass("highcharts-" + (t ? t + "-" : "") + "grid-line").add(d.gridGroup));
                if (!f && E && (c = d.getPlotLinePath(c + J, E.strokeWidth() * k, f, !0))) E[this.isNew ? "attr" : "animate"]({
                    d: c,
                    opacity: q
                });
                e && (d.opposite && (e[0] = -e[0]), F && (this.mark = x = p.path().addClass("highcharts-" + (t ? t + "-" : "") + "tick").add(d.axisGroup), 
                x.attr({
                    stroke: z,
                    "stroke-width": D
                })), x[F ? "attr" : "animate"]({
                    d: this.getMarkPath(I, K, e[0], x.strokeWidth() * k, l, p),
                    opacity: q
                }));
                m && G(I) && (m.xy = K = this.getLabelPosition(I, K, m, l, n, J, a, w), this.isFirst && !this.isLast && !g(b.showFirstLabel, 1) || this.isLast && !this.isFirst && !g(b.showLastLabel, 1) ? y = !1 : !l || d.isRadial || n.step || n.rotation || f || 0 === q || this.handleOverflow(K), 
                w && a % w && (y = !1), y && G(K.y) ? (K.opacity = q, m[this.isNew ? "attr" : "animate"](K)) : m.attr("y", -9999), 
                this.isNew = !1);
            },
            destroy: function() {
                H(this, this.axis);
            }
        };
    })(L);
    (function(a) {
        var B = a.addEvent, A = a.animObject, H = a.arrayMax, G = a.arrayMin, r = a.AxisPlotLineOrBandExtension, g = a.color, f = a.correctFloat, u = a.defaultOptions, l = a.defined, q = a.deg2rad, d = a.destroyObjectProperties, b = a.each, p = a.extend, C = a.fireEvent, t = a.format, m = a.getMagnitude, c = a.grep, n = a.inArray, E = a.isArray, z = a.isNumber, e = a.isString, x = a.merge, F = a.normalizeTickInterval, w = a.pick, h = a.PlotLineOrBand, y = a.removeEvent, J = a.splat, K = a.syncTimeout, I = a.Tick;
        a.Axis = function() {
            this.init.apply(this, arguments);
        };
        a.Axis.prototype = {
            defaultOptions: {
                dateTimeLabelFormats: {
                    millisecond: "%H:%M:%S.%L",
                    second: "%H:%M:%S",
                    minute: "%H:%M",
                    hour: "%H:%M",
                    day: "%e. %b",
                    week: "%e. %b",
                    month: "%b '%y",
                    year: "%Y"
                },
                endOnTick: !1,
                labels: {
                    enabled: !0,
                    style: {
                        color: "#666666",
                        cursor: "default",
                        fontSize: "11px"
                    },
                    x: 0
                },
                minPadding: .01,
                maxPadding: .01,
                minorTickLength: 2,
                minorTickPosition: "outside",
                startOfWeek: 1,
                startOnTick: !1,
                tickLength: 10,
                tickmarkPlacement: "between",
                tickPixelInterval: 100,
                tickPosition: "outside",
                title: {
                    align: "middle",
                    style: {
                        color: "#666666"
                    }
                },
                type: "linear",
                minorGridLineColor: "#f2f2f2",
                minorGridLineWidth: 1,
                minorTickColor: "#999999",
                lineColor: "#ccd6eb",
                lineWidth: 1,
                gridLineColor: "#e6e6e6",
                tickColor: "#ccd6eb"
            },
            defaultYAxisOptions: {
                endOnTick: !0,
                tickPixelInterval: 72,
                showLastLabel: !0,
                labels: {
                    x: -8
                },
                maxPadding: .05,
                minPadding: .05,
                startOnTick: !0,
                title: {
                    rotation: 270,
                    text: "Values"
                },
                stackLabels: {
                    enabled: !1,
                    formatter: function() {
                        return a.numberFormat(this.total, -1);
                    },
                    style: {
                        fontSize: "11px",
                        fontWeight: "bold",
                        color: "#000000",
                        textOutline: "1px contrast"
                    }
                },
                gridLineWidth: 1,
                lineWidth: 0
            },
            defaultLeftAxisOptions: {
                labels: {
                    x: -15
                },
                title: {
                    rotation: 270
                }
            },
            defaultRightAxisOptions: {
                labels: {
                    x: 15
                },
                title: {
                    rotation: 90
                }
            },
            defaultBottomAxisOptions: {
                labels: {
                    autoRotation: [ -45 ],
                    x: 0
                },
                title: {
                    rotation: 0
                }
            },
            defaultTopAxisOptions: {
                labels: {
                    autoRotation: [ -45 ],
                    x: 0
                },
                title: {
                    rotation: 0
                }
            },
            init: function(a, b) {
                var k = b.isX;
                this.chart = a;
                this.horiz = a.inverted ? !k : k;
                this.isXAxis = k;
                this.coll = this.coll || (k ? "xAxis" : "yAxis");
                this.opposite = b.opposite;
                this.side = b.side || (this.horiz ? this.opposite ? 0 : 2 : this.opposite ? 1 : 3);
                this.setOptions(b);
                var c = this.options, e = c.type;
                this.labelFormatter = c.labels.formatter || this.defaultLabelFormatter;
                this.userOptions = b;
                this.minPixelPadding = 0;
                this.reversed = c.reversed;
                this.visible = !1 !== c.visible;
                this.zoomEnabled = !1 !== c.zoomEnabled;
                this.hasNames = "category" === e || !0 === c.categories;
                this.categories = c.categories || this.hasNames;
                this.names = this.names || [];
                this.isLog = "logarithmic" === e;
                this.isDatetimeAxis = "datetime" === e;
                this.isLinked = l(c.linkedTo);
                this.ticks = {};
                this.labelEdge = [];
                this.minorTicks = {};
                this.plotLinesAndBands = [];
                this.alternateBands = {};
                this.len = 0;
                this.minRange = this.userMinRange = c.minRange || c.maxZoom;
                this.range = c.range;
                this.offset = c.offset || 0;
                this.stacks = {};
                this.oldStacks = {};
                this.stacksTouched = 0;
                this.min = this.max = null;
                this.crosshair = w(c.crosshair, J(a.options.tooltip.crosshairs)[k ? 0 : 1], !1);
                var h;
                b = this.options.events;
                -1 === n(this, a.axes) && (k ? a.axes.splice(a.xAxis.length, 0, this) : a.axes.push(this), 
                a[this.coll].push(this));
                this.series = this.series || [];
                a.inverted && k && void 0 === this.reversed && (this.reversed = !0);
                this.removePlotLine = this.removePlotBand = this.removePlotBandOrLine;
                for (h in b) B(this, h, b[h]);
                this.isLog && (this.val2lin = this.log2lin, this.lin2val = this.lin2log);
            },
            setOptions: function(a) {
                this.options = x(this.defaultOptions, "yAxis" === this.coll && this.defaultYAxisOptions, [ this.defaultTopAxisOptions, this.defaultRightAxisOptions, this.defaultBottomAxisOptions, this.defaultLeftAxisOptions ][this.side], x(u[this.coll], a));
            },
            defaultLabelFormatter: function() {
                var b = this.axis, c = this.value, e = b.categories, h = this.dateTimeLabelFormat, n = u.lang, d = n.numericSymbols, n = n.numericSymbolMagnitude || 1e3, v = d && d.length, m, f = b.options.labels.format, b = b.isLog ? c : b.tickInterval;
                if (f) m = t(f, this); else if (e) m = c; else if (h) m = a.dateFormat(h, c); else if (v && 1e3 <= b) for (;v-- && void 0 === m; ) e = Math.pow(n, v + 1), 
                b >= e && 0 === 10 * c % e && null !== d[v] && 0 !== c && (m = a.numberFormat(c / e, -1) + d[v]);
                void 0 === m && (m = 1e4 <= Math.abs(c) ? a.numberFormat(c, -1) : a.numberFormat(c, -1, void 0, ""));
                return m;
            },
            getSeriesExtremes: function() {
                var a = this, e = a.chart;
                a.hasVisibleSeries = !1;
                a.dataMin = a.dataMax = a.threshold = null;
                a.softThreshold = !a.isXAxis;
                a.buildStacks && a.buildStacks();
                b(a.series, function(b) {
                    if (b.visible || !e.options.chart.ignoreHiddenSeries) {
                        var k = b.options, h = k.threshold, D;
                        a.hasVisibleSeries = !0;
                        a.isLog && 0 >= h && (h = null);
                        if (a.isXAxis) k = b.xData, k.length && (b = G(k), z(b) || b instanceof Date || (k = c(k, function(a) {
                            return z(a);
                        }), b = G(k)), a.dataMin = Math.min(w(a.dataMin, k[0]), b), a.dataMax = Math.max(w(a.dataMax, k[0]), H(k))); else if (b.getExtremes(), 
                        D = b.dataMax, b = b.dataMin, l(b) && l(D) && (a.dataMin = Math.min(w(a.dataMin, b), b), 
                        a.dataMax = Math.max(w(a.dataMax, D), D)), l(h) && (a.threshold = h), !k.softThreshold || a.isLog) a.softThreshold = !1;
                    }
                });
            },
            translate: function(a, b, c, e, h, n) {
                var k = this.linkedParent || this, D = 1, m = 0, d = e ? k.oldTransA : k.transA;
                e = e ? k.oldMin : k.min;
                var f = k.minPixelPadding;
                h = (k.isOrdinal || k.isBroken || k.isLog && h) && k.lin2val;
                d || (d = k.transA);
                c && (D *= -1, m = k.len);
                k.reversed && (D *= -1, m -= D * (k.sector || k.len));
                b ? (a = (a * D + m - f) / d + e, h && (a = k.lin2val(a))) : (h && (a = k.val2lin(a)), 
                a = D * (a - e) * d + m + D * f + (z(n) ? d * n : 0));
                return a;
            },
            toPixels: function(a, b) {
                return this.translate(a, !1, !this.horiz, null, !0) + (b ? 0 : this.pos);
            },
            toValue: function(a, b) {
                return this.translate(a - (b ? 0 : this.pos), !0, !this.horiz, null, !0);
            },
            getPlotLinePath: function(a, b, c, e, h) {
                var k = this.chart, D = this.left, n = this.top, m, d, f = c && k.oldChartHeight || k.chartHeight, p = c && k.oldChartWidth || k.chartWidth, y;
                m = this.transB;
                var t = function(a, b, k) {
                    if (a < b || a > k) e ? a = Math.min(Math.max(b, a), k) : y = !0;
                    return a;
                };
                h = w(h, this.translate(a, null, null, c));
                a = c = Math.round(h + m);
                m = d = Math.round(f - h - m);
                z(h) ? this.horiz ? (m = n, d = f - this.bottom, a = c = t(a, D, D + this.width)) : (a = D, 
                c = p - this.right, m = d = t(m, n, n + this.height)) : y = !0;
                return y && !e ? null : k.renderer.crispLine([ "M", a, m, "L", c, d ], b || 1);
            },
            getLinearTickPositions: function(a, b, c) {
                var k, e = f(Math.floor(b / a) * a), h = f(Math.ceil(c / a) * a), D = [];
                if (b === c && z(b)) return [ b ];
                for (b = e; b <= h; ) {
                    D.push(b);
                    b = f(b + a);
                    if (b === k) break;
                    k = b;
                }
                return D;
            },
            getMinorTickPositions: function() {
                var a = this.options, b = this.tickPositions, c = this.minorTickInterval, e = [], h, n = this.pointRangePadding || 0;
                h = this.min - n;
                var n = this.max + n, m = n - h;
                if (m && m / c < this.len / 3) if (this.isLog) for (n = b.length, h = 1; h < n; h++) e = e.concat(this.getLogTickPositions(c, b[h - 1], b[h], !0)); else if (this.isDatetimeAxis && "auto" === a.minorTickInterval) e = e.concat(this.getTimeTicks(this.normalizeTimeTickInterval(c), h, n, a.startOfWeek)); else for (b = h + (b[0] - h) % c; b <= n && b !== e[0]; b += c) e.push(b);
                0 !== e.length && this.trimTicks(e, a.startOnTick, a.endOnTick);
                return e;
            },
            adjustForMinRange: function() {
                var a = this.options, c = this.min, e = this.max, h, n = this.dataMax - this.dataMin >= this.minRange, m, v, d, f, p, y;
                this.isXAxis && void 0 === this.minRange && !this.isLog && (l(a.min) || l(a.max) ? this.minRange = null : (b(this.series, function(a) {
                    f = a.xData;
                    for (v = p = a.xIncrement ? 1 : f.length - 1; 0 < v; v--) if (d = f[v] - f[v - 1], 
                    void 0 === m || d < m) m = d;
                }), this.minRange = Math.min(5 * m, this.dataMax - this.dataMin)));
                e - c < this.minRange && (y = this.minRange, h = (y - e + c) / 2, h = [ c - h, w(a.min, c - h) ], 
                n && (h[2] = this.isLog ? this.log2lin(this.dataMin) : this.dataMin), c = H(h), 
                e = [ c + y, w(a.max, c + y) ], n && (e[2] = this.isLog ? this.log2lin(this.dataMax) : this.dataMax), 
                e = G(e), e - c < y && (h[0] = e - y, h[1] = w(a.min, e - y), c = H(h)));
                this.min = c;
                this.max = e;
            },
            getClosest: function() {
                var a;
                this.categories ? a = 1 : b(this.series, function(b) {
                    var k = b.closestPointRange, c = b.visible || !b.chart.options.chart.ignoreHiddenSeries;
                    !b.noSharedTooltip && l(k) && c && (a = l(a) ? Math.min(a, k) : k);
                });
                return a;
            },
            nameToX: function(a) {
                var b = E(this.categories), k = b ? this.categories : this.names, c = a.options.x, e;
                a.series.requireSorting = !1;
                l(c) || (c = !1 === this.options.uniqueNames ? a.series.autoIncrement() : n(a.name, k));
                -1 === c ? b || (e = k.length) : e = c;
                this.names[e] = a.name;
                return e;
            },
            updateNames: function() {
                var a = this;
                0 < this.names.length && (this.names.length = 0, this.minRange = void 0, b(this.series || [], function(k) {
                    k.xIncrement = null;
                    if (!k.points || k.isDirtyData) k.processData(), k.generatePoints();
                    b(k.points, function(b, c) {
                        var e;
                        b.options && (e = a.nameToX(b), e !== b.x && (b.x = e, k.xData[c] = e));
                    });
                }));
            },
            setAxisTranslation: function(a) {
                var k = this, c = k.max - k.min, h = k.axisPointRange || 0, n, m = 0, d = 0, f = k.linkedParent, y = !!k.categories, p = k.transA, t = k.isXAxis;
                if (t || y || h) n = k.getClosest(), f ? (m = f.minPointOffset, d = f.pointRangePadding) : b(k.series, function(a) {
                    var b = y ? 1 : t ? w(a.options.pointRange, n, 0) : k.axisPointRange || 0;
                    a = a.options.pointPlacement;
                    h = Math.max(h, b);
                    k.single || (m = Math.max(m, e(a) ? 0 : b / 2), d = Math.max(d, "on" === a ? 0 : b));
                }), f = k.ordinalSlope && n ? k.ordinalSlope / n : 1, k.minPointOffset = m *= f, 
                k.pointRangePadding = d *= f, k.pointRange = Math.min(h, c), t && (k.closestPointRange = n);
                a && (k.oldTransA = p);
                k.translationSlope = k.transA = p = k.len / (c + d || 1);
                k.transB = k.horiz ? k.left : k.bottom;
                k.minPixelPadding = p * m;
            },
            minFromRange: function() {
                return this.max - this.range;
            },
            setTickInterval: function(k) {
                var c = this, e = c.chart, h = c.options, n = c.isLog, d = c.log2lin, v = c.isDatetimeAxis, y = c.isXAxis, p = c.isLinked, t = h.maxPadding, x = h.minPadding, g = h.tickInterval, E = h.tickPixelInterval, q = c.categories, J = c.threshold, K = c.softThreshold, I, r, u, A;
                v || q || p || this.getTickAmount();
                u = w(c.userMin, h.min);
                A = w(c.userMax, h.max);
                p ? (c.linkedParent = e[c.coll][h.linkedTo], e = c.linkedParent.getExtremes(), c.min = w(e.min, e.dataMin), 
                c.max = w(e.max, e.dataMax), h.type !== c.linkedParent.options.type && a.error(11, 1)) : (!K && l(J) && (c.dataMin >= J ? (I = J, 
                x = 0) : c.dataMax <= J && (r = J, t = 0)), c.min = w(u, I, c.dataMin), c.max = w(A, r, c.dataMax));
                n && (!k && 0 >= Math.min(c.min, w(c.dataMin, c.min)) && a.error(10, 1), c.min = f(d(c.min), 15), 
                c.max = f(d(c.max), 15));
                c.range && l(c.max) && (c.userMin = c.min = u = Math.max(c.min, c.minFromRange()), 
                c.userMax = A = c.max, c.range = null);
                C(c, "foundExtremes");
                c.beforePadding && c.beforePadding();
                c.adjustForMinRange();
                !(q || c.axisPointRange || c.usePercentage || p) && l(c.min) && l(c.max) && (d = c.max - c.min) && (!l(u) && x && (c.min -= d * x), 
                !l(A) && t && (c.max += d * t));
                z(h.floor) ? c.min = Math.max(c.min, h.floor) : z(h.softMin) && (c.min = Math.min(c.min, h.softMin));
                z(h.ceiling) ? c.max = Math.min(c.max, h.ceiling) : z(h.softMax) && (c.max = Math.max(c.max, h.softMax));
                K && l(c.dataMin) && (J = J || 0, !l(u) && c.min < J && c.dataMin >= J ? c.min = J : !l(A) && c.max > J && c.dataMax <= J && (c.max = J));
                c.tickInterval = c.min === c.max || void 0 === c.min || void 0 === c.max ? 1 : p && !g && E === c.linkedParent.options.tickPixelInterval ? g = c.linkedParent.tickInterval : w(g, this.tickAmount ? (c.max - c.min) / Math.max(this.tickAmount - 1, 1) : void 0, q ? 1 : (c.max - c.min) * E / Math.max(c.len, E));
                y && !k && b(c.series, function(a) {
                    a.processData(c.min !== c.oldMin || c.max !== c.oldMax);
                });
                c.setAxisTranslation(!0);
                c.beforeSetTickPositions && c.beforeSetTickPositions();
                c.postProcessTickInterval && (c.tickInterval = c.postProcessTickInterval(c.tickInterval));
                c.pointRange && !g && (c.tickInterval = Math.max(c.pointRange, c.tickInterval));
                k = w(h.minTickInterval, c.isDatetimeAxis && c.closestPointRange);
                !g && c.tickInterval < k && (c.tickInterval = k);
                v || n || g || (c.tickInterval = F(c.tickInterval, null, m(c.tickInterval), w(h.allowDecimals, !(.5 < c.tickInterval && 5 > c.tickInterval && 1e3 < c.max && 9999 > c.max)), !!this.tickAmount));
                this.tickAmount || (c.tickInterval = c.unsquish());
                this.setTickPositions();
            },
            setTickPositions: function() {
                var a = this.options, b, c = a.tickPositions, e = a.tickPositioner, h = a.startOnTick, n = a.endOnTick, m;
                this.tickmarkOffset = this.categories && "between" === a.tickmarkPlacement && 1 === this.tickInterval ? .5 : 0;
                this.minorTickInterval = "auto" === a.minorTickInterval && this.tickInterval ? this.tickInterval / 5 : a.minorTickInterval;
                this.tickPositions = b = c && c.slice();
                !b && (b = this.isDatetimeAxis ? this.getTimeTicks(this.normalizeTimeTickInterval(this.tickInterval, a.units), this.min, this.max, a.startOfWeek, this.ordinalPositions, this.closestPointRange, !0) : this.isLog ? this.getLogTickPositions(this.tickInterval, this.min, this.max) : this.getLinearTickPositions(this.tickInterval, this.min, this.max), 
                b.length > this.len && (b = [ b[0], b.pop() ]), this.tickPositions = b, e && (e = e.apply(this, [ this.min, this.max ]))) && (this.tickPositions = b = e);
                this.trimTicks(b, h, n);
                this.isLinked || (this.min === this.max && l(this.min) && !this.tickAmount && (m = !0, 
                this.min -= .5, this.max += .5), this.single = m, c || e || this.adjustTickAmount());
            },
            trimTicks: function(a, b, c) {
                var k = a[0], e = a[a.length - 1], h = this.minPointOffset || 0;
                if (!this.isLinked) {
                    if (b) this.min = k; else for (;this.min - h > a[0]; ) a.shift();
                    if (c) this.max = e; else for (;this.max + h < a[a.length - 1]; ) a.pop();
                    0 === a.length && l(k) && a.push((e + k) / 2);
                }
            },
            alignToOthers: function() {
                var a = {}, c, e = this.options;
                !1 === this.chart.options.chart.alignTicks || !1 === e.alignTicks || this.isLog || b(this.chart[this.coll], function(b) {
                    var k = b.options, k = [ b.horiz ? k.left : k.top, k.width, k.height, k.pane ].join();
                    b.series.length && (a[k] ? c = !0 : a[k] = 1);
                });
                return c;
            },
            getTickAmount: function() {
                var a = this.options, b = a.tickAmount, c = a.tickPixelInterval;
                !l(a.tickInterval) && this.len < c && !this.isRadial && !this.isLog && a.startOnTick && a.endOnTick && (b = 2);
                !b && this.alignToOthers() && (b = Math.ceil(this.len / c) + 1);
                4 > b && (this.finalTickAmt = b, b = 5);
                this.tickAmount = b;
            },
            adjustTickAmount: function() {
                var a = this.tickInterval, b = this.tickPositions, c = this.tickAmount, e = this.finalTickAmt, h = b && b.length;
                if (h < c) {
                    for (;b.length < c; ) b.push(f(b[b.length - 1] + a));
                    this.transA *= (h - 1) / (c - 1);
                    this.max = b[b.length - 1];
                } else h > c && (this.tickInterval *= 2, this.setTickPositions());
                if (l(e)) {
                    for (a = c = b.length; a--; ) (3 === e && 1 === a % 2 || 2 >= e && 0 < a && a < c - 1) && b.splice(a, 1);
                    this.finalTickAmt = void 0;
                }
            },
            setScale: function() {
                var a, c;
                this.oldMin = this.min;
                this.oldMax = this.max;
                this.oldAxisLength = this.len;
                this.setAxisSize();
                c = this.len !== this.oldAxisLength;
                b(this.series, function(b) {
                    if (b.isDirtyData || b.isDirty || b.xAxis.isDirty) a = !0;
                });
                c || a || this.isLinked || this.forceRedraw || this.userMin !== this.oldUserMin || this.userMax !== this.oldUserMax || this.alignToOthers() ? (this.resetStacks && this.resetStacks(), 
                this.forceRedraw = !1, this.getSeriesExtremes(), this.setTickInterval(), this.oldUserMin = this.userMin, 
                this.oldUserMax = this.userMax, this.isDirty || (this.isDirty = c || this.min !== this.oldMin || this.max !== this.oldMax)) : this.cleanStacks && this.cleanStacks();
            },
            setExtremes: function(a, c, e, h, n) {
                var k = this, m = k.chart;
                e = w(e, !0);
                b(k.series, function(a) {
                    delete a.kdTree;
                });
                n = p(n, {
                    min: a,
                    max: c
                });
                C(k, "setExtremes", n, function() {
                    k.userMin = a;
                    k.userMax = c;
                    k.eventArgs = n;
                    e && m.redraw(h);
                });
            },
            zoom: function(a, b) {
                var c = this.dataMin, k = this.dataMax, e = this.options, h = Math.min(c, w(e.min, c)), e = Math.max(k, w(e.max, k));
                if (a !== this.min || b !== this.max) this.allowZoomOutside || (l(c) && (a < h && (a = h), 
                a > e && (a = e)), l(k) && (b < h && (b = h), b > e && (b = e))), this.displayBtn = void 0 !== a || void 0 !== b, 
                this.setExtremes(a, b, !1, void 0, {
                    trigger: "zoom"
                });
                return !0;
            },
            setAxisSize: function() {
                var a = this.chart, b = this.options, c = b.offsets || [ 0, 0, 0, 0 ], e = this.horiz, h = w(b.width, a.plotWidth - c[3] + c[1]), n = w(b.height, a.plotHeight - c[0] + c[2]), m = w(b.top, a.plotTop + c[0]), b = w(b.left, a.plotLeft + c[3]), c = /%$/;
                c.test(n) && (n = Math.round(parseFloat(n) / 100 * a.plotHeight));
                c.test(m) && (m = Math.round(parseFloat(m) / 100 * a.plotHeight + a.plotTop));
                this.left = b;
                this.top = m;
                this.width = h;
                this.height = n;
                this.bottom = a.chartHeight - n - m;
                this.right = a.chartWidth - h - b;
                this.len = Math.max(e ? h : n, 0);
                this.pos = e ? b : m;
            },
            getExtremes: function() {
                var a = this.isLog, b = this.lin2log;
                return {
                    min: a ? f(b(this.min)) : this.min,
                    max: a ? f(b(this.max)) : this.max,
                    dataMin: this.dataMin,
                    dataMax: this.dataMax,
                    userMin: this.userMin,
                    userMax: this.userMax
                };
            },
            getThreshold: function(a) {
                var b = this.isLog, c = this.lin2log, k = b ? c(this.min) : this.min, b = b ? c(this.max) : this.max;
                null === a ? a = k : k > a ? a = k : b < a && (a = b);
                return this.translate(a, 0, 1, 0, 1);
            },
            autoLabelAlign: function(a) {
                a = (w(a, 0) - 90 * this.side + 720) % 360;
                return 15 < a && 165 > a ? "right" : 195 < a && 345 > a ? "left" : "center";
            },
            tickSize: function(a) {
                var b = this.options, c = b[a + "Length"], k = w(b[a + "Width"], "tick" === a && this.isXAxis ? 1 : 0);
                if (k && c) return "inside" === b[a + "Position"] && (c = -c), [ c, k ];
            },
            labelMetrics: function() {
                return this.chart.renderer.fontMetrics(this.options.labels.style && this.options.labels.style.fontSize, this.ticks[0] && this.ticks[0].label);
            },
            unsquish: function() {
                var a = this.options.labels, c = this.horiz, e = this.tickInterval, h = e, n = this.len / (((this.categories ? 1 : 0) + this.max - this.min) / e), m, d = a.rotation, f = this.labelMetrics(), p, y = Number.MAX_VALUE, t, x = function(a) {
                    a /= n || 1;
                    a = 1 < a ? Math.ceil(a) : 1;
                    return a * e;
                };
                c ? (t = !a.staggerLines && !a.step && (l(d) ? [ d ] : n < w(a.autoRotationLimit, 80) && a.autoRotation)) && b(t, function(a) {
                    var b;
                    if (a === d || a && -90 <= a && 90 >= a) p = x(Math.abs(f.h / Math.sin(q * a))), 
                    b = p + Math.abs(a / 360), b < y && (y = b, m = a, h = p);
                }) : a.step || (h = x(f.h));
                this.autoRotation = t;
                this.labelRotation = w(m, d);
                return h;
            },
            getSlotWidth: function() {
                var a = this.chart, b = this.horiz, c = this.options.labels, e = Math.max(this.tickPositions.length - (this.categories ? 0 : 1), 1), h = a.margin[3];
                return b && 2 > (c.step || 0) && !c.rotation && (this.staggerLines || 1) * this.len / e || !b && (h && h - a.spacing[3] || .33 * a.chartWidth);
            },
            renderUnsquish: function() {
                var a = this.chart, c = a.renderer, h = this.tickPositions, n = this.ticks, m = this.options.labels, d = this.horiz, v = this.getSlotWidth(), f = Math.max(1, Math.round(v - 2 * (m.padding || 5))), p = {}, y = this.labelMetrics(), t = m.style && m.style.textOverflow, g, z = 0, E, w;
                e(m.rotation) || (p.rotation = m.rotation || 0);
                b(h, function(a) {
                    (a = n[a]) && a.labelLength > z && (z = a.labelLength);
                });
                this.maxLabelLength = z;
                if (this.autoRotation) z > f && z > y.h ? p.rotation = this.labelRotation : this.labelRotation = 0; else if (v && (g = {
                    width: f + "px"
                }, !t)) for (g.textOverflow = "clip", E = h.length; !d && E--; ) if (w = h[E], f = n[w].label) f.styles && "ellipsis" === f.styles.textOverflow ? f.css({
                    textOverflow: "clip"
                }) : n[w].labelLength > v && f.css({
                    width: v + "px"
                }), f.getBBox().height > this.len / h.length - (y.h - y.f) && (f.specCss = {
                    textOverflow: "ellipsis"
                });
                p.rotation && (g = {
                    width: (z > .5 * a.chartHeight ? .33 * a.chartHeight : a.chartHeight) + "px"
                }, t || (g.textOverflow = "ellipsis"));
                if (this.labelAlign = m.align || this.autoLabelAlign(this.labelRotation)) p.align = this.labelAlign;
                b(h, function(a) {
                    var b = (a = n[a]) && a.label;
                    b && (b.attr(p), g && b.css(x(g, b.specCss)), delete b.specCss, a.rotation = p.rotation);
                });
                this.tickRotCorr = c.rotCorr(y.b, this.labelRotation || 0, 0 !== this.side);
            },
            hasData: function() {
                return this.hasVisibleSeries || l(this.min) && l(this.max) && !!this.tickPositions;
            },
            addTitle: function(a) {
                var b = this.chart.renderer, c = this.horiz, k = this.opposite, e = this.options.title, h;
                this.axisTitle || ((h = e.textAlign) || (h = (c ? {
                    low: "left",
                    middle: "center",
                    high: "right"
                } : {
                    low: k ? "right" : "left",
                    middle: "center",
                    high: k ? "left" : "right"
                })[e.align]), this.axisTitle = b.text(e.text, 0, 0, e.useHTML).attr({
                    zIndex: 7,
                    rotation: e.rotation || 0,
                    align: h
                }).addClass("highcharts-axis-title").css(e.style).add(this.axisGroup), this.axisTitle.isNew = !0);
                this.axisTitle[a ? "show" : "hide"](!0);
            },
            generateTick: function(a) {
                var b = this.ticks;
                b[a] ? b[a].addLabel() : b[a] = new I(this, a);
            },
            getOffset: function() {
                var a = this, c = a.chart, e = c.renderer, h = a.options, n = a.tickPositions, m = a.ticks, d = a.horiz, f = a.side, p = c.inverted ? [ 1, 0, 3, 2 ][f] : f, y, t, x = 0, g, z = 0, E = h.title, q = h.labels, F = 0, J = c.axisOffset, c = c.clipOffset, K = [ -1, 1, 1, -1 ][f], C, I = h.className, r = a.axisParent, u = this.tickSize("tick");
                y = a.hasData();
                a.showAxis = t = y || w(h.showEmpty, !0);
                a.staggerLines = a.horiz && q.staggerLines;
                a.axisGroup || (a.gridGroup = e.g("grid").attr({
                    zIndex: h.gridZIndex || 1
                }).addClass("highcharts-" + this.coll.toLowerCase() + "-grid " + (I || "")).add(r), 
                a.axisGroup = e.g("axis").attr({
                    zIndex: h.zIndex || 2
                }).addClass("highcharts-" + this.coll.toLowerCase() + " " + (I || "")).add(r), a.labelGroup = e.g("axis-labels").attr({
                    zIndex: q.zIndex || 7
                }).addClass("highcharts-" + a.coll.toLowerCase() + "-labels " + (I || "")).add(r));
                if (y || a.isLinked) b(n, function(b, c) {
                    a.generateTick(b, c);
                }), a.renderUnsquish(), !1 === q.reserveSpace || 0 !== f && 2 !== f && {
                    1: "left",
                    3: "right"
                }[f] !== a.labelAlign && "center" !== a.labelAlign || b(n, function(a) {
                    F = Math.max(m[a].getLabelSize(), F);
                }), a.staggerLines && (F *= a.staggerLines, a.labelOffset = F * (a.opposite ? -1 : 1)); else for (C in m) m[C].destroy(), 
                delete m[C];
                E && E.text && !1 !== E.enabled && (a.addTitle(t), t && (x = a.axisTitle.getBBox()[d ? "height" : "width"], 
                g = E.offset, z = l(g) ? 0 : w(E.margin, d ? 5 : 10)));
                a.renderLine();
                a.offset = K * w(h.offset, J[f]);
                a.tickRotCorr = a.tickRotCorr || {
                    x: 0,
                    y: 0
                };
                e = 0 === f ? -a.labelMetrics().h : 2 === f ? a.tickRotCorr.y : 0;
                z = Math.abs(F) + z;
                F && (z = z - e + K * (d ? w(q.y, a.tickRotCorr.y + 8 * K) : q.x));
                a.axisTitleMargin = w(g, z);
                J[f] = Math.max(J[f], a.axisTitleMargin + x + K * a.offset, z, y && n.length && u ? u[0] : 0);
                h = h.offset ? 0 : 2 * Math.floor(a.axisLine.strokeWidth() / 2);
                c[p] = Math.max(c[p], h);
            },
            getLinePath: function(a) {
                var b = this.chart, c = this.opposite, k = this.offset, e = this.horiz, h = this.left + (c ? this.width : 0) + k, k = b.chartHeight - this.bottom - (c ? this.height : 0) + k;
                c && (a *= -1);
                return b.renderer.crispLine([ "M", e ? this.left : h, e ? k : this.top, "L", e ? b.chartWidth - this.right : h, e ? k : b.chartHeight - this.bottom ], a);
            },
            renderLine: function() {
                this.axisLine || (this.axisLine = this.chart.renderer.path().addClass("highcharts-axis-line").add(this.axisGroup), 
                this.axisLine.attr({
                    stroke: this.options.lineColor,
                    "stroke-width": this.options.lineWidth,
                    zIndex: 7
                }));
            },
            getTitlePosition: function() {
                var a = this.horiz, b = this.left, c = this.top, e = this.len, h = this.options.title, n = a ? b : c, m = this.opposite, d = this.offset, f = h.x || 0, p = h.y || 0, y = this.chart.renderer.fontMetrics(h.style && h.style.fontSize, this.axisTitle).f, e = {
                    low: n + (a ? 0 : e),
                    middle: n + e / 2,
                    high: n + (a ? e : 0)
                }[h.align], b = (a ? c + this.height : b) + (a ? 1 : -1) * (m ? -1 : 1) * this.axisTitleMargin + (2 === this.side ? y : 0);
                return {
                    x: a ? e + f : b + (m ? this.width : 0) + d + f,
                    y: a ? b + p - (m ? this.height : 0) + d : e + p
                };
            },
            renderMinorTick: function(a) {
                var b = this.chart.hasRendered && z(this.oldMin), c = this.minorTicks;
                c[a] || (c[a] = new I(this, a, "minor"));
                b && c[a].isNew && c[a].render(null, !0);
                c[a].render(null, !1, 1);
            },
            renderTick: function(a, b) {
                var c = this.isLinked, e = this.ticks, k = this.chart.hasRendered && z(this.oldMin);
                if (!c || a >= this.min && a <= this.max) e[a] || (e[a] = new I(this, a)), k && e[a].isNew && e[a].render(b, !0, .1), 
                e[a].render(b);
            },
            render: function() {
                var a = this, c = a.chart, e = a.options, n = a.isLog, m = a.lin2log, d = a.isLinked, v = a.tickPositions, f = a.axisTitle, p = a.ticks, y = a.minorTicks, t = a.alternateBands, x = e.stackLabels, z = e.alternateGridColor, g = a.tickmarkOffset, E = a.axisLine, w = a.showAxis, l = A(c.renderer.globalAnimation), q, F;
                a.labelEdge.length = 0;
                a.overlap = !1;
                b([ p, y, t ], function(a) {
                    for (var b in a) a[b].isActive = !1;
                });
                if (a.hasData() || d) a.minorTickInterval && !a.categories && b(a.getMinorTickPositions(), function(b) {
                    a.renderMinorTick(b);
                }), v.length && (b(v, function(b, c) {
                    a.renderTick(b, c);
                }), g && (0 === a.min || a.single) && (p[-1] || (p[-1] = new I(a, (-1), null, (!0))), 
                p[-1].render(-1))), z && b(v, function(b, e) {
                    F = void 0 !== v[e + 1] ? v[e + 1] + g : a.max - g;
                    0 === e % 2 && b < a.max && F <= a.max + (c.polar ? -g : g) && (t[b] || (t[b] = new h(a)), 
                    q = b + g, t[b].options = {
                        from: n ? m(q) : q,
                        to: n ? m(F) : F,
                        color: z
                    }, t[b].render(), t[b].isActive = !0);
                }), a._addedPlotLB || (b((e.plotLines || []).concat(e.plotBands || []), function(b) {
                    a.addPlotBandOrLine(b);
                }), a._addedPlotLB = !0);
                b([ p, y, t ], function(a) {
                    var b, e, h = [], k = l.duration;
                    for (b in a) a[b].isActive || (a[b].render(b, !1, 0), a[b].isActive = !1, h.push(b));
                    K(function() {
                        for (e = h.length; e--; ) a[h[e]] && !a[h[e]].isActive && (a[h[e]].destroy(), delete a[h[e]]);
                    }, a !== t && c.hasRendered && k ? k : 0);
                });
                E && (E[E.isPlaced ? "animate" : "attr"]({
                    d: this.getLinePath(E.strokeWidth())
                }), E.isPlaced = !0, E[w ? "show" : "hide"](!0));
                f && w && (f[f.isNew ? "attr" : "animate"](a.getTitlePosition()), f.isNew = !1);
                x && x.enabled && a.renderStackTotals();
                a.isDirty = !1;
            },
            redraw: function() {
                this.visible && (this.render(), b(this.plotLinesAndBands, function(a) {
                    a.render();
                }));
                b(this.series, function(a) {
                    a.isDirty = !0;
                });
            },
            keepProps: "extKey hcEvents names series userMax userMin".split(" "),
            destroy: function(a) {
                var c = this, e = c.stacks, h, k = c.plotLinesAndBands, m;
                a || y(c);
                for (h in e) d(e[h]), e[h] = null;
                b([ c.ticks, c.minorTicks, c.alternateBands ], function(a) {
                    d(a);
                });
                if (k) for (a = k.length; a--; ) k[a].destroy();
                b("stackTotalGroup axisLine axisTitle axisGroup gridGroup labelGroup cross".split(" "), function(a) {
                    c[a] && (c[a] = c[a].destroy());
                });
                for (m in c) c.hasOwnProperty(m) && -1 === n(m, c.keepProps) && delete c[m];
            },
            drawCrosshair: function(a, b) {
                var c, e = this.crosshair, h = w(e.snap, !0), k, n = this.cross;
                a || (a = this.cross && this.cross.e);
                this.crosshair && !1 !== (l(b) || !h) ? (h ? l(b) && (k = this.isXAxis ? b.plotX : this.len - b.plotY) : k = a && (this.horiz ? a.chartX - this.pos : this.len - a.chartY + this.pos), 
                l(k) && (c = this.getPlotLinePath(b && (this.isXAxis ? b.x : w(b.stackY, b.y)), null, null, null, k) || null), 
                l(c) ? (b = this.categories && !this.isRadial, n || (this.cross = n = this.chart.renderer.path().addClass("highcharts-crosshair highcharts-crosshair-" + (b ? "category " : "thin ") + e.className).attr({
                    zIndex: w(e.zIndex, 2)
                }).add(), n.attr({
                    stroke: e.color || (b ? g("#ccd6eb").setOpacity(.25).get() : "#cccccc"),
                    "stroke-width": w(e.width, 1)
                }), e.dashStyle && n.attr({
                    dashstyle: e.dashStyle
                })), n.show().attr({
                    d: c
                }), b && !e.width && n.attr({
                    "stroke-width": this.transA
                }), this.cross.e = a) : this.hideCrosshair()) : this.hideCrosshair();
            },
            hideCrosshair: function() {
                this.cross && this.cross.hide();
            }
        };
        p(a.Axis.prototype, r);
    })(L);
    (function(a) {
        var B = a.Axis, A = a.Date, H = a.dateFormat, G = a.defaultOptions, r = a.defined, g = a.each, f = a.extend, u = a.getMagnitude, l = a.getTZOffset, q = a.normalizeTickInterval, d = a.pick, b = a.timeUnits;
        B.prototype.getTimeTicks = function(a, q, t, m) {
            var c = [], n = {}, p = G.global.useUTC, z, e = new A(q - l(q)), x = A.hcMakeTime, F = a.unitRange, w = a.count, h;
            if (r(q)) {
                e[A.hcSetMilliseconds](F >= b.second ? 0 : w * Math.floor(e.getMilliseconds() / w));
                if (F >= b.second) e[A.hcSetSeconds](F >= b.minute ? 0 : w * Math.floor(e.getSeconds() / w));
                if (F >= b.minute) e[A.hcSetMinutes](F >= b.hour ? 0 : w * Math.floor(e[A.hcGetMinutes]() / w));
                if (F >= b.hour) e[A.hcSetHours](F >= b.day ? 0 : w * Math.floor(e[A.hcGetHours]() / w));
                if (F >= b.day) e[A.hcSetDate](F >= b.month ? 1 : w * Math.floor(e[A.hcGetDate]() / w));
                F >= b.month && (e[A.hcSetMonth](F >= b.year ? 0 : w * Math.floor(e[A.hcGetMonth]() / w)), 
                z = e[A.hcGetFullYear]());
                if (F >= b.year) e[A.hcSetFullYear](z - z % w);
                if (F === b.week) e[A.hcSetDate](e[A.hcGetDate]() - e[A.hcGetDay]() + d(m, 1));
                z = e[A.hcGetFullYear]();
                m = e[A.hcGetMonth]();
                var y = e[A.hcGetDate](), J = e[A.hcGetHours]();
                if (A.hcTimezoneOffset || A.hcGetTimezoneOffset) h = (!p || !!A.hcGetTimezoneOffset) && (t - q > 4 * b.month || l(q) !== l(t)), 
                e = e.getTime(), e = new A(e + l(e));
                p = e.getTime();
                for (q = 1; p < t; ) c.push(p), p = F === b.year ? x(z + q * w, 0) : F === b.month ? x(z, m + q * w) : !h || F !== b.day && F !== b.week ? h && F === b.hour ? x(z, m, y, J + q * w) : p + F * w : x(z, m, y + q * w * (F === b.day ? 1 : 7)), 
                q++;
                c.push(p);
                F <= b.hour && 1e4 > c.length && g(c, function(a) {
                    0 === a % 18e5 && "000000000" === H("%H%M%S%L", a) && (n[a] = "day");
                });
            }
            c.info = f(a, {
                higherRanks: n,
                totalRange: F * w
            });
            return c;
        };
        B.prototype.normalizeTimeTickInterval = function(a, d) {
            var f = d || [ [ "millisecond", [ 1, 2, 5, 10, 20, 25, 50, 100, 200, 500 ] ], [ "second", [ 1, 2, 5, 10, 15, 30 ] ], [ "minute", [ 1, 2, 5, 10, 15, 30 ] ], [ "hour", [ 1, 2, 3, 4, 6, 8, 12 ] ], [ "day", [ 1, 2 ] ], [ "week", [ 1, 2 ] ], [ "month", [ 1, 2, 3, 4, 6 ] ], [ "year", null ] ];
            d = f[f.length - 1];
            var m = b[d[0]], c = d[1], n;
            for (n = 0; n < f.length && !(d = f[n], m = b[d[0]], c = d[1], f[n + 1] && a <= (m * c[c.length - 1] + b[f[n + 1][0]]) / 2); n++) ;
            m === b.year && a < 5 * m && (c = [ 1, 2, 5 ]);
            a = q(a / m, c, "year" === d[0] ? Math.max(u(a / m), 1) : 1);
            return {
                unitRange: m,
                count: a,
                unitName: d[0]
            };
        };
    })(L);
    (function(a) {
        var B = a.Axis, A = a.getMagnitude, H = a.map, G = a.normalizeTickInterval, r = a.pick;
        B.prototype.getLogTickPositions = function(a, f, u, l) {
            var g = this.options, d = this.len, b = this.lin2log, p = this.log2lin, C = [];
            l || (this._minorAutoInterval = null);
            if (.5 <= a) a = Math.round(a), C = this.getLinearTickPositions(a, f, u); else if (.08 <= a) for (var d = Math.floor(f), t, m, c, n, E, g = .3 < a ? [ 1, 2, 4 ] : .15 < a ? [ 1, 2, 4, 6, 8 ] : [ 1, 2, 3, 4, 5, 6, 7, 8, 9 ]; d < u + 1 && !E; d++) for (m = g.length, 
            t = 0; t < m && !E; t++) c = p(b(d) * g[t]), c > f && (!l || n <= u) && void 0 !== n && C.push(n), 
            n > u && (E = !0), n = c; else f = b(f), u = b(u), a = g[l ? "minorTickInterval" : "tickInterval"], 
            a = r("auto" === a ? null : a, this._minorAutoInterval, g.tickPixelInterval / (l ? 5 : 1) * (u - f) / ((l ? d / this.tickPositions.length : d) || 1)), 
            a = G(a, null, A(a)), C = H(this.getLinearTickPositions(a, f, u), p), l || (this._minorAutoInterval = a / 5);
            l || (this.tickInterval = a);
            return C;
        };
        B.prototype.log2lin = function(a) {
            return Math.log(a) / Math.LN10;
        };
        B.prototype.lin2log = function(a) {
            return Math.pow(10, a);
        };
    })(L);
    (function(a) {
        var B = a.dateFormat, A = a.each, H = a.extend, G = a.format, r = a.isNumber, g = a.map, f = a.merge, u = a.pick, l = a.splat, q = a.syncTimeout, d = a.timeUnits;
        a.Tooltip = function() {
            this.init.apply(this, arguments);
        };
        a.Tooltip.prototype = {
            init: function(a, d) {
                this.chart = a;
                this.options = d;
                this.crosshairs = [];
                this.now = {
                    x: 0,
                    y: 0
                };
                this.isHidden = !0;
                this.split = d.split && !a.inverted;
                this.shared = d.shared || this.split;
            },
            cleanSplit: function(a) {
                A(this.chart.series, function(b) {
                    var d = b && b.tt;
                    d && (!d.isActive || a ? b.tt = d.destroy() : d.isActive = !1);
                });
            },
            getLabel: function() {
                var a = this.chart.renderer, d = this.options;
                this.label || (this.split ? this.label = a.g("tooltip") : (this.label = a.label("", 0, 0, d.shape || "callout", null, null, d.useHTML, null, "tooltip").attr({
                    padding: d.padding,
                    r: d.borderRadius
                }), this.label.attr({
                    fill: d.backgroundColor,
                    "stroke-width": d.borderWidth
                }).css(d.style).shadow(d.shadow)), this.label.attr({
                    zIndex: 8
                }).add());
                return this.label;
            },
            update: function(a) {
                this.destroy();
                this.init(this.chart, f(!0, this.options, a));
            },
            destroy: function() {
                this.label && (this.label = this.label.destroy());
                this.split && this.tt && (this.cleanSplit(this.chart, !0), this.tt = this.tt.destroy());
                clearTimeout(this.hideTimer);
                clearTimeout(this.tooltipTimeout);
            },
            move: function(a, d, f, t) {
                var b = this, c = b.now, n = !1 !== b.options.animation && !b.isHidden && (1 < Math.abs(a - c.x) || 1 < Math.abs(d - c.y)), p = b.followPointer || 1 < b.len;
                H(c, {
                    x: n ? (2 * c.x + a) / 3 : a,
                    y: n ? (c.y + d) / 2 : d,
                    anchorX: p ? void 0 : n ? (2 * c.anchorX + f) / 3 : f,
                    anchorY: p ? void 0 : n ? (c.anchorY + t) / 2 : t
                });
                b.getLabel().attr(c);
                n && (clearTimeout(this.tooltipTimeout), this.tooltipTimeout = setTimeout(function() {
                    b && b.move(a, d, f, t);
                }, 32));
            },
            hide: function(a) {
                var b = this;
                clearTimeout(this.hideTimer);
                a = u(a, this.options.hideDelay, 500);
                this.isHidden || (this.hideTimer = q(function() {
                    b.getLabel()[a ? "fadeOut" : "hide"]();
                    b.isHidden = !0;
                }, a));
            },
            getAnchor: function(a, d) {
                var b, f = this.chart, m = f.inverted, c = f.plotTop, n = f.plotLeft, p = 0, z = 0, e, x;
                a = l(a);
                b = a[0].tooltipPos;
                this.followPointer && d && (void 0 === d.chartX && (d = f.pointer.normalize(d)), 
                b = [ d.chartX - f.plotLeft, d.chartY - c ]);
                b || (A(a, function(a) {
                    e = a.series.yAxis;
                    x = a.series.xAxis;
                    p += a.plotX + (!m && x ? x.left - n : 0);
                    z += (a.plotLow ? (a.plotLow + a.plotHigh) / 2 : a.plotY) + (!m && e ? e.top - c : 0);
                }), p /= a.length, z /= a.length, b = [ m ? f.plotWidth - z : p, this.shared && !m && 1 < a.length && d ? d.chartY - c : m ? f.plotHeight - p : z ]);
                return g(b, Math.round);
            },
            getPosition: function(a, d, f) {
                var b = this.chart, m = this.distance, c = {}, n = f.h || 0, p, z = [ "y", b.chartHeight, d, f.plotY + b.plotTop, b.plotTop, b.plotTop + b.plotHeight ], e = [ "x", b.chartWidth, a, f.plotX + b.plotLeft, b.plotLeft, b.plotLeft + b.plotWidth ], x = !this.followPointer && u(f.ttBelow, !b.inverted === !!f.negative), g = function(a, b, e, h, d, f) {
                    var k = e < h - m, y = h + m + e < b, p = h - m - e;
                    h += m;
                    if (x && y) c[a] = h; else if (!x && k) c[a] = p; else if (k) c[a] = Math.min(f - e, 0 > p - n ? p : p - n); else if (y) c[a] = Math.max(d, h + n + e > b ? h : h + n); else return !1;
                }, w = function(a, b, e, h) {
                    var k;
                    h < m || h > b - m ? k = !1 : c[a] = h < e / 2 ? 1 : h > b - e / 2 ? b - e - 2 : h - e / 2;
                    return k;
                }, h = function(a) {
                    var b = z;
                    z = e;
                    e = b;
                    p = a;
                }, y = function() {
                    !1 !== g.apply(0, z) ? !1 !== w.apply(0, e) || p || (h(!0), y()) : p ? c.x = c.y = 0 : (h(!0), 
                    y());
                };
                (b.inverted || 1 < this.len) && h();
                y();
                return c;
            },
            defaultFormatter: function(a) {
                var b = this.points || l(this), d;
                d = [ a.tooltipFooterHeaderFormatter(b[0]) ];
                d = d.concat(a.bodyFormatter(b));
                d.push(a.tooltipFooterHeaderFormatter(b[0], !0));
                return d;
            },
            refresh: function(a, d) {
                var b = this.chart, f, m = this.options, c, n, p = {}, z = [];
                f = m.formatter || this.defaultFormatter;
                var p = b.hoverPoints, e = this.shared;
                clearTimeout(this.hideTimer);
                this.followPointer = l(a)[0].series.tooltipOptions.followPointer;
                n = this.getAnchor(a, d);
                d = n[0];
                c = n[1];
                !e || a.series && a.series.noSharedTooltip ? p = a.getLabelConfig() : (b.hoverPoints = a, 
                p && A(p, function(a) {
                    a.setState();
                }), A(a, function(a) {
                    a.setState("hover");
                    z.push(a.getLabelConfig());
                }), p = {
                    x: a[0].category,
                    y: a[0].y
                }, p.points = z, a = a[0]);
                this.len = z.length;
                p = f.call(p, this);
                e = a.series;
                this.distance = u(e.tooltipOptions.distance, 16);
                !1 === p ? this.hide() : (f = this.getLabel(), this.isHidden && f.attr({
                    opacity: 1
                }).show(), this.split ? this.renderSplit(p, b.hoverPoints) : (f.attr({
                    text: p && p.join ? p.join("") : p
                }), f.removeClass(/highcharts-color-[\d]+/g).addClass("highcharts-color-" + u(a.colorIndex, e.colorIndex)), 
                f.attr({
                    stroke: m.borderColor || a.color || e.color || "#666666"
                }), this.updatePosition({
                    plotX: d,
                    plotY: c,
                    negative: a.negative,
                    ttBelow: a.ttBelow,
                    h: n[2] || 0
                })), this.isHidden = !1);
            },
            renderSplit: function(b, d) {
                var f = this, p = [], m = this.chart, c = m.renderer, n = !0, g = this.options, z, e = this.getLabel();
                A(b.slice(0, d.length + 1), function(a, b) {
                    b = d[b - 1] || {
                        isHeader: !0,
                        plotX: d[0].plotX
                    };
                    var x = b.series || f, h = x.tt, y = b.series || {}, t = "highcharts-color-" + u(b.colorIndex, y.colorIndex, "none");
                    h || (x.tt = h = c.label(null, null, null, "callout").addClass("highcharts-tooltip-box " + t).attr({
                        padding: g.padding,
                        r: g.borderRadius,
                        fill: g.backgroundColor,
                        stroke: b.color || y.color || "#333333",
                        "stroke-width": g.borderWidth
                    }).add(e));
                    h.isActive = !0;
                    h.attr({
                        text: a
                    });
                    h.css(g.style);
                    a = h.getBBox();
                    y = a.width + h.strokeWidth();
                    b.isHeader ? (z = a.height, y = Math.max(0, Math.min(b.plotX + m.plotLeft - y / 2, m.chartWidth - y))) : y = b.plotX + m.plotLeft - u(g.distance, 16) - y;
                    0 > y && (n = !1);
                    a = (b.series && b.series.yAxis && b.series.yAxis.pos) + (b.plotY || 0);
                    a -= m.plotTop;
                    p.push({
                        target: b.isHeader ? m.plotHeight + z : a,
                        rank: b.isHeader ? 1 : 0,
                        size: x.tt.getBBox().height + 1,
                        point: b,
                        x: y,
                        tt: h
                    });
                });
                this.cleanSplit();
                a.distribute(p, m.plotHeight + z);
                A(p, function(a) {
                    var b = a.point, c = b.series;
                    a.tt.attr({
                        visibility: void 0 === a.pos ? "hidden" : "inherit",
                        x: n || b.isHeader ? a.x : b.plotX + m.plotLeft + u(g.distance, 16),
                        y: a.pos + m.plotTop,
                        anchorX: b.isHeader ? b.plotX + m.plotLeft : b.plotX + c.xAxis.pos,
                        anchorY: b.isHeader ? a.pos + m.plotTop - 15 : b.plotY + c.yAxis.pos
                    });
                });
            },
            updatePosition: function(a) {
                var b = this.chart, d = this.getLabel(), d = (this.options.positioner || this.getPosition).call(this, d.width, d.height, a);
                this.move(Math.round(d.x), Math.round(d.y || 0), a.plotX + b.plotLeft, a.plotY + b.plotTop);
            },
            getDateFormat: function(a, f, g, t) {
                var b = B("%m-%d %H:%M:%S.%L", f), c, n, p = {
                    millisecond: 15,
                    second: 12,
                    minute: 9,
                    hour: 6,
                    day: 3
                }, z = "millisecond";
                for (n in d) {
                    if (a === d.week && +B("%w", f) === g && "00:00:00.000" === b.substr(6)) {
                        n = "week";
                        break;
                    }
                    if (d[n] > a) {
                        n = z;
                        break;
                    }
                    if (p[n] && b.substr(p[n]) !== "01-01 00:00:00.000".substr(p[n])) break;
                    "week" !== n && (z = n);
                }
                n && (c = t[n]);
                return c;
            },
            getXDateFormat: function(a, d, f) {
                d = d.dateTimeLabelFormats;
                var b = f && f.closestPointRange;
                return (b ? this.getDateFormat(b, a.x, f.options.startOfWeek, d) : d.day) || d.year;
            },
            tooltipFooterHeaderFormatter: function(a, d) {
                var b = d ? "footer" : "header";
                d = a.series;
                var f = d.tooltipOptions, m = f.xDateFormat, c = d.xAxis, n = c && "datetime" === c.options.type && r(a.key), b = f[b + "Format"];
                n && !m && (m = this.getXDateFormat(a, f, c));
                n && m && (b = b.replace("{point.key}", "{point.key:" + m + "}"));
                return G(b, {
                    point: a,
                    series: d
                });
            },
            bodyFormatter: function(a) {
                return g(a, function(a) {
                    var b = a.series.tooltipOptions;
                    return (b.pointFormatter || a.point.tooltipFormatter).call(a.point, b.pointFormat);
                });
            }
        };
    })(L);
    (function(a) {
        var B = a.addEvent, A = a.attr, H = a.charts, G = a.color, r = a.css, g = a.defined, f = a.doc, u = a.each, l = a.extend, q = a.fireEvent, d = a.offset, b = a.pick, p = a.removeEvent, C = a.splat, t = a.Tooltip, m = a.win;
        a.Pointer = function(a, b) {
            this.init(a, b);
        };
        a.Pointer.prototype = {
            init: function(a, d) {
                this.options = d;
                this.chart = a;
                this.runChartClick = d.chart.events && !!d.chart.events.click;
                this.pinchDown = [];
                this.lastValidTouch = {};
                t && d.tooltip.enabled && (a.tooltip = new t(a, d.tooltip), this.followTouchMove = b(d.tooltip.followTouchMove, !0));
                this.setDOMEvents();
            },
            zoomOption: function(a) {
                var c = this.chart, d = c.options.chart, m = d.zoomType || "", c = c.inverted;
                /touch/.test(a.type) && (m = b(d.pinchType, m));
                this.zoomX = a = /x/.test(m);
                this.zoomY = m = /y/.test(m);
                this.zoomHor = a && !c || m && c;
                this.zoomVert = m && !c || a && c;
                this.hasZoom = a || m;
            },
            normalize: function(a, b) {
                var c, n;
                a = a || m.event;
                a.target || (a.target = a.srcElement);
                n = a.touches ? a.touches.length ? a.touches.item(0) : a.changedTouches[0] : a;
                b || (this.chartPosition = b = d(this.chart.container));
                void 0 === n.pageX ? (c = Math.max(a.x, a.clientX - b.left), b = a.y) : (c = n.pageX - b.left, 
                b = n.pageY - b.top);
                return l(a, {
                    chartX: Math.round(c),
                    chartY: Math.round(b)
                });
            },
            getCoordinates: function(a) {
                var b = {
                    xAxis: [],
                    yAxis: []
                };
                u(this.chart.axes, function(c) {
                    b[c.isXAxis ? "xAxis" : "yAxis"].push({
                        axis: c,
                        value: c.toValue(a[c.horiz ? "chartX" : "chartY"])
                    });
                });
                return b;
            },
            runPointActions: function(c) {
                var d = this.chart, m = d.series, p = d.tooltip, e = p ? p.shared : !1, g = !0, t = d.hoverPoint, w = d.hoverSeries, h, y, l, q = [], r;
                if (!e && !w) for (h = 0; h < m.length; h++) if (m[h].directTouch || !m[h].options.stickyTracking) m = [];
                w && (e ? w.noSharedTooltip : w.directTouch) && t ? q = [ t ] : (e || !w || w.options.stickyTracking || (m = [ w ]), 
                u(m, function(a) {
                    y = a.noSharedTooltip && e;
                    l = !e && a.directTouch;
                    a.visible && !y && !l && b(a.options.enableMouseTracking, !0) && (r = a.searchPoint(c, !y && 1 === a.kdDimensions)) && r.series && q.push(r);
                }), q.sort(function(a, b) {
                    var c = a.distX - b.distX, h = a.dist - b.dist, k = (b.series.group && b.series.group.zIndex) - (a.series.group && a.series.group.zIndex);
                    return 0 !== c && e ? c : 0 !== h ? h : 0 !== k ? k : a.series.index > b.series.index ? -1 : 1;
                }));
                if (e) for (h = q.length; h--; ) (q[h].x !== q[0].x || q[h].series.noSharedTooltip) && q.splice(h, 1);
                if (q[0] && (q[0] !== this.prevKDPoint || p && p.isHidden)) {
                    if (e && !q[0].series.noSharedTooltip) {
                        for (h = 0; h < q.length; h++) q[h].onMouseOver(c, q[h] !== (w && w.directTouch && t || q[0]));
                        q.length && p && p.refresh(q.sort(function(a, b) {
                            return a.series.index - b.series.index;
                        }), c);
                    } else if (p && p.refresh(q[0], c), !w || !w.directTouch) q[0].onMouseOver(c);
                    this.prevKDPoint = q[0];
                    g = !1;
                }
                g && (m = w && w.tooltipOptions.followPointer, p && m && !p.isHidden && (m = p.getAnchor([ {} ], c), 
                p.updatePosition({
                    plotX: m[0],
                    plotY: m[1]
                })));
                this.unDocMouseMove || (this.unDocMouseMove = B(f, "mousemove", function(b) {
                    if (H[a.hoverChartIndex]) H[a.hoverChartIndex].pointer.onDocumentMouseMove(b);
                }));
                u(e ? q : [ b(t, q[0]) ], function(a) {
                    u(d.axes, function(b) {
                        (!a || a.series && a.series[b.coll] === b) && b.drawCrosshair(c, a);
                    });
                });
            },
            reset: function(a, b) {
                var c = this.chart, d = c.hoverSeries, e = c.hoverPoint, n = c.hoverPoints, m = c.tooltip, f = m && m.shared ? n : e;
                a && f && u(C(f), function(b) {
                    b.series.isCartesian && void 0 === b.plotX && (a = !1);
                });
                if (a) m && f && (m.refresh(f), e && (e.setState(e.state, !0), u(c.axes, function(a) {
                    a.crosshair && a.drawCrosshair(null, e);
                }))); else {
                    if (e) e.onMouseOut();
                    n && u(n, function(a) {
                        a.setState();
                    });
                    if (d) d.onMouseOut();
                    m && m.hide(b);
                    this.unDocMouseMove && (this.unDocMouseMove = this.unDocMouseMove());
                    u(c.axes, function(a) {
                        a.hideCrosshair();
                    });
                    this.hoverX = this.prevKDPoint = c.hoverPoints = c.hoverPoint = null;
                }
            },
            scaleGroups: function(a, b) {
                var c = this.chart, d;
                u(c.series, function(e) {
                    d = a || e.getPlotBox();
                    e.xAxis && e.xAxis.zoomEnabled && e.group && (e.group.attr(d), e.markerGroup && (e.markerGroup.attr(d), 
                    e.markerGroup.clip(b ? c.clipRect : null)), e.dataLabelsGroup && e.dataLabelsGroup.attr(d));
                });
                c.clipRect.attr(b || c.clipBox);
            },
            dragStart: function(a) {
                var b = this.chart;
                b.mouseIsDown = a.type;
                b.cancelClick = !1;
                b.mouseDownX = this.mouseDownX = a.chartX;
                b.mouseDownY = this.mouseDownY = a.chartY;
            },
            drag: function(a) {
                var b = this.chart, c = b.options.chart, d = a.chartX, e = a.chartY, m = this.zoomHor, f = this.zoomVert, p = b.plotLeft, h = b.plotTop, y = b.plotWidth, g = b.plotHeight, t, q = this.selectionMarker, k = this.mouseDownX, l = this.mouseDownY, r = c.panKey && a[c.panKey + "Key"];
                q && q.touch || (d < p ? d = p : d > p + y && (d = p + y), e < h ? e = h : e > h + g && (e = h + g), 
                this.hasDragged = Math.sqrt(Math.pow(k - d, 2) + Math.pow(l - e, 2)), 10 < this.hasDragged && (t = b.isInsidePlot(k - p, l - h), 
                b.hasCartesianSeries && (this.zoomX || this.zoomY) && t && !r && !q && (this.selectionMarker = q = b.renderer.rect(p, h, m ? 1 : y, f ? 1 : g, 0).attr({
                    fill: c.selectionMarkerFill || G("#335cad").setOpacity(.25).get(),
                    "class": "highcharts-selection-marker",
                    zIndex: 7
                }).add()), q && m && (d -= k, q.attr({
                    width: Math.abs(d),
                    x: (0 < d ? 0 : d) + k
                })), q && f && (d = e - l, q.attr({
                    height: Math.abs(d),
                    y: (0 < d ? 0 : d) + l
                })), t && !q && c.panning && b.pan(a, c.panning)));
            },
            drop: function(a) {
                var b = this, c = this.chart, d = this.hasPinched;
                if (this.selectionMarker) {
                    var e = {
                        originalEvent: a,
                        xAxis: [],
                        yAxis: []
                    }, m = this.selectionMarker, f = m.attr ? m.attr("x") : m.x, p = m.attr ? m.attr("y") : m.y, h = m.attr ? m.attr("width") : m.width, y = m.attr ? m.attr("height") : m.height, t;
                    if (this.hasDragged || d) u(c.axes, function(c) {
                        if (c.zoomEnabled && g(c.min) && (d || b[{
                            xAxis: "zoomX",
                            yAxis: "zoomY"
                        }[c.coll]])) {
                            var m = c.horiz, k = "touchend" === a.type ? c.minPixelPadding : 0, n = c.toValue((m ? f : p) + k), m = c.toValue((m ? f + h : p + y) - k);
                            e[c.coll].push({
                                axis: c,
                                min: Math.min(n, m),
                                max: Math.max(n, m)
                            });
                            t = !0;
                        }
                    }), t && q(c, "selection", e, function(a) {
                        c.zoom(l(a, d ? {
                            animation: !1
                        } : null));
                    });
                    this.selectionMarker = this.selectionMarker.destroy();
                    d && this.scaleGroups();
                }
                c && (r(c.container, {
                    cursor: c._cursor
                }), c.cancelClick = 10 < this.hasDragged, c.mouseIsDown = this.hasDragged = this.hasPinched = !1, 
                this.pinchDown = []);
            },
            onContainerMouseDown: function(a) {
                a = this.normalize(a);
                this.zoomOption(a);
                a.preventDefault && a.preventDefault();
                this.dragStart(a);
            },
            onDocumentMouseUp: function(b) {
                H[a.hoverChartIndex] && H[a.hoverChartIndex].pointer.drop(b);
            },
            onDocumentMouseMove: function(a) {
                var b = this.chart, c = this.chartPosition;
                a = this.normalize(a, c);
                !c || this.inClass(a.target, "highcharts-tracker") || b.isInsidePlot(a.chartX - b.plotLeft, a.chartY - b.plotTop) || this.reset();
            },
            onContainerMouseLeave: function(b) {
                var c = H[a.hoverChartIndex];
                c && (b.relatedTarget || b.toElement) && (c.pointer.reset(), c.pointer.chartPosition = null);
            },
            onContainerMouseMove: function(b) {
                var c = this.chart;
                g(a.hoverChartIndex) && H[a.hoverChartIndex] && H[a.hoverChartIndex].mouseIsDown || (a.hoverChartIndex = c.index);
                b = this.normalize(b);
                b.returnValue = !1;
                "mousedown" === c.mouseIsDown && this.drag(b);
                !this.inClass(b.target, "highcharts-tracker") && !c.isInsidePlot(b.chartX - c.plotLeft, b.chartY - c.plotTop) || c.openMenu || this.runPointActions(b);
            },
            inClass: function(a, b) {
                for (var c; a; ) {
                    if (c = A(a, "class")) {
                        if (-1 !== c.indexOf(b)) return !0;
                        if (-1 !== c.indexOf("highcharts-container")) return !1;
                    }
                    a = a.parentNode;
                }
            },
            onTrackerMouseOut: function(a) {
                var b = this.chart.hoverSeries;
                a = a.relatedTarget || a.toElement;
                if (!(!b || !a || b.options.stickyTracking || this.inClass(a, "highcharts-tooltip") || this.inClass(a, "highcharts-series-" + b.index) && this.inClass(a, "highcharts-tracker"))) b.onMouseOut();
            },
            onContainerClick: function(a) {
                var b = this.chart, c = b.hoverPoint, d = b.plotLeft, e = b.plotTop;
                a = this.normalize(a);
                b.cancelClick || (c && this.inClass(a.target, "highcharts-tracker") ? (q(c.series, "click", l(a, {
                    point: c
                })), b.hoverPoint && c.firePointEvent("click", a)) : (l(a, this.getCoordinates(a)), 
                b.isInsidePlot(a.chartX - d, a.chartY - e) && q(b, "click", a)));
            },
            setDOMEvents: function() {
                var b = this, d = b.chart.container;
                d.onmousedown = function(a) {
                    b.onContainerMouseDown(a);
                };
                d.onmousemove = function(a) {
                    b.onContainerMouseMove(a);
                };
                d.onclick = function(a) {
                    b.onContainerClick(a);
                };
                B(d, "mouseleave", b.onContainerMouseLeave);
                1 === a.chartCount && B(f, "mouseup", b.onDocumentMouseUp);
                a.hasTouch && (d.ontouchstart = function(a) {
                    b.onContainerTouchStart(a);
                }, d.ontouchmove = function(a) {
                    b.onContainerTouchMove(a);
                }, 1 === a.chartCount && B(f, "touchend", b.onDocumentTouchEnd));
            },
            destroy: function() {
                var b;
                p(this.chart.container, "mouseleave", this.onContainerMouseLeave);
                a.chartCount || (p(f, "mouseup", this.onDocumentMouseUp), p(f, "touchend", this.onDocumentTouchEnd));
                clearInterval(this.tooltipTimeout);
                for (b in this) this[b] = null;
            }
        };
    })(L);
    (function(a) {
        var B = a.charts, A = a.each, H = a.extend, G = a.map, r = a.noop, g = a.pick;
        H(a.Pointer.prototype, {
            pinchTranslate: function(a, g, l, q, d, b) {
                this.zoomHor && this.pinchTranslateDirection(!0, a, g, l, q, d, b);
                this.zoomVert && this.pinchTranslateDirection(!1, a, g, l, q, d, b);
            },
            pinchTranslateDirection: function(a, g, l, q, d, b, p, r) {
                var f = this.chart, m = a ? "x" : "y", c = a ? "X" : "Y", n = "chart" + c, E = a ? "width" : "height", z = f["plot" + (a ? "Left" : "Top")], e, x, F = r || 1, w = f.inverted, h = f.bounds[a ? "h" : "v"], y = 1 === g.length, J = g[0][n], u = l[0][n], I = !y && g[1][n], k = !y && l[1][n], D;
                l = function() {
                    !y && 20 < Math.abs(J - I) && (F = r || Math.abs(u - k) / Math.abs(J - I));
                    x = (z - u) / F + J;
                    e = f["plot" + (a ? "Width" : "Height")] / F;
                };
                l();
                g = x;
                g < h.min ? (g = h.min, D = !0) : g + e > h.max && (g = h.max - e, D = !0);
                D ? (u -= .8 * (u - p[m][0]), y || (k -= .8 * (k - p[m][1])), l()) : p[m] = [ u, k ];
                w || (b[m] = x - z, b[E] = e);
                b = w ? 1 / F : F;
                d[E] = e;
                d[m] = g;
                q[w ? a ? "scaleY" : "scaleX" : "scale" + c] = F;
                q["translate" + c] = b * z + (u - b * J);
            },
            pinch: function(a) {
                var f = this, l = f.chart, q = f.pinchDown, d = a.touches, b = d.length, p = f.lastValidTouch, C = f.hasZoom, t = f.selectionMarker, m = {}, c = 1 === b && (f.inClass(a.target, "highcharts-tracker") && l.runTrackerClick || f.runChartClick), n = {};
                1 < b && (f.initiated = !0);
                C && f.initiated && !c && a.preventDefault();
                G(d, function(a) {
                    return f.normalize(a);
                });
                "touchstart" === a.type ? (A(d, function(a, b) {
                    q[b] = {
                        chartX: a.chartX,
                        chartY: a.chartY
                    };
                }), p.x = [ q[0].chartX, q[1] && q[1].chartX ], p.y = [ q[0].chartY, q[1] && q[1].chartY ], 
                A(l.axes, function(a) {
                    if (a.zoomEnabled) {
                        var b = l.bounds[a.horiz ? "h" : "v"], c = a.minPixelPadding, d = a.toPixels(g(a.options.min, a.dataMin)), m = a.toPixels(g(a.options.max, a.dataMax)), f = Math.max(d, m);
                        b.min = Math.min(a.pos, Math.min(d, m) - c);
                        b.max = Math.max(a.pos + a.len, f + c);
                    }
                }), f.res = !0) : f.followTouchMove && 1 === b ? this.runPointActions(f.normalize(a)) : q.length && (t || (f.selectionMarker = t = H({
                    destroy: r,
                    touch: !0
                }, l.plotBox)), f.pinchTranslate(q, d, m, t, n, p), f.hasPinched = C, f.scaleGroups(m, n), 
                f.res && (f.res = !1, this.reset(!1, 0)));
            },
            touch: function(f, r) {
                var l = this.chart, q, d;
                if (l.index !== a.hoverChartIndex) this.onContainerMouseLeave({
                    relatedTarget: !0
                });
                a.hoverChartIndex = l.index;
                1 === f.touches.length ? (f = this.normalize(f), (d = l.isInsidePlot(f.chartX - l.plotLeft, f.chartY - l.plotTop)) && !l.openMenu ? (r && this.runPointActions(f), 
                "touchmove" === f.type && (r = this.pinchDown, q = r[0] ? 4 <= Math.sqrt(Math.pow(r[0].chartX - f.chartX, 2) + Math.pow(r[0].chartY - f.chartY, 2)) : !1), 
                g(q, !0) && this.pinch(f)) : r && this.reset()) : 2 === f.touches.length && this.pinch(f);
            },
            onContainerTouchStart: function(a) {
                this.zoomOption(a);
                this.touch(a, !0);
            },
            onContainerTouchMove: function(a) {
                this.touch(a);
            },
            onDocumentTouchEnd: function(f) {
                B[a.hoverChartIndex] && B[a.hoverChartIndex].pointer.drop(f);
            }
        });
    })(L);
    (function(a) {
        var B = a.addEvent, A = a.charts, H = a.css, G = a.doc, r = a.extend, g = a.noop, f = a.Pointer, u = a.removeEvent, l = a.win, q = a.wrap;
        if (l.PointerEvent || l.MSPointerEvent) {
            var d = {}, b = !!l.PointerEvent, p = function() {
                var a, b = [];
                b.item = function(a) {
                    return this[a];
                };
                for (a in d) d.hasOwnProperty(a) && b.push({
                    pageX: d[a].pageX,
                    pageY: d[a].pageY,
                    target: d[a].target
                });
                return b;
            }, C = function(b, d, c, f) {
                "touch" !== b.pointerType && b.pointerType !== b.MSPOINTER_TYPE_TOUCH || !A[a.hoverChartIndex] || (f(b), 
                f = A[a.hoverChartIndex].pointer, f[d]({
                    type: c,
                    target: b.currentTarget,
                    preventDefault: g,
                    touches: p()
                }));
            };
            r(f.prototype, {
                onContainerPointerDown: function(a) {
                    C(a, "onContainerTouchStart", "touchstart", function(a) {
                        d[a.pointerId] = {
                            pageX: a.pageX,
                            pageY: a.pageY,
                            target: a.currentTarget
                        };
                    });
                },
                onContainerPointerMove: function(a) {
                    C(a, "onContainerTouchMove", "touchmove", function(a) {
                        d[a.pointerId] = {
                            pageX: a.pageX,
                            pageY: a.pageY
                        };
                        d[a.pointerId].target || (d[a.pointerId].target = a.currentTarget);
                    });
                },
                onDocumentPointerUp: function(a) {
                    C(a, "onDocumentTouchEnd", "touchend", function(a) {
                        delete d[a.pointerId];
                    });
                },
                batchMSEvents: function(a) {
                    a(this.chart.container, b ? "pointerdown" : "MSPointerDown", this.onContainerPointerDown);
                    a(this.chart.container, b ? "pointermove" : "MSPointerMove", this.onContainerPointerMove);
                    a(G, b ? "pointerup" : "MSPointerUp", this.onDocumentPointerUp);
                }
            });
            q(f.prototype, "init", function(a, b, c) {
                a.call(this, b, c);
                this.hasZoom && H(b.container, {
                    "-ms-touch-action": "none",
                    "touch-action": "none"
                });
            });
            q(f.prototype, "setDOMEvents", function(a) {
                a.apply(this);
                (this.hasZoom || this.followTouchMove) && this.batchMSEvents(B);
            });
            q(f.prototype, "destroy", function(a) {
                this.batchMSEvents(u);
                a.call(this);
            });
        }
    })(L);
    (function(a) {
        var B, A = a.addEvent, H = a.css, G = a.discardElement, r = a.defined, g = a.each, f = a.extend, u = a.isFirefox, l = a.marginNames, q = a.merge, d = a.pick, b = a.setAnimation, p = a.stableSort, C = a.win, t = a.wrap;
        B = a.Legend = function(a, b) {
            this.init(a, b);
        };
        B.prototype = {
            init: function(a, b) {
                this.chart = a;
                this.setOptions(b);
                b.enabled && (this.render(), A(this.chart, "endResize", function() {
                    this.legend.positionCheckboxes();
                }));
            },
            setOptions: function(a) {
                var b = d(a.padding, 8);
                this.options = a;
                this.itemStyle = a.itemStyle;
                this.itemHiddenStyle = q(this.itemStyle, a.itemHiddenStyle);
                this.itemMarginTop = a.itemMarginTop || 0;
                this.initialItemX = this.padding = b;
                this.initialItemY = b - 5;
                this.itemHeight = this.maxItemWidth = 0;
                this.symbolWidth = d(a.symbolWidth, 16);
                this.pages = [];
            },
            update: function(a, b) {
                var c = this.chart;
                this.setOptions(q(!0, this.options, a));
                this.destroy();
                c.isDirtyLegend = c.isDirtyBox = !0;
                d(b, !0) && c.redraw();
            },
            colorizeItem: function(a, b) {
                a.legendGroup[b ? "removeClass" : "addClass"]("highcharts-legend-item-hidden");
                var c = this.options, d = a.legendItem, m = a.legendLine, e = a.legendSymbol, f = this.itemHiddenStyle.color, c = b ? c.itemStyle.color : f, p = b ? a.color || f : f, g = a.options && a.options.marker, h = {
                    fill: p
                }, y;
                d && d.css({
                    fill: c,
                    color: c
                });
                m && m.attr({
                    stroke: p
                });
                if (e) {
                    if (g && e.isMarker && (h = a.pointAttribs(), !b)) for (y in h) h[y] = f;
                    e.attr(h);
                }
            },
            positionItem: function(a) {
                var b = this.options, d = b.symbolPadding, b = !b.rtl, m = a._legendItemPos, f = m[0], m = m[1], e = a.checkbox;
                (a = a.legendGroup) && a.element && a.translate(b ? f : this.legendWidth - f - 2 * d - 4, m);
                e && (e.x = f, e.y = m);
            },
            destroyItem: function(a) {
                var b = a.checkbox;
                g([ "legendItem", "legendLine", "legendSymbol", "legendGroup" ], function(b) {
                    a[b] && (a[b] = a[b].destroy());
                });
                b && G(a.checkbox);
            },
            destroy: function() {
                function a(a) {
                    this[a] && (this[a] = this[a].destroy());
                }
                g(this.getAllItems(), function(b) {
                    g([ "legendItem", "legendGroup" ], a, b);
                });
                g([ "box", "title", "group" ], a, this);
                this.display = null;
            },
            positionCheckboxes: function(a) {
                var b = this.group && this.group.alignAttr, d, m = this.clipHeight || this.legendHeight, f = this.titleHeight;
                b && (d = b.translateY, g(this.allItems, function(c) {
                    var e = c.checkbox, n;
                    e && (n = d + f + e.y + (a || 0) + 3, H(e, {
                        left: b.translateX + c.checkboxOffset + e.x - 20 + "px",
                        top: n + "px",
                        display: n > d - 6 && n < d + m - 6 ? "" : "none"
                    }));
                }));
            },
            renderTitle: function() {
                var a = this.padding, b = this.options.title, d = 0;
                b.text && (this.title || (this.title = this.chart.renderer.label(b.text, a - 3, a - 4, null, null, null, null, null, "legend-title").attr({
                    zIndex: 1
                }).css(b.style).add(this.group)), a = this.title.getBBox(), d = a.height, this.offsetWidth = a.width, 
                this.contentGroup.attr({
                    translateY: d
                }));
                this.titleHeight = d;
            },
            setText: function(b) {
                var c = this.options;
                b.legendItem.attr({
                    text: c.labelFormat ? a.format(c.labelFormat, b) : c.labelFormatter.call(b)
                });
            },
            renderItem: function(a) {
                var b = this.chart, f = b.renderer, m = this.options, p = "horizontal" === m.layout, e = this.symbolWidth, g = m.symbolPadding, l = this.itemStyle, t = this.itemHiddenStyle, h = this.padding, y = p ? d(m.itemDistance, 20) : 0, J = !m.rtl, r = m.width, I = m.itemMarginBottom || 0, k = this.itemMarginTop, u = this.initialItemX, C = a.legendItem, N = !a.series, A = !N && a.series.drawLegendSymbol ? a.series : a, B = A.options, B = this.createCheckboxForItem && B && B.showCheckbox, v = m.useHTML;
                C || (a.legendGroup = f.g("legend-item").addClass("highcharts-" + A.type + "-series highcharts-color-" + a.colorIndex + (a.options.className ? " " + a.options.className : "") + (N ? " highcharts-series-" + a.index : "")).attr({
                    zIndex: 1
                }).add(this.scrollGroup), a.legendItem = C = f.text("", J ? e + g : -g, this.baseline || 0, v).css(q(a.visible ? l : t)).attr({
                    align: J ? "left" : "right",
                    zIndex: 2
                }).add(a.legendGroup), this.baseline || (l = l.fontSize, this.fontMetrics = f.fontMetrics(l, C), 
                this.baseline = this.fontMetrics.f + 3 + k, C.attr("y", this.baseline)), this.symbolHeight = m.symbolHeight || this.fontMetrics.f, 
                A.drawLegendSymbol(this, a), this.setItemEvents && this.setItemEvents(a, C, v), 
                B && this.createCheckboxForItem(a));
                this.colorizeItem(a, a.visible);
                this.setText(a);
                f = C.getBBox();
                e = a.checkboxOffset = m.itemWidth || a.legendItemWidth || e + g + f.width + y + (B ? 20 : 0);
                this.itemHeight = g = Math.round(a.legendItemHeight || f.height);
                p && this.itemX - u + e > (r || b.chartWidth - 2 * h - u - m.x) && (this.itemX = u, 
                this.itemY += k + this.lastLineHeight + I, this.lastLineHeight = 0);
                this.maxItemWidth = Math.max(this.maxItemWidth, e);
                this.lastItemY = k + this.itemY + I;
                this.lastLineHeight = Math.max(g, this.lastLineHeight);
                a._legendItemPos = [ this.itemX, this.itemY ];
                p ? this.itemX += e : (this.itemY += k + g + I, this.lastLineHeight = g);
                this.offsetWidth = r || Math.max((p ? this.itemX - u - y : e) + h, this.offsetWidth);
            },
            getAllItems: function() {
                var a = [];
                g(this.chart.series, function(b) {
                    var c = b && b.options;
                    b && d(c.showInLegend, r(c.linkedTo) ? !1 : void 0, !0) && (a = a.concat(b.legendItems || ("point" === c.legendType ? b.data : b)));
                });
                return a;
            },
            adjustMargins: function(a, b) {
                var c = this.chart, f = this.options, m = f.align.charAt(0) + f.verticalAlign.charAt(0) + f.layout.charAt(0);
                f.floating || g([ /(lth|ct|rth)/, /(rtv|rm|rbv)/, /(rbh|cb|lbh)/, /(lbv|lm|ltv)/ ], function(e, n) {
                    e.test(m) && !r(a[n]) && (c[l[n]] = Math.max(c[l[n]], c.legend[(n + 1) % 2 ? "legendHeight" : "legendWidth"] + [ 1, -1, -1, 1 ][n] * f[n % 2 ? "x" : "y"] + d(f.margin, 12) + b[n]));
                });
            },
            render: function() {
                var a = this, b = a.chart, d = b.renderer, q = a.group, l, e, t, r, w = a.box, h = a.options, y = a.padding;
                a.itemX = a.initialItemX;
                a.itemY = a.initialItemY;
                a.offsetWidth = 0;
                a.lastItemY = 0;
                q || (a.group = q = d.g("legend").attr({
                    zIndex: 7
                }).add(), a.contentGroup = d.g().attr({
                    zIndex: 1
                }).add(q), a.scrollGroup = d.g().add(a.contentGroup));
                a.renderTitle();
                l = a.getAllItems();
                p(l, function(a, b) {
                    return (a.options && a.options.legendIndex || 0) - (b.options && b.options.legendIndex || 0);
                });
                h.reversed && l.reverse();
                a.allItems = l;
                a.display = e = !!l.length;
                a.lastLineHeight = 0;
                g(l, function(b) {
                    a.renderItem(b);
                });
                t = (h.width || a.offsetWidth) + y;
                r = a.lastItemY + a.lastLineHeight + a.titleHeight;
                r = a.handleOverflow(r);
                r += y;
                w || (a.box = w = d.rect().addClass("highcharts-legend-box").attr({
                    r: h.borderRadius
                }).add(q), w.isNew = !0);
                w.attr({
                    stroke: h.borderColor,
                    "stroke-width": h.borderWidth || 0,
                    fill: h.backgroundColor || "none"
                }).shadow(h.shadow);
                0 < t && 0 < r && (w[w.isNew ? "attr" : "animate"](w.crisp({
                    x: 0,
                    y: 0,
                    width: t,
                    height: r
                }, w.strokeWidth())), w.isNew = !1);
                w[e ? "show" : "hide"]();
                a.legendWidth = t;
                a.legendHeight = r;
                g(l, function(b) {
                    a.positionItem(b);
                });
                e && q.align(f({
                    width: t,
                    height: r
                }, h), !0, "spacingBox");
                b.isResizing || this.positionCheckboxes();
            },
            handleOverflow: function(a) {
                var b = this, f = this.chart, m = f.renderer, p = this.options, e = p.y, f = f.spacingBox.height + ("top" === p.verticalAlign ? -e : e) - this.padding, e = p.maxHeight, q, l = this.clipRect, t = p.navigation, h = d(t.animation, !0), y = t.arrowSize || 12, r = this.nav, u = this.pages, I = this.padding, k, D = this.allItems, C = function(a) {
                    a ? l.attr({
                        height: a
                    }) : l && (b.clipRect = l.destroy(), b.contentGroup.clip());
                    b.contentGroup.div && (b.contentGroup.div.style.clip = a ? "rect(" + I + "px,9999px," + (I + a) + "px,0)" : "auto");
                };
                "horizontal" !== p.layout || "middle" === p.verticalAlign || p.floating || (f /= 2);
                e && (f = Math.min(f, e));
                u.length = 0;
                a > f && !1 !== t.enabled ? (this.clipHeight = q = Math.max(f - 20 - this.titleHeight - I, 0), 
                this.currentPage = d(this.currentPage, 1), this.fullHeight = a, g(D, function(a, b) {
                    var c = a._legendItemPos[1];
                    a = Math.round(a.legendItem.getBBox().height);
                    var e = u.length;
                    if (!e || c - u[e - 1] > q && (k || c) !== u[e - 1]) u.push(k || c), e++;
                    b === D.length - 1 && c + a - u[e - 1] > q && u.push(c);
                    c !== k && (k = c);
                }), l || (l = b.clipRect = m.clipRect(0, I, 9999, 0), b.contentGroup.clip(l)), C(q), 
                r || (this.nav = r = m.g().attr({
                    zIndex: 1
                }).add(this.group), this.up = m.symbol("triangle", 0, 0, y, y).on("click", function() {
                    b.scroll(-1, h);
                }).add(r), this.pager = m.text("", 15, 10).addClass("highcharts-legend-navigation").css(t.style).add(r), 
                this.down = m.symbol("triangle-down", 0, 0, y, y).on("click", function() {
                    b.scroll(1, h);
                }).add(r)), b.scroll(0), a = f) : r && (C(), r.hide(), this.scrollGroup.attr({
                    translateY: 1
                }), this.clipHeight = 0);
                return a;
            },
            scroll: function(a, c) {
                var d = this.pages, f = d.length;
                a = this.currentPage + a;
                var m = this.clipHeight, e = this.options.navigation, p = this.pager, g = this.padding;
                a > f && (a = f);
                0 < a && (void 0 !== c && b(c, this.chart), this.nav.attr({
                    translateX: g,
                    translateY: m + this.padding + 7 + this.titleHeight,
                    visibility: "visible"
                }), this.up.attr({
                    "class": 1 === a ? "highcharts-legend-nav-inactive" : "highcharts-legend-nav-active"
                }), p.attr({
                    text: a + "/" + f
                }), this.down.attr({
                    x: 18 + this.pager.getBBox().width,
                    "class": a === f ? "highcharts-legend-nav-inactive" : "highcharts-legend-nav-active"
                }), this.up.attr({
                    fill: 1 === a ? e.inactiveColor : e.activeColor
                }).css({
                    cursor: 1 === a ? "default" : "pointer"
                }), this.down.attr({
                    fill: a === f ? e.inactiveColor : e.activeColor
                }).css({
                    cursor: a === f ? "default" : "pointer"
                }), c = -d[a - 1] + this.initialItemY, this.scrollGroup.animate({
                    translateY: c
                }), this.currentPage = a, this.positionCheckboxes(c));
            }
        };
        a.LegendSymbolMixin = {
            drawRectangle: function(a, b) {
                var c = a.symbolHeight, f = a.options.squareSymbol;
                b.legendSymbol = this.chart.renderer.rect(f ? (a.symbolWidth - c) / 2 : 0, a.baseline - c + 1, f ? c : a.symbolWidth, c, d(a.options.symbolRadius, c / 2)).addClass("highcharts-point").attr({
                    zIndex: 3
                }).add(b.legendGroup);
            },
            drawLineMarker: function(a) {
                var b = this.options, f = b.marker, m = a.symbolWidth, p = a.symbolHeight, e = p / 2, g = this.chart.renderer, l = this.legendGroup;
                a = a.baseline - Math.round(.3 * a.fontMetrics.b);
                var t;
                t = {
                    "stroke-width": b.lineWidth || 0
                };
                b.dashStyle && (t.dashstyle = b.dashStyle);
                this.legendLine = g.path([ "M", 0, a, "L", m, a ]).addClass("highcharts-graph").attr(t).add(l);
                f && !1 !== f.enabled && (b = Math.min(d(f.radius, e), e), 0 === this.symbol.indexOf("url") && (f = q(f, {
                    width: p,
                    height: p
                }), b = 0), this.legendSymbol = f = g.symbol(this.symbol, m / 2 - b, a - b, 2 * b, 2 * b, f).addClass("highcharts-point").add(l), 
                f.isMarker = !0);
            }
        };
        (/Trident\/7\.0/.test(C.navigator.userAgent) || u) && t(B.prototype, "positionItem", function(a, b) {
            var c = this, d = function() {
                b._legendItemPos && a.call(c, b);
            };
            d();
            setTimeout(d);
        });
    })(L);
    (function(a) {
        var B = a.addEvent, A = a.animate, H = a.animObject, G = a.attr, r = a.doc, g = a.Axis, f = a.createElement, u = a.defaultOptions, l = a.discardElement, q = a.charts, d = a.css, b = a.defined, p = a.each, C = a.extend, t = a.find, m = a.fireEvent, c = a.getStyle, n = a.grep, E = a.isNumber, z = a.isObject, e = a.isString, x = a.Legend, F = a.marginNames, w = a.merge, h = a.Pointer, y = a.pick, J = a.pInt, K = a.removeEvent, I = a.seriesTypes, k = a.splat, D = a.svg, P = a.syncTimeout, N = a.win, S = a.Renderer, O = a.Chart = function() {
            this.getArgs.apply(this, arguments);
        };
        a.chart = function(a, b, c) {
            return new O(a, b, c);
        };
        O.prototype = {
            callbacks: [],
            getArgs: function() {
                var a = [].slice.call(arguments);
                if (e(a[0]) || a[0].nodeName) this.renderTo = a.shift();
                this.init(a[0], a[1]);
            },
            init: function(b, c) {
                var e, h = b.series;
                b.series = null;
                e = w(u, b);
                e.series = b.series = h;
                this.userOptions = b;
                this.respRules = [];
                b = e.chart;
                h = b.events;
                this.margin = [];
                this.spacing = [];
                this.bounds = {
                    h: {},
                    v: {}
                };
                this.callback = c;
                this.isResizing = 0;
                this.options = e;
                this.axes = [];
                this.series = [];
                this.hasCartesianSeries = b.showAxes;
                var d;
                this.index = q.length;
                q.push(this);
                a.chartCount++;
                if (h) for (d in h) B(this, d, h[d]);
                this.xAxis = [];
                this.yAxis = [];
                this.pointCount = this.colorCounter = this.symbolCounter = 0;
                this.firstRender();
            },
            initSeries: function(b) {
                var c = this.options.chart;
                (c = I[b.type || c.type || c.defaultSeriesType]) || a.error(17, !0);
                c = new c();
                c.init(this, b);
                return c;
            },
            orderSeries: function(a) {
                var b = this.series;
                for (a = a || 0; a < b.length; a++) b[a] && (b[a].index = a, b[a].name = b[a].name || "Series " + (b[a].index + 1));
            },
            isInsidePlot: function(a, b, c) {
                var e = c ? b : a;
                a = c ? a : b;
                return 0 <= e && e <= this.plotWidth && 0 <= a && a <= this.plotHeight;
            },
            redraw: function(b) {
                var c = this.axes, e = this.series, h = this.pointer, d = this.legend, k = this.isDirtyLegend, f, n, y = this.hasCartesianSeries, g = this.isDirtyBox, v = e.length, l = v, q = this.renderer, t = q.isHidden(), w = [];
                this.setResponsive && this.setResponsive(!1);
                a.setAnimation(b, this);
                t && this.cloneRenderTo();
                for (this.layOutTitles(); l--; ) if (b = e[l], b.options.stacking && (f = !0, b.isDirty)) {
                    n = !0;
                    break;
                }
                if (n) for (l = v; l--; ) b = e[l], b.options.stacking && (b.isDirty = !0);
                p(e, function(a) {
                    a.isDirty && "point" === a.options.legendType && (a.updateTotals && a.updateTotals(), 
                    k = !0);
                    a.isDirtyData && m(a, "updatedData");
                });
                k && d.options.enabled && (d.render(), this.isDirtyLegend = !1);
                f && this.getStacks();
                y && p(c, function(a) {
                    a.updateNames();
                    a.setScale();
                });
                this.getMargins();
                y && (p(c, function(a) {
                    a.isDirty && (g = !0);
                }), p(c, function(a) {
                    var b = a.min + "," + a.max;
                    a.extKey !== b && (a.extKey = b, w.push(function() {
                        m(a, "afterSetExtremes", C(a.eventArgs, a.getExtremes()));
                        delete a.eventArgs;
                    }));
                    (g || f) && a.redraw();
                }));
                g && this.drawChartBox();
                m(this, "predraw");
                p(e, function(a) {
                    (g || a.isDirty) && a.visible && a.redraw();
                    a.isDirtyData = !1;
                });
                h && h.reset(!0);
                q.draw();
                m(this, "redraw");
                m(this, "render");
                t && this.cloneRenderTo(!0);
                p(w, function(a) {
                    a.call();
                });
            },
            get: function(a) {
                function b(b) {
                    return b.id === a || b.options && b.options.id === a;
                }
                var c, e = this.series, h;
                c = t(this.axes, b) || t(this.series, b);
                for (h = 0; !c && h < e.length; h++) c = t(e[h].points || [], b);
                return c;
            },
            getAxes: function() {
                var a = this, b = this.options, c = b.xAxis = k(b.xAxis || {}), b = b.yAxis = k(b.yAxis || {});
                p(c, function(a, b) {
                    a.index = b;
                    a.isX = !0;
                });
                p(b, function(a, b) {
                    a.index = b;
                });
                c = c.concat(b);
                p(c, function(b) {
                    new g(a, b);
                });
            },
            getSelectedPoints: function() {
                var a = [];
                p(this.series, function(b) {
                    a = a.concat(n(b.points || [], function(a) {
                        return a.selected;
                    }));
                });
                return a;
            },
            getSelectedSeries: function() {
                return n(this.series, function(a) {
                    return a.selected;
                });
            },
            setTitle: function(a, b, c) {
                var e = this, h = e.options, d;
                d = h.title = w({
                    style: {
                        color: "#333333",
                        fontSize: h.isStock ? "16px" : "18px"
                    }
                }, h.title, a);
                h = h.subtitle = w({
                    style: {
                        color: "#666666"
                    }
                }, h.subtitle, b);
                p([ [ "title", a, d ], [ "subtitle", b, h ] ], function(a, b) {
                    var c = a[0], h = e[c], d = a[1];
                    a = a[2];
                    h && d && (e[c] = h = h.destroy());
                    a && a.text && !h && (e[c] = e.renderer.text(a.text, 0, 0, a.useHTML).attr({
                        align: a.align,
                        "class": "highcharts-" + c,
                        zIndex: a.zIndex || 4
                    }).add(), e[c].update = function(a) {
                        e.setTitle(!b && a, b && a);
                    }, e[c].css(a.style));
                });
                e.layOutTitles(c);
            },
            layOutTitles: function(a) {
                var b = 0, c, e = this.renderer, h = this.spacingBox;
                p([ "title", "subtitle" ], function(a) {
                    var c = this[a], d = this.options[a], k;
                    c && (k = d.style.fontSize, k = e.fontMetrics(k, c).b, c.css({
                        width: (d.width || h.width + d.widthAdjust) + "px"
                    }).align(C({
                        y: b + k + ("title" === a ? -3 : 2)
                    }, d), !1, "spacingBox"), d.floating || d.verticalAlign || (b = Math.ceil(b + c.getBBox().height)));
                }, this);
                c = this.titleOffset !== b;
                this.titleOffset = b;
                !this.isDirtyBox && c && (this.isDirtyBox = c, this.hasRendered && y(a, !0) && this.isDirtyBox && this.redraw());
            },
            getChartSize: function() {
                var a = this.options.chart, e = a.width, a = a.height, h = this.renderToClone || this.renderTo;
                b(e) || (this.containerWidth = c(h, "width"));
                b(a) || (this.containerHeight = c(h, "height"));
                this.chartWidth = Math.max(0, e || this.containerWidth || 600);
                this.chartHeight = Math.max(0, a || this.containerHeight || 400);
            },
            cloneRenderTo: function(a) {
                var b = this.renderToClone, c = this.container;
                if (a) {
                    if (b) {
                        for (;b.childNodes.length; ) this.renderTo.appendChild(b.firstChild);
                        l(b);
                        delete this.renderToClone;
                    }
                } else c && c.parentNode === this.renderTo && this.renderTo.removeChild(c), this.renderToClone = b = this.renderTo.cloneNode(0), 
                d(b, {
                    position: "absolute",
                    top: "-9999px",
                    display: "block"
                }), b.style.setProperty && b.style.setProperty("display", "block", "important"), 
                r.body.appendChild(b), c && b.appendChild(c);
            },
            setClassName: function(a) {
                this.container.className = "highcharts-container " + (a || "");
            },
            getContainer: function() {
                var b, c = this.options, h = c.chart, d, k;
                b = this.renderTo;
                var m = a.uniqueKey(), n;
                b || (this.renderTo = b = h.renderTo);
                e(b) && (this.renderTo = b = r.getElementById(b));
                b || a.error(13, !0);
                d = J(G(b, "data-highcharts-chart"));
                E(d) && q[d] && q[d].hasRendered && q[d].destroy();
                G(b, "data-highcharts-chart", this.index);
                b.innerHTML = "";
                h.skipClone || b.offsetWidth || this.cloneRenderTo();
                this.getChartSize();
                d = this.chartWidth;
                k = this.chartHeight;
                n = C({
                    position: "relative",
                    overflow: "hidden",
                    width: d + "px",
                    height: k + "px",
                    textAlign: "left",
                    lineHeight: "normal",
                    zIndex: 0,
                    "-webkit-tap-highlight-color": "rgba(0,0,0,0)"
                }, h.style);
                this.container = b = f("div", {
                    id: m
                }, n, this.renderToClone || b);
                this._cursor = b.style.cursor;
                this.renderer = new (a[h.renderer] || S)(b, d, k, null, h.forExport, c.exporting && c.exporting.allowHTML);
                this.setClassName(h.className);
                this.renderer.setStyle(h.style);
                this.renderer.chartIndex = this.index;
            },
            getMargins: function(a) {
                var c = this.spacing, e = this.margin, h = this.titleOffset;
                this.resetMargins();
                h && !b(e[0]) && (this.plotTop = Math.max(this.plotTop, h + this.options.title.margin + c[0]));
                this.legend.display && this.legend.adjustMargins(e, c);
                this.extraMargin && (this[this.extraMargin.type] = (this[this.extraMargin.type] || 0) + this.extraMargin.value);
                this.extraTopMargin && (this.plotTop += this.extraTopMargin);
                a || this.getAxisMargins();
            },
            getAxisMargins: function() {
                var a = this, c = a.axisOffset = [ 0, 0, 0, 0 ], e = a.margin;
                a.hasCartesianSeries && p(a.axes, function(a) {
                    a.visible && a.getOffset();
                });
                p(F, function(h, d) {
                    b(e[d]) || (a[h] += c[d]);
                });
                a.setChartSize();
            },
            reflow: function(a) {
                var e = this, h = e.options.chart, d = e.renderTo, k = b(h.width), f = h.width || c(d, "width"), h = h.height || c(d, "height"), d = a ? a.target : N;
                if (!k && !e.isPrinting && f && h && (d === N || d === r)) {
                    if (f !== e.containerWidth || h !== e.containerHeight) clearTimeout(e.reflowTimeout), 
                    e.reflowTimeout = P(function() {
                        e.container && e.setSize(void 0, void 0, !1);
                    }, a ? 100 : 0);
                    e.containerWidth = f;
                    e.containerHeight = h;
                }
            },
            initReflow: function() {
                var a = this, b;
                b = B(N, "resize", function(b) {
                    a.reflow(b);
                });
                B(a, "destroy", b);
            },
            setSize: function(b, c, e) {
                var h = this, k = h.renderer;
                h.isResizing += 1;
                a.setAnimation(e, h);
                h.oldChartHeight = h.chartHeight;
                h.oldChartWidth = h.chartWidth;
                void 0 !== b && (h.options.chart.width = b);
                void 0 !== c && (h.options.chart.height = c);
                h.getChartSize();
                b = k.globalAnimation;
                (b ? A : d)(h.container, {
                    width: h.chartWidth + "px",
                    height: h.chartHeight + "px"
                }, b);
                h.setChartSize(!0);
                k.setSize(h.chartWidth, h.chartHeight, e);
                p(h.axes, function(a) {
                    a.isDirty = !0;
                    a.setScale();
                });
                h.isDirtyLegend = !0;
                h.isDirtyBox = !0;
                h.layOutTitles();
                h.getMargins();
                h.redraw(e);
                h.oldChartHeight = null;
                m(h, "resize");
                P(function() {
                    h && m(h, "endResize", null, function() {
                        --h.isResizing;
                    });
                }, H(b).duration);
            },
            setChartSize: function(a) {
                var b = this.inverted, c = this.renderer, e = this.chartWidth, h = this.chartHeight, d = this.options.chart, k = this.spacing, f = this.clipOffset, m, n, y, g;
                this.plotLeft = m = Math.round(this.plotLeft);
                this.plotTop = n = Math.round(this.plotTop);
                this.plotWidth = y = Math.max(0, Math.round(e - m - this.marginRight));
                this.plotHeight = g = Math.max(0, Math.round(h - n - this.marginBottom));
                this.plotSizeX = b ? g : y;
                this.plotSizeY = b ? y : g;
                this.plotBorderWidth = d.plotBorderWidth || 0;
                this.spacingBox = c.spacingBox = {
                    x: k[3],
                    y: k[0],
                    width: e - k[3] - k[1],
                    height: h - k[0] - k[2]
                };
                this.plotBox = c.plotBox = {
                    x: m,
                    y: n,
                    width: y,
                    height: g
                };
                e = 2 * Math.floor(this.plotBorderWidth / 2);
                b = Math.ceil(Math.max(e, f[3]) / 2);
                c = Math.ceil(Math.max(e, f[0]) / 2);
                this.clipBox = {
                    x: b,
                    y: c,
                    width: Math.floor(this.plotSizeX - Math.max(e, f[1]) / 2 - b),
                    height: Math.max(0, Math.floor(this.plotSizeY - Math.max(e, f[2]) / 2 - c))
                };
                a || p(this.axes, function(a) {
                    a.setAxisSize();
                    a.setAxisTranslation();
                });
            },
            resetMargins: function() {
                var a = this, b = a.options.chart;
                p([ "margin", "spacing" ], function(c) {
                    var e = b[c], h = z(e) ? e : [ e, e, e, e ];
                    p([ "Top", "Right", "Bottom", "Left" ], function(e, d) {
                        a[c][d] = y(b[c + e], h[d]);
                    });
                });
                p(F, function(b, c) {
                    a[b] = y(a.margin[c], a.spacing[c]);
                });
                a.axisOffset = [ 0, 0, 0, 0 ];
                a.clipOffset = [ 0, 0, 0, 0 ];
            },
            drawChartBox: function() {
                var a = this.options.chart, b = this.renderer, c = this.chartWidth, e = this.chartHeight, h = this.chartBackground, d = this.plotBackground, k = this.plotBorder, f, m = this.plotBGImage, n = a.backgroundColor, p = a.plotBackgroundColor, y = a.plotBackgroundImage, g, l = this.plotLeft, q = this.plotTop, t = this.plotWidth, w = this.plotHeight, x = this.plotBox, r = this.clipRect, z = this.clipBox, J = "animate";
                h || (this.chartBackground = h = b.rect().addClass("highcharts-background").add(), 
                J = "attr");
                f = a.borderWidth || 0;
                g = f + (a.shadow ? 8 : 0);
                n = {
                    fill: n || "none"
                };
                if (f || h["stroke-width"]) n.stroke = a.borderColor, n["stroke-width"] = f;
                h.attr(n).shadow(a.shadow);
                h[J]({
                    x: g / 2,
                    y: g / 2,
                    width: c - g - f % 2,
                    height: e - g - f % 2,
                    r: a.borderRadius
                });
                J = "animate";
                d || (J = "attr", this.plotBackground = d = b.rect().addClass("highcharts-plot-background").add());
                d[J](x);
                d.attr({
                    fill: p || "none"
                }).shadow(a.plotShadow);
                y && (m ? m.animate(x) : this.plotBGImage = b.image(y, l, q, t, w).add());
                r ? r.animate({
                    width: z.width,
                    height: z.height
                }) : this.clipRect = b.clipRect(z);
                J = "animate";
                k || (J = "attr", this.plotBorder = k = b.rect().addClass("highcharts-plot-border").attr({
                    zIndex: 1
                }).add());
                k.attr({
                    stroke: a.plotBorderColor,
                    "stroke-width": a.plotBorderWidth || 0,
                    fill: "none"
                });
                k[J](k.crisp({
                    x: l,
                    y: q,
                    width: t,
                    height: w
                }, -k.strokeWidth()));
                this.isDirtyBox = !1;
            },
            propFromSeries: function() {
                var a = this, b = a.options.chart, c, e = a.options.series, h, d;
                p([ "inverted", "angular", "polar" ], function(k) {
                    c = I[b.type || b.defaultSeriesType];
                    d = b[k] || c && c.prototype[k];
                    for (h = e && e.length; !d && h--; ) (c = I[e[h].type]) && c.prototype[k] && (d = !0);
                    a[k] = d;
                });
            },
            linkSeries: function() {
                var a = this, b = a.series;
                p(b, function(a) {
                    a.linkedSeries.length = 0;
                });
                p(b, function(b) {
                    var c = b.options.linkedTo;
                    e(c) && (c = ":previous" === c ? a.series[b.index - 1] : a.get(c)) && c.linkedParent !== b && (c.linkedSeries.push(b), 
                    b.linkedParent = c, b.visible = y(b.options.visible, c.options.visible, b.visible));
                });
            },
            renderSeries: function() {
                p(this.series, function(a) {
                    a.translate();
                    a.render();
                });
            },
            renderLabels: function() {
                var a = this, b = a.options.labels;
                b.items && p(b.items, function(c) {
                    var e = C(b.style, c.style), h = J(e.left) + a.plotLeft, d = J(e.top) + a.plotTop + 12;
                    delete e.left;
                    delete e.top;
                    a.renderer.text(c.html, h, d).attr({
                        zIndex: 2
                    }).css(e).add();
                });
            },
            render: function() {
                var a = this.axes, b = this.renderer, c = this.options, e, h, d;
                this.setTitle();
                this.legend = new x(this, c.legend);
                this.getStacks && this.getStacks();
                this.getMargins(!0);
                this.setChartSize();
                c = this.plotWidth;
                e = this.plotHeight -= 21;
                p(a, function(a) {
                    a.setScale();
                });
                this.getAxisMargins();
                h = 1.1 < c / this.plotWidth;
                d = 1.05 < e / this.plotHeight;
                if (h || d) p(a, function(a) {
                    (a.horiz && h || !a.horiz && d) && a.setTickInterval(!0);
                }), this.getMargins();
                this.drawChartBox();
                this.hasCartesianSeries && p(a, function(a) {
                    a.visible && a.render();
                });
                this.seriesGroup || (this.seriesGroup = b.g("series-group").attr({
                    zIndex: 3
                }).add());
                this.renderSeries();
                this.renderLabels();
                this.addCredits();
                this.setResponsive && this.setResponsive();
                this.hasRendered = !0;
            },
            addCredits: function(a) {
                var b = this;
                a = w(!0, this.options.credits, a);
                a.enabled && !this.credits && (this.credits = this.renderer.text(a.text + (this.mapCredits || ""), 0, 0).addClass("highcharts-credits").on("click", function() {
                    a.href && (N.location.href = a.href);
                }).attr({
                    align: a.position.align,
                    zIndex: 8
                }).css(a.style).add().align(a.position), this.credits.update = function(a) {
                    b.credits = b.credits.destroy();
                    b.addCredits(a);
                });
            },
            destroy: function() {
                var b = this, c = b.axes, e = b.series, h = b.container, d, k = h && h.parentNode;
                m(b, "destroy");
                q[b.index] = void 0;
                a.chartCount--;
                b.renderTo.removeAttribute("data-highcharts-chart");
                K(b);
                for (d = c.length; d--; ) c[d] = c[d].destroy();
                this.scroller && this.scroller.destroy && this.scroller.destroy();
                for (d = e.length; d--; ) e[d] = e[d].destroy();
                p("title subtitle chartBackground plotBackground plotBGImage plotBorder seriesGroup clipRect credits pointer rangeSelector legend resetZoomButton tooltip renderer".split(" "), function(a) {
                    var c = b[a];
                    c && c.destroy && (b[a] = c.destroy());
                });
                h && (h.innerHTML = "", K(h), k && l(h));
                for (d in b) delete b[d];
            },
            isReadyToRender: function() {
                var a = this;
                return D || N != N.top || "complete" === r.readyState ? !0 : (r.attachEvent("onreadystatechange", function() {
                    r.detachEvent("onreadystatechange", a.firstRender);
                    "complete" === r.readyState && a.firstRender();
                }), !1);
            },
            firstRender: function() {
                var a = this, b = a.options;
                if (a.isReadyToRender()) {
                    a.getContainer();
                    m(a, "init");
                    a.resetMargins();
                    a.setChartSize();
                    a.propFromSeries();
                    a.getAxes();
                    p(b.series || [], function(b) {
                        a.initSeries(b);
                    });
                    a.linkSeries();
                    m(a, "beforeRender");
                    h && (a.pointer = new h(a, b));
                    a.render();
                    if (!a.renderer.imgCount && a.onload) a.onload();
                    a.cloneRenderTo(!0);
                }
            },
            onload: function() {
                p([ this.callback ].concat(this.callbacks), function(a) {
                    a && void 0 !== this.index && a.apply(this, [ this ]);
                }, this);
                m(this, "load");
                m(this, "render");
                b(this.index) && !1 !== this.options.chart.reflow && this.initReflow();
                this.onload = null;
            }
        };
    })(L);
    (function(a) {
        var B, A = a.each, H = a.extend, G = a.erase, r = a.fireEvent, g = a.format, f = a.isArray, u = a.isNumber, l = a.pick, q = a.removeEvent;
        B = a.Point = function() {};
        B.prototype = {
            init: function(a, b, f) {
                this.series = a;
                this.color = a.color;
                this.applyOptions(b, f);
                a.options.colorByPoint ? (b = a.options.colors || a.chart.options.colors, this.color = this.color || b[a.colorCounter], 
                b = b.length, f = a.colorCounter, a.colorCounter++, a.colorCounter === b && (a.colorCounter = 0)) : f = a.colorIndex;
                this.colorIndex = l(this.colorIndex, f);
                a.chart.pointCount++;
                return this;
            },
            applyOptions: function(a, b) {
                var d = this.series, f = d.options.pointValKey || d.pointValKey;
                a = B.prototype.optionsToObject.call(this, a);
                H(this, a);
                this.options = this.options ? H(this.options, a) : a;
                a.group && delete this.group;
                f && (this.y = this[f]);
                this.isNull = l(this.isValid && !this.isValid(), null === this.x || !u(this.y, !0));
                this.selected && (this.state = "select");
                "name" in this && void 0 === b && d.xAxis && d.xAxis.hasNames && (this.x = d.xAxis.nameToX(this));
                void 0 === this.x && d && (this.x = void 0 === b ? d.autoIncrement(this) : b);
                return this;
            },
            optionsToObject: function(a) {
                var b = {}, d = this.series, g = d.options.keys, l = g || d.pointArrayMap || [ "y" ], m = l.length, c = 0, n = 0;
                if (u(a) || null === a) b[l[0]] = a; else if (f(a)) for (!g && a.length > m && (d = typeof a[0], 
                "string" === d ? b.name = a[0] : "number" === d && (b.x = a[0]), c++); n < m; ) g && void 0 === a[c] || (b[l[n]] = a[c]), 
                c++, n++; else "object" === typeof a && (b = a, a.dataLabels && (d._hasPointLabels = !0), 
                a.marker && (d._hasPointMarkers = !0));
                return b;
            },
            getClassName: function() {
                return "highcharts-point" + (this.selected ? " highcharts-point-select" : "") + (this.negative ? " highcharts-negative" : "") + (this.isNull ? " highcharts-null-point" : "") + (void 0 !== this.colorIndex ? " highcharts-color-" + this.colorIndex : "") + (this.options.className ? " " + this.options.className : "") + (this.zone && this.zone.className ? " " + this.zone.className.replace("highcharts-negative", "") : "");
            },
            getZone: function() {
                var a = this.series, b = a.zones, a = a.zoneAxis || "y", f = 0, g;
                for (g = b[f]; this[a] >= g.value; ) g = b[++f];
                g && g.color && !this.options.color && (this.color = g.color);
                return g;
            },
            destroy: function() {
                var a = this.series.chart, b = a.hoverPoints, f;
                a.pointCount--;
                b && (this.setState(), G(b, this), b.length || (a.hoverPoints = null));
                if (this === a.hoverPoint) this.onMouseOut();
                if (this.graphic || this.dataLabel) q(this), this.destroyElements();
                this.legendItem && a.legend.destroyItem(this);
                for (f in this) this[f] = null;
            },
            destroyElements: function() {
                for (var a = [ "graphic", "dataLabel", "dataLabelUpper", "connector", "shadowGroup" ], b, f = 6; f--; ) b = a[f], 
                this[b] && (this[b] = this[b].destroy());
            },
            getLabelConfig: function() {
                return {
                    x: this.category,
                    y: this.y,
                    color: this.color,
                    colorIndex: this.colorIndex,
                    key: this.name || this.category,
                    series: this.series,
                    point: this,
                    percentage: this.percentage,
                    total: this.total || this.stackTotal
                };
            },
            tooltipFormatter: function(a) {
                var b = this.series, d = b.tooltipOptions, f = l(d.valueDecimals, ""), q = d.valuePrefix || "", m = d.valueSuffix || "";
                A(b.pointArrayMap || [ "y" ], function(b) {
                    b = "{point." + b;
                    if (q || m) a = a.replace(b + "}", q + b + "}" + m);
                    a = a.replace(b + "}", b + ":,." + f + "f}");
                });
                return g(a, {
                    point: this,
                    series: this.series
                });
            },
            firePointEvent: function(a, b, f) {
                var d = this, g = this.series.options;
                (g.point.events[a] || d.options && d.options.events && d.options.events[a]) && this.importEvents();
                "click" === a && g.allowPointSelect && (f = function(a) {
                    d.select && d.select(null, a.ctrlKey || a.metaKey || a.shiftKey);
                });
                r(this, a, b, f);
            },
            visible: !0
        };
    })(L);
    (function(a) {
        var B = a.addEvent, A = a.animObject, H = a.arrayMax, G = a.arrayMin, r = a.correctFloat, g = a.Date, f = a.defaultOptions, u = a.defaultPlotOptions, l = a.defined, q = a.each, d = a.erase, b = a.extend, p = a.fireEvent, C = a.grep, t = a.isArray, m = a.isNumber, c = a.isString, n = a.merge, E = a.pick, z = a.removeEvent, e = a.splat, x = a.SVGElement, F = a.syncTimeout, w = a.win;
        a.Series = a.seriesType("line", null, {
            lineWidth: 2,
            allowPointSelect: !1,
            showCheckbox: !1,
            animation: {
                duration: 1e3
            },
            events: {},
            marker: {
                lineWidth: 0,
                lineColor: "#ffffff",
                radius: 4,
                states: {
                    hover: {
                        animation: {
                            duration: 50
                        },
                        enabled: !0,
                        radiusPlus: 2,
                        lineWidthPlus: 1
                    },
                    select: {
                        fillColor: "#cccccc",
                        lineColor: "#000000",
                        lineWidth: 2
                    }
                }
            },
            point: {
                events: {}
            },
            dataLabels: {
                align: "center",
                formatter: function() {
                    return null === this.y ? "" : a.numberFormat(this.y, -1);
                },
                style: {
                    fontSize: "11px",
                    fontWeight: "bold",
                    color: "contrast",
                    textOutline: "1px contrast"
                },
                verticalAlign: "bottom",
                x: 0,
                y: 0,
                padding: 5
            },
            cropThreshold: 300,
            pointRange: 0,
            softThreshold: !0,
            states: {
                hover: {
                    lineWidthPlus: 1,
                    marker: {},
                    halo: {
                        size: 10,
                        opacity: .25
                    }
                },
                select: {
                    marker: {}
                }
            },
            stickyTracking: !0,
            turboThreshold: 1e3
        }, {
            isCartesian: !0,
            pointClass: a.Point,
            sorted: !0,
            requireSorting: !0,
            directTouch: !1,
            axisTypes: [ "xAxis", "yAxis" ],
            colorCounter: 0,
            parallelArrays: [ "x", "y" ],
            coll: "series",
            init: function(a, c) {
                var e = this, h, d, k = a.series, f;
                e.chart = a;
                e.options = c = e.setOptions(c);
                e.linkedSeries = [];
                e.bindAxes();
                b(e, {
                    name: c.name,
                    state: "",
                    visible: !1 !== c.visible,
                    selected: !0 === c.selected
                });
                d = c.events;
                for (h in d) B(e, h, d[h]);
                if (d && d.click || c.point && c.point.events && c.point.events.click || c.allowPointSelect) a.runTrackerClick = !0;
                e.getColor();
                e.getSymbol();
                q(e.parallelArrays, function(a) {
                    e[a + "Data"] = [];
                });
                e.setData(c.data, !1);
                e.isCartesian && (a.hasCartesianSeries = !0);
                k.length && (f = k[k.length - 1]);
                e._i = E(f && f._i, -1) + 1;
                a.orderSeries(this.insert(k));
            },
            insert: function(a) {
                var b = this.options.index, c;
                if (m(b)) {
                    for (c = a.length; c--; ) if (b >= E(a[c].options.index, a[c]._i)) {
                        a.splice(c + 1, 0, this);
                        break;
                    }
                    -1 === c && a.unshift(this);
                    c += 1;
                } else a.push(this);
                return E(c, a.length - 1);
            },
            bindAxes: function() {
                var b = this, c = b.options, e = b.chart, d;
                q(b.axisTypes || [], function(h) {
                    q(e[h], function(a) {
                        d = a.options;
                        if (c[h] === d.index || void 0 !== c[h] && c[h] === d.id || void 0 === c[h] && 0 === d.index) b.insert(a.series), 
                        b[h] = a, a.isDirty = !0;
                    });
                    b[h] || b.optionalAxis === h || a.error(18, !0);
                });
            },
            updateParallelArrays: function(a, b) {
                var c = a.series, e = arguments, h = m(b) ? function(e) {
                    var h = "y" === e && c.toYData ? c.toYData(a) : a[e];
                    c[e + "Data"][b] = h;
                } : function(a) {
                    Array.prototype[b].apply(c[a + "Data"], Array.prototype.slice.call(e, 2));
                };
                q(c.parallelArrays, h);
            },
            autoIncrement: function() {
                var a = this.options, b = this.xIncrement, c, e = a.pointIntervalUnit, b = E(b, a.pointStart, 0);
                this.pointInterval = c = E(this.pointInterval, a.pointInterval, 1);
                e && (a = new g(b), "day" === e ? a = +a[g.hcSetDate](a[g.hcGetDate]() + c) : "month" === e ? a = +a[g.hcSetMonth](a[g.hcGetMonth]() + c) : "year" === e && (a = +a[g.hcSetFullYear](a[g.hcGetFullYear]() + c)), 
                c = a - b);
                this.xIncrement = b + c;
                return b;
            },
            setOptions: function(a) {
                var b = this.chart, c = b.options.plotOptions, b = b.userOptions || {}, e = b.plotOptions || {}, h = c[this.type];
                this.userOptions = a;
                c = n(h, c.series, a);
                this.tooltipOptions = n(f.tooltip, f.plotOptions[this.type].tooltip, b.tooltip, e.series && e.series.tooltip, e[this.type] && e[this.type].tooltip, a.tooltip);
                null === h.marker && delete c.marker;
                this.zoneAxis = c.zoneAxis;
                a = this.zones = (c.zones || []).slice();
                !c.negativeColor && !c.negativeFillColor || c.zones || a.push({
                    value: c[this.zoneAxis + "Threshold"] || c.threshold || 0,
                    className: "highcharts-negative",
                    color: c.negativeColor,
                    fillColor: c.negativeFillColor
                });
                a.length && l(a[a.length - 1].value) && a.push({
                    color: this.color,
                    fillColor: this.fillColor
                });
                return c;
            },
            getCyclic: function(a, b, c) {
                var e, h = this.chart, d = this.userOptions, f = a + "Index", n = a + "Counter", m = c ? c.length : E(h.options.chart[a + "Count"], h[a + "Count"]);
                b || (e = E(d[f], d["_" + f]), l(e) || (h.series.length || (h[n] = 0), d["_" + f] = e = h[n] % m, 
                h[n] += 1), c && (b = c[e]));
                void 0 !== e && (this[f] = e);
                this[a] = b;
            },
            getColor: function() {
                this.options.colorByPoint ? this.options.color = null : this.getCyclic("color", this.options.color || u[this.type].color, this.chart.options.colors);
            },
            getSymbol: function() {
                this.getCyclic("symbol", this.options.marker.symbol, this.chart.options.symbols);
            },
            drawLegendSymbol: a.LegendSymbolMixin.drawLineMarker,
            setData: function(b, e, d, f) {
                var h = this, k = h.points, n = k && k.length || 0, g, p = h.options, y = h.chart, l = null, w = h.xAxis, x = p.turboThreshold, r = this.xData, z = this.yData, F = (g = h.pointArrayMap) && g.length;
                b = b || [];
                g = b.length;
                e = E(e, !0);
                if (!1 !== f && g && n === g && !h.cropped && !h.hasGroupedData && h.visible) q(b, function(a, b) {
                    k[b].update && a !== p.data[b] && k[b].update(a, !1, null, !1);
                }); else {
                    h.xIncrement = null;
                    h.colorCounter = 0;
                    q(this.parallelArrays, function(a) {
                        h[a + "Data"].length = 0;
                    });
                    if (x && g > x) {
                        for (d = 0; null === l && d < g; ) l = b[d], d++;
                        if (m(l)) for (d = 0; d < g; d++) r[d] = this.autoIncrement(), z[d] = b[d]; else if (t(l)) if (F) for (d = 0; d < g; d++) l = b[d], 
                        r[d] = l[0], z[d] = l.slice(1, F + 1); else for (d = 0; d < g; d++) l = b[d], r[d] = l[0], 
                        z[d] = l[1]; else a.error(12);
                    } else for (d = 0; d < g; d++) void 0 !== b[d] && (l = {
                        series: h
                    }, h.pointClass.prototype.applyOptions.apply(l, [ b[d] ]), h.updateParallelArrays(l, d));
                    c(z[0]) && a.error(14, !0);
                    h.data = [];
                    h.options.data = h.userOptions.data = b;
                    for (d = n; d--; ) k[d] && k[d].destroy && k[d].destroy();
                    w && (w.minRange = w.userMinRange);
                    h.isDirty = y.isDirtyBox = !0;
                    h.isDirtyData = !!k;
                    d = !1;
                }
                "point" === p.legendType && (this.processData(), this.generatePoints());
                e && y.redraw(d);
            },
            processData: function(b) {
                var c = this.xData, e = this.yData, h = c.length, d;
                d = 0;
                var k, f, n = this.xAxis, m, g = this.options;
                m = g.cropThreshold;
                var p = this.getExtremesFromAll || g.getExtremesFromAll, l = this.isCartesian, g = n && n.val2lin, q = n && n.isLog, t, w;
                if (l && !this.isDirty && !n.isDirty && !this.yAxis.isDirty && !b) return !1;
                n && (b = n.getExtremes(), t = b.min, w = b.max);
                if (l && this.sorted && !p && (!m || h > m || this.forceCrop)) if (c[h - 1] < t || c[0] > w) c = [], 
                e = []; else if (c[0] < t || c[h - 1] > w) d = this.cropData(this.xData, this.yData, t, w), 
                c = d.xData, e = d.yData, d = d.start, k = !0;
                for (m = c.length || 1; --m; ) h = q ? g(c[m]) - g(c[m - 1]) : c[m] - c[m - 1], 
                0 < h && (void 0 === f || h < f) ? f = h : 0 > h && this.requireSorting && a.error(15);
                this.cropped = k;
                this.cropStart = d;
                this.processedXData = c;
                this.processedYData = e;
                this.closestPointRange = f;
            },
            cropData: function(a, b, c, e) {
                var h = a.length, d = 0, f = h, n = E(this.cropShoulder, 1), m;
                for (m = 0; m < h; m++) if (a[m] >= c) {
                    d = Math.max(0, m - n);
                    break;
                }
                for (c = m; c < h; c++) if (a[c] > e) {
                    f = c + n;
                    break;
                }
                return {
                    xData: a.slice(d, f),
                    yData: b.slice(d, f),
                    start: d,
                    end: f
                };
            },
            generatePoints: function() {
                var a = this.options.data, b = this.data, c, d = this.processedXData, f = this.processedYData, k = this.pointClass, n = d.length, m = this.cropStart || 0, g, p = this.hasGroupedData, l, q = [], t;
                b || p || (b = [], b.length = a.length, b = this.data = b);
                for (t = 0; t < n; t++) g = m + t, p ? (l = new k().init(this, [ d[t] ].concat(e(f[t]))), 
                l.dataGroup = this.groupMap[t]) : (l = b[g]) || void 0 === a[g] || (b[g] = l = new k().init(this, a[g], d[t])), 
                l.index = g, q[t] = l;
                if (b && (n !== (c = b.length) || p)) for (t = 0; t < c; t++) t !== m || p || (t += n), 
                b[t] && (b[t].destroyElements(), b[t].plotX = void 0);
                this.data = b;
                this.points = q;
            },
            getExtremes: function(a) {
                var b = this.yAxis, c = this.processedXData, e, h = [], d = 0;
                e = this.xAxis.getExtremes();
                var f = e.min, n = e.max, g, p, l, q;
                a = a || this.stackedYData || this.processedYData || [];
                e = a.length;
                for (q = 0; q < e; q++) if (p = c[q], l = a[q], g = (m(l, !0) || t(l)) && (!b.isLog || l.length || 0 < l), 
                p = this.getExtremesFromAll || this.options.getExtremesFromAll || this.cropped || (c[q + 1] || p) >= f && (c[q - 1] || p) <= n, 
                g && p) if (g = l.length) for (;g--; ) null !== l[g] && (h[d++] = l[g]); else h[d++] = l;
                this.dataMin = G(h);
                this.dataMax = H(h);
            },
            translate: function() {
                this.processedXData || this.processData();
                this.generatePoints();
                var a = this.options, b = a.stacking, c = this.xAxis, e = c.categories, d = this.yAxis, k = this.points, f = k.length, n = !!this.modifyValue, g = a.pointPlacement, p = "between" === g || m(g), q = a.threshold, t = a.startFromThreshold ? q : 0, w, x, z, F, u = Number.MAX_VALUE;
                "between" === g && (g = .5);
                m(g) && (g *= E(a.pointRange || c.pointRange));
                for (a = 0; a < f; a++) {
                    var C = k[a], A = C.x, B = C.y;
                    x = C.low;
                    var H = b && d.stacks[(this.negStacks && B < (t ? 0 : q) ? "-" : "") + this.stackKey], G;
                    d.isLog && null !== B && 0 >= B && (C.isNull = !0);
                    C.plotX = w = r(Math.min(Math.max(-1e5, c.translate(A, 0, 0, 0, 1, g, "flags" === this.type)), 1e5));
                    b && this.visible && !C.isNull && H && H[A] && (F = this.getStackIndicator(F, A, this.index), 
                    G = H[A], B = G.points[F.key], x = B[0], B = B[1], x === t && F.key === H[A].base && (x = E(q, d.min)), 
                    d.isLog && 0 >= x && (x = null), C.total = C.stackTotal = G.total, C.percentage = G.total && C.y / G.total * 100, 
                    C.stackY = B, G.setOffset(this.pointXOffset || 0, this.barW || 0));
                    C.yBottom = l(x) ? d.translate(x, 0, 1, 0, 1) : null;
                    n && (B = this.modifyValue(B, C));
                    C.plotY = x = "number" === typeof B && Infinity !== B ? Math.min(Math.max(-1e5, d.translate(B, 0, 1, 0, 1)), 1e5) : void 0;
                    C.isInside = void 0 !== x && 0 <= x && x <= d.len && 0 <= w && w <= c.len;
                    C.clientX = p ? r(c.translate(A, 0, 0, 0, 1, g)) : w;
                    C.negative = C.y < (q || 0);
                    C.category = e && void 0 !== e[C.x] ? e[C.x] : C.x;
                    C.isNull || (void 0 !== z && (u = Math.min(u, Math.abs(w - z))), z = w);
                    C.zone = this.zones.length && C.getZone();
                }
                this.closestPointRangePx = u;
            },
            getValidPoints: function(a, b) {
                var c = this.chart;
                return C(a || this.points || [], function(a) {
                    return b && !c.isInsidePlot(a.plotX, a.plotY, c.inverted) ? !1 : !a.isNull;
                });
            },
            setClip: function(a) {
                var b = this.chart, c = this.options, e = b.renderer, d = b.inverted, h = this.clipBox, f = h || b.clipBox, n = this.sharedClipKey || [ "_sharedClip", a && a.duration, a && a.easing, f.height, c.xAxis, c.yAxis ].join(), m = b[n], g = b[n + "m"];
                m || (a && (f.width = 0, b[n + "m"] = g = e.clipRect(-99, d ? -b.plotLeft : -b.plotTop, 99, d ? b.chartWidth : b.chartHeight)), 
                b[n] = m = e.clipRect(f), m.count = {
                    length: 0
                });
                a && !m.count[this.index] && (m.count[this.index] = !0, m.count.length += 1);
                !1 !== c.clip && (this.group.clip(a || h ? m : b.clipRect), this.markerGroup.clip(g), 
                this.sharedClipKey = n);
                a || (m.count[this.index] && (delete m.count[this.index], --m.count.length), 0 === m.count.length && n && b[n] && (h || (b[n] = b[n].destroy()), 
                b[n + "m"] && (this.markerGroup.clip(), b[n + "m"] = b[n + "m"].destroy())));
            },
            animate: function(a) {
                var b = this.chart, c = A(this.options.animation), e;
                a ? this.setClip(c) : (e = this.sharedClipKey, (a = b[e]) && a.animate({
                    width: b.plotSizeX
                }, c), b[e + "m"] && b[e + "m"].animate({
                    width: b.plotSizeX + 99
                }, c), this.animate = null);
            },
            afterAnimate: function() {
                this.setClip();
                p(this, "afterAnimate");
            },
            drawPoints: function() {
                var a = this.points, b = this.chart, c, e, d, k, f = this.options.marker, n, g, p, l, q = this.markerGroup, t = E(f.enabled, this.xAxis.isRadial ? !0 : null, this.closestPointRangePx > 2 * f.radius);
                if (!1 !== f.enabled || this._hasPointMarkers) for (e = 0; e < a.length; e++) d = a[e], 
                c = d.plotY, k = d.graphic, n = d.marker || {}, g = !!d.marker, p = t && void 0 === n.enabled || n.enabled, 
                l = d.isInside, p && m(c) && null !== d.y ? (c = E(n.symbol, this.symbol), d.hasImage = 0 === c.indexOf("url"), 
                p = this.markerAttribs(d, d.selected && "select"), k ? k[l ? "show" : "hide"](!0).animate(p) : l && (0 < p.width || d.hasImage) && (d.graphic = k = b.renderer.symbol(c, p.x, p.y, p.width, p.height, g ? n : f).add(q)), 
                k && k.attr(this.pointAttribs(d, d.selected && "select")), k && k.addClass(d.getClassName(), !0)) : k && (d.graphic = k.destroy());
            },
            markerAttribs: function(a, b) {
                var c = this.options.marker, e = a.marker || {}, d = E(e.radius, c.radius);
                b && (c = c.states[b], b = e.states && e.states[b], d = E(b && b.radius, c && c.radius, d + (c && c.radiusPlus || 0)));
                a.hasImage && (d = 0);
                a = {
                    x: Math.floor(a.plotX) - d,
                    y: a.plotY - d
                };
                d && (a.width = a.height = 2 * d);
                return a;
            },
            pointAttribs: function(a, b) {
                var c = this.options.marker, e = a && a.options, d = e && e.marker || {}, h = this.color, f = e && e.color, n = a && a.color, e = E(d.lineWidth, c.lineWidth);
                a = a && a.zone && a.zone.color;
                h = f || a || n || h;
                a = d.fillColor || c.fillColor || h;
                h = d.lineColor || c.lineColor || h;
                b && (c = c.states[b], b = d.states && d.states[b] || {}, e = E(b.lineWidth, c.lineWidth, e + E(b.lineWidthPlus, c.lineWidthPlus, 0)), 
                a = b.fillColor || c.fillColor || a, h = b.lineColor || c.lineColor || h);
                return {
                    stroke: h,
                    "stroke-width": e,
                    fill: a
                };
            },
            destroy: function() {
                var a = this, b = a.chart, c = /AppleWebKit\/533/.test(w.navigator.userAgent), e, f = a.data || [], k, n, m;
                p(a, "destroy");
                z(a);
                q(a.axisTypes || [], function(b) {
                    (m = a[b]) && m.series && (d(m.series, a), m.isDirty = m.forceRedraw = !0);
                });
                a.legendItem && a.chart.legend.destroyItem(a);
                for (e = f.length; e--; ) (k = f[e]) && k.destroy && k.destroy();
                a.points = null;
                clearTimeout(a.animationTimeout);
                for (n in a) a[n] instanceof x && !a[n].survive && (e = c && "group" === n ? "hide" : "destroy", 
                a[n][e]());
                b.hoverSeries === a && (b.hoverSeries = null);
                d(b.series, a);
                b.orderSeries();
                for (n in a) delete a[n];
            },
            getGraphPath: function(a, b, c) {
                var e = this, d = e.options, h = d.step, f, n = [], m = [], g;
                a = a || e.points;
                (f = a.reversed) && a.reverse();
                (h = {
                    right: 1,
                    center: 2
                }[h] || h && 3) && f && (h = 4 - h);
                !d.connectNulls || b || c || (a = this.getValidPoints(a));
                q(a, function(f, k) {
                    var p = f.plotX, q = f.plotY, t = a[k - 1];
                    (f.leftCliff || t && t.rightCliff) && !c && (g = !0);
                    f.isNull && !l(b) && 0 < k ? g = !d.connectNulls : f.isNull && !b ? g = !0 : (0 === k || g ? k = [ "M", f.plotX, f.plotY ] : e.getPointSpline ? k = e.getPointSpline(a, f, k) : h ? (k = 1 === h ? [ "L", t.plotX, q ] : 2 === h ? [ "L", (t.plotX + p) / 2, t.plotY, "L", (t.plotX + p) / 2, q ] : [ "L", p, t.plotY ], 
                    k.push("L", p, q)) : k = [ "L", p, q ], m.push(f.x), h && m.push(f.x), n.push.apply(n, k), 
                    g = !1);
                });
                n.xMap = m;
                return e.graphPath = n;
            },
            drawGraph: function() {
                var a = this, b = this.options, c = (this.gappedPath || this.getGraphPath).call(this), e = [ [ "graph", "highcharts-graph", b.lineColor || this.color, b.dashStyle ] ];
                q(this.zones, function(c, d) {
                    e.push([ "zone-graph-" + d, "highcharts-graph highcharts-zone-graph-" + d + " " + (c.className || ""), c.color || a.color, c.dashStyle || b.dashStyle ]);
                });
                q(e, function(e, d) {
                    var h = e[0], f = a[h];
                    f ? (f.endX = c.xMap, f.animate({
                        d: c
                    })) : c.length && (a[h] = a.chart.renderer.path(c).addClass(e[1]).attr({
                        zIndex: 1
                    }).add(a.group), f = {
                        stroke: e[2],
                        "stroke-width": b.lineWidth,
                        fill: a.fillGraph && a.color || "none"
                    }, e[3] ? f.dashstyle = e[3] : "square" !== b.linecap && (f["stroke-linecap"] = f["stroke-linejoin"] = "round"), 
                    f = a[h].attr(f).shadow(2 > d && b.shadow));
                    f && (f.startX = c.xMap, f.isArea = c.isArea);
                });
            },
            applyZones: function() {
                var a = this, b = this.chart, c = b.renderer, e = this.zones, d, f, n = this.clips || [], m, g = this.graph, p = this.area, l = Math.max(b.chartWidth, b.chartHeight), t = this[(this.zoneAxis || "y") + "Axis"], w, x, r = b.inverted, z, F, u, C, A = !1;
                e.length && (g || p) && t && void 0 !== t.min && (x = t.reversed, z = t.horiz, g && g.hide(), 
                p && p.hide(), w = t.getExtremes(), q(e, function(e, h) {
                    d = x ? z ? b.plotWidth : 0 : z ? 0 : t.toPixels(w.min);
                    d = Math.min(Math.max(E(f, d), 0), l);
                    f = Math.min(Math.max(Math.round(t.toPixels(E(e.value, w.max), !0)), 0), l);
                    A && (d = f = t.toPixels(w.max));
                    F = Math.abs(d - f);
                    u = Math.min(d, f);
                    C = Math.max(d, f);
                    t.isXAxis ? (m = {
                        x: r ? C : u,
                        y: 0,
                        width: F,
                        height: l
                    }, z || (m.x = b.plotHeight - m.x)) : (m = {
                        x: 0,
                        y: r ? C : u,
                        width: l,
                        height: F
                    }, z && (m.y = b.plotWidth - m.y));
                    r && c.isVML && (m = t.isXAxis ? {
                        x: 0,
                        y: x ? u : C,
                        height: m.width,
                        width: b.chartWidth
                    } : {
                        x: m.y - b.plotLeft - b.spacingBox.x,
                        y: 0,
                        width: m.height,
                        height: b.chartHeight
                    });
                    n[h] ? n[h].animate(m) : (n[h] = c.clipRect(m), g && a["zone-graph-" + h].clip(n[h]), 
                    p && a["zone-area-" + h].clip(n[h]));
                    A = e.value > w.max;
                }), this.clips = n);
            },
            invertGroups: function(a) {
                function b() {
                    q([ "group", "markerGroup" ], function(b) {
                        c[b] && (c[b].width = c.yAxis.len, c[b].height = c.xAxis.len, c[b].invert(a));
                    });
                }
                var c = this, e;
                c.xAxis && (e = B(c.chart, "resize", b), B(c, "destroy", e), b(a), c.invertGroups = b);
            },
            plotGroup: function(a, b, c, e, d) {
                var h = this[a], f = !h;
                f && (this[a] = h = this.chart.renderer.g(b).attr({
                    zIndex: e || .1
                }).add(d), h.addClass("highcharts-series-" + this.index + " highcharts-" + this.type + "-series highcharts-color-" + this.colorIndex + " " + (this.options.className || "")));
                h.attr({
                    visibility: c
                })[f ? "attr" : "animate"](this.getPlotBox());
                return h;
            },
            getPlotBox: function() {
                var a = this.chart, b = this.xAxis, c = this.yAxis;
                a.inverted && (b = c, c = this.xAxis);
                return {
                    translateX: b ? b.left : a.plotLeft,
                    translateY: c ? c.top : a.plotTop,
                    scaleX: 1,
                    scaleY: 1
                };
            },
            render: function() {
                var a = this, b = a.chart, c, e = a.options, d = !!a.animate && b.renderer.isSVG && A(e.animation).duration, f = a.visible ? "inherit" : "hidden", n = e.zIndex, m = a.hasRendered, g = b.seriesGroup, p = b.inverted;
                c = a.plotGroup("group", "series", f, n, g);
                a.markerGroup = a.plotGroup("markerGroup", "markers", f, n, g);
                d && a.animate(!0);
                c.inverted = a.isCartesian ? p : !1;
                a.drawGraph && (a.drawGraph(), a.applyZones());
                a.drawDataLabels && a.drawDataLabels();
                a.visible && a.drawPoints();
                a.drawTracker && !1 !== a.options.enableMouseTracking && a.drawTracker();
                a.invertGroups(p);
                !1 === e.clip || a.sharedClipKey || m || c.clip(b.clipRect);
                d && a.animate();
                m || (a.animationTimeout = F(function() {
                    a.afterAnimate();
                }, d));
                a.isDirty = !1;
                a.hasRendered = !0;
            },
            redraw: function() {
                var a = this.chart, b = this.isDirty || this.isDirtyData, c = this.group, e = this.xAxis, d = this.yAxis;
                c && (a.inverted && c.attr({
                    width: a.plotWidth,
                    height: a.plotHeight
                }), c.animate({
                    translateX: E(e && e.left, a.plotLeft),
                    translateY: E(d && d.top, a.plotTop)
                }));
                this.translate();
                this.render();
                b && delete this.kdTree;
            },
            kdDimensions: 1,
            kdAxisArray: [ "clientX", "plotY" ],
            searchPoint: function(a, b) {
                var c = this.xAxis, e = this.yAxis, d = this.chart.inverted;
                return this.searchKDTree({
                    clientX: d ? c.len - a.chartY + c.pos : a.chartX - c.pos,
                    plotY: d ? e.len - a.chartX + e.pos : a.chartY - e.pos
                }, b);
            },
            buildKDTree: function() {
                function a(c, e, d) {
                    var h, f;
                    if (f = c && c.length) return h = b.kdAxisArray[e % d], c.sort(function(a, b) {
                        return a[h] - b[h];
                    }), f = Math.floor(f / 2), {
                        point: c[f],
                        left: a(c.slice(0, f), e + 1, d),
                        right: a(c.slice(f + 1), e + 1, d)
                    };
                }
                this.buildingKdTree = !0;
                var b = this, c = b.kdDimensions;
                delete b.kdTree;
                F(function() {
                    b.kdTree = a(b.getValidPoints(null, !b.directTouch), c, c);
                    b.buildingKdTree = !1;
                }, b.options.kdNow ? 0 : 1);
            },
            searchKDTree: function(a, b) {
                function c(a, b, k, n) {
                    var m = b.point, g = e.kdAxisArray[k % n], p, t, q = m;
                    t = l(a[d]) && l(m[d]) ? Math.pow(a[d] - m[d], 2) : null;
                    p = l(a[h]) && l(m[h]) ? Math.pow(a[h] - m[h], 2) : null;
                    p = (t || 0) + (p || 0);
                    m.dist = l(p) ? Math.sqrt(p) : Number.MAX_VALUE;
                    m.distX = l(t) ? Math.sqrt(t) : Number.MAX_VALUE;
                    g = a[g] - m[g];
                    p = 0 > g ? "left" : "right";
                    t = 0 > g ? "right" : "left";
                    b[p] && (p = c(a, b[p], k + 1, n), q = p[f] < q[f] ? p : m);
                    b[t] && Math.sqrt(g * g) < q[f] && (a = c(a, b[t], k + 1, n), q = a[f] < q[f] ? a : q);
                    return q;
                }
                var e = this, d = this.kdAxisArray[0], h = this.kdAxisArray[1], f = b ? "distX" : "dist";
                this.kdTree || this.buildingKdTree || this.buildKDTree();
                if (this.kdTree) return c(a, this.kdTree, this.kdDimensions, this.kdDimensions);
            }
        });
    })(L);
    (function(a) {
        function B(a, d, b, f, g) {
            var p = a.chart.inverted;
            this.axis = a;
            this.isNegative = b;
            this.options = d;
            this.x = f;
            this.total = null;
            this.points = {};
            this.stack = g;
            this.rightCliff = this.leftCliff = 0;
            this.alignOptions = {
                align: d.align || (p ? b ? "left" : "right" : "center"),
                verticalAlign: d.verticalAlign || (p ? "middle" : b ? "bottom" : "top"),
                y: l(d.y, p ? 4 : b ? 14 : -6),
                x: l(d.x, p ? b ? -6 : 6 : 0)
            };
            this.textAlign = d.textAlign || (p ? b ? "right" : "left" : "center");
        }
        var A = a.Axis, H = a.Chart, G = a.correctFloat, r = a.defined, g = a.destroyObjectProperties, f = a.each, u = a.format, l = a.pick;
        a = a.Series;
        B.prototype = {
            destroy: function() {
                g(this, this.axis);
            },
            render: function(a) {
                var d = this.options, b = d.format, b = b ? u(b, this) : d.formatter.call(this);
                this.label ? this.label.attr({
                    text: b,
                    visibility: "hidden"
                }) : this.label = this.axis.chart.renderer.text(b, null, null, d.useHTML).css(d.style).attr({
                    align: this.textAlign,
                    rotation: d.rotation,
                    visibility: "hidden"
                }).add(a);
            },
            setOffset: function(a, d) {
                var b = this.axis, f = b.chart, g = f.inverted, l = b.reversed, l = this.isNegative && !l || !this.isNegative && l, m = b.translate(b.usePercentage ? 100 : this.total, 0, 0, 0, 1), b = b.translate(0), b = Math.abs(m - b);
                a = f.xAxis[0].translate(this.x) + a;
                var c = f.plotHeight, g = {
                    x: g ? l ? m : m - b : a,
                    y: g ? c - a - d : l ? c - m - b : c - m,
                    width: g ? b : d,
                    height: g ? d : b
                };
                if (d = this.label) d.align(this.alignOptions, null, g), g = d.alignAttr, d[!1 === this.options.crop || f.isInsidePlot(g.x, g.y) ? "show" : "hide"](!0);
            }
        };
        H.prototype.getStacks = function() {
            var a = this;
            f(a.yAxis, function(a) {
                a.stacks && a.hasVisibleSeries && (a.oldStacks = a.stacks);
            });
            f(a.series, function(d) {
                !d.options.stacking || !0 !== d.visible && !1 !== a.options.chart.ignoreHiddenSeries || (d.stackKey = d.type + l(d.options.stack, ""));
            });
        };
        A.prototype.buildStacks = function() {
            var a = this.series, d, b = l(this.options.reversedStacks, !0), f = a.length, g;
            if (!this.isXAxis) {
                this.usePercentage = !1;
                for (g = f; g--; ) a[b ? g : f - g - 1].setStackedPoints();
                for (g = f; g--; ) d = a[b ? g : f - g - 1], d.setStackCliffs && d.setStackCliffs();
                if (this.usePercentage) for (g = 0; g < f; g++) a[g].setPercentStacks();
            }
        };
        A.prototype.renderStackTotals = function() {
            var a = this.chart, d = a.renderer, b = this.stacks, f, g, l = this.stackTotalGroup;
            l || (this.stackTotalGroup = l = d.g("stack-labels").attr({
                visibility: "visible",
                zIndex: 6
            }).add());
            l.translate(a.plotLeft, a.plotTop);
            for (f in b) for (g in a = b[f], a) a[g].render(l);
        };
        A.prototype.resetStacks = function() {
            var a = this.stacks, d, b;
            if (!this.isXAxis) for (d in a) for (b in a[d]) a[d][b].touched < this.stacksTouched ? (a[d][b].destroy(), 
            delete a[d][b]) : (a[d][b].total = null, a[d][b].cum = null);
        };
        A.prototype.cleanStacks = function() {
            var a, d, b;
            if (!this.isXAxis) for (d in this.oldStacks && (a = this.stacks = this.oldStacks), 
            a) for (b in a[d]) a[d][b].cum = a[d][b].total;
        };
        a.prototype.setStackedPoints = function() {
            if (this.options.stacking && (!0 === this.visible || !1 === this.chart.options.chart.ignoreHiddenSeries)) {
                var a = this.processedXData, d = this.processedYData, b = [], f = d.length, g = this.options, t = g.threshold, m = g.startFromThreshold ? t : 0, c = g.stack, g = g.stacking, n = this.stackKey, u = "-" + n, z = this.negStacks, e = this.yAxis, x = e.stacks, F = e.oldStacks, w, h, y, A, K, I, k;
                e.stacksTouched += 1;
                for (K = 0; K < f; K++) I = a[K], k = d[K], w = this.getStackIndicator(w, I, this.index), 
                A = w.key, y = (h = z && k < (m ? 0 : t)) ? u : n, x[y] || (x[y] = {}), x[y][I] || (F[y] && F[y][I] ? (x[y][I] = F[y][I], 
                x[y][I].total = null) : x[y][I] = new B(e, e.options.stackLabels, h, I, c)), y = x[y][I], 
                null !== k && (y.points[A] = y.points[this.index] = [ l(y.cum, m) ], r(y.cum) || (y.base = A), 
                y.touched = e.stacksTouched, 0 < w.index && !1 === this.singleStacks && (y.points[A][0] = y.points[this.index + "," + I + ",0"][0])), 
                "percent" === g ? (h = h ? n : u, z && x[h] && x[h][I] ? (h = x[h][I], y.total = h.total = Math.max(h.total, y.total) + Math.abs(k) || 0) : y.total = G(y.total + (Math.abs(k) || 0))) : y.total = G(y.total + (k || 0)), 
                y.cum = l(y.cum, m) + (k || 0), null !== k && (y.points[A].push(y.cum), b[K] = y.cum);
                "percent" === g && (e.usePercentage = !0);
                this.stackedYData = b;
                e.oldStacks = {};
            }
        };
        a.prototype.setPercentStacks = function() {
            var a = this, d = a.stackKey, b = a.yAxis.stacks, g = a.processedXData, l;
            f([ d, "-" + d ], function(d) {
                for (var f = g.length, c, n; f--; ) if (c = g[f], l = a.getStackIndicator(l, c, a.index, d), 
                c = (n = b[d] && b[d][c]) && n.points[l.key]) n = n.total ? 100 / n.total : 0, c[0] = G(c[0] * n), 
                c[1] = G(c[1] * n), a.stackedYData[f] = c[1];
            });
        };
        a.prototype.getStackIndicator = function(a, d, b, f) {
            !r(a) || a.x !== d || f && a.key !== f ? a = {
                x: d,
                index: 0,
                key: f
            } : a.index++;
            a.key = [ b, d, a.index ].join();
            return a;
        };
    })(L);
    (function(a) {
        var B = a.addEvent, A = a.animate, H = a.Axis, G = a.createElement, r = a.css, g = a.defined, f = a.each, u = a.erase, l = a.extend, q = a.fireEvent, d = a.inArray, b = a.isNumber, p = a.isObject, C = a.merge, t = a.pick, m = a.Point, c = a.Series, n = a.seriesTypes, E = a.setAnimation, z = a.splat;
        l(a.Chart.prototype, {
            addSeries: function(a, b, c) {
                var e, d = this;
                a && (b = t(b, !0), q(d, "addSeries", {
                    options: a
                }, function() {
                    e = d.initSeries(a);
                    d.isDirtyLegend = !0;
                    d.linkSeries();
                    b && d.redraw(c);
                }));
                return e;
            },
            addAxis: function(a, b, c, d) {
                var e = b ? "xAxis" : "yAxis", f = this.options;
                a = C(a, {
                    index: this[e].length,
                    isX: b
                });
                new H(this, a);
                f[e] = z(f[e] || {});
                f[e].push(a);
                t(c, !0) && this.redraw(d);
            },
            showLoading: function(a) {
                var b = this, c = b.options, e = b.loadingDiv, d = c.loading, f = function() {
                    e && r(e, {
                        left: b.plotLeft + "px",
                        top: b.plotTop + "px",
                        width: b.plotWidth + "px",
                        height: b.plotHeight + "px"
                    });
                };
                e || (b.loadingDiv = e = G("div", {
                    className: "highcharts-loading highcharts-loading-hidden"
                }, null, b.container), b.loadingSpan = G("span", {
                    className: "highcharts-loading-inner"
                }, null, e), B(b, "redraw", f));
                e.className = "highcharts-loading";
                b.loadingSpan.innerHTML = a || c.lang.loading;
                r(e, l(d.style, {
                    zIndex: 10
                }));
                r(b.loadingSpan, d.labelStyle);
                b.loadingShown || (r(e, {
                    opacity: 0,
                    display: ""
                }), A(e, {
                    opacity: d.style.opacity || .5
                }, {
                    duration: d.showDuration || 0
                }));
                b.loadingShown = !0;
                f();
            },
            hideLoading: function() {
                var a = this.options, b = this.loadingDiv;
                b && (b.className = "highcharts-loading highcharts-loading-hidden", A(b, {
                    opacity: 0
                }, {
                    duration: a.loading.hideDuration || 100,
                    complete: function() {
                        r(b, {
                            display: "none"
                        });
                    }
                }));
                this.loadingShown = !1;
            },
            propsRequireDirtyBox: "backgroundColor borderColor borderWidth margin marginTop marginRight marginBottom marginLeft spacing spacingTop spacingRight spacingBottom spacingLeft borderRadius plotBackgroundColor plotBackgroundImage plotBorderColor plotBorderWidth plotShadow shadow".split(" "),
            propsRequireUpdateSeries: "chart.inverted chart.polar chart.ignoreHiddenSeries chart.type colors plotOptions".split(" "),
            update: function(a, c) {
                var e, n = {
                    credits: "addCredits",
                    title: "setTitle",
                    subtitle: "setSubtitle"
                }, h = a.chart, m, p;
                if (h) {
                    C(!0, this.options.chart, h);
                    "className" in h && this.setClassName(h.className);
                    if ("inverted" in h || "polar" in h) this.propFromSeries(), m = !0;
                    for (e in h) h.hasOwnProperty(e) && (-1 !== d("chart." + e, this.propsRequireUpdateSeries) && (p = !0), 
                    -1 !== d(e, this.propsRequireDirtyBox) && (this.isDirtyBox = !0));
                    "style" in h && this.renderer.setStyle(h.style);
                }
                for (e in a) {
                    if (this[e] && "function" === typeof this[e].update) this[e].update(a[e], !1); else if ("function" === typeof this[n[e]]) this[n[e]](a[e]);
                    "chart" !== e && -1 !== d(e, this.propsRequireUpdateSeries) && (p = !0);
                }
                a.colors && (this.options.colors = a.colors);
                a.plotOptions && C(!0, this.options.plotOptions, a.plotOptions);
                f([ "xAxis", "yAxis", "series" ], function(b) {
                    a[b] && f(z(a[b]), function(a, c) {
                        (c = g(a.id) && this.get(a.id) || this[b][c]) && c.coll === b && c.update(a, !1);
                    }, this);
                }, this);
                m && f(this.axes, function(a) {
                    a.update({}, !1);
                });
                p && f(this.series, function(a) {
                    a.update({}, !1);
                });
                a.loading && C(!0, this.options.loading, a.loading);
                e = h && h.width;
                h = h && h.height;
                b(e) && e !== this.chartWidth || b(h) && h !== this.chartHeight ? this.setSize(e, h) : t(c, !0) && this.redraw();
            },
            setSubtitle: function(a) {
                this.setTitle(void 0, a);
            }
        });
        l(m.prototype, {
            update: function(a, b, c, d) {
                function e() {
                    f.applyOptions(a);
                    null === f.y && n && (f.graphic = n.destroy());
                    p(a, !0) && (n && n.element && a && a.marker && a.marker.symbol && (f.graphic = n.destroy()), 
                    a && a.dataLabels && f.dataLabel && (f.dataLabel = f.dataLabel.destroy()));
                    m = f.index;
                    g.updateParallelArrays(f, m);
                    l.data[m] = p(l.data[m], !0) ? f.options : a;
                    g.isDirty = g.isDirtyData = !0;
                    !g.fixedBox && g.hasCartesianSeries && (k.isDirtyBox = !0);
                    "point" === l.legendType && (k.isDirtyLegend = !0);
                    b && k.redraw(c);
                }
                var f = this, g = f.series, n = f.graphic, m, k = g.chart, l = g.options;
                b = t(b, !0);
                !1 === d ? e() : f.firePointEvent("update", {
                    options: a
                }, e);
            },
            remove: function(a, b) {
                this.series.removePoint(d(this, this.series.data), a, b);
            }
        });
        l(c.prototype, {
            addPoint: function(a, b, c, d) {
                var e = this.options, f = this.data, g = this.chart, n = this.xAxis, n = n && n.hasNames && n.names, m = e.data, k, p, l = this.xData, q, w;
                b = t(b, !0);
                k = {
                    series: this
                };
                this.pointClass.prototype.applyOptions.apply(k, [ a ]);
                w = k.x;
                q = l.length;
                if (this.requireSorting && w < l[q - 1]) for (p = !0; q && l[q - 1] > w; ) q--;
                this.updateParallelArrays(k, "splice", q, 0, 0);
                this.updateParallelArrays(k, q);
                n && k.name && (n[w] = k.name);
                m.splice(q, 0, a);
                p && (this.data.splice(q, 0, null), this.processData());
                "point" === e.legendType && this.generatePoints();
                c && (f[0] && f[0].remove ? f[0].remove(!1) : (f.shift(), this.updateParallelArrays(k, "shift"), 
                m.shift()));
                this.isDirtyData = this.isDirty = !0;
                b && g.redraw(d);
            },
            removePoint: function(a, b, c) {
                var e = this, d = e.data, f = d[a], g = e.points, n = e.chart, m = function() {
                    g && g.length === d.length && g.splice(a, 1);
                    d.splice(a, 1);
                    e.options.data.splice(a, 1);
                    e.updateParallelArrays(f || {
                        series: e
                    }, "splice", a, 1);
                    f && f.destroy();
                    e.isDirty = !0;
                    e.isDirtyData = !0;
                    b && n.redraw();
                };
                E(c, n);
                b = t(b, !0);
                f ? f.firePointEvent("remove", null, m) : m();
            },
            remove: function(a, b, c) {
                function e() {
                    d.destroy();
                    f.isDirtyLegend = f.isDirtyBox = !0;
                    f.linkSeries();
                    t(a, !0) && f.redraw(b);
                }
                var d = this, f = d.chart;
                !1 !== c ? q(d, "remove", null, e) : e();
            },
            update: function(a, b) {
                var c = this, e = this.chart, d = this.userOptions, g = this.type, m = a.type || d.type || e.options.chart.type, p = n[g].prototype, q = [ "group", "markerGroup", "dataLabelsGroup" ], k;
                if (m && m !== g || void 0 !== a.zIndex) q.length = 0;
                f(q, function(a) {
                    q[a] = c[a];
                    delete c[a];
                });
                a = C(d, {
                    animation: !1,
                    index: this.index,
                    pointStart: this.xData[0]
                }, {
                    data: this.options.data
                }, a);
                this.remove(!1, null, !1);
                for (k in p) this[k] = void 0;
                l(this, n[m || g].prototype);
                f(q, function(a) {
                    c[a] = q[a];
                });
                this.init(e, a);
                e.linkSeries();
                t(b, !0) && e.redraw(!1);
            }
        });
        l(H.prototype, {
            update: function(a, b) {
                var c = this.chart;
                a = c.options[this.coll][this.options.index] = C(this.userOptions, a);
                this.destroy(!0);
                this.init(c, l(a, {
                    events: void 0
                }));
                c.isDirtyBox = !0;
                t(b, !0) && c.redraw();
            },
            remove: function(a) {
                for (var b = this.chart, c = this.coll, e = this.series, d = e.length; d--; ) e[d] && e[d].remove(!1);
                u(b.axes, this);
                u(b[c], this);
                b.options[c].splice(this.options.index, 1);
                f(b[c], function(a, b) {
                    a.options.index = b;
                });
                this.destroy();
                b.isDirtyBox = !0;
                t(a, !0) && b.redraw();
            },
            setTitle: function(a, b) {
                this.update({
                    title: a
                }, b);
            },
            setCategories: function(a, b) {
                this.update({
                    categories: a
                }, b);
            }
        });
    })(L);
    (function(a) {
        var B = a.color, A = a.each, H = a.map, G = a.pick, r = a.Series, g = a.seriesType;
        g("area", "line", {
            softThreshold: !1,
            threshold: 0
        }, {
            singleStacks: !1,
            getStackPoints: function() {
                var a = [], g = [], l = this.xAxis, q = this.yAxis, d = q.stacks[this.stackKey], b = {}, p = this.points, r = this.index, t = q.series, m = t.length, c, n = G(q.options.reversedStacks, !0) ? 1 : -1, E, z;
                if (this.options.stacking) {
                    for (E = 0; E < p.length; E++) b[p[E].x] = p[E];
                    for (z in d) null !== d[z].total && g.push(z);
                    g.sort(function(a, b) {
                        return a - b;
                    });
                    c = H(t, function() {
                        return this.visible;
                    });
                    A(g, function(e, f) {
                        var p = 0, t, h;
                        if (b[e] && !b[e].isNull) a.push(b[e]), A([ -1, 1 ], function(a) {
                            var p = 1 === a ? "rightNull" : "leftNull", l = 0, q = d[g[f + a]];
                            if (q) for (E = r; 0 <= E && E < m; ) t = q.points[E], t || (E === r ? b[e][p] = !0 : c[E] && (h = d[e].points[E]) && (l -= h[1] - h[0])), 
                            E += n;
                            b[e][1 === a ? "rightCliff" : "leftCliff"] = l;
                        }); else {
                            for (E = r; 0 <= E && E < m; ) {
                                if (t = d[e].points[E]) {
                                    p = t[1];
                                    break;
                                }
                                E += n;
                            }
                            p = q.toPixels(p, !0);
                            a.push({
                                isNull: !0,
                                plotX: l.toPixels(e, !0),
                                plotY: p,
                                yBottom: p
                            });
                        }
                    });
                }
                return a;
            },
            getGraphPath: function(a) {
                var f = r.prototype.getGraphPath, g = this.options, q = g.stacking, d = this.yAxis, b, p, C = [], t = [], m = this.index, c, n = d.stacks[this.stackKey], E = g.threshold, z = d.getThreshold(g.threshold), e, g = g.connectNulls || "percent" === q, x = function(b, e, f) {
                    var h = a[b];
                    b = q && n[h.x].points[m];
                    var g = h[f + "Null"] || 0;
                    f = h[f + "Cliff"] || 0;
                    var p, l, h = !0;
                    f || g ? (p = (g ? b[0] : b[1]) + f, l = b[0] + f, h = !!g) : !q && a[e] && a[e].isNull && (p = l = E);
                    void 0 !== p && (t.push({
                        plotX: c,
                        plotY: null === p ? z : d.getThreshold(p),
                        isNull: h
                    }), C.push({
                        plotX: c,
                        plotY: null === l ? z : d.getThreshold(l),
                        doCurve: !1
                    }));
                };
                a = a || this.points;
                q && (a = this.getStackPoints());
                for (b = 0; b < a.length; b++) if (p = a[b].isNull, c = G(a[b].rectPlotX, a[b].plotX), 
                e = G(a[b].yBottom, z), !p || g) g || x(b, b - 1, "left"), p && !q && g || (t.push(a[b]), 
                C.push({
                    x: b,
                    plotX: c,
                    plotY: e
                })), g || x(b, b + 1, "right");
                b = f.call(this, t, !0, !0);
                C.reversed = !0;
                p = f.call(this, C, !0, !0);
                p.length && (p[0] = "L");
                p = b.concat(p);
                f = f.call(this, t, !1, g);
                p.xMap = b.xMap;
                this.areaPath = p;
                return f;
            },
            drawGraph: function() {
                this.areaPath = [];
                r.prototype.drawGraph.apply(this);
                var a = this, g = this.areaPath, l = this.options, q = [ [ "area", "highcharts-area", this.color, l.fillColor ] ];
                A(this.zones, function(d, b) {
                    q.push([ "zone-area-" + b, "highcharts-area highcharts-zone-area-" + b + " " + d.className, d.color || a.color, d.fillColor || l.fillColor ]);
                });
                A(q, function(d) {
                    var b = d[0], f = a[b];
                    f ? (f.endX = g.xMap, f.animate({
                        d: g
                    })) : (f = a[b] = a.chart.renderer.path(g).addClass(d[1]).attr({
                        fill: G(d[3], B(d[2]).setOpacity(G(l.fillOpacity, .75)).get()),
                        zIndex: 0
                    }).add(a.group), f.isArea = !0);
                    f.startX = g.xMap;
                    f.shiftUnit = l.step ? 2 : 1;
                });
            },
            drawLegendSymbol: a.LegendSymbolMixin.drawRectangle
        });
    })(L);
    (function(a) {
        var B = a.pick;
        a = a.seriesType;
        a("spline", "line", {}, {
            getPointSpline: function(a, H, G) {
                var r = H.plotX, g = H.plotY, f = a[G - 1];
                G = a[G + 1];
                var u, l, q, d;
                if (f && !f.isNull && !1 !== f.doCurve && G && !G.isNull && !1 !== G.doCurve) {
                    a = f.plotY;
                    q = G.plotX;
                    G = G.plotY;
                    var b = 0;
                    u = (1.5 * r + f.plotX) / 2.5;
                    l = (1.5 * g + a) / 2.5;
                    q = (1.5 * r + q) / 2.5;
                    d = (1.5 * g + G) / 2.5;
                    q !== u && (b = (d - l) * (q - r) / (q - u) + g - d);
                    l += b;
                    d += b;
                    l > a && l > g ? (l = Math.max(a, g), d = 2 * g - l) : l < a && l < g && (l = Math.min(a, g), 
                    d = 2 * g - l);
                    d > G && d > g ? (d = Math.max(G, g), l = 2 * g - d) : d < G && d < g && (d = Math.min(G, g), 
                    l = 2 * g - d);
                    H.rightContX = q;
                    H.rightContY = d;
                }
                H = [ "C", B(f.rightContX, f.plotX), B(f.rightContY, f.plotY), B(u, r), B(l, g), r, g ];
                f.rightContX = f.rightContY = null;
                return H;
            }
        });
    })(L);
    (function(a) {
        var B = a.seriesTypes.area.prototype, A = a.seriesType;
        A("areaspline", "spline", a.defaultPlotOptions.area, {
            getStackPoints: B.getStackPoints,
            getGraphPath: B.getGraphPath,
            setStackCliffs: B.setStackCliffs,
            drawGraph: B.drawGraph,
            drawLegendSymbol: a.LegendSymbolMixin.drawRectangle
        });
    })(L);
    (function(a) {
        var B = a.animObject, A = a.color, H = a.each, G = a.extend, r = a.isNumber, g = a.merge, f = a.pick, u = a.Series, l = a.seriesType, q = a.svg;
        l("column", "line", {
            borderRadius: 0,
            groupPadding: .2,
            marker: null,
            pointPadding: .1,
            minPointLength: 0,
            cropThreshold: 50,
            pointRange: null,
            states: {
                hover: {
                    halo: !1,
                    brightness: .1,
                    shadow: !1
                },
                select: {
                    color: "#cccccc",
                    borderColor: "#000000",
                    shadow: !1
                }
            },
            dataLabels: {
                align: null,
                verticalAlign: null,
                y: null
            },
            softThreshold: !1,
            startFromThreshold: !0,
            stickyTracking: !1,
            tooltip: {
                distance: 6
            },
            threshold: 0,
            borderColor: "#ffffff"
        }, {
            cropShoulder: 0,
            directTouch: !0,
            trackerGroups: [ "group", "dataLabelsGroup" ],
            negStacks: !0,
            init: function() {
                u.prototype.init.apply(this, arguments);
                var a = this, b = a.chart;
                b.hasRendered && H(b.series, function(b) {
                    b.type === a.type && (b.isDirty = !0);
                });
            },
            getColumnMetrics: function() {
                var a = this, b = a.options, g = a.xAxis, l = a.yAxis, t = g.reversed, m, c = {}, n = 0;
                !1 === b.grouping ? n = 1 : H(a.chart.series, function(b) {
                    var e = b.options, d = b.yAxis, f;
                    b.type === a.type && b.visible && l.len === d.len && l.pos === d.pos && (e.stacking ? (m = b.stackKey, 
                    void 0 === c[m] && (c[m] = n++), f = c[m]) : !1 !== e.grouping && (f = n++), b.columnIndex = f);
                });
                var q = Math.min(Math.abs(g.transA) * (g.ordinalSlope || b.pointRange || g.closestPointRange || g.tickInterval || 1), g.len), r = q * b.groupPadding, e = (q - 2 * r) / (n || 1), b = Math.min(b.maxPointWidth || g.len, f(b.pointWidth, e * (1 - 2 * b.pointPadding)));
                a.columnMetrics = {
                    width: b,
                    offset: (e - b) / 2 + (r + ((a.columnIndex || 0) + (t ? 1 : 0)) * e - q / 2) * (t ? -1 : 1)
                };
                return a.columnMetrics;
            },
            crispCol: function(a, b, f, g) {
                var d = this.chart, m = this.borderWidth, c = -(m % 2 ? .5 : 0), m = m % 2 ? .5 : 1;
                d.inverted && d.renderer.isVML && (m += 1);
                f = Math.round(a + f) + c;
                a = Math.round(a) + c;
                g = Math.round(b + g) + m;
                c = .5 >= Math.abs(b) && .5 < g;
                b = Math.round(b) + m;
                g -= b;
                c && g && (--b, g += 1);
                return {
                    x: a,
                    y: b,
                    width: f - a,
                    height: g
                };
            },
            translate: function() {
                var a = this, b = a.chart, g = a.options, l = a.dense = 2 > a.closestPointRange * a.xAxis.transA, l = a.borderWidth = f(g.borderWidth, l ? 0 : 1), t = a.yAxis, m = a.translatedThreshold = t.getThreshold(g.threshold), c = f(g.minPointLength, 5), n = a.getColumnMetrics(), q = n.width, r = a.barW = Math.max(q, 1 + 2 * l), e = a.pointXOffset = n.offset;
                b.inverted && (m -= .5);
                g.pointPadding && (r = Math.ceil(r));
                u.prototype.translate.apply(a);
                H(a.points, function(d) {
                    var g = f(d.yBottom, m), n = 999 + Math.abs(g), n = Math.min(Math.max(-n, d.plotY), t.len + n), h = d.plotX + e, l = r, p = Math.min(n, g), z, x = Math.max(n, g) - p;
                    Math.abs(x) < c && c && (x = c, z = !t.reversed && !d.negative || t.reversed && d.negative, 
                    p = Math.abs(p - m) > c ? g - c : m - (z ? c : 0));
                    d.barX = h;
                    d.pointWidth = q;
                    d.tooltipPos = b.inverted ? [ t.len + t.pos - b.plotLeft - n, a.xAxis.len - h - l / 2, x ] : [ h + l / 2, n + t.pos - b.plotTop, x ];
                    d.shapeType = "rect";
                    d.shapeArgs = a.crispCol.apply(a, d.isNull ? [ d.plotX, t.len / 2, 0, 0 ] : [ h, p, l, x ]);
                });
            },
            getSymbol: a.noop,
            drawLegendSymbol: a.LegendSymbolMixin.drawRectangle,
            drawGraph: function() {
                this.group[this.dense ? "addClass" : "removeClass"]("highcharts-dense-data");
            },
            pointAttribs: function(a, b) {
                var d = this.options, f, g = this.pointAttrToOptions || {};
                f = g.stroke || "borderColor";
                var m = g["stroke-width"] || "borderWidth", c = a && a.color || this.color, n = a[f] || d[f] || this.color || c, l = a[m] || d[m] || this[m] || 0, g = d.dashStyle;
                a && this.zones.length && (c = (c = a.getZone()) && c.color || a.options.color || this.color);
                b && (a = d.states[b], b = a.brightness, c = a.color || void 0 !== b && A(c).brighten(a.brightness).get() || c, 
                n = a[f] || n, l = a[m] || l, g = a.dashStyle || g);
                f = {
                    fill: c,
                    stroke: n,
                    "stroke-width": l
                };
                d.borderRadius && (f.r = d.borderRadius);
                g && (f.dashstyle = g);
                return f;
            },
            drawPoints: function() {
                var a = this, b = this.chart, f = a.options, l = b.renderer, t = f.animationLimit || 250, m;
                H(a.points, function(c) {
                    var d = c.graphic;
                    if (r(c.plotY) && null !== c.y) {
                        m = c.shapeArgs;
                        if (d) d[b.pointCount < t ? "animate" : "attr"](g(m)); else c.graphic = d = l[c.shapeType](m).attr({
                            "class": c.getClassName()
                        }).add(c.group || a.group);
                        d.attr(a.pointAttribs(c, c.selected && "select")).shadow(f.shadow, null, f.stacking && !f.borderRadius);
                    } else d && (c.graphic = d.destroy());
                });
            },
            animate: function(a) {
                var b = this, d = this.yAxis, f = b.options, g = this.chart.inverted, m = {};
                q && (a ? (m.scaleY = .001, a = Math.min(d.pos + d.len, Math.max(d.pos, d.toPixels(f.threshold))), 
                g ? m.translateX = a - d.len : m.translateY = a, b.group.attr(m)) : (m[g ? "translateX" : "translateY"] = d.pos, 
                b.group.animate(m, G(B(b.options.animation), {
                    step: function(a, d) {
                        b.group.attr({
                            scaleY: Math.max(.001, d.pos)
                        });
                    }
                })), b.animate = null));
            },
            remove: function() {
                var a = this, b = a.chart;
                b.hasRendered && H(b.series, function(b) {
                    b.type === a.type && (b.isDirty = !0);
                });
                u.prototype.remove.apply(a, arguments);
            }
        });
    })(L);
    (function(a) {
        a = a.seriesType;
        a("bar", "column", null, {
            inverted: !0
        });
    })(L);
    (function(a) {
        var B = a.Series;
        a = a.seriesType;
        a("scatter", "line", {
            lineWidth: 0,
            marker: {
                enabled: !0
            },
            tooltip: {
                headerFormat: '<span style="color:{point.color}">â</span> <span style="font-size: 0.85em"> {series.name}</span><br/>',
                pointFormat: "x: <b>{point.x}</b><br/>y: <b>{point.y}</b><br/>"
            }
        }, {
            sorted: !1,
            requireSorting: !1,
            noSharedTooltip: !0,
            trackerGroups: [ "group", "markerGroup", "dataLabelsGroup" ],
            takeOrdinalPosition: !1,
            kdDimensions: 2,
            drawGraph: function() {
                this.options.lineWidth && B.prototype.drawGraph.call(this);
            }
        });
    })(L);
    (function(a) {
        var B = a.pick, A = a.relativeLength;
        a.CenteredSeriesMixin = {
            getCenter: function() {
                var a = this.options, G = this.chart, r = 2 * (a.slicedOffset || 0), g = G.plotWidth - 2 * r, G = G.plotHeight - 2 * r, f = a.center, f = [ B(f[0], "50%"), B(f[1], "50%"), a.size || "100%", a.innerSize || 0 ], u = Math.min(g, G), l, q;
                for (l = 0; 4 > l; ++l) q = f[l], a = 2 > l || 2 === l && /%$/.test(q), f[l] = A(q, [ g, G, u, f[2] ][l]) + (a ? r : 0);
                f[3] > f[2] && (f[3] = f[2]);
                return f;
            }
        };
    })(L);
    (function(a) {
        var B = a.addEvent, A = a.defined, H = a.each, G = a.extend, r = a.inArray, g = a.noop, f = a.pick, u = a.Point, l = a.Series, q = a.seriesType, d = a.setAnimation;
        q("pie", "line", {
            center: [ null, null ],
            clip: !1,
            colorByPoint: !0,
            dataLabels: {
                distance: 30,
                enabled: !0,
                formatter: function() {
                    return null === this.y ? void 0 : this.point.name;
                },
                x: 0
            },
            ignoreHiddenPoint: !0,
            legendType: "point",
            marker: null,
            size: null,
            showInLegend: !1,
            slicedOffset: 10,
            stickyTracking: !1,
            tooltip: {
                followPointer: !0
            },
            borderColor: "#ffffff",
            borderWidth: 1,
            states: {
                hover: {
                    brightness: .1,
                    shadow: !1
                }
            }
        }, {
            isCartesian: !1,
            requireSorting: !1,
            directTouch: !0,
            noSharedTooltip: !0,
            trackerGroups: [ "group", "dataLabelsGroup" ],
            axisTypes: [],
            pointAttribs: a.seriesTypes.column.prototype.pointAttribs,
            animate: function(a) {
                var b = this, d = b.points, f = b.startAngleRad;
                a || (H(d, function(a) {
                    var c = a.graphic, d = a.shapeArgs;
                    c && (c.attr({
                        r: a.startR || b.center[3] / 2,
                        start: f,
                        end: f
                    }), c.animate({
                        r: d.r,
                        start: d.start,
                        end: d.end
                    }, b.options.animation));
                }), b.animate = null);
            },
            updateTotals: function() {
                var a, d = 0, f = this.points, g = f.length, m, c = this.options.ignoreHiddenPoint;
                for (a = 0; a < g; a++) m = f[a], 0 > m.y && (m.y = null), d += c && !m.visible ? 0 : m.y;
                this.total = d;
                for (a = 0; a < g; a++) m = f[a], m.percentage = 0 < d && (m.visible || !c) ? m.y / d * 100 : 0, 
                m.total = d;
            },
            generatePoints: function() {
                l.prototype.generatePoints.call(this);
                this.updateTotals();
            },
            translate: function(a) {
                this.generatePoints();
                var b = 0, d = this.options, g = d.slicedOffset, m = g + (d.borderWidth || 0), c, n, l, q = d.startAngle || 0, e = this.startAngleRad = Math.PI / 180 * (q - 90), q = (this.endAngleRad = Math.PI / 180 * (f(d.endAngle, q + 360) - 90)) - e, r = this.points, u = d.dataLabels.distance, d = d.ignoreHiddenPoint, w, h = r.length, y;
                a || (this.center = a = this.getCenter());
                this.getX = function(b, c) {
                    l = Math.asin(Math.min((b - a[1]) / (a[2] / 2 + u), 1));
                    return a[0] + (c ? -1 : 1) * Math.cos(l) * (a[2] / 2 + u);
                };
                for (w = 0; w < h; w++) {
                    y = r[w];
                    c = e + b * q;
                    if (!d || y.visible) b += y.percentage / 100;
                    n = e + b * q;
                    y.shapeType = "arc";
                    y.shapeArgs = {
                        x: a[0],
                        y: a[1],
                        r: a[2] / 2,
                        innerR: a[3] / 2,
                        start: Math.round(1e3 * c) / 1e3,
                        end: Math.round(1e3 * n) / 1e3
                    };
                    l = (n + c) / 2;
                    l > 1.5 * Math.PI ? l -= 2 * Math.PI : l < -Math.PI / 2 && (l += 2 * Math.PI);
                    y.slicedTranslation = {
                        translateX: Math.round(Math.cos(l) * g),
                        translateY: Math.round(Math.sin(l) * g)
                    };
                    c = Math.cos(l) * a[2] / 2;
                    n = Math.sin(l) * a[2] / 2;
                    y.tooltipPos = [ a[0] + .7 * c, a[1] + .7 * n ];
                    y.half = l < -Math.PI / 2 || l > Math.PI / 2 ? 1 : 0;
                    y.angle = l;
                    m = Math.min(m, u / 5);
                    y.labelPos = [ a[0] + c + Math.cos(l) * u, a[1] + n + Math.sin(l) * u, a[0] + c + Math.cos(l) * m, a[1] + n + Math.sin(l) * m, a[0] + c, a[1] + n, 0 > u ? "center" : y.half ? "right" : "left", l ];
                }
            },
            drawGraph: null,
            drawPoints: function() {
                var a = this, d = a.chart.renderer, f, g, m, c, n = a.options.shadow;
                n && !a.shadowGroup && (a.shadowGroup = d.g("shadow").add(a.group));
                H(a.points, function(b) {
                    if (null !== b.y) {
                        g = b.graphic;
                        c = b.shapeArgs;
                        f = b.sliced ? b.slicedTranslation : {};
                        var l = b.shadowGroup;
                        n && !l && (l = b.shadowGroup = d.g("shadow").add(a.shadowGroup));
                        l && l.attr(f);
                        m = a.pointAttribs(b, b.selected && "select");
                        g ? g.setRadialReference(a.center).attr(m).animate(G(c, f)) : (b.graphic = g = d[b.shapeType](c).addClass(b.getClassName()).setRadialReference(a.center).attr(f).add(a.group), 
                        b.visible || g.attr({
                            visibility: "hidden"
                        }), g.attr(m).attr({
                            "stroke-linejoin": "round"
                        }).shadow(n, l));
                    }
                });
            },
            searchPoint: g,
            sortByAngle: function(a, d) {
                a.sort(function(a, b) {
                    return void 0 !== a.angle && (b.angle - a.angle) * d;
                });
            },
            drawLegendSymbol: a.LegendSymbolMixin.drawRectangle,
            getCenter: a.CenteredSeriesMixin.getCenter,
            getSymbol: g
        }, {
            init: function() {
                u.prototype.init.apply(this, arguments);
                var a = this, d;
                a.name = f(a.name, "Slice");
                d = function(b) {
                    a.slice("select" === b.type);
                };
                B(a, "select", d);
                B(a, "unselect", d);
                return a;
            },
            setVisible: function(a, d) {
                var b = this, g = b.series, m = g.chart, c = g.options.ignoreHiddenPoint;
                d = f(d, c);
                a !== b.visible && (b.visible = b.options.visible = a = void 0 === a ? !b.visible : a, 
                g.options.data[r(b, g.data)] = b.options, H([ "graphic", "dataLabel", "connector", "shadowGroup" ], function(c) {
                    if (b[c]) b[c][a ? "show" : "hide"](!0);
                }), b.legendItem && m.legend.colorizeItem(b, a), a || "hover" !== b.state || b.setState(""), 
                c && (g.isDirty = !0), d && m.redraw());
            },
            slice: function(a, g, l) {
                var b = this.series;
                d(l, b.chart);
                f(g, !0);
                this.sliced = this.options.sliced = a = A(a) ? a : !this.sliced;
                b.options.data[r(this, b.data)] = this.options;
                a = a ? this.slicedTranslation : {
                    translateX: 0,
                    translateY: 0
                };
                this.graphic.animate(a);
                this.shadowGroup && this.shadowGroup.animate(a);
            },
            haloPath: function(a) {
                var b = this.shapeArgs;
                return this.sliced || !this.visible ? [] : this.series.chart.renderer.symbols.arc(b.x, b.y, b.r + a, b.r + a, {
                    innerR: this.shapeArgs.r,
                    start: b.start,
                    end: b.end
                });
            }
        });
    })(L);
    (function(a) {
        var B = a.addEvent, A = a.arrayMax, H = a.defined, G = a.each, r = a.extend, g = a.format, f = a.map, u = a.merge, l = a.noop, q = a.pick, d = a.relativeLength, b = a.Series, p = a.seriesTypes, C = a.stableSort;
        a.distribute = function(a, b) {
            function c(a, b) {
                return a.target - b.target;
            }
            var d, g = !0, m = a, e = [], l;
            l = 0;
            for (d = a.length; d--; ) l += a[d].size;
            if (l > b) {
                C(a, function(a, b) {
                    return (b.rank || 0) - (a.rank || 0);
                });
                for (l = d = 0; l <= b; ) l += a[d].size, d++;
                e = a.splice(d - 1, a.length);
            }
            C(a, c);
            for (a = f(a, function(a) {
                return {
                    size: a.size,
                    targets: [ a.target ]
                };
            }); g; ) {
                for (d = a.length; d--; ) g = a[d], l = (Math.min.apply(0, g.targets) + Math.max.apply(0, g.targets)) / 2, 
                g.pos = Math.min(Math.max(0, l - g.size / 2), b - g.size);
                d = a.length;
                for (g = !1; d--; ) 0 < d && a[d - 1].pos + a[d - 1].size > a[d].pos && (a[d - 1].size += a[d].size, 
                a[d - 1].targets = a[d - 1].targets.concat(a[d].targets), a[d - 1].pos + a[d - 1].size > b && (a[d - 1].pos = b - a[d - 1].size), 
                a.splice(d, 1), g = !0);
            }
            d = 0;
            G(a, function(a) {
                var b = 0;
                G(a.targets, function() {
                    m[d].pos = a.pos + b;
                    b += m[d].size;
                    d++;
                });
            });
            m.push.apply(m, e);
            C(m, c);
        };
        b.prototype.drawDataLabels = function() {
            var a = this, b = a.options, c = b.dataLabels, d = a.points, f, l, e = a.hasRendered || 0, p, r, w = q(c.defer, !0), h = a.chart.renderer;
            if (c.enabled || a._hasPointLabels) a.dlProcessOptions && a.dlProcessOptions(c), 
            r = a.plotGroup("dataLabelsGroup", "data-labels", w && !e ? "hidden" : "visible", c.zIndex || 6), 
            w && (r.attr({
                opacity: +e
            }), e || B(a, "afterAnimate", function() {
                a.visible && r.show(!0);
                r[b.animation ? "animate" : "attr"]({
                    opacity: 1
                }, {
                    duration: 200
                });
            })), l = c, G(d, function(e) {
                var d, m = e.dataLabel, n, k, t, z = e.connector, w = !m, x;
                f = e.dlOptions || e.options && e.options.dataLabels;
                if (d = q(f && f.enabled, l.enabled) && null !== e.y) for (k in c = u(l, f), n = e.getLabelConfig(), 
                p = c.format ? g(c.format, n) : c.formatter.call(n, c), x = c.style, t = c.rotation, 
                x.color = q(c.color, x.color, a.color, "#000000"), "contrast" === x.color && (x.color = c.inside || 0 > c.distance || b.stacking ? h.getContrast(e.color || a.color) : "#000000"), 
                b.cursor && (x.cursor = b.cursor), n = {
                    fill: c.backgroundColor,
                    stroke: c.borderColor,
                    "stroke-width": c.borderWidth,
                    r: c.borderRadius || 0,
                    rotation: t,
                    padding: c.padding,
                    zIndex: 1
                }, n) void 0 === n[k] && delete n[k];
                !m || d && H(p) ? d && H(p) && (m ? n.text = p : (m = e.dataLabel = h[t ? "text" : "label"](p, 0, -9999, c.shape, null, null, c.useHTML, null, "data-label"), 
                m.addClass("highcharts-data-label-color-" + e.colorIndex + " " + (c.className || "") + (c.useHTML ? "highcharts-tracker" : ""))), 
                m.attr(n), m.css(x).shadow(c.shadow), m.added || m.add(r), a.alignDataLabel(e, m, c, null, w)) : (e.dataLabel = m.destroy(), 
                z && (e.connector = z.destroy()));
            });
        };
        b.prototype.alignDataLabel = function(a, b, c, d, f) {
            var g = this.chart, e = g.inverted, m = q(a.plotX, -9999), n = q(a.plotY, -9999), l = b.getBBox(), h, p = c.rotation, t = c.align, u = this.visible && (a.series.forceDL || g.isInsidePlot(m, Math.round(n), e) || d && g.isInsidePlot(m, e ? d.x + 1 : d.y + d.height - 1, e)), E = "justify" === q(c.overflow, "justify");
            u && (h = c.style.fontSize, h = g.renderer.fontMetrics(h, b).b, d = r({
                x: e ? g.plotWidth - n : m,
                y: Math.round(e ? g.plotHeight - m : n),
                width: 0,
                height: 0
            }, d), r(c, {
                width: l.width,
                height: l.height
            }), p ? (E = !1, e = g.renderer.rotCorr(h, p), e = {
                x: d.x + c.x + d.width / 2 + e.x,
                y: d.y + c.y + {
                    top: 0,
                    middle: .5,
                    bottom: 1
                }[c.verticalAlign] * d.height
            }, b[f ? "attr" : "animate"](e).attr({
                align: t
            }), m = (p + 720) % 360, m = 180 < m && 360 > m, "left" === t ? e.y -= m ? l.height : 0 : "center" === t ? (e.x -= l.width / 2, 
            e.y -= l.height / 2) : "right" === t && (e.x -= l.width, e.y -= m ? 0 : l.height)) : (b.align(c, null, d), 
            e = b.alignAttr), E ? this.justifyDataLabel(b, c, e, l, d, f) : q(c.crop, !0) && (u = g.isInsidePlot(e.x, e.y) && g.isInsidePlot(e.x + l.width, e.y + l.height)), 
            c.shape && !p && b.attr({
                anchorX: a.plotX,
                anchorY: a.plotY
            }));
            u || (b.attr({
                y: -9999
            }), b.placed = !1);
        };
        b.prototype.justifyDataLabel = function(a, b, c, d, f, g) {
            var e = this.chart, m = b.align, n = b.verticalAlign, l, h, p = a.box ? 0 : a.padding || 0;
            l = c.x + p;
            0 > l && ("right" === m ? b.align = "left" : b.x = -l, h = !0);
            l = c.x + d.width - p;
            l > e.plotWidth && ("left" === m ? b.align = "right" : b.x = e.plotWidth - l, h = !0);
            l = c.y + p;
            0 > l && ("bottom" === n ? b.verticalAlign = "top" : b.y = -l, h = !0);
            l = c.y + d.height - p;
            l > e.plotHeight && ("top" === n ? b.verticalAlign = "bottom" : b.y = e.plotHeight - l, 
            h = !0);
            h && (a.placed = !g, a.align(b, null, f));
        };
        p.pie && (p.pie.prototype.drawDataLabels = function() {
            var d = this, g = d.data, c, l = d.chart, p = d.options.dataLabels, r = q(p.connectorPadding, 10), e = q(p.connectorWidth, 1), u = l.plotWidth, F = l.plotHeight, w, h = p.distance, y = d.center, C = y[2] / 2, B = y[1], H = 0 < h, k, D, L, N, S = [ [], [] ], O, v, M, Q, R = [ 0, 0, 0, 0 ];
            d.visible && (p.enabled || d._hasPointLabels) && (b.prototype.drawDataLabels.apply(d), 
            G(g, function(a) {
                a.dataLabel && a.visible && (S[a.half].push(a), a.dataLabel._pos = null);
            }), G(S, function(b, e) {
                var g, m, n = b.length, q, t, z;
                if (n) for (d.sortByAngle(b, e - .5), 0 < h && (g = Math.max(0, B - C - h), m = Math.min(B + C + h, l.plotHeight), 
                q = f(b, function(a) {
                    if (a.dataLabel) return z = a.dataLabel.getBBox().height || 21, {
                        target: a.labelPos[1] - g + z / 2,
                        size: z,
                        rank: a.y
                    };
                }), a.distribute(q, m + z - g)), Q = 0; Q < n; Q++) c = b[Q], L = c.labelPos, k = c.dataLabel, 
                M = !1 === c.visible ? "hidden" : "inherit", t = L[1], q ? void 0 === q[Q].pos ? M = "hidden" : (N = q[Q].size, 
                v = g + q[Q].pos) : v = t, O = p.justify ? y[0] + (e ? -1 : 1) * (C + h) : d.getX(v < g + 2 || v > m - 2 ? t : v, e), 
                k._attr = {
                    visibility: M,
                    align: L[6]
                }, k._pos = {
                    x: O + p.x + ({
                        left: r,
                        right: -r
                    }[L[6]] || 0),
                    y: v + p.y - 10
                }, L.x = O, L.y = v, null === d.options.size && (D = k.width, O - D < r ? R[3] = Math.max(Math.round(D - O + r), R[3]) : O + D > u - r && (R[1] = Math.max(Math.round(O + D - u + r), R[1])), 
                0 > v - N / 2 ? R[0] = Math.max(Math.round(-v + N / 2), R[0]) : v + N / 2 > F && (R[2] = Math.max(Math.round(v + N / 2 - F), R[2])));
            }), 0 === A(R) || this.verifyDataLabelOverflow(R)) && (this.placeDataLabels(), H && e && G(this.points, function(a) {
                var b;
                w = a.connector;
                if ((k = a.dataLabel) && k._pos && a.visible) {
                    M = k._attr.visibility;
                    if (b = !w) a.connector = w = l.renderer.path().addClass("highcharts-data-label-connector highcharts-color-" + a.colorIndex).add(d.dataLabelsGroup), 
                    w.attr({
                        "stroke-width": e,
                        stroke: p.connectorColor || a.color || "#666666"
                    });
                    w[b ? "attr" : "animate"]({
                        d: d.connectorPath(a.labelPos)
                    });
                    w.attr("visibility", M);
                } else w && (a.connector = w.destroy());
            }));
        }, p.pie.prototype.connectorPath = function(a) {
            var b = a.x, c = a.y;
            return q(this.options.dataLabels.softConnector, !0) ? [ "M", b + ("left" === a[6] ? 5 : -5), c, "C", b, c, 2 * a[2] - a[4], 2 * a[3] - a[5], a[2], a[3], "L", a[4], a[5] ] : [ "M", b + ("left" === a[6] ? 5 : -5), c, "L", a[2], a[3], "L", a[4], a[5] ];
        }, p.pie.prototype.placeDataLabels = function() {
            G(this.points, function(a) {
                var b = a.dataLabel;
                b && a.visible && ((a = b._pos) ? (b.attr(b._attr), b[b.moved ? "animate" : "attr"](a), 
                b.moved = !0) : b && b.attr({
                    y: -9999
                }));
            });
        }, p.pie.prototype.alignDataLabel = l, p.pie.prototype.verifyDataLabelOverflow = function(a) {
            var b = this.center, c = this.options, f = c.center, g = c.minSize || 80, l, e;
            null !== f[0] ? l = Math.max(b[2] - Math.max(a[1], a[3]), g) : (l = Math.max(b[2] - a[1] - a[3], g), 
            b[0] += (a[3] - a[1]) / 2);
            null !== f[1] ? l = Math.max(Math.min(l, b[2] - Math.max(a[0], a[2])), g) : (l = Math.max(Math.min(l, b[2] - a[0] - a[2]), g), 
            b[1] += (a[0] - a[2]) / 2);
            l < b[2] ? (b[2] = l, b[3] = Math.min(d(c.innerSize || 0, l), l), this.translate(b), 
            this.drawDataLabels && this.drawDataLabels()) : e = !0;
            return e;
        });
        p.column && (p.column.prototype.alignDataLabel = function(a, d, c, f, g) {
            var l = this.chart.inverted, e = a.series, m = a.dlBox || a.shapeArgs, n = q(a.below, a.plotY > q(this.translatedThreshold, e.yAxis.len)), p = q(c.inside, !!this.options.stacking);
            m && (f = u(m), 0 > f.y && (f.height += f.y, f.y = 0), m = f.y + f.height - e.yAxis.len, 
            0 < m && (f.height -= m), l && (f = {
                x: e.yAxis.len - f.y - f.height,
                y: e.xAxis.len - f.x - f.width,
                width: f.height,
                height: f.width
            }), p || (l ? (f.x += n ? 0 : f.width, f.width = 0) : (f.y += n ? f.height : 0, 
            f.height = 0)));
            c.align = q(c.align, !l || p ? "center" : n ? "right" : "left");
            c.verticalAlign = q(c.verticalAlign, l || p ? "middle" : n ? "top" : "bottom");
            b.prototype.alignDataLabel.call(this, a, d, c, f, g);
        });
    })(L);
    (function(a) {
        var B = a.Chart, A = a.each, H = a.pick, G = a.addEvent;
        B.prototype.callbacks.push(function(a) {
            function g() {
                var f = [];
                A(a.series, function(a) {
                    var g = a.options.dataLabels, q = a.dataLabelCollections || [ "dataLabel" ];
                    (g.enabled || a._hasPointLabels) && !g.allowOverlap && a.visible && A(q, function(d) {
                        A(a.points, function(a) {
                            a[d] && (a[d].labelrank = H(a.labelrank, a.shapeArgs && a.shapeArgs.height), f.push(a[d]));
                        });
                    });
                });
                a.hideOverlappingLabels(f);
            }
            g();
            G(a, "redraw", g);
        });
        B.prototype.hideOverlappingLabels = function(a) {
            var g = a.length, f, r, l, q, d, b, p, C, t, m = function(a, b, d, f, e, g, l, m) {
                return !(e > a + d || e + l < a || g > b + f || g + m < b);
            };
            for (r = 0; r < g; r++) if (f = a[r]) f.oldOpacity = f.opacity, f.newOpacity = 1;
            a.sort(function(a, b) {
                return (b.labelrank || 0) - (a.labelrank || 0);
            });
            for (r = 0; r < g; r++) for (l = a[r], f = r + 1; f < g; ++f) if (q = a[f], l && q && l.placed && q.placed && 0 !== l.newOpacity && 0 !== q.newOpacity && (d = l.alignAttr, 
            b = q.alignAttr, p = l.parentGroup, C = q.parentGroup, t = 2 * (l.box ? 0 : l.padding), 
            d = m(d.x + p.translateX, d.y + p.translateY, l.width - t, l.height - t, b.x + C.translateX, b.y + C.translateY, q.width - t, q.height - t))) (l.labelrank < q.labelrank ? l : q).newOpacity = 0;
            A(a, function(a) {
                var b, c;
                a && (c = a.newOpacity, a.oldOpacity !== c && a.placed && (c ? a.show(!0) : b = function() {
                    a.hide();
                }, a.alignAttr.opacity = c, a[a.isOld ? "animate" : "attr"](a.alignAttr, null, b)), 
                a.isOld = !0);
            });
        };
    })(L);
    (function(a) {
        var B = a.addEvent, A = a.Chart, H = a.createElement, G = a.css, r = a.defaultOptions, g = a.defaultPlotOptions, f = a.each, u = a.extend, l = a.fireEvent, q = a.hasTouch, d = a.inArray, b = a.isObject, p = a.Legend, C = a.merge, t = a.pick, m = a.Point, c = a.Series, n = a.seriesTypes, E = a.svg;
        a = a.TrackerMixin = {
            drawTrackerPoint: function() {
                var a = this, b = a.chart, c = b.pointer, d = function(a) {
                    for (var c = a.target, e; c && !e; ) e = c.point, c = c.parentNode;
                    if (void 0 !== e && e !== b.hoverPoint) e.onMouseOver(a);
                };
                f(a.points, function(a) {
                    a.graphic && (a.graphic.element.point = a);
                    a.dataLabel && (a.dataLabel.div ? a.dataLabel.div.point = a : a.dataLabel.element.point = a);
                });
                a._hasTracking || (f(a.trackerGroups, function(b) {
                    if (a[b]) {
                        a[b].addClass("highcharts-tracker").on("mouseover", d).on("mouseout", function(a) {
                            c.onTrackerMouseOut(a);
                        });
                        if (q) a[b].on("touchstart", d);
                        a.options.cursor && a[b].css(G).css({
                            cursor: a.options.cursor
                        });
                    }
                }), a._hasTracking = !0);
            },
            drawTrackerGraph: function() {
                var a = this, b = a.options, c = b.trackByArea, d = [].concat(c ? a.areaPath : a.graphPath), g = d.length, h = a.chart, l = h.pointer, m = h.renderer, n = h.options.tooltip.snap, p = a.tracker, k, r = function() {
                    if (h.hoverSeries !== a) a.onMouseOver();
                }, t = "rgba(192,192,192," + (E ? 1e-4 : .002) + ")";
                if (g && !c) for (k = g + 1; k--; ) "M" === d[k] && d.splice(k + 1, 0, d[k + 1] - n, d[k + 2], "L"), 
                (k && "M" === d[k] || k === g) && d.splice(k, 0, "L", d[k - 2] + n, d[k - 1]);
                p ? p.attr({
                    d: d
                }) : a.graph && (a.tracker = m.path(d).attr({
                    "stroke-linejoin": "round",
                    visibility: a.visible ? "visible" : "hidden",
                    stroke: t,
                    fill: c ? t : "none",
                    "stroke-width": a.graph.strokeWidth() + (c ? 0 : 2 * n),
                    zIndex: 2
                }).add(a.group), f([ a.tracker, a.markerGroup ], function(a) {
                    a.addClass("highcharts-tracker").on("mouseover", r).on("mouseout", function(a) {
                        l.onTrackerMouseOut(a);
                    });
                    b.cursor && a.css({
                        cursor: b.cursor
                    });
                    if (q) a.on("touchstart", r);
                }));
            }
        };
        n.column && (n.column.prototype.drawTracker = a.drawTrackerPoint);
        n.pie && (n.pie.prototype.drawTracker = a.drawTrackerPoint);
        n.scatter && (n.scatter.prototype.drawTracker = a.drawTrackerPoint);
        u(p.prototype, {
            setItemEvents: function(a, b, c) {
                var e = this, d = e.chart, f = "highcharts-legend-" + (a.series ? "point" : "series") + "-active";
                (c ? b : a.legendGroup).on("mouseover", function() {
                    a.setState("hover");
                    d.seriesGroup.addClass(f);
                    b.css(e.options.itemHoverStyle);
                }).on("mouseout", function() {
                    b.css(a.visible ? e.itemStyle : e.itemHiddenStyle);
                    d.seriesGroup.removeClass(f);
                    a.setState();
                }).on("click", function(b) {
                    var c = function() {
                        a.setVisible && a.setVisible();
                    };
                    b = {
                        browserEvent: b
                    };
                    a.firePointEvent ? a.firePointEvent("legendItemClick", b, c) : l(a, "legendItemClick", b, c);
                });
            },
            createCheckboxForItem: function(a) {
                a.checkbox = H("input", {
                    type: "checkbox",
                    checked: a.selected,
                    defaultChecked: a.selected
                }, this.options.itemCheckboxStyle, this.chart.container);
                B(a.checkbox, "click", function(b) {
                    l(a.series || a, "checkboxClick", {
                        checked: b.target.checked,
                        item: a
                    }, function() {
                        a.select();
                    });
                });
            }
        });
        r.legend.itemStyle.cursor = "pointer";
        u(A.prototype, {
            showResetZoom: function() {
                var a = this, b = r.lang, c = a.options.chart.resetZoomButton, d = c.theme, f = d.states, g = "chart" === c.relativeTo ? null : "plotBox";
                this.resetZoomButton = a.renderer.button(b.resetZoom, null, null, function() {
                    a.zoomOut();
                }, d, f && f.hover).attr({
                    align: c.position.align,
                    title: b.resetZoomTitle
                }).addClass("highcharts-reset-zoom").add().align(c.position, !1, g);
            },
            zoomOut: function() {
                var a = this;
                l(a, "selection", {
                    resetSelection: !0
                }, function() {
                    a.zoom();
                });
            },
            zoom: function(a) {
                var c, d = this.pointer, g = !1, l;
                !a || a.resetSelection ? f(this.axes, function(a) {
                    c = a.zoom();
                }) : f(a.xAxis.concat(a.yAxis), function(a) {
                    var b = a.axis;
                    d[b.isXAxis ? "zoomX" : "zoomY"] && (c = b.zoom(a.min, a.max), b.displayBtn && (g = !0));
                });
                l = this.resetZoomButton;
                g && !l ? this.showResetZoom() : !g && b(l) && (this.resetZoomButton = l.destroy());
                c && this.redraw(t(this.options.chart.animation, a && a.animation, 100 > this.pointCount));
            },
            pan: function(a, b) {
                var c = this, d = c.hoverPoints, e;
                d && f(d, function(a) {
                    a.setState();
                });
                f("xy" === b ? [ 1, 0 ] : [ 1 ], function(b) {
                    b = c[b ? "xAxis" : "yAxis"][0];
                    var d = b.horiz, f = a[d ? "chartX" : "chartY"], d = d ? "mouseDownX" : "mouseDownY", g = c[d], h = (b.pointRange || 0) / 2, k = b.getExtremes(), l = b.toValue(g - f, !0) + h, h = b.toValue(g + b.len - f, !0) - h, m = h < l, g = m ? h : l, l = m ? l : h, h = Math.min(k.dataMin, k.min) - g, k = l - Math.max(k.dataMax, k.max);
                    b.series.length && 0 > h && 0 > k && (b.setExtremes(g, l, !1, !1, {
                        trigger: "pan"
                    }), e = !0);
                    c[d] = f;
                });
                e && c.redraw(!1);
                G(c.container, {
                    cursor: "move"
                });
            }
        });
        u(m.prototype, {
            select: function(a, b) {
                var c = this, e = c.series, g = e.chart;
                a = t(a, !c.selected);
                c.firePointEvent(a ? "select" : "unselect", {
                    accumulate: b
                }, function() {
                    c.selected = c.options.selected = a;
                    e.options.data[d(c, e.data)] = c.options;
                    c.setState(a && "select");
                    b || f(g.getSelectedPoints(), function(a) {
                        a.selected && a !== c && (a.selected = a.options.selected = !1, e.options.data[d(a, e.data)] = a.options, 
                        a.setState(""), a.firePointEvent("unselect"));
                    });
                });
            },
            onMouseOver: function(a, b) {
                var c = this.series, d = c.chart, e = d.tooltip, f = d.hoverPoint;
                if (this.series) {
                    if (!b) {
                        if (f && f !== this) f.onMouseOut();
                        if (d.hoverSeries !== c) c.onMouseOver();
                        d.hoverPoint = this;
                    }
                    !e || e.shared && !c.noSharedTooltip ? e || this.setState("hover") : (this.setState("hover"), 
                    e.refresh(this, a));
                    this.firePointEvent("mouseOver");
                }
            },
            onMouseOut: function() {
                var a = this.series.chart, b = a.hoverPoints;
                this.firePointEvent("mouseOut");
                b && -1 !== d(this, b) || (this.setState(), a.hoverPoint = null);
            },
            importEvents: function() {
                if (!this.hasImportedEvents) {
                    var a = C(this.series.options.point, this.options).events, b;
                    this.events = a;
                    for (b in a) B(this, b, a[b]);
                    this.hasImportedEvents = !0;
                }
            },
            setState: function(a, b) {
                var c = Math.floor(this.plotX), d = this.plotY, e = this.series, f = e.options.states[a] || {}, l = g[e.type].marker && e.options.marker, m = l && !1 === l.enabled, n = l && l.states && l.states[a] || {}, p = !1 === n.enabled, k = e.stateMarkerGraphic, q = this.marker || {}, r = e.chart, z = e.halo, C, A = l && e.markerAttribs;
                a = a || "";
                if (!(a === this.state && !b || this.selected && "select" !== a || !1 === f.enabled || a && (p || m && !1 === n.enabled) || a && q.states && q.states[a] && !1 === q.states[a].enabled)) {
                    A && (C = e.markerAttribs(this, a));
                    if (this.graphic) this.state && this.graphic.removeClass("highcharts-point-" + this.state), 
                    a && this.graphic.addClass("highcharts-point-" + a), this.graphic.attr(e.pointAttribs(this, a)), 
                    C && this.graphic.animate(C, t(r.options.chart.animation, n.animation, l.animation)), 
                    k && k.hide(); else {
                        if (a && n) {
                            l = q.symbol || e.symbol;
                            k && k.currentSymbol !== l && (k = k.destroy());
                            if (k) k[b ? "animate" : "attr"]({
                                x: C.x,
                                y: C.y
                            }); else l && (e.stateMarkerGraphic = k = r.renderer.symbol(l, C.x, C.y, C.width, C.height).add(e.markerGroup), 
                            k.currentSymbol = l);
                            k && k.attr(e.pointAttribs(this, a));
                        }
                        k && (k[a && r.isInsidePlot(c, d, r.inverted) ? "show" : "hide"](), k.element.point = this);
                    }
                    (c = f.halo) && c.size ? (z || (e.halo = z = r.renderer.path().add(A ? e.markerGroup : e.group)), 
                    z[b ? "animate" : "attr"]({
                        d: this.haloPath(c.size)
                    }), z.attr({
                        "class": "highcharts-halo highcharts-color-" + t(this.colorIndex, e.colorIndex)
                    }), z.point = this, z.attr(u({
                        fill: this.color || e.color,
                        "fill-opacity": c.opacity,
                        zIndex: -1
                    }, c.attributes))) : z && z.point && z.point.haloPath && z.animate({
                        d: z.point.haloPath(0)
                    });
                    this.state = a;
                }
            },
            haloPath: function(a) {
                return this.series.chart.renderer.symbols.circle(Math.floor(this.plotX) - a, this.plotY - a, 2 * a, 2 * a);
            }
        });
        u(c.prototype, {
            onMouseOver: function() {
                var a = this.chart, b = a.hoverSeries;
                if (b && b !== this) b.onMouseOut();
                this.options.events.mouseOver && l(this, "mouseOver");
                this.setState("hover");
                a.hoverSeries = this;
            },
            onMouseOut: function() {
                var a = this.options, b = this.chart, c = b.tooltip, d = b.hoverPoint;
                b.hoverSeries = null;
                if (d) d.onMouseOut();
                this && a.events.mouseOut && l(this, "mouseOut");
                !c || a.stickyTracking || c.shared && !this.noSharedTooltip || c.hide();
                this.setState();
            },
            setState: function(a) {
                var b = this, c = b.options, d = b.graph, g = c.states, h = c.lineWidth, c = 0;
                a = a || "";
                if (b.state !== a && (f([ b.group, b.markerGroup ], function(c) {
                    c && (b.state && c.removeClass("highcharts-series-" + b.state), a && c.addClass("highcharts-series-" + a));
                }), b.state = a, !g[a] || !1 !== g[a].enabled) && (a && (h = g[a].lineWidth || h + (g[a].lineWidthPlus || 0)), 
                d && !d.dashstyle)) for (g = {
                    "stroke-width": h
                }, d.attr(g); b["zone-graph-" + c]; ) b["zone-graph-" + c].attr(g), c += 1;
            },
            setVisible: function(a, b) {
                var c = this, d = c.chart, e = c.legendItem, g, m = d.options.chart.ignoreHiddenSeries, n = c.visible;
                g = (c.visible = a = c.options.visible = c.userOptions.visible = void 0 === a ? !n : a) ? "show" : "hide";
                f([ "group", "dataLabelsGroup", "markerGroup", "tracker", "tt" ], function(a) {
                    if (c[a]) c[a][g]();
                });
                if (d.hoverSeries === c || (d.hoverPoint && d.hoverPoint.series) === c) c.onMouseOut();
                e && d.legend.colorizeItem(c, a);
                c.isDirty = !0;
                c.options.stacking && f(d.series, function(a) {
                    a.options.stacking && a.visible && (a.isDirty = !0);
                });
                f(c.linkedSeries, function(b) {
                    b.setVisible(a, !1);
                });
                m && (d.isDirtyBox = !0);
                !1 !== b && d.redraw();
                l(c, g);
            },
            show: function() {
                this.setVisible(!0);
            },
            hide: function() {
                this.setVisible(!1);
            },
            select: function(a) {
                this.selected = a = void 0 === a ? !this.selected : a;
                this.checkbox && (this.checkbox.checked = a);
                l(this, a ? "select" : "unselect");
            },
            drawTracker: a.drawTrackerGraph
        });
    })(L);
    (function(a) {
        var B = a.Chart, A = a.each, H = a.inArray, G = a.isObject, r = a.pick, g = a.splat;
        B.prototype.setResponsive = function(a) {
            var f = this.options.responsive;
            f && f.rules && A(f.rules, function(f) {
                this.matchResponsiveRule(f, a);
            }, this);
        };
        B.prototype.matchResponsiveRule = function(f, g) {
            var l = this.respRules, q = f.condition, d;
            d = q.callback || function() {
                return this.chartWidth <= r(q.maxWidth, Number.MAX_VALUE) && this.chartHeight <= r(q.maxHeight, Number.MAX_VALUE) && this.chartWidth >= r(q.minWidth, 0) && this.chartHeight >= r(q.minHeight, 0);
            };
            void 0 === f._id && (f._id = a.uniqueKey());
            d = d.call(this);
            !l[f._id] && d ? f.chartOptions && (l[f._id] = this.currentOptions(f.chartOptions), 
            this.update(f.chartOptions, g)) : l[f._id] && !d && (this.update(l[f._id], g), delete l[f._id]);
        };
        B.prototype.currentOptions = function(a) {
            function f(a, d, b, l) {
                var p, q;
                for (p in a) if (!l && -1 < H(p, [ "series", "xAxis", "yAxis" ])) for (a[p] = g(a[p]), 
                b[p] = [], q = 0; q < a[p].length; q++) b[p][q] = {}, f(a[p][q], d[p][q], b[p][q], l + 1); else G(a[p]) ? (b[p] = {}, 
                f(a[p], d[p] || {}, b[p], l + 1)) : b[p] = d[p] || null;
            }
            var l = {};
            f(a, this.options, l, 0);
            return l;
        };
    })(L);
    return L;
});

(function(u) {
    "object" === typeof module && module.exports ? module.exports = u : u(Highcharts);
})(function(u) {
    (function(a) {
        function p(a, b, d) {
            this.init(a, b, d);
        }
        var v = a.each, w = a.extend, l = a.merge, q = a.splat;
        w(p.prototype, {
            init: function(a, b, d) {
                var k = this, m = k.defaultOptions;
                k.chart = b;
                k.options = a = l(m, b.angular ? {
                    background: {}
                } : void 0, a);
                (a = a.background) && v([].concat(q(a)).reverse(), function(b) {
                    var c, m = d.userOptions;
                    c = l(k.defaultBackgroundOptions, b);
                    b.backgroundColor && (c.backgroundColor = b.backgroundColor);
                    c.color = c.backgroundColor;
                    d.options.plotBands.unshift(c);
                    m.plotBands = m.plotBands || [];
                    m.plotBands !== d.options.plotBands && m.plotBands.unshift(c);
                });
            },
            defaultOptions: {
                center: [ "50%", "50%" ],
                size: "85%",
                startAngle: 0
            },
            defaultBackgroundOptions: {
                className: "highcharts-pane",
                shape: "circle",
                borderWidth: 1,
                borderColor: "#cccccc",
                backgroundColor: {
                    linearGradient: {
                        x1: 0,
                        y1: 0,
                        x2: 0,
                        y2: 1
                    },
                    stops: [ [ 0, "#ffffff" ], [ 1, "#e6e6e6" ] ]
                },
                from: -Number.MAX_VALUE,
                innerRadius: 0,
                to: Number.MAX_VALUE,
                outerRadius: "105%"
            }
        });
        a.Pane = p;
    })(u);
    (function(a) {
        var p = a.CenteredSeriesMixin, v = a.each, w = a.extend, l = a.map, q = a.merge, f = a.noop, b = a.Pane, d = a.pick, k = a.pInt, m = a.splat, n = a.wrap, c, g, h = a.Axis.prototype;
        a = a.Tick.prototype;
        c = {
            getOffset: f,
            redraw: function() {
                this.isDirty = !1;
            },
            render: function() {
                this.isDirty = !1;
            },
            setScale: f,
            setCategories: f,
            setTitle: f
        };
        g = {
            defaultRadialGaugeOptions: {
                labels: {
                    align: "center",
                    x: 0,
                    y: null
                },
                minorGridLineWidth: 0,
                minorTickInterval: "auto",
                minorTickLength: 10,
                minorTickPosition: "inside",
                minorTickWidth: 1,
                tickLength: 10,
                tickPosition: "inside",
                tickWidth: 2,
                title: {
                    rotation: 0
                },
                zIndex: 2
            },
            defaultRadialXOptions: {
                gridLineWidth: 1,
                labels: {
                    align: null,
                    distance: 15,
                    x: 0,
                    y: null
                },
                maxPadding: 0,
                minPadding: 0,
                showLastLabel: !1,
                tickLength: 0
            },
            defaultRadialYOptions: {
                gridLineInterpolation: "circle",
                labels: {
                    align: "right",
                    x: -3,
                    y: -2
                },
                showLastLabel: !1,
                title: {
                    x: 4,
                    text: null,
                    rotation: 90
                }
            },
            setOptions: function(b) {
                b = this.options = q(this.defaultOptions, this.defaultRadialOptions, b);
                b.plotBands || (b.plotBands = []);
            },
            getOffset: function() {
                h.getOffset.call(this);
                this.chart.axisOffset[this.side] = 0;
                this.center = this.pane.center = p.getCenter.call(this.pane);
            },
            getLinePath: function(b, e) {
                b = this.center;
                var c = this.chart, k = d(e, b[2] / 2 - this.offset);
                this.isCircular || void 0 !== e ? e = this.chart.renderer.symbols.arc(this.left + b[0], this.top + b[1], k, k, {
                    start: this.startAngleRad,
                    end: this.endAngleRad,
                    open: !0,
                    innerR: 0
                }) : (e = this.postTranslate(this.angleRad, k), e = [ "M", b[0] + c.plotLeft, b[1] + c.plotTop, "L", e.x, e.y ]);
                return e;
            },
            setAxisTranslation: function() {
                h.setAxisTranslation.call(this);
                this.center && (this.transA = this.isCircular ? (this.endAngleRad - this.startAngleRad) / (this.max - this.min || 1) : this.center[2] / 2 / (this.max - this.min || 1), 
                this.minPixelPadding = this.isXAxis ? this.transA * this.minPointOffset : 0);
            },
            beforeSetTickPositions: function() {
                if (this.autoConnect = this.isCircular && void 0 === d(this.userMax, this.options.max) && this.endAngleRad - this.startAngleRad === 2 * Math.PI) this.max += this.categories && 1 || this.pointRange || this.closestPointRange || 0;
            },
            setAxisSize: function() {
                h.setAxisSize.call(this);
                this.isRadial && (this.center = this.pane.center = p.getCenter.call(this.pane), 
                this.isCircular && (this.sector = this.endAngleRad - this.startAngleRad), this.len = this.width = this.height = this.center[2] * d(this.sector, 1) / 2);
            },
            getPosition: function(b, e) {
                return this.postTranslate(this.isCircular ? this.translate(b) : this.angleRad, d(this.isCircular ? e : this.translate(b), this.center[2] / 2) - this.offset);
            },
            postTranslate: function(b, e) {
                var d = this.chart, c = this.center;
                b = this.startAngleRad + b;
                return {
                    x: d.plotLeft + c[0] + Math.cos(b) * e,
                    y: d.plotTop + c[1] + Math.sin(b) * e
                };
            },
            getPlotBandPath: function(b, e, c) {
                var m = this.center, t = this.startAngleRad, h = m[2] / 2, a = [ d(c.outerRadius, "100%"), c.innerRadius, d(c.thickness, 10) ], r = Math.min(this.offset, 0), g = /%$/, n, f = this.isCircular;
                "polygon" === this.options.gridLineInterpolation ? m = this.getPlotLinePath(b).concat(this.getPlotLinePath(e, !0)) : (b = Math.max(b, this.min), 
                e = Math.min(e, this.max), f || (a[0] = this.translate(b), a[1] = this.translate(e)), 
                a = l(a, function(b) {
                    g.test(b) && (b = k(b, 10) * h / 100);
                    return b;
                }), "circle" !== c.shape && f ? (b = t + this.translate(b), e = t + this.translate(e)) : (b = -Math.PI / 2, 
                e = 1.5 * Math.PI, n = !0), a[0] -= r, a[2] -= r, m = this.chart.renderer.symbols.arc(this.left + m[0], this.top + m[1], a[0], a[0], {
                    start: Math.min(b, e),
                    end: Math.max(b, e),
                    innerR: d(a[1], a[0] - a[2]),
                    open: n
                }));
                return m;
            },
            getPlotLinePath: function(b, e) {
                var c = this, d = c.center, k = c.chart, m = c.getPosition(b), a, h, g;
                c.isCircular ? g = [ "M", d[0] + k.plotLeft, d[1] + k.plotTop, "L", m.x, m.y ] : "circle" === c.options.gridLineInterpolation ? (b = c.translate(b)) && (g = c.getLinePath(0, b)) : (v(k.xAxis, function(b) {
                    b.pane === c.pane && (a = b);
                }), g = [], b = c.translate(b), d = a.tickPositions, a.autoConnect && (d = d.concat([ d[0] ])), 
                e && (d = [].concat(d).reverse()), v(d, function(c, d) {
                    h = a.getPosition(c, b);
                    g.push(d ? "L" : "M", h.x, h.y);
                }));
                return g;
            },
            getTitlePosition: function() {
                var b = this.center, c = this.chart, d = this.options.title;
                return {
                    x: c.plotLeft + b[0] + (d.x || 0),
                    y: c.plotTop + b[1] - {
                        high: .5,
                        middle: .25,
                        low: 0
                    }[d.align] * b[2] + (d.y || 0)
                };
            }
        };
        n(h, "init", function(k, e, a) {
            var h = e.angular, n = e.polar, t = a.isX, r = h && t, f, x = e.options, l = a.pane || 0;
            if (h) {
                if (w(this, r ? c : g), f = !t) this.defaultRadialOptions = this.defaultRadialGaugeOptions;
            } else n && (w(this, g), this.defaultRadialOptions = (f = t) ? this.defaultRadialXOptions : q(this.defaultYAxisOptions, this.defaultRadialYOptions));
            h || n ? (this.isRadial = !0, e.inverted = !1, x.chart.zoomType = null) : this.isRadial = !1;
            k.call(this, e, a);
            r || !h && !n || (k = this.options, e.panes || (e.panes = []), this.pane = e = e.panes[l] = e.panes[l] || new b(m(x.pane)[l], e, this), 
            e = e.options, this.angleRad = (k.angle || 0) * Math.PI / 180, this.startAngleRad = (e.startAngle - 90) * Math.PI / 180, 
            this.endAngleRad = (d(e.endAngle, e.startAngle + 360) - 90) * Math.PI / 180, this.offset = k.offset || 0, 
            this.isCircular = f);
        });
        n(h, "autoLabelAlign", function(b) {
            if (!this.isRadial) return b.apply(this, [].slice.call(arguments, 1));
        });
        n(a, "getPosition", function(b, c, d, k, a) {
            var e = this.axis;
            return e.getPosition ? e.getPosition(d) : b.call(this, c, d, k, a);
        });
        n(a, "getLabelPosition", function(b, c, k, a, m, h, g, n, f) {
            var e = this.axis, t = h.y, r = 20, z = h.align, x = (e.translate(this.pos) + e.startAngleRad + Math.PI / 2) / Math.PI * 180 % 360;
            e.isRadial ? (b = e.getPosition(this.pos, e.center[2] / 2 + d(h.distance, -25)), 
            "auto" === h.rotation ? a.attr({
                rotation: x
            }) : null === t && (t = e.chart.renderer.fontMetrics(a.styles.fontSize).b - a.getBBox().height / 2), 
            null === z && (e.isCircular ? (this.label.getBBox().width > e.len * e.tickInterval / (e.max - e.min) && (r = 0), 
            z = x > r && x < 180 - r ? "left" : x > 180 + r && x < 360 - r ? "right" : "center") : z = "center", 
            a.attr({
                align: z
            })), b.x += h.x, b.y += t) : b = b.call(this, c, k, a, m, h, g, n, f);
            return b;
        });
        n(a, "getMarkPath", function(b, c, d, k, a, m, h) {
            var e = this.axis;
            e.isRadial ? (b = e.getPosition(this.pos, e.center[2] / 2 + k), c = [ "M", c, d, "L", b.x, b.y ]) : c = b.call(this, c, d, k, a, m, h);
            return c;
        });
    })(u);
    (function(a) {
        var p = a.each, v = a.noop, w = a.pick, l = a.Series, q = a.seriesType, f = a.seriesTypes;
        q("arearange", "area", {
            lineWidth: 1,
            marker: null,
            threshold: null,
            tooltip: {
                pointFormat: '<span style="color:{series.color}">â</span> {series.name}: <b>{point.low}</b> - <b>{point.high}</b><br/>'
            },
            trackByArea: !0,
            dataLabels: {
                align: null,
                verticalAlign: null,
                xLow: 0,
                xHigh: 0,
                yLow: 0,
                yHigh: 0
            },
            states: {
                hover: {
                    halo: !1
                }
            }
        }, {
            pointArrayMap: [ "low", "high" ],
            dataLabelCollections: [ "dataLabel", "dataLabelUpper" ],
            toYData: function(b) {
                return [ b.low, b.high ];
            },
            pointValKey: "low",
            deferTranslatePolar: !0,
            highToXY: function(b) {
                var d = this.chart, k = this.xAxis.postTranslate(b.rectPlotX, this.yAxis.len - b.plotHigh);
                b.plotHighX = k.x - d.plotLeft;
                b.plotHigh = k.y - d.plotTop;
            },
            translate: function() {
                var b = this, d = b.yAxis, k = !!b.modifyValue;
                f.area.prototype.translate.apply(b);
                p(b.points, function(a) {
                    var m = a.low, c = a.high, g = a.plotY;
                    null === c || null === m ? a.isNull = !0 : (a.plotLow = g, a.plotHigh = d.translate(k ? b.modifyValue(c, a) : c, 0, 1, 0, 1), 
                    k && (a.yBottom = a.plotHigh));
                });
                this.chart.polar && p(this.points, function(d) {
                    b.highToXY(d);
                });
            },
            getGraphPath: function(b) {
                var d = [], k = [], a, n = f.area.prototype.getGraphPath, c, g, h;
                h = this.options;
                var r = this.chart.polar && !1 !== h.connectEnds, e = h.step;
                b = b || this.points;
                for (a = b.length; a--; ) c = b[a], c.isNull || r || b[a + 1] && !b[a + 1].isNull || k.push({
                    plotX: c.plotX,
                    plotY: c.plotY,
                    doCurve: !1
                }), g = {
                    polarPlotY: c.polarPlotY,
                    rectPlotX: c.rectPlotX,
                    yBottom: c.yBottom,
                    plotX: w(c.plotHighX, c.plotX),
                    plotY: c.plotHigh,
                    isNull: c.isNull
                }, k.push(g), d.push(g), c.isNull || r || b[a - 1] && !b[a - 1].isNull || k.push({
                    plotX: c.plotX,
                    plotY: c.plotY,
                    doCurve: !1
                });
                b = n.call(this, b);
                e && (!0 === e && (e = "left"), h.step = {
                    left: "right",
                    center: "center",
                    right: "left"
                }[e]);
                d = n.call(this, d);
                k = n.call(this, k);
                h.step = e;
                h = [].concat(b, d);
                this.chart.polar || "M" !== k[0] || (k[0] = "L");
                this.graphPath = h;
                this.areaPath = this.areaPath.concat(b, k);
                h.isArea = !0;
                h.xMap = b.xMap;
                this.areaPath.xMap = b.xMap;
                return h;
            },
            drawDataLabels: function() {
                var b = this.data, d = b.length, a, m = [], n = l.prototype, c = this.options.dataLabels, g = c.align, h = c.verticalAlign, r = c.inside, e, t, f = this.chart.inverted;
                if (c.enabled || this._hasPointLabels) {
                    for (a = d; a--; ) if (e = b[a]) t = r ? e.plotHigh < e.plotLow : e.plotHigh > e.plotLow, 
                    e.y = e.high, e._plotY = e.plotY, e.plotY = e.plotHigh, m[a] = e.dataLabel, e.dataLabel = e.dataLabelUpper, 
                    e.below = t, f ? g || (c.align = t ? "right" : "left") : h || (c.verticalAlign = t ? "top" : "bottom"), 
                    c.x = c.xHigh, c.y = c.yHigh;
                    n.drawDataLabels && n.drawDataLabels.apply(this, arguments);
                    for (a = d; a--; ) if (e = b[a]) t = r ? e.plotHigh < e.plotLow : e.plotHigh > e.plotLow, 
                    e.dataLabelUpper = e.dataLabel, e.dataLabel = m[a], e.y = e.low, e.plotY = e._plotY, 
                    e.below = !t, f ? g || (c.align = t ? "left" : "right") : h || (c.verticalAlign = t ? "bottom" : "top"), 
                    c.x = c.xLow, c.y = c.yLow;
                    n.drawDataLabels && n.drawDataLabels.apply(this, arguments);
                }
                c.align = g;
                c.verticalAlign = h;
            },
            alignDataLabel: function() {
                f.column.prototype.alignDataLabel.apply(this, arguments);
            },
            setStackedPoints: v,
            getSymbol: v,
            drawPoints: v
        });
    })(u);
    (function(a) {
        var p = a.seriesType;
        p("areasplinerange", "arearange", null, {
            getPointSpline: a.seriesTypes.spline.prototype.getPointSpline
        });
    })(u);
    (function(a) {
        var p = a.defaultPlotOptions, v = a.each, w = a.merge, l = a.noop, q = a.pick, f = a.seriesType, b = a.seriesTypes.column.prototype;
        f("columnrange", "arearange", w(p.column, p.arearange, {
            lineWidth: 1,
            pointRange: null
        }), {
            translate: function() {
                var d = this, a = d.yAxis, m = d.xAxis, n = m.startAngleRad, c, g = d.chart, h = d.xAxis.isRadial, r;
                b.translate.apply(d);
                v(d.points, function(b) {
                    var e = b.shapeArgs, k = d.options.minPointLength, f, l;
                    b.plotHigh = r = a.translate(b.high, 0, 1, 0, 1);
                    b.plotLow = b.plotY;
                    l = r;
                    f = q(b.rectPlotY, b.plotY) - r;
                    Math.abs(f) < k ? (k -= f, f += k, l -= k / 2) : 0 > f && (f *= -1, l -= f);
                    h ? (c = b.barX + n, b.shapeType = "path", b.shapeArgs = {
                        d: d.polarArc(l + f, l, c, c + b.pointWidth)
                    }) : (e.height = f, e.y = l, b.tooltipPos = g.inverted ? [ a.len + a.pos - g.plotLeft - l - f / 2, m.len + m.pos - g.plotTop - e.x - e.width / 2, f ] : [ m.left - g.plotLeft + e.x + e.width / 2, a.pos - g.plotTop + l + f / 2, f ]);
                });
            },
            directTouch: !0,
            trackerGroups: [ "group", "dataLabelsGroup" ],
            drawGraph: l,
            crispCol: b.crispCol,
            drawPoints: b.drawPoints,
            drawTracker: b.drawTracker,
            getColumnMetrics: b.getColumnMetrics,
            animate: function() {
                return b.animate.apply(this, arguments);
            },
            polarArc: function() {
                return b.polarArc.apply(this, arguments);
            },
            pointAttribs: b.pointAttribs
        });
    })(u);
    (function(a) {
        var p = a.each, v = a.isNumber, w = a.merge, l = a.pick, q = a.pInt, f = a.Series, b = a.seriesType, d = a.TrackerMixin;
        b("gauge", "line", {
            dataLabels: {
                enabled: !0,
                defer: !1,
                y: 15,
                borderRadius: 3,
                crop: !1,
                verticalAlign: "top",
                zIndex: 2,
                borderWidth: 1,
                borderColor: "#cccccc"
            },
            dial: {},
            pivot: {},
            tooltip: {
                headerFormat: ""
            },
            showInLegend: !1
        }, {
            angular: !0,
            directTouch: !0,
            drawGraph: a.noop,
            fixedBox: !0,
            forceDL: !0,
            noSharedTooltip: !0,
            trackerGroups: [ "group", "dataLabelsGroup" ],
            translate: function() {
                var b = this.yAxis, a = this.options, d = b.center;
                this.generatePoints();
                p(this.points, function(c) {
                    var k = w(a.dial, c.dial), h = q(l(k.radius, 80)) * d[2] / 200, m = q(l(k.baseLength, 70)) * h / 100, e = q(l(k.rearLength, 10)) * h / 100, n = k.baseWidth || 3, f = k.topWidth || 1, p = a.overshoot, y = b.startAngleRad + b.translate(c.y, null, null, null, !0);
                    v(p) ? (p = p / 180 * Math.PI, y = Math.max(b.startAngleRad - p, Math.min(b.endAngleRad + p, y))) : !1 === a.wrap && (y = Math.max(b.startAngleRad, Math.min(b.endAngleRad, y)));
                    y = 180 * y / Math.PI;
                    c.shapeType = "path";
                    c.shapeArgs = {
                        d: k.path || [ "M", -e, -n / 2, "L", m, -n / 2, h, -f / 2, h, f / 2, m, n / 2, -e, n / 2, "z" ],
                        translateX: d[0],
                        translateY: d[1],
                        rotation: y
                    };
                    c.plotX = d[0];
                    c.plotY = d[1];
                });
            },
            drawPoints: function() {
                var b = this, a = b.yAxis.center, d = b.pivot, c = b.options, g = c.pivot, h = b.chart.renderer;
                p(b.points, function(a) {
                    var d = a.graphic, k = a.shapeArgs, g = k.d, m = w(c.dial, a.dial);
                    d ? (d.animate(k), k.d = g) : (a.graphic = h[a.shapeType](k).attr({
                        rotation: k.rotation,
                        zIndex: 1
                    }).addClass("highcharts-dial").add(b.group), a.graphic.attr({
                        stroke: m.borderColor || "none",
                        "stroke-width": m.borderWidth || 0,
                        fill: m.backgroundColor || "#000000"
                    }));
                });
                d ? d.animate({
                    translateX: a[0],
                    translateY: a[1]
                }) : (b.pivot = h.circle(0, 0, l(g.radius, 5)).attr({
                    zIndex: 2
                }).addClass("highcharts-pivot").translate(a[0], a[1]).add(b.group), b.pivot.attr({
                    "stroke-width": g.borderWidth || 0,
                    stroke: g.borderColor || "#cccccc",
                    fill: g.backgroundColor || "#000000"
                }));
            },
            animate: function(b) {
                var a = this;
                b || (p(a.points, function(b) {
                    var d = b.graphic;
                    d && (d.attr({
                        rotation: 180 * a.yAxis.startAngleRad / Math.PI
                    }), d.animate({
                        rotation: b.shapeArgs.rotation
                    }, a.options.animation));
                }), a.animate = null);
            },
            render: function() {
                this.group = this.plotGroup("group", "series", this.visible ? "visible" : "hidden", this.options.zIndex, this.chart.seriesGroup);
                f.prototype.render.call(this);
                this.group.clip(this.chart.clipRect);
            },
            setData: function(b, a) {
                f.prototype.setData.call(this, b, !1);
                this.processData();
                this.generatePoints();
                l(a, !0) && this.chart.redraw();
            },
            drawTracker: d && d.drawTrackerPoint
        }, {
            setState: function(b) {
                this.state = b;
            }
        });
    })(u);
    (function(a) {
        var p = a.each, v = a.noop, w = a.pick, l = a.seriesType, q = a.seriesTypes;
        l("boxplot", "column", {
            threshold: null,
            tooltip: {
                pointFormat: '<span style="color:{point.color}">â</span> <b> {series.name}</b><br/>Maximum: {point.high}<br/>Upper quartile: {point.q3}<br/>Median: {point.median}<br/>Lower quartile: {point.q1}<br/>Minimum: {point.low}<br/>'
            },
            whiskerLength: "50%",
            fillColor: "#ffffff",
            lineWidth: 1,
            medianWidth: 2,
            states: {
                hover: {
                    brightness: -.3
                }
            },
            whiskerWidth: 2
        }, {
            pointArrayMap: [ "low", "q1", "median", "q3", "high" ],
            toYData: function(a) {
                return [ a.low, a.q1, a.median, a.q3, a.high ];
            },
            pointValKey: "high",
            pointAttribs: function(a) {
                var b = this.options, d = a && a.color || this.color;
                return {
                    fill: a.fillColor || b.fillColor || d,
                    stroke: b.lineColor || d,
                    "stroke-width": b.lineWidth || 0
                };
            },
            drawDataLabels: v,
            translate: function() {
                var a = this.yAxis, b = this.pointArrayMap;
                q.column.prototype.translate.apply(this);
                p(this.points, function(d) {
                    p(b, function(b) {
                        null !== d[b] && (d[b + "Plot"] = a.translate(d[b], 0, 1, 0, 1));
                    });
                });
            },
            drawPoints: function() {
                var a = this, b = a.options, d = a.chart.renderer, k, m, n, c, g, h, r = 0, e, t, l, q, y = !1 !== a.doQuartiles, v, B = a.options.whiskerLength;
                p(a.points, function(f) {
                    var p = f.graphic, z = p ? "animate" : "attr", x = f.shapeArgs, u = {}, D = {}, H = {}, I = f.color || a.color;
                    void 0 !== f.plotY && (e = x.width, t = Math.floor(x.x), l = t + e, q = Math.round(e / 2), 
                    k = Math.floor(y ? f.q1Plot : f.lowPlot), m = Math.floor(y ? f.q3Plot : f.lowPlot), 
                    n = Math.floor(f.highPlot), c = Math.floor(f.lowPlot), p || (f.graphic = p = d.g("point").add(a.group), 
                    f.stem = d.path().addClass("highcharts-boxplot-stem").add(p), B && (f.whiskers = d.path().addClass("highcharts-boxplot-whisker").add(p)), 
                    y && (f.box = d.path(void 0).addClass("highcharts-boxplot-box").add(p)), f.medianShape = d.path(void 0).addClass("highcharts-boxplot-median").add(p), 
                    u.stroke = f.stemColor || b.stemColor || I, u["stroke-width"] = w(f.stemWidth, b.stemWidth, b.lineWidth), 
                    u.dashstyle = f.stemDashStyle || b.stemDashStyle, f.stem.attr(u), B && (D.stroke = f.whiskerColor || b.whiskerColor || I, 
                    D["stroke-width"] = w(f.whiskerWidth, b.whiskerWidth, b.lineWidth), f.whiskers.attr(D)), 
                    y && (p = a.pointAttribs(f), f.box.attr(p)), H.stroke = f.medianColor || b.medianColor || I, 
                    H["stroke-width"] = w(f.medianWidth, b.medianWidth, b.lineWidth), f.medianShape.attr(H)), 
                    h = f.stem.strokeWidth() % 2 / 2, r = t + q + h, f.stem[z]({
                        d: [ "M", r, m, "L", r, n, "M", r, k, "L", r, c ]
                    }), y && (h = f.box.strokeWidth() % 2 / 2, k = Math.floor(k) + h, m = Math.floor(m) + h, 
                    t += h, l += h, f.box[z]({
                        d: [ "M", t, m, "L", t, k, "L", l, k, "L", l, m, "L", t, m, "z" ]
                    })), B && (h = f.whiskers.strokeWidth() % 2 / 2, n += h, c += h, v = /%$/.test(B) ? q * parseFloat(B) / 100 : B / 2, 
                    f.whiskers[z]({
                        d: [ "M", r - v, n, "L", r + v, n, "M", r - v, c, "L", r + v, c ]
                    })), g = Math.round(f.medianPlot), h = f.medianShape.strokeWidth() % 2 / 2, g += h, 
                    f.medianShape[z]({
                        d: [ "M", t, g, "L", l, g ]
                    }));
                });
            },
            setStackedPoints: v
        });
    })(u);
    (function(a) {
        var p = a.each, v = a.noop, w = a.seriesType, l = a.seriesTypes;
        w("errorbar", "boxplot", {
            color: "#000000",
            grouping: !1,
            linkedTo: ":previous",
            tooltip: {
                pointFormat: '<span style="color:{point.color}">â</span> {series.name}: <b>{point.low}</b> - <b>{point.high}</b><br/>'
            },
            whiskerWidth: null
        }, {
            type: "errorbar",
            pointArrayMap: [ "low", "high" ],
            toYData: function(a) {
                return [ a.low, a.high ];
            },
            pointValKey: "high",
            doQuartiles: !1,
            drawDataLabels: l.arearange ? function() {
                var a = this.pointValKey;
                l.arearange.prototype.drawDataLabels.call(this);
                p(this.data, function(f) {
                    f.y = f[a];
                });
            } : v,
            getColumnMetrics: function() {
                return this.linkedParent && this.linkedParent.columnMetrics || l.column.prototype.getColumnMetrics.call(this);
            }
        });
    })(u);
    (function(a) {
        var p = a.correctFloat, v = a.isNumber, w = a.pick, l = a.Point, q = a.Series, f = a.seriesType, b = a.seriesTypes;
        f("waterfall", "column", {
            dataLabels: {
                inside: !0
            },
            lineWidth: 1,
            lineColor: "#333333",
            dashStyle: "dot",
            borderColor: "#333333",
            states: {
                hover: {
                    lineWidthPlus: 0
                }
            }
        }, {
            pointValKey: "y",
            translate: function() {
                var a = this.options, k = this.yAxis, m, f, c, g, h, r, e, t, l, q = w(a.minPointLength, 5), y = a.threshold, v = a.stacking, u = 0, x = 0, A;
                b.column.prototype.translate.apply(this);
                e = t = y;
                f = this.points;
                m = 0;
                for (a = f.length; m < a; m++) c = f[m], r = this.processedYData[m], g = c.shapeArgs, 
                h = v && k.stacks[(this.negStacks && r < y ? "-" : "") + this.stackKey], A = this.getStackIndicator(A, c.x), 
                l = h ? h[c.x].points[this.index + "," + m + "," + A.index] : [ 0, r ], c.isSum ? c.y = p(r) : c.isIntermediateSum && (c.y = p(r - t)), 
                h = Math.max(e, e + c.y) + l[0], g.y = k.toPixels(h, !0), c.isSum ? (g.y = k.toPixels(l[1], !0), 
                g.height = Math.min(k.toPixels(l[0], !0), k.len) - g.y + u + x) : c.isIntermediateSum ? (g.y = k.toPixels(l[1], !0), 
                g.height = Math.min(k.toPixels(t, !0), k.len) - g.y + u + x, t = l[1]) : (g.height = 0 < r ? k.toPixels(e, !0) - g.y : k.toPixels(e, !0) - k.toPixels(e - r, !0), 
                e += r), 0 > g.height && (g.y += g.height, g.height *= -1), c.plotY = g.y = Math.round(g.y) - this.borderWidth % 2 / 2, 
                g.height = Math.max(Math.round(g.height), .001), c.yBottom = g.y + g.height, g.y -= x, 
                g.height <= q && !c.isNull && (g.height = q, 0 > c.y ? x -= q : u += q), g.y -= u, 
                g = c.plotY - x - u + (c.negative && 0 <= x ? g.height : 0), this.chart.inverted ? c.tooltipPos[0] = k.len - g : c.tooltipPos[1] = g;
            },
            processData: function(b) {
                var a = this.yData, d = this.options.data, f, c = a.length, g, h, r, e, t, l;
                h = g = r = e = this.options.threshold || 0;
                for (l = 0; l < c; l++) t = a[l], f = d && d[l] ? d[l] : {}, "sum" === t || f.isSum ? a[l] = p(h) : "intermediateSum" === t || f.isIntermediateSum ? a[l] = p(g) : (h += t, 
                g += t), r = Math.min(h, r), e = Math.max(h, e);
                q.prototype.processData.call(this, b);
                this.dataMin = r;
                this.dataMax = e;
            },
            toYData: function(b) {
                return b.isSum ? 0 === b.x ? null : "sum" : b.isIntermediateSum ? 0 === b.x ? null : "intermediateSum" : b.y;
            },
            pointAttribs: function(a, k) {
                var d = this.options.upColor;
                d && !a.options.color && (a.color = 0 < a.y ? d : null);
                a = b.column.prototype.pointAttribs.call(this, a, k);
                delete a.dashstyle;
                return a;
            },
            getGraphPath: function() {
                return [ "M", 0, 0 ];
            },
            getCrispPath: function() {
                var b = this.data, a = b.length, f = this.graph.strokeWidth() + this.borderWidth, f = Math.round(f) % 2 / 2, n = [], c, g, h;
                for (h = 1; h < a; h++) g = b[h].shapeArgs, c = b[h - 1].shapeArgs, g = [ "M", c.x + c.width, c.y + f, "L", g.x, c.y + f ], 
                0 > b[h - 1].y && (g[2] += c.height, g[5] += c.height), n = n.concat(g);
                return n;
            },
            drawGraph: function() {
                q.prototype.drawGraph.call(this);
                this.graph.attr({
                    d: this.getCrispPath()
                });
            },
            getExtremes: a.noop
        }, {
            getClassName: function() {
                var b = l.prototype.getClassName.call(this);
                this.isSum ? b += " highcharts-sum" : this.isIntermediateSum && (b += " highcharts-intermediate-sum");
                return b;
            },
            isValid: function() {
                return v(this.y, !0) || this.isSum || this.isIntermediateSum;
            }
        });
    })(u);
    (function(a) {
        var p = a.Series, v = a.seriesType, u = a.seriesTypes;
        v("polygon", "scatter", {
            marker: {
                enabled: !1,
                states: {
                    hover: {
                        enabled: !1
                    }
                }
            },
            stickyTracking: !1,
            tooltip: {
                followPointer: !0,
                pointFormat: ""
            },
            trackByArea: !0
        }, {
            type: "polygon",
            getGraphPath: function() {
                for (var a = p.prototype.getGraphPath.call(this), q = a.length + 1; q--; ) (q === a.length || "M" === a[q]) && 0 < q && a.splice(q, 0, "z");
                return this.areaPath = a;
            },
            drawGraph: function() {
                this.options.fillColor = this.color;
                u.area.prototype.drawGraph.call(this);
            },
            drawLegendSymbol: a.LegendSymbolMixin.drawRectangle,
            drawTracker: p.prototype.drawTracker,
            setStackedPoints: a.noop
        });
    })(u);
    (function(a) {
        var p = a.arrayMax, v = a.arrayMin, u = a.Axis, l = a.color, q = a.each, f = a.isNumber, b = a.noop, d = a.pick, k = a.pInt, m = a.Point, n = a.Series, c = a.seriesType, g = a.seriesTypes;
        c("bubble", "scatter", {
            dataLabels: {
                formatter: function() {
                    return this.point.z;
                },
                inside: !0,
                verticalAlign: "middle"
            },
            marker: {
                lineColor: null,
                lineWidth: 1,
                radius: null,
                states: {
                    hover: {
                        radiusPlus: 0
                    }
                },
                symbol: "circle"
            },
            minSize: 8,
            maxSize: "20%",
            softThreshold: !1,
            states: {
                hover: {
                    halo: {
                        size: 5
                    }
                }
            },
            tooltip: {
                pointFormat: "({point.x}, {point.y}), Size: {point.z}"
            },
            turboThreshold: 0,
            zThreshold: 0,
            zoneAxis: "z"
        }, {
            pointArrayMap: [ "y", "z" ],
            parallelArrays: [ "x", "y", "z" ],
            trackerGroups: [ "markerGroup", "dataLabelsGroup" ],
            bubblePadding: !0,
            zoneAxis: "z",
            pointAttribs: function(b, a) {
                var c = d(this.options.marker.fillOpacity, .5);
                b = n.prototype.pointAttribs.call(this, b, a);
                1 !== c && (b.fill = l(b.fill).setOpacity(c).get("rgba"));
                return b;
            },
            getRadii: function(b, a, c, d) {
                var e, k, h, g = this.zData, f = [], m = this.options, n = "width" !== m.sizeBy, t = m.zThreshold, l = a - b;
                k = 0;
                for (e = g.length; k < e; k++) h = g[k], m.sizeByAbsoluteValue && null !== h && (h = Math.abs(h - t), 
                a = Math.max(a - t, Math.abs(b - t)), b = 0), null === h ? h = null : h < b ? h = c / 2 - 1 : (h = 0 < l ? (h - b) / l : .5, 
                n && 0 <= h && (h = Math.sqrt(h)), h = Math.ceil(c + h * (d - c)) / 2), f.push(h);
                this.radii = f;
            },
            animate: function(b) {
                var a = this.options.animation;
                b || (q(this.points, function(b) {
                    var c = b.graphic, d;
                    c && c.width && (d = {
                        x: c.x,
                        y: c.y,
                        width: c.width,
                        height: c.height
                    }, c.attr({
                        x: b.plotX,
                        y: b.plotY,
                        width: 1,
                        height: 1
                    }), c.animate(d, a));
                }), this.animate = null);
            },
            translate: function() {
                var b, a = this.data, c, d, k = this.radii;
                g.scatter.prototype.translate.call(this);
                for (b = a.length; b--; ) c = a[b], d = k ? k[b] : 0, f(d) && d >= this.minPxSize / 2 ? (c.marker = {
                    radius: d,
                    width: 2 * d,
                    height: 2 * d
                }, c.dlBox = {
                    x: c.plotX - d,
                    y: c.plotY - d,
                    width: 2 * d,
                    height: 2 * d
                }) : c.shapeArgs = c.plotY = c.dlBox = void 0;
            },
            alignDataLabel: g.column.prototype.alignDataLabel,
            buildKDTree: b,
            applyZones: b
        }, {
            haloPath: function(b) {
                return m.prototype.haloPath.call(this, 0 === b ? 0 : this.marker.radius + b);
            },
            ttBelow: !1
        });
        u.prototype.beforePadding = function() {
            var b = this, a = this.len, c = this.chart, g = 0, m = a, n = this.isXAxis, l = n ? "xData" : "yData", u = this.min, w = {}, x = Math.min(c.plotWidth, c.plotHeight), A = Number.MAX_VALUE, E = -Number.MAX_VALUE, F = this.max - u, C = a / F, G = [];
            q(this.series, function(a) {
                var e = a.options;
                !a.bubblePadding || !a.visible && c.options.chart.ignoreHiddenSeries || (b.allowZoomOutside = !0, 
                G.push(a), n && (q([ "minSize", "maxSize" ], function(b) {
                    var a = e[b], c = /%$/.test(a), a = k(a);
                    w[b] = c ? x * a / 100 : a;
                }), a.minPxSize = w.minSize, a.maxPxSize = Math.max(w.maxSize, w.minSize), a = a.zData, 
                a.length && (A = d(e.zMin, Math.min(A, Math.max(v(a), !1 === e.displayNegative ? e.zThreshold : -Number.MAX_VALUE))), 
                E = d(e.zMax, Math.max(E, p(a))))));
            });
            q(G, function(a) {
                var c = a[l], d = c.length, e;
                n && a.getRadii(A, E, a.minPxSize, a.maxPxSize);
                if (0 < F) for (;d--; ) f(c[d]) && b.dataMin <= c[d] && c[d] <= b.dataMax && (e = a.radii[d], 
                g = Math.min((c[d] - u) * C - e, g), m = Math.max((c[d] - u) * C + e, m));
            });
            G.length && 0 < F && !this.isLog && (m -= a, C *= (a + g - m) / a, q([ [ "min", "userMin", g ], [ "max", "userMax", m ] ], function(a) {
                void 0 === d(b.options[a[0]], b[a[1]]) && (b[a[0]] += a[2] / C);
            }));
        };
    })(u);
    (function(a) {
        function p(b, a) {
            var d = this.chart, f = this.options.animation, n = this.group, c = this.markerGroup, g = this.xAxis.center, h = d.plotLeft, l = d.plotTop;
            d.polar ? d.renderer.isSVG && (!0 === f && (f = {}), a ? (b = {
                translateX: g[0] + h,
                translateY: g[1] + l,
                scaleX: .001,
                scaleY: .001
            }, n.attr(b), c && c.attr(b)) : (b = {
                translateX: h,
                translateY: l,
                scaleX: 1,
                scaleY: 1
            }, n.animate(b, f), c && c.animate(b, f), this.animate = null)) : b.call(this, a);
        }
        var u = a.each, w = a.pick, l = a.seriesTypes, q = a.wrap, f = a.Series.prototype;
        a = a.Pointer.prototype;
        f.searchPointByAngle = function(b) {
            var a = this.chart, k = this.xAxis.pane.center;
            return this.searchKDTree({
                clientX: 180 + -180 / Math.PI * Math.atan2(b.chartX - k[0] - a.plotLeft, b.chartY - k[1] - a.plotTop)
            });
        };
        q(f, "buildKDTree", function(b) {
            this.chart.polar && (this.kdByAngle ? this.searchPoint = this.searchPointByAngle : this.kdDimensions = 2);
            b.apply(this);
        });
        f.toXY = function(b) {
            var a, k = this.chart, f = b.plotX;
            a = b.plotY;
            b.rectPlotX = f;
            b.rectPlotY = a;
            a = this.xAxis.postTranslate(b.plotX, this.yAxis.len - a);
            b.plotX = b.polarPlotX = a.x - k.plotLeft;
            b.plotY = b.polarPlotY = a.y - k.plotTop;
            this.kdByAngle ? (k = (f / Math.PI * 180 + this.xAxis.pane.options.startAngle) % 360, 
            0 > k && (k += 360), b.clientX = k) : b.clientX = b.plotX;
        };
        l.spline && q(l.spline.prototype, "getPointSpline", function(b, a, k, f) {
            var d, c, g, h, m, e, l;
            this.chart.polar ? (d = k.plotX, c = k.plotY, b = a[f - 1], g = a[f + 1], this.connectEnds && (b || (b = a[a.length - 2]), 
            g || (g = a[1])), b && g && (h = b.plotX, m = b.plotY, a = g.plotX, e = g.plotY, 
            h = (1.5 * d + h) / 2.5, m = (1.5 * c + m) / 2.5, g = (1.5 * d + a) / 2.5, l = (1.5 * c + e) / 2.5, 
            a = Math.sqrt(Math.pow(h - d, 2) + Math.pow(m - c, 2)), e = Math.sqrt(Math.pow(g - d, 2) + Math.pow(l - c, 2)), 
            h = Math.atan2(m - c, h - d), m = Math.atan2(l - c, g - d), l = Math.PI / 2 + (h + m) / 2, 
            Math.abs(h - l) > Math.PI / 2 && (l -= Math.PI), h = d + Math.cos(l) * a, m = c + Math.sin(l) * a, 
            g = d + Math.cos(Math.PI + l) * e, l = c + Math.sin(Math.PI + l) * e, k.rightContX = g, 
            k.rightContY = l), f ? (k = [ "C", b.rightContX || b.plotX, b.rightContY || b.plotY, h || d, m || c, d, c ], 
            b.rightContX = b.rightContY = null) : k = [ "M", d, c ]) : k = b.call(this, a, k, f);
            return k;
        });
        q(f, "translate", function(a) {
            var b = this.chart;
            a.call(this);
            if (b.polar && (this.kdByAngle = b.tooltip && b.tooltip.shared, !this.preventPostTranslate)) for (a = this.points, 
            b = a.length; b--; ) this.toXY(a[b]);
        });
        q(f, "getGraphPath", function(a, d) {
            var b = this, f, l;
            if (this.chart.polar) {
                d = d || this.points;
                for (f = 0; f < d.length; f++) if (!d[f].isNull) {
                    l = f;
                    break;
                }
                !1 !== this.options.connectEnds && void 0 !== l && (this.connectEnds = !0, d.splice(d.length, 0, d[l]));
                u(d, function(a) {
                    void 0 === a.polarPlotY && b.toXY(a);
                });
            }
            return a.apply(this, [].slice.call(arguments, 1));
        });
        q(f, "animate", p);
        l.column && (l = l.column.prototype, l.polarArc = function(a, d, f, l) {
            var b = this.xAxis.center, c = this.yAxis.len;
            return this.chart.renderer.symbols.arc(b[0], b[1], c - d, null, {
                start: f,
                end: l,
                innerR: c - w(a, c)
            });
        }, q(l, "animate", p), q(l, "translate", function(a) {
            var b = this.xAxis, f = b.startAngleRad, l, n, c;
            this.preventPostTranslate = !0;
            a.call(this);
            if (b.isRadial) for (l = this.points, c = l.length; c--; ) n = l[c], a = n.barX + f, 
            n.shapeType = "path", n.shapeArgs = {
                d: this.polarArc(n.yBottom, n.plotY, a, a + n.pointWidth)
            }, this.toXY(n), n.tooltipPos = [ n.plotX, n.plotY ], n.ttBelow = n.plotY > b.center[1];
        }), q(l, "alignDataLabel", function(a, d, k, l, n, c) {
            this.chart.polar ? (a = d.rectPlotX / Math.PI * 180, null === l.align && (l.align = 20 < a && 160 > a ? "left" : 200 < a && 340 > a ? "right" : "center"), 
            null === l.verticalAlign && (l.verticalAlign = 45 > a || 315 < a ? "bottom" : 135 < a && 225 > a ? "top" : "middle"), 
            f.alignDataLabel.call(this, d, k, l, n, c)) : a.call(this, d, k, l, n, c);
        }));
        q(a, "getCoordinates", function(a, d) {
            var b = this.chart, f = {
                xAxis: [],
                yAxis: []
            };
            b.polar ? u(b.axes, function(a) {
                var c = a.isXAxis, g = a.center, h = d.chartX - g[0] - b.plotLeft, g = d.chartY - g[1] - b.plotTop;
                f[c ? "xAxis" : "yAxis"].push({
                    axis: a,
                    value: a.translate(c ? Math.PI - Math.atan2(h, g) : Math.sqrt(Math.pow(h, 2) + Math.pow(g, 2)), !0)
                });
            }) : f = a.call(this, d);
            return f;
        });
    })(u);
});

(function(h) {
    "object" === typeof module && module.exports ? module.exports = h : h(Highcharts);
})(function(h) {
    (function(f) {
        var h = f.defaultOptions, n = f.doc, A = f.Chart, u = f.addEvent, F = f.removeEvent, D = f.fireEvent, q = f.createElement, B = f.discardElement, v = f.css, p = f.merge, C = f.pick, k = f.each, r = f.extend, G = f.isTouchDevice, E = f.win, H = f.Renderer.prototype.symbols;
        r(h.lang, {
            printChart: "Print chart",
            downloadPNG: "Download PNG image",
            downloadJPEG: "Download JPEG image",
            downloadPDF: "Download PDF document",
            downloadSVG: "Download SVG vector image",
            contextButtonTitle: "Chart context menu"
        });
        h.navigation = {
            buttonOptions: {
                theme: {},
                symbolSize: 14,
                symbolX: 12.5,
                symbolY: 10.5,
                align: "right",
                buttonSpacing: 3,
                height: 22,
                verticalAlign: "top",
                width: 24
            }
        };
        p(!0, h.navigation, {
            menuStyle: {
                border: "1px solid #999999",
                background: "#ffffff",
                padding: "5px 0"
            },
            menuItemStyle: {
                padding: "0.5em 1em",
                background: "none",
                color: "#333333",
                fontSize: G ? "14px" : "11px",
                transition: "background 250ms, color 250ms"
            },
            menuItemHoverStyle: {
                background: "#335cad",
                color: "#ffffff"
            },
            buttonOptions: {
                symbolFill: "#666666",
                symbolStroke: "#666666",
                symbolStrokeWidth: 3,
                theme: {
                    fill: "#ffffff",
                    stroke: "none",
                    padding: 5
                }
            }
        });
        h.exporting = {
            type: "image/png",
            url: "https://export.highcharts.com/",
            printMaxWidth: 780,
            scale: 2,
            buttons: {
                contextButton: {
                    className: "highcharts-contextbutton",
                    menuClassName: "highcharts-contextmenu",
                    symbol: "menu",
                    _titleKey: "contextButtonTitle",
                    menuItems: [ {
                        textKey: "printChart",
                        onclick: function() {
                            this.print();
                        }
                    }, {
                        separator: !0
                    }, {
                        textKey: "downloadPNG",
                        onclick: function() {
                            this.exportChart();
                        }
                    }, {
                        textKey: "downloadJPEG",
                        onclick: function() {
                            this.exportChart({
                                type: "image/jpeg"
                            });
                        }
                    }, {
                        textKey: "downloadPDF",
                        onclick: function() {
                            this.exportChart({
                                type: "application/pdf"
                            });
                        }
                    }, {
                        textKey: "downloadSVG",
                        onclick: function() {
                            this.exportChart({
                                type: "image/svg+xml"
                            });
                        }
                    } ]
                }
            }
        };
        f.post = function(a, c, e) {
            var b;
            a = q("form", p({
                method: "post",
                action: a,
                enctype: "multipart/form-data"
            }, e), {
                display: "none"
            }, n.body);
            for (b in c) q("input", {
                type: "hidden",
                name: b,
                value: c[b]
            }, null, a);
            a.submit();
            B(a);
        };
        r(A.prototype, {
            sanitizeSVG: function(a, c) {
                if (c && c.exporting && c.exporting.allowHTML) {
                    var e = a.match(/<\/svg>(.*?$)/);
                    e && (e = '<foreignObject x="0" y="0" width="' + c.chart.width + '" height="' + c.chart.height + '"><body xmlns="http://www.w3.org/1999/xhtml">' + e[1] + "</body></foreignObject>", 
                    a = a.replace("</svg>", e + "</svg>"));
                }
                a = a.replace(/zIndex="[^"]+"/g, "").replace(/isShadow="[^"]+"/g, "").replace(/symbolName="[^"]+"/g, "").replace(/jQuery[0-9]+="[^"]+"/g, "").replace(/url\(("|&quot;)(\S+)("|&quot;)\)/g, "url($2)").replace(/url\([^#]+#/g, "url(#").replace(/<svg /, '<svg xmlns:xlink="http://www.w3.org/1999/xlink" ').replace(/ (NS[0-9]+\:)?href=/g, " xlink:href=").replace(/\n/, " ").replace(/<\/svg>.*?$/, "</svg>").replace(/(fill|stroke)="rgba\(([ 0-9]+,[ 0-9]+,[ 0-9]+),([ 0-9\.]+)\)"/g, '$1="rgb($2)" $1-opacity="$3"').replace(/&nbsp;/g, "Â ").replace(/&shy;/g, "Â­");
                return a = a.replace(/<IMG /g, "<image ").replace(/<(\/?)TITLE>/g, "<$1title>").replace(/height=([^" ]+)/g, 'height="$1"').replace(/width=([^" ]+)/g, 'width="$1"').replace(/hc-svg-href="([^"]+)">/g, 'xlink:href="$1"/>').replace(/ id=([^" >]+)/g, ' id="$1"').replace(/class=([^" >]+)/g, 'class="$1"').replace(/ transform /g, " ").replace(/:(path|rect)/g, "$1").replace(/style="([^"]+)"/g, function(a) {
                    return a.toLowerCase();
                });
            },
            getChartHTML: function() {
                return this.container.innerHTML;
            },
            getSVG: function(a) {
                var c, e, b, w, m, g = p(this.options, a);
                n.createElementNS || (n.createElementNS = function(a, c) {
                    return n.createElement(c);
                });
                e = q("div", null, {
                    position: "absolute",
                    top: "-9999em",
                    width: this.chartWidth + "px",
                    height: this.chartHeight + "px"
                }, n.body);
                b = this.renderTo.style.width;
                m = this.renderTo.style.height;
                b = g.exporting.sourceWidth || g.chart.width || /px$/.test(b) && parseInt(b, 10) || 600;
                m = g.exporting.sourceHeight || g.chart.height || /px$/.test(m) && parseInt(m, 10) || 400;
                r(g.chart, {
                    animation: !1,
                    renderTo: e,
                    forExport: !0,
                    renderer: "SVGRenderer",
                    width: b,
                    height: m
                });
                g.exporting.enabled = !1;
                delete g.data;
                g.series = [];
                k(this.series, function(a) {
                    w = p(a.userOptions, {
                        animation: !1,
                        enableMouseTracking: !1,
                        showCheckbox: !1,
                        visible: a.visible
                    });
                    w.isInternal || g.series.push(w);
                });
                k(this.axes, function(a) {
                    a.userOptions.internalKey = f.uniqueKey();
                });
                c = new f.Chart(g, this.callback);
                a && k([ "xAxis", "yAxis", "series" ], function(b) {
                    var d = {};
                    a[b] && (d[b] = a[b], c.update(d));
                });
                k(this.axes, function(a) {
                    var b = f.find(c.axes, function(b) {
                        return b.options.internalKey === a.userOptions.internalKey;
                    }), d = a.getExtremes(), e = d.userMin, d = d.userMax;
                    !b || void 0 === e && void 0 === d || b.setExtremes(e, d, !0, !1);
                });
                b = c.getChartHTML();
                b = this.sanitizeSVG(b, g);
                g = null;
                c.destroy();
                B(e);
                return b;
            },
            getSVGForExport: function(a, c) {
                var e = this.options.exporting;
                return this.getSVG(p({
                    chart: {
                        borderRadius: 0
                    }
                }, e.chartOptions, c, {
                    exporting: {
                        sourceWidth: a && a.sourceWidth || e.sourceWidth,
                        sourceHeight: a && a.sourceHeight || e.sourceHeight
                    }
                }));
            },
            exportChart: function(a, c) {
                c = this.getSVGForExport(a, c);
                a = p(this.options.exporting, a);
                f.post(a.url, {
                    filename: a.filename || "chart",
                    type: a.type,
                    width: a.width || 0,
                    scale: a.scale,
                    svg: c
                }, a.formAttributes);
            },
            print: function() {
                var a = this, c = a.container, e = [], b = c.parentNode, f = n.body, m = f.childNodes, g = a.options.exporting.printMaxWidth, d, t;
                if (!a.isPrinting) {
                    a.isPrinting = !0;
                    a.pointer.reset(null, 0);
                    D(a, "beforePrint");
                    if (t = g && a.chartWidth > g) d = [ a.options.chart.width, void 0, !1 ], a.setSize(g, void 0, !1);
                    k(m, function(a, b) {
                        1 === a.nodeType && (e[b] = a.style.display, a.style.display = "none");
                    });
                    f.appendChild(c);
                    E.focus();
                    E.print();
                    setTimeout(function() {
                        b.appendChild(c);
                        k(m, function(a, b) {
                            1 === a.nodeType && (a.style.display = e[b]);
                        });
                        a.isPrinting = !1;
                        t && a.setSize.apply(a, d);
                        D(a, "afterPrint");
                    }, 1e3);
                }
            },
            contextMenu: function(a, c, e, b, f, m, g) {
                var d = this, t = d.options.navigation, w = d.chartWidth, h = d.chartHeight, p = "cache-" + a, l = d[p], x = Math.max(f, m), y, z;
                l || (d[p] = l = q("div", {
                    className: a
                }, {
                    position: "absolute",
                    zIndex: 1e3,
                    padding: x + "px"
                }, d.container), y = q("div", {
                    className: "highcharts-menu"
                }, null, l), v(y, r({
                    MozBoxShadow: "3px 3px 10px #888",
                    WebkitBoxShadow: "3px 3px 10px #888",
                    boxShadow: "3px 3px 10px #888"
                }, t.menuStyle)), z = function() {
                    v(l, {
                        display: "none"
                    });
                    g && g.setState(0);
                    d.openMenu = !1;
                }, u(l, "mouseleave", function() {
                    l.hideTimer = setTimeout(z, 500);
                }), u(l, "mouseenter", function() {
                    clearTimeout(l.hideTimer);
                }), p = u(n, "mouseup", function(b) {
                    d.pointer.inClass(b.target, a) || z();
                }), u(d, "destroy", p), k(c, function(a) {
                    if (a) {
                        var b;
                        a.separator ? b = q("hr", null, null, y) : (b = q("div", {
                            className: "highcharts-menu-item",
                            onclick: function(b) {
                                b && b.stopPropagation();
                                z();
                                a.onclick && a.onclick.apply(d, arguments);
                            },
                            innerHTML: a.text || d.options.lang[a.textKey]
                        }, null, y), b.onmouseover = function() {
                            v(this, t.menuItemHoverStyle);
                        }, b.onmouseout = function() {
                            v(this, t.menuItemStyle);
                        }, v(b, r({
                            cursor: "pointer"
                        }, t.menuItemStyle)));
                        d.exportDivElements.push(b);
                    }
                }), d.exportDivElements.push(y, l), d.exportMenuWidth = l.offsetWidth, d.exportMenuHeight = l.offsetHeight);
                c = {
                    display: "block"
                };
                e + d.exportMenuWidth > w ? c.right = w - e - f - x + "px" : c.left = e - x + "px";
                b + m + d.exportMenuHeight > h && "top" !== g.alignOptions.verticalAlign ? c.bottom = h - b - x + "px" : c.top = b + m - x + "px";
                v(l, c);
                d.openMenu = !0;
            },
            addButton: function(a) {
                var c = this, e = c.renderer, b = p(c.options.navigation.buttonOptions, a), f = b.onclick, m = b.menuItems, g, d, h = b.symbolSize || 12;
                c.btnCount || (c.btnCount = 0);
                c.exportDivElements || (c.exportDivElements = [], c.exportSVGElements = []);
                if (!1 !== b.enabled) {
                    var k = b.theme, n = k.states, q = n && n.hover, n = n && n.select, l;
                    delete k.states;
                    f ? l = function(a) {
                        a.stopPropagation();
                        f.call(c, a);
                    } : m && (l = function() {
                        c.contextMenu(d.menuClassName, m, d.translateX, d.translateY, d.width, d.height, d);
                        d.setState(2);
                    });
                    b.text && b.symbol ? k.paddingLeft = C(k.paddingLeft, 25) : b.text || r(k, {
                        width: b.width,
                        height: b.height,
                        padding: 0
                    });
                    d = e.button(b.text, 0, 0, l, k, q, n).addClass(a.className).attr({
                        "stroke-linecap": "round",
                        title: c.options.lang[b._titleKey],
                        zIndex: 3
                    });
                    d.menuClassName = a.menuClassName || "highcharts-menu-" + c.btnCount++;
                    b.symbol && (g = e.symbol(b.symbol, b.symbolX - h / 2, b.symbolY - h / 2, h, h).addClass("highcharts-button-symbol").attr({
                        zIndex: 1
                    }).add(d), g.attr({
                        stroke: b.symbolStroke,
                        fill: b.symbolFill,
                        "stroke-width": b.symbolStrokeWidth || 1
                    }));
                    d.add().align(r(b, {
                        width: d.width,
                        x: C(b.x, c.buttonOffset)
                    }), !0, "spacingBox");
                    c.buttonOffset += (d.width + b.buttonSpacing) * ("right" === b.align ? -1 : 1);
                    c.exportSVGElements.push(d, g);
                }
            },
            destroyExport: function(a) {
                var c = a ? a.target : this;
                a = c.exportSVGElements;
                var e = c.exportDivElements;
                a && (k(a, function(a, e) {
                    a && (a.onclick = a.ontouchstart = null, c.exportSVGElements[e] = a.destroy());
                }), a.length = 0);
                e && (k(e, function(a, e) {
                    clearTimeout(a.hideTimer);
                    F(a, "mouseleave");
                    c.exportDivElements[e] = a.onmouseout = a.onmouseover = a.ontouchstart = a.onclick = null;
                    B(a);
                }), e.length = 0);
            }
        });
        H.menu = function(a, c, e, b) {
            return [ "M", a, c + 2.5, "L", a + e, c + 2.5, "M", a, c + b / 2 + .5, "L", a + e, c + b / 2 + .5, "M", a, c + b - 1.5, "L", a + e, c + b - 1.5 ];
        };
        A.prototype.renderExporting = function() {
            var a, c = this.options.exporting, e = c.buttons, b = this.isDirtyExporting || !this.exportSVGElements;
            this.buttonOffset = 0;
            this.isDirtyExporting && this.destroyExport();
            if (b && !1 !== c.enabled) {
                for (a in e) this.addButton(e[a]);
                this.isDirtyExporting = !1;
            }
            u(this, "destroy", this.destroyExport);
        };
        A.prototype.callbacks.push(function(a) {
            a.renderExporting();
            u(a, "redraw", a.renderExporting);
            k([ "exporting", "navigation" ], function(c) {
                a[c] = {
                    update: function(e, b) {
                        a.isDirtyExporting = !0;
                        p(!0, a.options[c], e);
                        C(b, !0) && a.redraw();
                    }
                };
            });
        });
    })(h);
});

(function(q) {
    "object" === typeof module && module.exports ? module.exports = q : q(Highcharts);
})(function(q) {
    (function(g) {
        var q = g.seriesType, l = g.seriesTypes, E = g.map, v = g.merge, y = g.extend, z = g.noop, n = g.each, x = g.grep, F = g.isNumber, A = g.isString, k = g.pick, r = g.Series, G = g.stableSort, B = g.Color, H = function(a, b, c) {
            var e;
            c = c || this;
            for (e in a) a.hasOwnProperty(e) && b.call(c, a[e], e, a);
        }, C = function(a, b, c, e) {
            e = e || this;
            a = a || [];
            n(a, function(d, f) {
                c = b.call(e, c, d, f, a);
            });
            return c;
        }, w = function(a, b, c) {
            c = c || this;
            a = b.call(c, a);
            !1 !== a && w(a, b, c);
        };
        q("treemap", "scatter", {
            showInLegend: !1,
            marker: !1,
            dataLabels: {
                enabled: !0,
                defer: !1,
                verticalAlign: "middle",
                formatter: function() {
                    return this.point.name || this.point.id;
                },
                inside: !0
            },
            tooltip: {
                headerFormat: "",
                pointFormat: "<b>{point.name}</b>: {point.value}</b><br/>"
            },
            layoutAlgorithm: "sliceAndDice",
            layoutStartingDirection: "vertical",
            alternateStartingDirection: !1,
            levelIsConstant: !0,
            drillUpButton: {
                position: {
                    align: "right",
                    x: -10,
                    y: 10
                }
            },
            borderColor: "#e6e6e6",
            borderWidth: 1,
            opacity: .15,
            states: {
                hover: {
                    borderColor: "#999999",
                    brightness: l.heatmap ? 0 : .1,
                    opacity: .75,
                    shadow: !1
                }
            }
        }, {
            pointArrayMap: [ "value" ],
            axisTypes: l.heatmap ? [ "xAxis", "yAxis", "colorAxis" ] : [ "xAxis", "yAxis" ],
            optionalAxis: "colorAxis",
            getSymbol: z,
            parallelArrays: [ "x", "y", "value", "colorValue" ],
            colorKey: "colorValue",
            translateColors: l.heatmap && l.heatmap.prototype.translateColors,
            trackerGroups: [ "group", "dataLabelsGroup" ],
            getListOfParents: function(a, b) {
                a = C(a, function(a, b, d) {
                    b = k(b.parent, "");
                    void 0 === a[b] && (a[b] = []);
                    a[b].push(d);
                    return a;
                }, {});
                H(a, function(a, e, d) {
                    "" !== e && -1 === g.inArray(e, b) && (n(a, function(a) {
                        d[""].push(a);
                    }), delete d[e]);
                });
                return a;
            },
            getTree: function() {
                var a = E(this.data, function(a) {
                    return a.id;
                }), a = this.getListOfParents(this.data, a);
                this.nodeMap = [];
                return this.buildNode("", -1, 0, a, null);
            },
            init: function(a, b) {
                r.prototype.init.call(this, a, b);
                this.options.allowDrillToNode && g.addEvent(this, "click", this.onClickDrillToNode);
            },
            buildNode: function(a, b, c, e, d) {
                var f = this, h = [], D = f.points[b], p;
                n(e[a] || [], function(b) {
                    p = f.buildNode(f.points[b].id, b, c + 1, e, a);
                    h.push(p);
                });
                b = {
                    id: a,
                    i: b,
                    children: h,
                    level: c,
                    parent: d,
                    visible: !1
                };
                f.nodeMap[b.id] = b;
                D && (D.node = b);
                return b;
            },
            setTreeValues: function(a) {
                var b = this, c = b.options, e = 0, d = [], f, h = b.points[a.i];
                w(b.nodeMap[b.rootNode], function(a) {
                    var c = !1, d = a.parent;
                    a.visible = !0;
                    if (d || "" === d) c = b.nodeMap[d];
                    return c;
                });
                w(b.nodeMap[b.rootNode].children, function(a) {
                    var b = !1;
                    n(a, function(a) {
                        a.visible = !0;
                        a.children.length && (b = (b || []).concat(a.children));
                    });
                    return b;
                });
                n(a.children, function(a) {
                    a = b.setTreeValues(a);
                    d.push(a);
                    a.ignore ? w(a.children, function(a) {
                        var b = !1;
                        n(a, function(a) {
                            y(a, {
                                ignore: !0,
                                isLeaf: !1,
                                visible: !1
                            });
                            a.children.length && (b = (b || []).concat(a.children));
                        });
                        return b;
                    }) : e += a.val;
                });
                G(d, function(a, b) {
                    return a.sortIndex - b.sortIndex;
                });
                f = k(h && h.options.value, e);
                h && (h.value = f);
                y(a, {
                    children: d,
                    childrenTotal: e,
                    ignore: !(k(h && h.visible, !0) && 0 < f),
                    isLeaf: a.visible && !e,
                    levelDynamic: c.levelIsConstant ? a.level : a.level - b.nodeMap[b.rootNode].level,
                    name: k(h && h.name, ""),
                    sortIndex: k(h && h.sortIndex, -f),
                    val: f
                });
                return a;
            },
            calculateChildrenAreas: function(a, b) {
                var c = this, e = c.options, d = this.levelMap[a.levelDynamic + 1], f = k(c[d && d.layoutAlgorithm] && d.layoutAlgorithm, e.layoutAlgorithm), h = e.alternateStartingDirection, g = [];
                a = x(a.children, function(a) {
                    return !a.ignore;
                });
                d && d.layoutStartingDirection && (b.direction = "vertical" === d.layoutStartingDirection ? 0 : 1);
                g = c[f](b, a);
                n(a, function(a, d) {
                    d = g[d];
                    a.values = v(d, {
                        val: a.childrenTotal,
                        direction: h ? 1 - b.direction : b.direction
                    });
                    a.pointValues = v(d, {
                        x: d.x / c.axisRatio,
                        width: d.width / c.axisRatio
                    });
                    a.children.length && c.calculateChildrenAreas(a, a.values);
                });
            },
            setPointValues: function() {
                var a = this, b = a.xAxis, c = a.yAxis;
                n(a.points, function(e) {
                    var d = e.node, f = d.pointValues, h, g, p = (a.pointAttribs(e)["stroke-width"] || 0) % 2 / 2;
                    f && d.visible ? (d = Math.round(b.translate(f.x, 0, 0, 0, 1)) - p, h = Math.round(b.translate(f.x + f.width, 0, 0, 0, 1)) - p, 
                    g = Math.round(c.translate(f.y, 0, 0, 0, 1)) - p, f = Math.round(c.translate(f.y + f.height, 0, 0, 0, 1)) - p, 
                    e.shapeType = "rect", e.shapeArgs = {
                        x: Math.min(d, h),
                        y: Math.min(g, f),
                        width: Math.abs(h - d),
                        height: Math.abs(f - g)
                    }, e.plotX = e.shapeArgs.x + e.shapeArgs.width / 2, e.plotY = e.shapeArgs.y + e.shapeArgs.height / 2) : (delete e.plotX, 
                    delete e.plotY);
                });
            },
            setColorRecursive: function(a, b, c) {
                var e = this, d, f;
                a && (d = e.points[a.i], f = e.levelMap[a.levelDynamic], b = k(d && d.options.color, f && f.color, b), 
                c = k(d && d.options.colorIndex, f && f.colorIndex, c), d && (d.color = b, d.colorIndex = c), 
                a.children.length && n(a.children, function(a) {
                    e.setColorRecursive(a, b, c);
                }));
            },
            algorithmGroup: function(a, b, c, e) {
                this.height = a;
                this.width = b;
                this.plot = e;
                this.startDirection = this.direction = c;
                this.lH = this.nH = this.lW = this.nW = this.total = 0;
                this.elArr = [];
                this.lP = {
                    total: 0,
                    lH: 0,
                    nH: 0,
                    lW: 0,
                    nW: 0,
                    nR: 0,
                    lR: 0,
                    aspectRatio: function(a, b) {
                        return Math.max(a / b, b / a);
                    }
                };
                this.addElement = function(a) {
                    this.lP.total = this.elArr[this.elArr.length - 1];
                    this.total += a;
                    0 === this.direction ? (this.lW = this.nW, this.lP.lH = this.lP.total / this.lW, 
                    this.lP.lR = this.lP.aspectRatio(this.lW, this.lP.lH), this.nW = this.total / this.height, 
                    this.lP.nH = this.lP.total / this.nW, this.lP.nR = this.lP.aspectRatio(this.nW, this.lP.nH)) : (this.lH = this.nH, 
                    this.lP.lW = this.lP.total / this.lH, this.lP.lR = this.lP.aspectRatio(this.lP.lW, this.lH), 
                    this.nH = this.total / this.width, this.lP.nW = this.lP.total / this.nH, this.lP.nR = this.lP.aspectRatio(this.lP.nW, this.nH));
                    this.elArr.push(a);
                };
                this.reset = function() {
                    this.lW = this.nW = 0;
                    this.elArr = [];
                    this.total = 0;
                };
            },
            algorithmCalcPoints: function(a, b, c, e) {
                var d, f, h, g, p = c.lW, k = c.lH, m = c.plot, l, t = 0, u = c.elArr.length - 1;
                b ? (p = c.nW, k = c.nH) : l = c.elArr[c.elArr.length - 1];
                n(c.elArr, function(a) {
                    if (b || t < u) 0 === c.direction ? (d = m.x, f = m.y, h = p, g = a / h) : (d = m.x, 
                    f = m.y, g = k, h = a / g), e.push({
                        x: d,
                        y: f,
                        width: h,
                        height: g
                    }), 0 === c.direction ? m.y += g : m.x += h;
                    t += 1;
                });
                c.reset();
                0 === c.direction ? c.width -= p : c.height -= k;
                m.y = m.parent.y + (m.parent.height - c.height);
                m.x = m.parent.x + (m.parent.width - c.width);
                a && (c.direction = 1 - c.direction);
                b || c.addElement(l);
            },
            algorithmLowAspectRatio: function(a, b, c) {
                var e = [], d = this, f, g = {
                    x: b.x,
                    y: b.y,
                    parent: b
                }, k = 0, p = c.length - 1, l = new this.algorithmGroup(b.height, b.width, b.direction, g);
                n(c, function(c) {
                    f = c.val / b.val * b.height * b.width;
                    l.addElement(f);
                    l.lP.nR > l.lP.lR && d.algorithmCalcPoints(a, !1, l, e, g);
                    k === p && d.algorithmCalcPoints(a, !0, l, e, g);
                    k += 1;
                });
                return e;
            },
            algorithmFill: function(a, b, c) {
                var e = [], d, f = b.direction, g = b.x, k = b.y, l = b.width, q = b.height, m, r, t, u;
                n(c, function(c) {
                    d = c.val / b.val * b.height * b.width;
                    m = g;
                    r = k;
                    0 === f ? (u = q, t = d / u, l -= t, g += t) : (t = l, u = d / t, q -= u, k += u);
                    e.push({
                        x: m,
                        y: r,
                        width: t,
                        height: u
                    });
                    a && (f = 1 - f);
                });
                return e;
            },
            strip: function(a, b) {
                return this.algorithmLowAspectRatio(!1, a, b);
            },
            squarified: function(a, b) {
                return this.algorithmLowAspectRatio(!0, a, b);
            },
            sliceAndDice: function(a, b) {
                return this.algorithmFill(!0, a, b);
            },
            stripes: function(a, b) {
                return this.algorithmFill(!1, a, b);
            },
            translate: function() {
                var a = this.rootNode = k(this.rootNode, this.options.rootId, ""), b, c;
                r.prototype.translate.call(this);
                this.levelMap = C(this.options.levels, function(a, b) {
                    a[b.level] = b;
                    return a;
                }, {});
                c = this.tree = this.getTree();
                b = this.nodeMap[a];
                "" === a || b && b.children.length || (this.drillToNode("", !1), a = this.rootNode, 
                b = this.nodeMap[a]);
                this.setTreeValues(c);
                this.axisRatio = this.xAxis.len / this.yAxis.len;
                this.nodeMap[""].pointValues = a = {
                    x: 0,
                    y: 0,
                    width: 100,
                    height: 100
                };
                this.nodeMap[""].values = a = v(a, {
                    width: a.width * this.axisRatio,
                    direction: "vertical" === this.options.layoutStartingDirection ? 0 : 1,
                    val: c.val
                });
                this.calculateChildrenAreas(c, a);
                this.colorAxis ? this.translateColors() : this.options.colorByPoint || this.setColorRecursive(this.tree);
                this.options.allowDrillToNode && (b = b.pointValues, this.xAxis.setExtremes(b.x, b.x + b.width, !1), 
                this.yAxis.setExtremes(b.y, b.y + b.height, !1), this.xAxis.setScale(), this.yAxis.setScale());
                this.setPointValues();
            },
            drawDataLabels: function() {
                var a = this, b = x(a.points, function(a) {
                    return a.node.visible;
                }), c, e;
                n(b, function(b) {
                    e = a.levelMap[b.node.levelDynamic];
                    c = {
                        style: {}
                    };
                    b.node.isLeaf || (c.enabled = !1);
                    e && e.dataLabels && (c = v(c, e.dataLabels), a._hasPointLabels = !0);
                    b.shapeArgs && (c.style.width = b.shapeArgs.width, b.dataLabel && b.dataLabel.css({
                        width: b.shapeArgs.width + "px"
                    }));
                    b.dlOptions = v(c, b.options.dataLabels);
                });
                r.prototype.drawDataLabels.call(this);
            },
            alignDataLabel: function(a) {
                l.column.prototype.alignDataLabel.apply(this, arguments);
                a.dataLabel && a.dataLabel.attr({
                    zIndex: a.node.zIndex + 1
                });
            },
            pointAttribs: function(a, b) {
                var c = this.levelMap[a.node.levelDynamic] || {}, e = this.options, d = b && e.states[b] || {}, f = a.getClassName();
                a = {
                    stroke: a.borderColor || c.borderColor || d.borderColor || e.borderColor,
                    "stroke-width": k(a.borderWidth, c.borderWidth, d.borderWidth, e.borderWidth),
                    dashstyle: a.borderDashStyle || c.borderDashStyle || d.borderDashStyle || e.borderDashStyle,
                    fill: a.color || this.color
                };
                -1 !== f.indexOf("highcharts-above-level") ? (a.fill = "none", a["stroke-width"] = 0) : -1 !== f.indexOf("highcharts-internal-node-interactive") ? (b = k(d.opacity, e.opacity), 
                a.fill = B(a.fill).setOpacity(b).get(), a.cursor = "pointer") : -1 !== f.indexOf("highcharts-internal-node") ? a.fill = "none" : b && (a.fill = B(a.fill).brighten(d.brightness).get());
                return a;
            },
            drawPoints: function() {
                var a = this, b = x(a.points, function(a) {
                    return a.node.visible;
                });
                n(b, function(b) {
                    var c = "levelGroup-" + b.node.levelDynamic;
                    a[c] || (a[c] = a.chart.renderer.g(c).attr({
                        zIndex: 1e3 - b.node.levelDynamic
                    }).add(a.group));
                    b.group = a[c];
                });
                l.column.prototype.drawPoints.call(this);
                a.options.allowDrillToNode && n(b, function(b) {
                    b.graphic && (b.drillId = a.options.interactByLeaf ? a.drillToByLeaf(b) : a.drillToByGroup(b));
                });
            },
            onClickDrillToNode: function(a) {
                var b = (a = a.point) && a.drillId;
                A(b) && (a.setState(""), this.drillToNode(b));
            },
            drillToByGroup: function(a) {
                var b = !1;
                1 !== a.node.level - this.nodeMap[this.rootNode].level || a.node.isLeaf || (b = a.id);
                return b;
            },
            drillToByLeaf: function(a) {
                var b = !1;
                if (a.node.parent !== this.rootNode && a.node.isLeaf) for (a = a.node; !b; ) a = this.nodeMap[a.parent], 
                a.parent === this.rootNode && (b = a.id);
                return b;
            },
            drillUp: function() {
                var a = this.nodeMap[this.rootNode];
                a && A(a.parent) && this.drillToNode(a.parent);
            },
            drillToNode: function(a, b) {
                var c = this.nodeMap[a];
                this.rootNode = a;
                "" === a ? this.drillUpButton = this.drillUpButton.destroy() : this.showDrillUpButton(c && c.name || a);
                this.isDirty = !0;
                k(b, !0) && this.chart.redraw();
            },
            showDrillUpButton: function(a) {
                var b = this;
                a = a || "< Back";
                var c = b.options.drillUpButton, e, d;
                c.text && (a = c.text);
                this.drillUpButton ? this.drillUpButton.attr({
                    text: a
                }).align() : (d = (e = c.theme) && e.states, this.drillUpButton = this.chart.renderer.button(a, null, null, function() {
                    b.drillUp();
                }, e, d && d.hover, d && d.select).attr({
                    align: c.position.align,
                    zIndex: 7
                }).add().align(c.position, !1, c.relativeTo || "plotBox"));
            },
            buildKDTree: z,
            drawLegendSymbol: g.LegendSymbolMixin.drawRectangle,
            getExtremes: function() {
                r.prototype.getExtremes.call(this, this.colorValueData);
                this.valueMin = this.dataMin;
                this.valueMax = this.dataMax;
                r.prototype.getExtremes.call(this);
            },
            getExtremesFromAll: !0,
            bindAxes: function() {
                var a = {
                    endOnTick: !1,
                    gridLineWidth: 0,
                    lineWidth: 0,
                    min: 0,
                    dataMin: 0,
                    minPadding: 0,
                    max: 100,
                    dataMax: 100,
                    maxPadding: 0,
                    startOnTick: !1,
                    title: null,
                    tickPositions: []
                };
                r.prototype.bindAxes.call(this);
                g.extend(this.yAxis.options, a);
                g.extend(this.xAxis.options, a);
            }
        }, {
            getClassName: function() {
                var a = g.Point.prototype.getClassName.call(this), b = this.series, c = b.options;
                this.node.level <= b.nodeMap[b.rootNode].level ? a += " highcharts-above-level" : this.node.isLeaf || k(c.interactByLeaf, !c.allowDrillToNode) ? this.node.isLeaf || (a += " highcharts-internal-node") : a += " highcharts-internal-node-interactive";
                return a;
            },
            isValid: function() {
                return F(this.value);
            },
            setState: function(a) {
                g.Point.prototype.setState.call(this, a);
                this.graphic.attr({
                    zIndex: "hover" === a ? 1 : 0
                });
            },
            setVisible: l.pie.prototype.pointClass.prototype.setVisible
        });
    })(q);
});

(function(n) {
    "object" === typeof module && module.exports ? module.exports = n : n(Highcharts);
})(function(n) {
    (function(c) {
        var k = c.Axis, r = c.Chart, m = c.color, l, e = c.each, v = c.extend, w = c.isNumber, p = c.Legend, f = c.LegendSymbolMixin, x = c.noop, q = c.merge, u = c.pick, t = c.wrap;
        l = c.ColorAxis = function() {
            this.init.apply(this, arguments);
        };
        v(l.prototype, k.prototype);
        v(l.prototype, {
            defaultColorAxisOptions: {
                lineWidth: 0,
                minPadding: 0,
                maxPadding: 0,
                gridLineWidth: 1,
                tickPixelInterval: 72,
                startOnTick: !0,
                endOnTick: !0,
                offset: 0,
                marker: {
                    animation: {
                        duration: 50
                    },
                    width: .01,
                    color: "#999999"
                },
                labels: {
                    overflow: "justify",
                    rotation: 0
                },
                minColor: "#e6ebf5",
                maxColor: "#003399",
                tickLength: 5,
                showInLegend: !0
            },
            keepProps: [ "legendGroup", "legendItem", "legendSymbol" ].concat(k.prototype.keepProps),
            init: function(a, b) {
                var d = "vertical" !== a.options.legend.layout, g;
                this.coll = "colorAxis";
                g = q(this.defaultColorAxisOptions, {
                    side: d ? 2 : 1,
                    reversed: !d
                }, b, {
                    opposite: !d,
                    showEmpty: !1,
                    title: null
                });
                k.prototype.init.call(this, a, g);
                b.dataClasses && this.initDataClasses(b);
                this.initStops(b);
                this.horiz = d;
                this.zoomEnabled = !1;
                this.defaultLegendLength = 200;
            },
            tweenColors: function(a, b, d) {
                var g;
                b.rgba.length && a.rgba.length ? (a = a.rgba, b = b.rgba, g = 1 !== b[3] || 1 !== a[3], 
                a = (g ? "rgba(" : "rgb(") + Math.round(b[0] + (a[0] - b[0]) * (1 - d)) + "," + Math.round(b[1] + (a[1] - b[1]) * (1 - d)) + "," + Math.round(b[2] + (a[2] - b[2]) * (1 - d)) + (g ? "," + (b[3] + (a[3] - b[3]) * (1 - d)) : "") + ")") : a = b.input || "none";
                return a;
            },
            initDataClasses: function(a) {
                var b = this, d = this.chart, g, h = 0, c = d.options.chart.colorCount, y = this.options, f = a.dataClasses.length;
                this.dataClasses = g = [];
                this.legendItems = [];
                e(a.dataClasses, function(a, e) {
                    a = q(a);
                    g.push(a);
                    a.color || ("category" === y.dataClassColor ? (e = d.options.colors, c = e.length, 
                    a.color = e[h], a.colorIndex = h, h++, h === c && (h = 0)) : a.color = b.tweenColors(m(y.minColor), m(y.maxColor), 2 > f ? .5 : e / (f - 1)));
                });
            },
            initStops: function(a) {
                this.stops = a.stops || [ [ 0, this.options.minColor ], [ 1, this.options.maxColor ] ];
                e(this.stops, function(a) {
                    a.color = m(a[1]);
                });
            },
            setOptions: function(a) {
                k.prototype.setOptions.call(this, a);
                this.options.crosshair = this.options.marker;
            },
            setAxisSize: function() {
                var a = this.legendSymbol, b = this.chart, d = b.options.legend || {}, g, h;
                a ? (this.left = d = a.attr("x"), this.top = g = a.attr("y"), this.width = h = a.attr("width"), 
                this.height = a = a.attr("height"), this.right = b.chartWidth - d - h, this.bottom = b.chartHeight - g - a, 
                this.len = this.horiz ? h : a, this.pos = this.horiz ? d : g) : this.len = (this.horiz ? d.symbolWidth : d.symbolHeight) || this.defaultLegendLength;
            },
            toColor: function(a, b) {
                var d = this.stops, g, h, c = this.dataClasses, e, f;
                if (c) for (f = c.length; f--; ) {
                    if (e = c[f], g = e.from, d = e.to, (void 0 === g || a >= g) && (void 0 === d || a <= d)) {
                        h = e.color;
                        b && (b.dataClass = f, b.colorIndex = e.colorIndex);
                        break;
                    }
                } else {
                    this.isLog && (a = this.val2lin(a));
                    a = 1 - (this.max - a) / (this.max - this.min || 1);
                    for (f = d.length; f-- && !(a > d[f][0]); ) ;
                    g = d[f] || d[f + 1];
                    d = d[f + 1] || g;
                    a = 1 - (d[0] - a) / (d[0] - g[0] || 1);
                    h = this.tweenColors(g.color, d.color, a);
                }
                return h;
            },
            getOffset: function() {
                var a = this.legendGroup, b = this.chart.axisOffset[this.side];
                a && (this.axisParent = a, k.prototype.getOffset.call(this), this.added || (this.added = !0, 
                this.labelLeft = 0, this.labelRight = this.width), this.chart.axisOffset[this.side] = b);
            },
            setLegendColor: function() {
                var a, b = this.options, d = this.reversed;
                a = d ? 1 : 0;
                d = d ? 0 : 1;
                a = this.horiz ? [ a, 0, d, 0 ] : [ 0, d, 0, a ];
                this.legendColor = {
                    linearGradient: {
                        x1: a[0],
                        y1: a[1],
                        x2: a[2],
                        y2: a[3]
                    },
                    stops: b.stops || [ [ 0, b.minColor ], [ 1, b.maxColor ] ]
                };
            },
            drawLegendSymbol: function(a, b) {
                var d = a.padding, g = a.options, h = this.horiz, c = u(g.symbolWidth, h ? this.defaultLegendLength : 12), f = u(g.symbolHeight, h ? 12 : this.defaultLegendLength), e = u(g.labelPadding, h ? 16 : 30), g = u(g.itemDistance, 10);
                this.setLegendColor();
                b.legendSymbol = this.chart.renderer.rect(0, a.baseline - 11, c, f).attr({
                    zIndex: 1
                }).add(b.legendGroup);
                this.legendItemWidth = c + d + (h ? g : e);
                this.legendItemHeight = f + d + (h ? e : 0);
            },
            setState: x,
            visible: !0,
            setVisible: x,
            getSeriesExtremes: function() {
                var a = this.series, b = a.length;
                this.dataMin = Infinity;
                for (this.dataMax = -Infinity; b--; ) void 0 !== a[b].valueMin && (this.dataMin = Math.min(this.dataMin, a[b].valueMin), 
                this.dataMax = Math.max(this.dataMax, a[b].valueMax));
            },
            drawCrosshair: function(a, b) {
                var d = b && b.plotX, c = b && b.plotY, h, f = this.pos, e = this.len;
                b && (h = this.toPixels(b[b.series.colorKey]), h < f ? h = f - 2 : h > f + e && (h = f + e + 2), 
                b.plotX = h, b.plotY = this.len - h, k.prototype.drawCrosshair.call(this, a, b), 
                b.plotX = d, b.plotY = c, this.cross && (this.cross.addClass("highcharts-coloraxis-marker").add(this.legendGroup), 
                this.cross.attr({
                    fill: this.crosshair.color
                })));
            },
            getPlotLinePath: function(a, b, d, c, h) {
                return w(h) ? this.horiz ? [ "M", h - 4, this.top - 6, "L", h + 4, this.top - 6, h, this.top, "Z" ] : [ "M", this.left, h, "L", this.left - 6, h + 6, this.left - 6, h - 6, "Z" ] : k.prototype.getPlotLinePath.call(this, a, b, d, c);
            },
            update: function(a, b) {
                var d = this.chart, c = d.legend;
                e(this.series, function(a) {
                    a.isDirtyData = !0;
                });
                a.dataClasses && c.allItems && (e(c.allItems, function(a) {
                    a.isDataClass && a.legendGroup.destroy();
                }), d.isDirtyLegend = !0);
                d.options[this.coll] = q(this.userOptions, a);
                k.prototype.update.call(this, a, b);
                this.legendItem && (this.setLegendColor(), c.colorizeItem(this, !0));
            },
            getDataClassLegendSymbols: function() {
                var a = this, b = this.chart, d = this.legendItems, g = b.options.legend, h = g.valueDecimals, t = g.valueSuffix || "", k;
                d.length || e(this.dataClasses, function(g, p) {
                    var l = !0, q = g.from, m = g.to;
                    k = "";
                    void 0 === q ? k = "< " : void 0 === m && (k = "> ");
                    void 0 !== q && (k += c.numberFormat(q, h) + t);
                    void 0 !== q && void 0 !== m && (k += " - ");
                    void 0 !== m && (k += c.numberFormat(m, h) + t);
                    d.push(v({
                        chart: b,
                        name: k,
                        options: {},
                        drawLegendSymbol: f.drawRectangle,
                        visible: !0,
                        setState: x,
                        isDataClass: !0,
                        setVisible: function() {
                            l = this.visible = !l;
                            e(a.series, function(a) {
                                e(a.points, function(a) {
                                    a.dataClass === p && a.setVisible(l);
                                });
                            });
                            b.legend.colorizeItem(this, l);
                        }
                    }, g));
                });
                return d;
            },
            name: ""
        });
        e([ "fill", "stroke" ], function(a) {
            c.Fx.prototype[a + "Setter"] = function() {
                this.elem.attr(a, l.prototype.tweenColors(m(this.start), m(this.end), this.pos), null, !0);
            };
        });
        t(r.prototype, "getAxes", function(a) {
            var b = this.options.colorAxis;
            a.call(this);
            this.colorAxis = [];
            b && new l(this, b);
        });
        t(p.prototype, "getAllItems", function(a) {
            var b = [], d = this.chart.colorAxis[0];
            d && d.options && (d.options.showInLegend && (d.options.dataClasses ? b = b.concat(d.getDataClassLegendSymbols()) : b.push(d)), 
            e(d.series, function(a) {
                a.options.showInLegend = !1;
            }));
            return b.concat(a.call(this));
        });
        t(p.prototype, "colorizeItem", function(a, b, d) {
            a.call(this, b, d);
            d && b.legendColor && b.legendSymbol.attr({
                fill: b.legendColor
            });
        });
    })(n);
    (function(c) {
        var k = c.defined, r = c.each, m = c.noop, l = c.seriesTypes;
        c.colorPointMixin = {
            isValid: function() {
                return null !== this.value;
            },
            setVisible: function(c) {
                var e = this, k = c ? "show" : "hide";
                r([ "graphic", "dataLabel" ], function(c) {
                    if (e[c]) e[c][k]();
                });
            },
            setState: function(e) {
                c.Point.prototype.setState.call(this, e);
                this.graphic && this.graphic.attr({
                    zIndex: "hover" === e ? 1 : 0
                });
            }
        };
        c.colorSeriesMixin = {
            pointArrayMap: [ "value" ],
            axisTypes: [ "xAxis", "yAxis", "colorAxis" ],
            optionalAxis: "colorAxis",
            trackerGroups: [ "group", "markerGroup", "dataLabelsGroup" ],
            getSymbol: m,
            parallelArrays: [ "x", "y", "value" ],
            colorKey: "value",
            pointAttribs: l.column.prototype.pointAttribs,
            translateColors: function() {
                var c = this, k = this.options.nullColor, l = this.colorAxis, m = this.colorKey;
                r(this.data, function(f) {
                    var e = f[m];
                    if (e = f.options.color || (f.isNull ? k : l && void 0 !== e ? l.toColor(e, f) : f.color || c.color)) f.color = e;
                });
            },
            colorAttribs: function(c) {
                var e = {};
                k(c.color) && (e[this.colorProp || "fill"] = c.color);
                return e;
            }
        };
    })(n);
    (function(c) {
        var k = c.colorPointMixin, r = c.each, m = c.merge, l = c.noop, e = c.pick, n = c.Series, w = c.seriesType, p = c.seriesTypes;
        w("heatmap", "scatter", {
            animation: !1,
            borderWidth: 0,
            nullColor: "#f7f7f7",
            dataLabels: {
                formatter: function() {
                    return this.point.value;
                },
                inside: !0,
                verticalAlign: "middle",
                crop: !1,
                overflow: !1,
                padding: 0
            },
            marker: null,
            pointRange: null,
            tooltip: {
                pointFormat: "{point.x}, {point.y}: {point.value}<br/>"
            },
            states: {
                normal: {
                    animation: !0
                },
                hover: {
                    halo: !1,
                    brightness: .2
                }
            }
        }, m(c.colorSeriesMixin, {
            pointArrayMap: [ "y", "value" ],
            hasPointSpecificOptions: !0,
            supportsDrilldown: !0,
            getExtremesFromAll: !0,
            directTouch: !0,
            init: function() {
                var c;
                p.scatter.prototype.init.apply(this, arguments);
                c = this.options;
                c.pointRange = e(c.pointRange, c.colsize || 1);
                this.yAxis.axisPointRange = c.rowsize || 1;
            },
            translate: function() {
                var c = this.options, e = this.xAxis, k = this.yAxis, l = function(c, a, b) {
                    return Math.min(Math.max(a, c), b);
                };
                this.generatePoints();
                r(this.points, function(f) {
                    var a = (c.colsize || 1) / 2, b = (c.rowsize || 1) / 2, d = l(Math.round(e.len - e.translate(f.x - a, 0, 1, 0, 1)), -e.len, 2 * e.len), a = l(Math.round(e.len - e.translate(f.x + a, 0, 1, 0, 1)), -e.len, 2 * e.len), g = l(Math.round(k.translate(f.y - b, 0, 1, 0, 1)), -k.len, 2 * k.len), b = l(Math.round(k.translate(f.y + b, 0, 1, 0, 1)), -k.len, 2 * k.len);
                    f.plotX = f.clientX = (d + a) / 2;
                    f.plotY = (g + b) / 2;
                    f.shapeType = "rect";
                    f.shapeArgs = {
                        x: Math.min(d, a),
                        y: Math.min(g, b),
                        width: Math.abs(a - d),
                        height: Math.abs(b - g)
                    };
                });
                this.translateColors();
            },
            drawPoints: function() {
                p.column.prototype.drawPoints.call(this);
                r(this.points, function(c) {
                    c.graphic.attr(this.colorAttribs(c));
                }, this);
            },
            animate: l,
            getBox: l,
            drawLegendSymbol: c.LegendSymbolMixin.drawRectangle,
            alignDataLabel: p.column.prototype.alignDataLabel,
            getExtremes: function() {
                n.prototype.getExtremes.call(this, this.valueData);
                this.valueMin = this.dataMin;
                this.valueMax = this.dataMax;
                n.prototype.getExtremes.call(this);
            }
        }), k);
    })(n);
});

if (typeof module !== "undefined" && typeof exports !== "undefined" && module.exports === exports) {
    module.exports = "highcharts-ng";
}

(function() {
    "use strict";
    angular.module("highcharts-ng", []).provider("highchartsNG", highchartsNGProvider).directive("highchart", [ "highchartsNG", "$timeout", highchart ]);
    function highchartsNGProvider() {
        var modules = [];
        var basePath = false;
        var lazyLoad = false;
        return {
            HIGHCHART: "highcharts.js",
            HIGHSTOCK: "stock/highstock.js",
            basePath: function(p) {
                basePath = p;
            },
            lazyLoad: function(list) {
                if (list === undefined) {
                    modules = [ this.HIGHCHART ];
                } else {
                    modules = list;
                }
                lazyLoad = true;
            },
            $get: [ "$window", "$rootScope", function($window, $rootScope) {
                if (!basePath) {
                    basePath = (window.location.protocol === "https:" ? "https" : "http") + "://code.highcharts.com/";
                }
                return highchartsNG($window, $rootScope, lazyLoad, basePath, modules);
            } ]
        };
    }
    function highchartsNG($window, $rootScope, lazyload, basePath, modules) {
        var readyQueue = [];
        var loading = false;
        return {
            lazyLoad: lazyload,
            ready: function(callback, thisArg) {
                if (typeof $window.Highcharts !== "undefined" || !lazyload) {
                    callback();
                } else {
                    readyQueue.push([ callback, thisArg ]);
                    if (loading) {
                        return;
                    }
                    loading = true;
                    var self = this;
                    if (typeof jQuery === "undefined") {
                        modules.unshift("adapters/standalone-framework.js");
                    }
                    var doWork = function() {
                        if (modules.length === 0) {
                            loading = false;
                            $rootScope.$apply(function() {
                                angular.forEach(readyQueue, function(e) {
                                    e[0].apply(e[1], []);
                                });
                            });
                        } else {
                            var s = modules.shift();
                            self.loadScript(s, doWork);
                        }
                    };
                    doWork();
                }
            },
            loadScript: function(path, callback) {
                var s = document.createElement("script");
                s.type = "text/javascript";
                s.src = basePath + path;
                s.onload = callback;
                document.getElementsByTagName("body")[0].appendChild(s);
            },
            indexOf: function(arr, find, i) {
                if (i === undefined) i = 0;
                if (i < 0) i += arr.length;
                if (i < 0) i = 0;
                for (var n = arr.length; i < n; i++) if (i in arr && arr[i] === find) return i;
                return -1;
            },
            prependMethod: function(obj, method, func) {
                var original = obj[method];
                obj[method] = function() {
                    var args = Array.prototype.slice.call(arguments);
                    func.apply(this, args);
                    if (original) {
                        return original.apply(this, args);
                    } else {
                        return;
                    }
                };
            },
            deepExtend: function deepExtend(destination, source) {
                if (angular.isArray(source)) {
                    destination = angular.isArray(destination) ? destination : [];
                    for (var i = 0; i < source.length; i++) {
                        destination[i] = deepExtend(destination[i] || {}, source[i]);
                    }
                } else if (angular.isObject(source)) {
                    destination = angular.isObject(destination) ? destination : {};
                    for (var property in source) {
                        destination[property] = deepExtend(destination[property] || {}, source[property]);
                    }
                } else {
                    destination = source;
                }
                return destination;
            }
        };
    }
    function highchart(highchartsNGUtils, $timeout) {
        var seriesId = 0;
        var ensureIds = function(series) {
            var changed = false;
            angular.forEach(series, function(s) {
                if (!angular.isDefined(s.id)) {
                    s.id = "series-" + seriesId++;
                    changed = true;
                }
            });
            return changed;
        };
        var axisNames = [ "xAxis", "yAxis" ];
        var chartTypeMap = {
            stock: "StockChart",
            map: "Map",
            chart: "Chart"
        };
        var getMergedOptions = function(scope, element, config) {
            var mergedOptions = {};
            var defaultOptions = {
                chart: {
                    events: {}
                },
                title: {},
                subtitle: {},
                series: [],
                plotOptions: {},
                navigator: {
                    enabled: false
                },
                xAxis: {
                    events: {}
                },
                credits: {
                    enabled: false
                },
                exporting: {
                    enabled: false
                }
            };
            if (config.options) {
                mergedOptions = highchartsNGUtils.deepExtend(defaultOptions, config.options);
            } else {
                mergedOptions = defaultOptions;
            }
            mergedOptions.chart.renderTo = element[0];
            angular.forEach(axisNames, function(axisName) {
                if (angular.isDefined(config[axisName])) {
                    mergedOptions[axisName] = highchartsNGUtils.deepExtend(mergedOptions[axisName] || {}, config[axisName]);
                    if (angular.isDefined(config[axisName].currentMin) || angular.isDefined(config[axisName].currentMax)) {
                        highchartsNGUtils.prependMethod(mergedOptions.chart.events, "selection", function(e) {
                            var thisChart = this;
                            if (e[axisName]) {
                                scope.$apply(function() {
                                    scope.config[axisName].currentMin = e[axisName][0].min;
                                    scope.config[axisName].currentMax = e[axisName][0].max;
                                });
                            } else {
                                scope.$apply(function() {
                                    scope.config[axisName].currentMin = thisChart[axisName][0].dataMin;
                                    scope.config[axisName].currentMax = thisChart[axisName][0].dataMax;
                                });
                            }
                        });
                        highchartsNGUtils.prependMethod(mergedOptions.chart.events, "addSeries", function(e) {
                            scope.config[axisName].currentMin = this[axisName][0].min || scope.config[axisName].currentMin;
                            scope.config[axisName].currentMax = this[axisName][0].max || scope.config[axisName].currentMax;
                        });
                        highchartsNGUtils.prependMethod(mergedOptions[axisName].events, "setExtremes", function(e) {
                            if (e.trigger && e.trigger !== "zoom") {
                                $timeout(function() {
                                    scope.config[axisName].currentMin = e.min;
                                    scope.config[axisName].currentMax = e.max;
                                    scope.config[axisName].min = e.min;
                                    scope.config[axisName].max = e.max;
                                }, 0);
                            }
                        });
                    }
                }
            });
            if (config.title) {
                mergedOptions.title = config.title;
            }
            if (config.subtitle) {
                mergedOptions.subtitle = config.subtitle;
            }
            if (config.credits) {
                mergedOptions.credits = config.credits;
            }
            if (config.size) {
                if (config.size.width) {
                    mergedOptions.chart.width = config.size.width;
                }
                if (config.size.height) {
                    mergedOptions.chart.height = config.size.height;
                }
            }
            return mergedOptions;
        };
        var updateZoom = function(axis, modelAxis) {
            var extremes = axis.getExtremes();
            if (modelAxis.currentMin !== extremes.dataMin || modelAxis.currentMax !== extremes.dataMax) {
                if (axis.setExtremes) {
                    axis.setExtremes(modelAxis.currentMin, modelAxis.currentMax, false);
                } else {
                    axis.detachedsetExtremes(modelAxis.currentMin, modelAxis.currentMax, false);
                }
            }
        };
        var processExtremes = function(chart, axis, axisName) {
            if (axis.currentMin || axis.currentMax) {
                chart[axisName][0].setExtremes(axis.currentMin, axis.currentMax, true);
            }
        };
        var chartOptionsWithoutEasyOptions = function(options) {
            return angular.extend(highchartsNGUtils.deepExtend({}, options), {
                data: null,
                visible: null
            });
        };
        var getChartType = function(scope) {
            if (scope.config === undefined) return "Chart";
            return chartTypeMap[("" + scope.config.chartType).toLowerCase()] || (scope.config.useHighStocks ? "StockChart" : "Chart");
        };
        var res = {
            restrict: "EAC",
            replace: true,
            template: "<div></div>",
            scope: {
                config: "=",
                disableDataWatch: "="
            },
            link: function(scope, element, attrs) {
                var prevSeriesOptions = {};
                var processSeries = function(series) {
                    var i;
                    var ids = [];
                    if (series) {
                        var setIds = ensureIds(series);
                        if (setIds && !scope.disableDataWatch) {
                            return false;
                        }
                        angular.forEach(series, function(s) {
                            ids.push(s.id);
                            var chartSeries = chart.get(s.id);
                            if (chartSeries) {
                                if (!angular.equals(prevSeriesOptions[s.id], chartOptionsWithoutEasyOptions(s))) {
                                    chartSeries.update(angular.copy(s), false);
                                } else {
                                    if (s.visible !== undefined && chartSeries.visible !== s.visible) {
                                        chartSeries.setVisible(s.visible, false);
                                    }
                                    chartSeries.setData(angular.copy(s.data), false);
                                }
                            } else {
                                chart.addSeries(angular.copy(s), false);
                            }
                            prevSeriesOptions[s.id] = chartOptionsWithoutEasyOptions(s);
                        });
                        if (scope.config.noData) {
                            var chartContainsData = false;
                            for (i = 0; i < series.length; i++) {
                                if (series[i].data && series[i].data.length > 0) {
                                    chartContainsData = true;
                                    break;
                                }
                            }
                            if (!chartContainsData) {
                                chart.showLoading(scope.config.noData);
                            } else {
                                chart.hideLoading();
                            }
                        }
                    }
                    for (i = chart.series.length - 1; i >= 0; i--) {
                        var s = chart.series[i];
                        if (s.options.id !== "highcharts-navigator-series" && highchartsNGUtils.indexOf(ids, s.options.id) < 0) {
                            s.remove(false);
                        }
                    }
                    return true;
                };
                var chart = false;
                var initChart = function() {
                    if (chart) chart.destroy();
                    prevSeriesOptions = {};
                    var config = scope.config || {};
                    var mergedOptions = getMergedOptions(scope, element, config);
                    var func = config.func || undefined;
                    var chartType = getChartType(scope);
                    chart = new Highcharts[chartType](mergedOptions, func);
                    for (var i = 0; i < axisNames.length; i++) {
                        if (config[axisNames[i]]) {
                            processExtremes(chart, config[axisNames[i]], axisNames[i]);
                        }
                    }
                    if (config.loading) {
                        chart.showLoading();
                    }
                    config.getHighcharts = function() {
                        return chart;
                    };
                };
                initChart();
                if (scope.disableDataWatch) {
                    scope.$watchCollection("config.series", function(newSeries, oldSeries) {
                        processSeries(newSeries);
                        chart.redraw();
                    });
                } else {
                    scope.$watch("config.series", function(newSeries, oldSeries) {
                        var needsRedraw = processSeries(newSeries);
                        if (needsRedraw) {
                            chart.redraw();
                        }
                    }, true);
                }
                scope.$watch("config.title", function(newTitle) {
                    chart.setTitle(newTitle, true);
                }, true);
                scope.$watch("config.subtitle", function(newSubtitle) {
                    chart.setTitle(true, newSubtitle);
                }, true);
                scope.$watch("config.loading", function(loading) {
                    if (loading) {
                        chart.showLoading(loading === true ? null : loading);
                    } else {
                        chart.hideLoading();
                    }
                });
                scope.$watch("config.noData", function(noData) {
                    if (scope.config && scope.config.loading) {
                        chart.showLoading(noData);
                    }
                }, true);
                scope.$watch("config.credits.enabled", function(enabled) {
                    if (enabled) {
                        chart.credits.show();
                    } else if (chart.credits) {
                        chart.credits.hide();
                    }
                });
                scope.$watch(getChartType, function(chartType, oldChartType) {
                    if (chartType === oldChartType) return;
                    initChart();
                });
                angular.forEach(axisNames, function(axisName) {
                    scope.$watch("config." + axisName, function(newAxes, oldAxes) {
                        if (newAxes === oldAxes || !newAxes) {
                            return;
                        }
                        if (angular.isArray(newAxes)) {
                            for (var axisIndex = 0; axisIndex < newAxes.length; axisIndex++) {
                                var axis = newAxes[axisIndex];
                                if (axisIndex < chart[axisName].length) {
                                    chart[axisName][axisIndex].update(axis, false);
                                    updateZoom(chart[axisName][axisIndex], angular.copy(axis));
                                }
                            }
                        } else {
                            chart[axisName][0].update(newAxes, false);
                            updateZoom(chart[axisName][0], angular.copy(newAxes));
                        }
                        chart.redraw();
                    }, true);
                });
                scope.$watch("config.options", function(newOptions, oldOptions, scope) {
                    if (newOptions === oldOptions) return;
                    initChart();
                    processSeries(scope.config.series);
                    chart.redraw();
                }, true);
                scope.$watch("config.size", function(newSize, oldSize) {
                    if (newSize === oldSize) return;
                    if (newSize) {
                        chart.setSize(newSize.width || chart.chartWidth, newSize.height || chart.chartHeight);
                    }
                }, true);
                scope.$on("highchartsng.reflow", function() {
                    chart.reflow();
                });
                scope.$on("$destroy", function() {
                    if (chart) {
                        try {
                            chart.destroy();
                        } catch (ex) {}
                        $timeout(function() {
                            element.remove();
                        }, 0);
                    }
                });
            }
        };
        if (highchartsNGUtils.lazyLoad) {
            var oldLink = res.link;
            res.link = function() {
                var args = arguments;
                highchartsNGUtils.ready(function() {
                    oldLink.apply(this, args);
                }, this);
            };
        }
        return res;
    }
})();

(function(global, factory) {
    typeof exports === "object" && typeof module !== "undefined" ? module.exports = factory() : typeof define === "function" && define.amd ? define(factory) : global.moment = factory();
})(this, function() {
    "use strict";
    var hookCallback;
    function utils_hooks__hooks() {
        return hookCallback.apply(null, arguments);
    }
    function setHookCallback(callback) {
        hookCallback = callback;
    }
    function isArray(input) {
        return Object.prototype.toString.call(input) === "[object Array]";
    }
    function isDate(input) {
        return input instanceof Date || Object.prototype.toString.call(input) === "[object Date]";
    }
    function map(arr, fn) {
        var res = [], i;
        for (i = 0; i < arr.length; ++i) {
            res.push(fn(arr[i], i));
        }
        return res;
    }
    function hasOwnProp(a, b) {
        return Object.prototype.hasOwnProperty.call(a, b);
    }
    function extend(a, b) {
        for (var i in b) {
            if (hasOwnProp(b, i)) {
                a[i] = b[i];
            }
        }
        if (hasOwnProp(b, "toString")) {
            a.toString = b.toString;
        }
        if (hasOwnProp(b, "valueOf")) {
            a.valueOf = b.valueOf;
        }
        return a;
    }
    function create_utc__createUTC(input, format, locale, strict) {
        return createLocalOrUTC(input, format, locale, strict, true).utc();
    }
    function defaultParsingFlags() {
        return {
            empty: false,
            unusedTokens: [],
            unusedInput: [],
            overflow: -2,
            charsLeftOver: 0,
            nullInput: false,
            invalidMonth: null,
            invalidFormat: false,
            userInvalidated: false,
            iso: false
        };
    }
    function getParsingFlags(m) {
        if (m._pf == null) {
            m._pf = defaultParsingFlags();
        }
        return m._pf;
    }
    function valid__isValid(m) {
        if (m._isValid == null) {
            var flags = getParsingFlags(m);
            m._isValid = !isNaN(m._d.getTime()) && flags.overflow < 0 && !flags.empty && !flags.invalidMonth && !flags.invalidWeekday && !flags.nullInput && !flags.invalidFormat && !flags.userInvalidated;
            if (m._strict) {
                m._isValid = m._isValid && flags.charsLeftOver === 0 && flags.unusedTokens.length === 0 && flags.bigHour === undefined;
            }
        }
        return m._isValid;
    }
    function valid__createInvalid(flags) {
        var m = create_utc__createUTC(NaN);
        if (flags != null) {
            extend(getParsingFlags(m), flags);
        } else {
            getParsingFlags(m).userInvalidated = true;
        }
        return m;
    }
    var momentProperties = utils_hooks__hooks.momentProperties = [];
    function copyConfig(to, from) {
        var i, prop, val;
        if (typeof from._isAMomentObject !== "undefined") {
            to._isAMomentObject = from._isAMomentObject;
        }
        if (typeof from._i !== "undefined") {
            to._i = from._i;
        }
        if (typeof from._f !== "undefined") {
            to._f = from._f;
        }
        if (typeof from._l !== "undefined") {
            to._l = from._l;
        }
        if (typeof from._strict !== "undefined") {
            to._strict = from._strict;
        }
        if (typeof from._tzm !== "undefined") {
            to._tzm = from._tzm;
        }
        if (typeof from._isUTC !== "undefined") {
            to._isUTC = from._isUTC;
        }
        if (typeof from._offset !== "undefined") {
            to._offset = from._offset;
        }
        if (typeof from._pf !== "undefined") {
            to._pf = getParsingFlags(from);
        }
        if (typeof from._locale !== "undefined") {
            to._locale = from._locale;
        }
        if (momentProperties.length > 0) {
            for (i in momentProperties) {
                prop = momentProperties[i];
                val = from[prop];
                if (typeof val !== "undefined") {
                    to[prop] = val;
                }
            }
        }
        return to;
    }
    var updateInProgress = false;
    function Moment(config) {
        copyConfig(this, config);
        this._d = new Date(config._d != null ? config._d.getTime() : NaN);
        if (updateInProgress === false) {
            updateInProgress = true;
            utils_hooks__hooks.updateOffset(this);
            updateInProgress = false;
        }
    }
    function isMoment(obj) {
        return obj instanceof Moment || obj != null && obj._isAMomentObject != null;
    }
    function absFloor(number) {
        if (number < 0) {
            return Math.ceil(number);
        } else {
            return Math.floor(number);
        }
    }
    function toInt(argumentForCoercion) {
        var coercedNumber = +argumentForCoercion, value = 0;
        if (coercedNumber !== 0 && isFinite(coercedNumber)) {
            value = absFloor(coercedNumber);
        }
        return value;
    }
    function compareArrays(array1, array2, dontConvert) {
        var len = Math.min(array1.length, array2.length), lengthDiff = Math.abs(array1.length - array2.length), diffs = 0, i;
        for (i = 0; i < len; i++) {
            if (dontConvert && array1[i] !== array2[i] || !dontConvert && toInt(array1[i]) !== toInt(array2[i])) {
                diffs++;
            }
        }
        return diffs + lengthDiff;
    }
    function Locale() {}
    var locales = {};
    var globalLocale;
    function normalizeLocale(key) {
        return key ? key.toLowerCase().replace("_", "-") : key;
    }
    function chooseLocale(names) {
        var i = 0, j, next, locale, split;
        while (i < names.length) {
            split = normalizeLocale(names[i]).split("-");
            j = split.length;
            next = normalizeLocale(names[i + 1]);
            next = next ? next.split("-") : null;
            while (j > 0) {
                locale = loadLocale(split.slice(0, j).join("-"));
                if (locale) {
                    return locale;
                }
                if (next && next.length >= j && compareArrays(split, next, true) >= j - 1) {
                    break;
                }
                j--;
            }
            i++;
        }
        return null;
    }
    function loadLocale(name) {
        var oldLocale = null;
        if (!locales[name] && typeof module !== "undefined" && module && module.exports) {
            try {
                oldLocale = globalLocale._abbr;
                require("./locale/" + name);
                locale_locales__getSetGlobalLocale(oldLocale);
            } catch (e) {}
        }
        return locales[name];
    }
    function locale_locales__getSetGlobalLocale(key, values) {
        var data;
        if (key) {
            if (typeof values === "undefined") {
                data = locale_locales__getLocale(key);
            } else {
                data = defineLocale(key, values);
            }
            if (data) {
                globalLocale = data;
            }
        }
        return globalLocale._abbr;
    }
    function defineLocale(name, values) {
        if (values !== null) {
            values.abbr = name;
            locales[name] = locales[name] || new Locale();
            locales[name].set(values);
            locale_locales__getSetGlobalLocale(name);
            return locales[name];
        } else {
            delete locales[name];
            return null;
        }
    }
    function locale_locales__getLocale(key) {
        var locale;
        if (key && key._locale && key._locale._abbr) {
            key = key._locale._abbr;
        }
        if (!key) {
            return globalLocale;
        }
        if (!isArray(key)) {
            locale = loadLocale(key);
            if (locale) {
                return locale;
            }
            key = [ key ];
        }
        return chooseLocale(key);
    }
    var aliases = {};
    function addUnitAlias(unit, shorthand) {
        var lowerCase = unit.toLowerCase();
        aliases[lowerCase] = aliases[lowerCase + "s"] = aliases[shorthand] = unit;
    }
    function normalizeUnits(units) {
        return typeof units === "string" ? aliases[units] || aliases[units.toLowerCase()] : undefined;
    }
    function normalizeObjectUnits(inputObject) {
        var normalizedInput = {}, normalizedProp, prop;
        for (prop in inputObject) {
            if (hasOwnProp(inputObject, prop)) {
                normalizedProp = normalizeUnits(prop);
                if (normalizedProp) {
                    normalizedInput[normalizedProp] = inputObject[prop];
                }
            }
        }
        return normalizedInput;
    }
    function makeGetSet(unit, keepTime) {
        return function(value) {
            if (value != null) {
                get_set__set(this, unit, value);
                utils_hooks__hooks.updateOffset(this, keepTime);
                return this;
            } else {
                return get_set__get(this, unit);
            }
        };
    }
    function get_set__get(mom, unit) {
        return mom._d["get" + (mom._isUTC ? "UTC" : "") + unit]();
    }
    function get_set__set(mom, unit, value) {
        return mom._d["set" + (mom._isUTC ? "UTC" : "") + unit](value);
    }
    function getSet(units, value) {
        var unit;
        if (typeof units === "object") {
            for (unit in units) {
                this.set(unit, units[unit]);
            }
        } else {
            units = normalizeUnits(units);
            if (typeof this[units] === "function") {
                return this[units](value);
            }
        }
        return this;
    }
    function zeroFill(number, targetLength, forceSign) {
        var absNumber = "" + Math.abs(number), zerosToFill = targetLength - absNumber.length, sign = number >= 0;
        return (sign ? forceSign ? "+" : "" : "-") + Math.pow(10, Math.max(0, zerosToFill)).toString().substr(1) + absNumber;
    }
    var formattingTokens = /(\[[^\[]*\])|(\\)?(Mo|MM?M?M?|Do|DDDo|DD?D?D?|ddd?d?|do?|w[o|w]?|W[o|W]?|Q|YYYYYY|YYYYY|YYYY|YY|gg(ggg?)?|GG(GGG?)?|e|E|a|A|hh?|HH?|mm?|ss?|S{1,9}|x|X|zz?|ZZ?|.)/g;
    var localFormattingTokens = /(\[[^\[]*\])|(\\)?(LTS|LT|LL?L?L?|l{1,4})/g;
    var formatFunctions = {};
    var formatTokenFunctions = {};
    function addFormatToken(token, padded, ordinal, callback) {
        var func = callback;
        if (typeof callback === "string") {
            func = function() {
                return this[callback]();
            };
        }
        if (token) {
            formatTokenFunctions[token] = func;
        }
        if (padded) {
            formatTokenFunctions[padded[0]] = function() {
                return zeroFill(func.apply(this, arguments), padded[1], padded[2]);
            };
        }
        if (ordinal) {
            formatTokenFunctions[ordinal] = function() {
                return this.localeData().ordinal(func.apply(this, arguments), token);
            };
        }
    }
    function removeFormattingTokens(input) {
        if (input.match(/\[[\s\S]/)) {
            return input.replace(/^\[|\]$/g, "");
        }
        return input.replace(/\\/g, "");
    }
    function makeFormatFunction(format) {
        var array = format.match(formattingTokens), i, length;
        for (i = 0, length = array.length; i < length; i++) {
            if (formatTokenFunctions[array[i]]) {
                array[i] = formatTokenFunctions[array[i]];
            } else {
                array[i] = removeFormattingTokens(array[i]);
            }
        }
        return function(mom) {
            var output = "";
            for (i = 0; i < length; i++) {
                output += array[i] instanceof Function ? array[i].call(mom, format) : array[i];
            }
            return output;
        };
    }
    function formatMoment(m, format) {
        if (!m.isValid()) {
            return m.localeData().invalidDate();
        }
        format = expandFormat(format, m.localeData());
        formatFunctions[format] = formatFunctions[format] || makeFormatFunction(format);
        return formatFunctions[format](m);
    }
    function expandFormat(format, locale) {
        var i = 5;
        function replaceLongDateFormatTokens(input) {
            return locale.longDateFormat(input) || input;
        }
        localFormattingTokens.lastIndex = 0;
        while (i >= 0 && localFormattingTokens.test(format)) {
            format = format.replace(localFormattingTokens, replaceLongDateFormatTokens);
            localFormattingTokens.lastIndex = 0;
            i -= 1;
        }
        return format;
    }
    var match1 = /\d/;
    var match2 = /\d\d/;
    var match3 = /\d{3}/;
    var match4 = /\d{4}/;
    var match6 = /[+-]?\d{6}/;
    var match1to2 = /\d\d?/;
    var match1to3 = /\d{1,3}/;
    var match1to4 = /\d{1,4}/;
    var match1to6 = /[+-]?\d{1,6}/;
    var matchUnsigned = /\d+/;
    var matchSigned = /[+-]?\d+/;
    var matchOffset = /Z|[+-]\d\d:?\d\d/gi;
    var matchTimestamp = /[+-]?\d+(\.\d{1,3})?/;
    var matchWord = /[0-9]*['a-z\u00A0-\u05FF\u0700-\uD7FF\uF900-\uFDCF\uFDF0-\uFFEF]+|[\u0600-\u06FF\/]+(\s*?[\u0600-\u06FF]+){1,2}/i;
    var regexes = {};
    function isFunction(sth) {
        return typeof sth === "function" && Object.prototype.toString.call(sth) === "[object Function]";
    }
    function addRegexToken(token, regex, strictRegex) {
        regexes[token] = isFunction(regex) ? regex : function(isStrict) {
            return isStrict && strictRegex ? strictRegex : regex;
        };
    }
    function getParseRegexForToken(token, config) {
        if (!hasOwnProp(regexes, token)) {
            return new RegExp(unescapeFormat(token));
        }
        return regexes[token](config._strict, config._locale);
    }
    function unescapeFormat(s) {
        return s.replace("\\", "").replace(/\\(\[)|\\(\])|\[([^\]\[]*)\]|\\(.)/g, function(matched, p1, p2, p3, p4) {
            return p1 || p2 || p3 || p4;
        }).replace(/[-\/\\^$*+?.()|[\]{}]/g, "\\$&");
    }
    var tokens = {};
    function addParseToken(token, callback) {
        var i, func = callback;
        if (typeof token === "string") {
            token = [ token ];
        }
        if (typeof callback === "number") {
            func = function(input, array) {
                array[callback] = toInt(input);
            };
        }
        for (i = 0; i < token.length; i++) {
            tokens[token[i]] = func;
        }
    }
    function addWeekParseToken(token, callback) {
        addParseToken(token, function(input, array, config, token) {
            config._w = config._w || {};
            callback(input, config._w, config, token);
        });
    }
    function addTimeToArrayFromToken(token, input, config) {
        if (input != null && hasOwnProp(tokens, token)) {
            tokens[token](input, config._a, config, token);
        }
    }
    var YEAR = 0;
    var MONTH = 1;
    var DATE = 2;
    var HOUR = 3;
    var MINUTE = 4;
    var SECOND = 5;
    var MILLISECOND = 6;
    function daysInMonth(year, month) {
        return new Date(Date.UTC(year, month + 1, 0)).getUTCDate();
    }
    addFormatToken("M", [ "MM", 2 ], "Mo", function() {
        return this.month() + 1;
    });
    addFormatToken("MMM", 0, 0, function(format) {
        return this.localeData().monthsShort(this, format);
    });
    addFormatToken("MMMM", 0, 0, function(format) {
        return this.localeData().months(this, format);
    });
    addUnitAlias("month", "M");
    addRegexToken("M", match1to2);
    addRegexToken("MM", match1to2, match2);
    addRegexToken("MMM", matchWord);
    addRegexToken("MMMM", matchWord);
    addParseToken([ "M", "MM" ], function(input, array) {
        array[MONTH] = toInt(input) - 1;
    });
    addParseToken([ "MMM", "MMMM" ], function(input, array, config, token) {
        var month = config._locale.monthsParse(input, token, config._strict);
        if (month != null) {
            array[MONTH] = month;
        } else {
            getParsingFlags(config).invalidMonth = input;
        }
    });
    var defaultLocaleMonths = "January_February_March_April_May_June_July_August_September_October_November_December".split("_");
    function localeMonths(m) {
        return this._months[m.month()];
    }
    var defaultLocaleMonthsShort = "Jan_Feb_Mar_Apr_May_Jun_Jul_Aug_Sep_Oct_Nov_Dec".split("_");
    function localeMonthsShort(m) {
        return this._monthsShort[m.month()];
    }
    function localeMonthsParse(monthName, format, strict) {
        var i, mom, regex;
        if (!this._monthsParse) {
            this._monthsParse = [];
            this._longMonthsParse = [];
            this._shortMonthsParse = [];
        }
        for (i = 0; i < 12; i++) {
            mom = create_utc__createUTC([ 2e3, i ]);
            if (strict && !this._longMonthsParse[i]) {
                this._longMonthsParse[i] = new RegExp("^" + this.months(mom, "").replace(".", "") + "$", "i");
                this._shortMonthsParse[i] = new RegExp("^" + this.monthsShort(mom, "").replace(".", "") + "$", "i");
            }
            if (!strict && !this._monthsParse[i]) {
                regex = "^" + this.months(mom, "") + "|^" + this.monthsShort(mom, "");
                this._monthsParse[i] = new RegExp(regex.replace(".", ""), "i");
            }
            if (strict && format === "MMMM" && this._longMonthsParse[i].test(monthName)) {
                return i;
            } else if (strict && format === "MMM" && this._shortMonthsParse[i].test(monthName)) {
                return i;
            } else if (!strict && this._monthsParse[i].test(monthName)) {
                return i;
            }
        }
    }
    function setMonth(mom, value) {
        var dayOfMonth;
        if (typeof value === "string") {
            value = mom.localeData().monthsParse(value);
            if (typeof value !== "number") {
                return mom;
            }
        }
        dayOfMonth = Math.min(mom.date(), daysInMonth(mom.year(), value));
        mom._d["set" + (mom._isUTC ? "UTC" : "") + "Month"](value, dayOfMonth);
        return mom;
    }
    function getSetMonth(value) {
        if (value != null) {
            setMonth(this, value);
            utils_hooks__hooks.updateOffset(this, true);
            return this;
        } else {
            return get_set__get(this, "Month");
        }
    }
    function getDaysInMonth() {
        return daysInMonth(this.year(), this.month());
    }
    function checkOverflow(m) {
        var overflow;
        var a = m._a;
        if (a && getParsingFlags(m).overflow === -2) {
            overflow = a[MONTH] < 0 || a[MONTH] > 11 ? MONTH : a[DATE] < 1 || a[DATE] > daysInMonth(a[YEAR], a[MONTH]) ? DATE : a[HOUR] < 0 || a[HOUR] > 24 || a[HOUR] === 24 && (a[MINUTE] !== 0 || a[SECOND] !== 0 || a[MILLISECOND] !== 0) ? HOUR : a[MINUTE] < 0 || a[MINUTE] > 59 ? MINUTE : a[SECOND] < 0 || a[SECOND] > 59 ? SECOND : a[MILLISECOND] < 0 || a[MILLISECOND] > 999 ? MILLISECOND : -1;
            if (getParsingFlags(m)._overflowDayOfYear && (overflow < YEAR || overflow > DATE)) {
                overflow = DATE;
            }
            getParsingFlags(m).overflow = overflow;
        }
        return m;
    }
    function warn(msg) {
        if (utils_hooks__hooks.suppressDeprecationWarnings === false && typeof console !== "undefined" && console.warn) {
            console.warn("Deprecation warning: " + msg);
        }
    }
    function deprecate(msg, fn) {
        var firstTime = true;
        return extend(function() {
            if (firstTime) {
                warn(msg + "\n" + new Error().stack);
                firstTime = false;
            }
            return fn.apply(this, arguments);
        }, fn);
    }
    var deprecations = {};
    function deprecateSimple(name, msg) {
        if (!deprecations[name]) {
            warn(msg);
            deprecations[name] = true;
        }
    }
    utils_hooks__hooks.suppressDeprecationWarnings = false;
    var from_string__isoRegex = /^\s*(?:[+-]\d{6}|\d{4})-(?:(\d\d-\d\d)|(W\d\d$)|(W\d\d-\d)|(\d\d\d))((T| )(\d\d(:\d\d(:\d\d(\.\d+)?)?)?)?([\+\-]\d\d(?::?\d\d)?|\s*Z)?)?$/;
    var isoDates = [ [ "YYYYYY-MM-DD", /[+-]\d{6}-\d{2}-\d{2}/ ], [ "YYYY-MM-DD", /\d{4}-\d{2}-\d{2}/ ], [ "GGGG-[W]WW-E", /\d{4}-W\d{2}-\d/ ], [ "GGGG-[W]WW", /\d{4}-W\d{2}/ ], [ "YYYY-DDD", /\d{4}-\d{3}/ ] ];
    var isoTimes = [ [ "HH:mm:ss.SSSS", /(T| )\d\d:\d\d:\d\d\.\d+/ ], [ "HH:mm:ss", /(T| )\d\d:\d\d:\d\d/ ], [ "HH:mm", /(T| )\d\d:\d\d/ ], [ "HH", /(T| )\d\d/ ] ];
    var aspNetJsonRegex = /^\/?Date\((\-?\d+)/i;
    function configFromISO(config) {
        var i, l, string = config._i, match = from_string__isoRegex.exec(string);
        if (match) {
            getParsingFlags(config).iso = true;
            for (i = 0, l = isoDates.length; i < l; i++) {
                if (isoDates[i][1].exec(string)) {
                    config._f = isoDates[i][0];
                    break;
                }
            }
            for (i = 0, l = isoTimes.length; i < l; i++) {
                if (isoTimes[i][1].exec(string)) {
                    config._f += (match[6] || " ") + isoTimes[i][0];
                    break;
                }
            }
            if (string.match(matchOffset)) {
                config._f += "Z";
            }
            configFromStringAndFormat(config);
        } else {
            config._isValid = false;
        }
    }
    function configFromString(config) {
        var matched = aspNetJsonRegex.exec(config._i);
        if (matched !== null) {
            config._d = new Date((+matched[1]));
            return;
        }
        configFromISO(config);
        if (config._isValid === false) {
            delete config._isValid;
            utils_hooks__hooks.createFromInputFallback(config);
        }
    }
    utils_hooks__hooks.createFromInputFallback = deprecate("moment construction falls back to js Date. This is " + "discouraged and will be removed in upcoming major " + "release. Please refer to " + "https://github.com/moment/moment/issues/1407 for more info.", function(config) {
        config._d = new Date(config._i + (config._useUTC ? " UTC" : ""));
    });
    function createDate(y, m, d, h, M, s, ms) {
        var date = new Date(y, m, d, h, M, s, ms);
        if (y < 1970) {
            date.setFullYear(y);
        }
        return date;
    }
    function createUTCDate(y) {
        var date = new Date(Date.UTC.apply(null, arguments));
        if (y < 1970) {
            date.setUTCFullYear(y);
        }
        return date;
    }
    addFormatToken(0, [ "YY", 2 ], 0, function() {
        return this.year() % 100;
    });
    addFormatToken(0, [ "YYYY", 4 ], 0, "year");
    addFormatToken(0, [ "YYYYY", 5 ], 0, "year");
    addFormatToken(0, [ "YYYYYY", 6, true ], 0, "year");
    addUnitAlias("year", "y");
    addRegexToken("Y", matchSigned);
    addRegexToken("YY", match1to2, match2);
    addRegexToken("YYYY", match1to4, match4);
    addRegexToken("YYYYY", match1to6, match6);
    addRegexToken("YYYYYY", match1to6, match6);
    addParseToken([ "YYYYY", "YYYYYY" ], YEAR);
    addParseToken("YYYY", function(input, array) {
        array[YEAR] = input.length === 2 ? utils_hooks__hooks.parseTwoDigitYear(input) : toInt(input);
    });
    addParseToken("YY", function(input, array) {
        array[YEAR] = utils_hooks__hooks.parseTwoDigitYear(input);
    });
    function daysInYear(year) {
        return isLeapYear(year) ? 366 : 365;
    }
    function isLeapYear(year) {
        return year % 4 === 0 && year % 100 !== 0 || year % 400 === 0;
    }
    utils_hooks__hooks.parseTwoDigitYear = function(input) {
        return toInt(input) + (toInt(input) > 68 ? 1900 : 2e3);
    };
    var getSetYear = makeGetSet("FullYear", false);
    function getIsLeapYear() {
        return isLeapYear(this.year());
    }
    addFormatToken("w", [ "ww", 2 ], "wo", "week");
    addFormatToken("W", [ "WW", 2 ], "Wo", "isoWeek");
    addUnitAlias("week", "w");
    addUnitAlias("isoWeek", "W");
    addRegexToken("w", match1to2);
    addRegexToken("ww", match1to2, match2);
    addRegexToken("W", match1to2);
    addRegexToken("WW", match1to2, match2);
    addWeekParseToken([ "w", "ww", "W", "WW" ], function(input, week, config, token) {
        week[token.substr(0, 1)] = toInt(input);
    });
    function weekOfYear(mom, firstDayOfWeek, firstDayOfWeekOfYear) {
        var end = firstDayOfWeekOfYear - firstDayOfWeek, daysToDayOfWeek = firstDayOfWeekOfYear - mom.day(), adjustedMoment;
        if (daysToDayOfWeek > end) {
            daysToDayOfWeek -= 7;
        }
        if (daysToDayOfWeek < end - 7) {
            daysToDayOfWeek += 7;
        }
        adjustedMoment = local__createLocal(mom).add(daysToDayOfWeek, "d");
        return {
            week: Math.ceil(adjustedMoment.dayOfYear() / 7),
            year: adjustedMoment.year()
        };
    }
    function localeWeek(mom) {
        return weekOfYear(mom, this._week.dow, this._week.doy).week;
    }
    var defaultLocaleWeek = {
        dow: 0,
        doy: 6
    };
    function localeFirstDayOfWeek() {
        return this._week.dow;
    }
    function localeFirstDayOfYear() {
        return this._week.doy;
    }
    function getSetWeek(input) {
        var week = this.localeData().week(this);
        return input == null ? week : this.add((input - week) * 7, "d");
    }
    function getSetISOWeek(input) {
        var week = weekOfYear(this, 1, 4).week;
        return input == null ? week : this.add((input - week) * 7, "d");
    }
    addFormatToken("DDD", [ "DDDD", 3 ], "DDDo", "dayOfYear");
    addUnitAlias("dayOfYear", "DDD");
    addRegexToken("DDD", match1to3);
    addRegexToken("DDDD", match3);
    addParseToken([ "DDD", "DDDD" ], function(input, array, config) {
        config._dayOfYear = toInt(input);
    });
    function dayOfYearFromWeeks(year, week, weekday, firstDayOfWeekOfYear, firstDayOfWeek) {
        var week1Jan = 6 + firstDayOfWeek - firstDayOfWeekOfYear, janX = createUTCDate(year, 0, 1 + week1Jan), d = janX.getUTCDay(), dayOfYear;
        if (d < firstDayOfWeek) {
            d += 7;
        }
        weekday = weekday != null ? 1 * weekday : firstDayOfWeek;
        dayOfYear = 1 + week1Jan + 7 * (week - 1) - d + weekday;
        return {
            year: dayOfYear > 0 ? year : year - 1,
            dayOfYear: dayOfYear > 0 ? dayOfYear : daysInYear(year - 1) + dayOfYear
        };
    }
    function getSetDayOfYear(input) {
        var dayOfYear = Math.round((this.clone().startOf("day") - this.clone().startOf("year")) / 864e5) + 1;
        return input == null ? dayOfYear : this.add(input - dayOfYear, "d");
    }
    function defaults(a, b, c) {
        if (a != null) {
            return a;
        }
        if (b != null) {
            return b;
        }
        return c;
    }
    function currentDateArray(config) {
        var now = new Date();
        if (config._useUTC) {
            return [ now.getUTCFullYear(), now.getUTCMonth(), now.getUTCDate() ];
        }
        return [ now.getFullYear(), now.getMonth(), now.getDate() ];
    }
    function configFromArray(config) {
        var i, date, input = [], currentDate, yearToUse;
        if (config._d) {
            return;
        }
        currentDate = currentDateArray(config);
        if (config._w && config._a[DATE] == null && config._a[MONTH] == null) {
            dayOfYearFromWeekInfo(config);
        }
        if (config._dayOfYear) {
            yearToUse = defaults(config._a[YEAR], currentDate[YEAR]);
            if (config._dayOfYear > daysInYear(yearToUse)) {
                getParsingFlags(config)._overflowDayOfYear = true;
            }
            date = createUTCDate(yearToUse, 0, config._dayOfYear);
            config._a[MONTH] = date.getUTCMonth();
            config._a[DATE] = date.getUTCDate();
        }
        for (i = 0; i < 3 && config._a[i] == null; ++i) {
            config._a[i] = input[i] = currentDate[i];
        }
        for (;i < 7; i++) {
            config._a[i] = input[i] = config._a[i] == null ? i === 2 ? 1 : 0 : config._a[i];
        }
        if (config._a[HOUR] === 24 && config._a[MINUTE] === 0 && config._a[SECOND] === 0 && config._a[MILLISECOND] === 0) {
            config._nextDay = true;
            config._a[HOUR] = 0;
        }
        config._d = (config._useUTC ? createUTCDate : createDate).apply(null, input);
        if (config._tzm != null) {
            config._d.setUTCMinutes(config._d.getUTCMinutes() - config._tzm);
        }
        if (config._nextDay) {
            config._a[HOUR] = 24;
        }
    }
    function dayOfYearFromWeekInfo(config) {
        var w, weekYear, week, weekday, dow, doy, temp;
        w = config._w;
        if (w.GG != null || w.W != null || w.E != null) {
            dow = 1;
            doy = 4;
            weekYear = defaults(w.GG, config._a[YEAR], weekOfYear(local__createLocal(), 1, 4).year);
            week = defaults(w.W, 1);
            weekday = defaults(w.E, 1);
        } else {
            dow = config._locale._week.dow;
            doy = config._locale._week.doy;
            weekYear = defaults(w.gg, config._a[YEAR], weekOfYear(local__createLocal(), dow, doy).year);
            week = defaults(w.w, 1);
            if (w.d != null) {
                weekday = w.d;
                if (weekday < dow) {
                    ++week;
                }
            } else if (w.e != null) {
                weekday = w.e + dow;
            } else {
                weekday = dow;
            }
        }
        temp = dayOfYearFromWeeks(weekYear, week, weekday, doy, dow);
        config._a[YEAR] = temp.year;
        config._dayOfYear = temp.dayOfYear;
    }
    utils_hooks__hooks.ISO_8601 = function() {};
    function configFromStringAndFormat(config) {
        if (config._f === utils_hooks__hooks.ISO_8601) {
            configFromISO(config);
            return;
        }
        config._a = [];
        getParsingFlags(config).empty = true;
        var string = "" + config._i, i, parsedInput, tokens, token, skipped, stringLength = string.length, totalParsedInputLength = 0;
        tokens = expandFormat(config._f, config._locale).match(formattingTokens) || [];
        for (i = 0; i < tokens.length; i++) {
            token = tokens[i];
            parsedInput = (string.match(getParseRegexForToken(token, config)) || [])[0];
            if (parsedInput) {
                skipped = string.substr(0, string.indexOf(parsedInput));
                if (skipped.length > 0) {
                    getParsingFlags(config).unusedInput.push(skipped);
                }
                string = string.slice(string.indexOf(parsedInput) + parsedInput.length);
                totalParsedInputLength += parsedInput.length;
            }
            if (formatTokenFunctions[token]) {
                if (parsedInput) {
                    getParsingFlags(config).empty = false;
                } else {
                    getParsingFlags(config).unusedTokens.push(token);
                }
                addTimeToArrayFromToken(token, parsedInput, config);
            } else if (config._strict && !parsedInput) {
                getParsingFlags(config).unusedTokens.push(token);
            }
        }
        getParsingFlags(config).charsLeftOver = stringLength - totalParsedInputLength;
        if (string.length > 0) {
            getParsingFlags(config).unusedInput.push(string);
        }
        if (getParsingFlags(config).bigHour === true && config._a[HOUR] <= 12 && config._a[HOUR] > 0) {
            getParsingFlags(config).bigHour = undefined;
        }
        config._a[HOUR] = meridiemFixWrap(config._locale, config._a[HOUR], config._meridiem);
        configFromArray(config);
        checkOverflow(config);
    }
    function meridiemFixWrap(locale, hour, meridiem) {
        var isPm;
        if (meridiem == null) {
            return hour;
        }
        if (locale.meridiemHour != null) {
            return locale.meridiemHour(hour, meridiem);
        } else if (locale.isPM != null) {
            isPm = locale.isPM(meridiem);
            if (isPm && hour < 12) {
                hour += 12;
            }
            if (!isPm && hour === 12) {
                hour = 0;
            }
            return hour;
        } else {
            return hour;
        }
    }
    function configFromStringAndArray(config) {
        var tempConfig, bestMoment, scoreToBeat, i, currentScore;
        if (config._f.length === 0) {
            getParsingFlags(config).invalidFormat = true;
            config._d = new Date(NaN);
            return;
        }
        for (i = 0; i < config._f.length; i++) {
            currentScore = 0;
            tempConfig = copyConfig({}, config);
            if (config._useUTC != null) {
                tempConfig._useUTC = config._useUTC;
            }
            tempConfig._f = config._f[i];
            configFromStringAndFormat(tempConfig);
            if (!valid__isValid(tempConfig)) {
                continue;
            }
            currentScore += getParsingFlags(tempConfig).charsLeftOver;
            currentScore += getParsingFlags(tempConfig).unusedTokens.length * 10;
            getParsingFlags(tempConfig).score = currentScore;
            if (scoreToBeat == null || currentScore < scoreToBeat) {
                scoreToBeat = currentScore;
                bestMoment = tempConfig;
            }
        }
        extend(config, bestMoment || tempConfig);
    }
    function configFromObject(config) {
        if (config._d) {
            return;
        }
        var i = normalizeObjectUnits(config._i);
        config._a = [ i.year, i.month, i.day || i.date, i.hour, i.minute, i.second, i.millisecond ];
        configFromArray(config);
    }
    function createFromConfig(config) {
        var res = new Moment(checkOverflow(prepareConfig(config)));
        if (res._nextDay) {
            res.add(1, "d");
            res._nextDay = undefined;
        }
        return res;
    }
    function prepareConfig(config) {
        var input = config._i, format = config._f;
        config._locale = config._locale || locale_locales__getLocale(config._l);
        if (input === null || format === undefined && input === "") {
            return valid__createInvalid({
                nullInput: true
            });
        }
        if (typeof input === "string") {
            config._i = input = config._locale.preparse(input);
        }
        if (isMoment(input)) {
            return new Moment(checkOverflow(input));
        } else if (isArray(format)) {
            configFromStringAndArray(config);
        } else if (format) {
            configFromStringAndFormat(config);
        } else if (isDate(input)) {
            config._d = input;
        } else {
            configFromInput(config);
        }
        return config;
    }
    function configFromInput(config) {
        var input = config._i;
        if (input === undefined) {
            config._d = new Date();
        } else if (isDate(input)) {
            config._d = new Date((+input));
        } else if (typeof input === "string") {
            configFromString(config);
        } else if (isArray(input)) {
            config._a = map(input.slice(0), function(obj) {
                return parseInt(obj, 10);
            });
            configFromArray(config);
        } else if (typeof input === "object") {
            configFromObject(config);
        } else if (typeof input === "number") {
            config._d = new Date(input);
        } else {
            utils_hooks__hooks.createFromInputFallback(config);
        }
    }
    function createLocalOrUTC(input, format, locale, strict, isUTC) {
        var c = {};
        if (typeof locale === "boolean") {
            strict = locale;
            locale = undefined;
        }
        c._isAMomentObject = true;
        c._useUTC = c._isUTC = isUTC;
        c._l = locale;
        c._i = input;
        c._f = format;
        c._strict = strict;
        return createFromConfig(c);
    }
    function local__createLocal(input, format, locale, strict) {
        return createLocalOrUTC(input, format, locale, strict, false);
    }
    var prototypeMin = deprecate("moment().min is deprecated, use moment.min instead. https://github.com/moment/moment/issues/1548", function() {
        var other = local__createLocal.apply(null, arguments);
        return other < this ? this : other;
    });
    var prototypeMax = deprecate("moment().max is deprecated, use moment.max instead. https://github.com/moment/moment/issues/1548", function() {
        var other = local__createLocal.apply(null, arguments);
        return other > this ? this : other;
    });
    function pickBy(fn, moments) {
        var res, i;
        if (moments.length === 1 && isArray(moments[0])) {
            moments = moments[0];
        }
        if (!moments.length) {
            return local__createLocal();
        }
        res = moments[0];
        for (i = 1; i < moments.length; ++i) {
            if (!moments[i].isValid() || moments[i][fn](res)) {
                res = moments[i];
            }
        }
        return res;
    }
    function min() {
        var args = [].slice.call(arguments, 0);
        return pickBy("isBefore", args);
    }
    function max() {
        var args = [].slice.call(arguments, 0);
        return pickBy("isAfter", args);
    }
    function Duration(duration) {
        var normalizedInput = normalizeObjectUnits(duration), years = normalizedInput.year || 0, quarters = normalizedInput.quarter || 0, months = normalizedInput.month || 0, weeks = normalizedInput.week || 0, days = normalizedInput.day || 0, hours = normalizedInput.hour || 0, minutes = normalizedInput.minute || 0, seconds = normalizedInput.second || 0, milliseconds = normalizedInput.millisecond || 0;
        this._milliseconds = +milliseconds + seconds * 1e3 + minutes * 6e4 + hours * 36e5;
        this._days = +days + weeks * 7;
        this._months = +months + quarters * 3 + years * 12;
        this._data = {};
        this._locale = locale_locales__getLocale();
        this._bubble();
    }
    function isDuration(obj) {
        return obj instanceof Duration;
    }
    function offset(token, separator) {
        addFormatToken(token, 0, 0, function() {
            var offset = this.utcOffset();
            var sign = "+";
            if (offset < 0) {
                offset = -offset;
                sign = "-";
            }
            return sign + zeroFill(~~(offset / 60), 2) + separator + zeroFill(~~offset % 60, 2);
        });
    }
    offset("Z", ":");
    offset("ZZ", "");
    addRegexToken("Z", matchOffset);
    addRegexToken("ZZ", matchOffset);
    addParseToken([ "Z", "ZZ" ], function(input, array, config) {
        config._useUTC = true;
        config._tzm = offsetFromString(input);
    });
    var chunkOffset = /([\+\-]|\d\d)/gi;
    function offsetFromString(string) {
        var matches = (string || "").match(matchOffset) || [];
        var chunk = matches[matches.length - 1] || [];
        var parts = (chunk + "").match(chunkOffset) || [ "-", 0, 0 ];
        var minutes = +(parts[1] * 60) + toInt(parts[2]);
        return parts[0] === "+" ? minutes : -minutes;
    }
    function cloneWithOffset(input, model) {
        var res, diff;
        if (model._isUTC) {
            res = model.clone();
            diff = (isMoment(input) || isDate(input) ? +input : +local__createLocal(input)) - +res;
            res._d.setTime(+res._d + diff);
            utils_hooks__hooks.updateOffset(res, false);
            return res;
        } else {
            return local__createLocal(input).local();
        }
    }
    function getDateOffset(m) {
        return -Math.round(m._d.getTimezoneOffset() / 15) * 15;
    }
    utils_hooks__hooks.updateOffset = function() {};
    function getSetOffset(input, keepLocalTime) {
        var offset = this._offset || 0, localAdjust;
        if (input != null) {
            if (typeof input === "string") {
                input = offsetFromString(input);
            }
            if (Math.abs(input) < 16) {
                input = input * 60;
            }
            if (!this._isUTC && keepLocalTime) {
                localAdjust = getDateOffset(this);
            }
            this._offset = input;
            this._isUTC = true;
            if (localAdjust != null) {
                this.add(localAdjust, "m");
            }
            if (offset !== input) {
                if (!keepLocalTime || this._changeInProgress) {
                    add_subtract__addSubtract(this, create__createDuration(input - offset, "m"), 1, false);
                } else if (!this._changeInProgress) {
                    this._changeInProgress = true;
                    utils_hooks__hooks.updateOffset(this, true);
                    this._changeInProgress = null;
                }
            }
            return this;
        } else {
            return this._isUTC ? offset : getDateOffset(this);
        }
    }
    function getSetZone(input, keepLocalTime) {
        if (input != null) {
            if (typeof input !== "string") {
                input = -input;
            }
            this.utcOffset(input, keepLocalTime);
            return this;
        } else {
            return -this.utcOffset();
        }
    }
    function setOffsetToUTC(keepLocalTime) {
        return this.utcOffset(0, keepLocalTime);
    }
    function setOffsetToLocal(keepLocalTime) {
        if (this._isUTC) {
            this.utcOffset(0, keepLocalTime);
            this._isUTC = false;
            if (keepLocalTime) {
                this.subtract(getDateOffset(this), "m");
            }
        }
        return this;
    }
    function setOffsetToParsedOffset() {
        if (this._tzm) {
            this.utcOffset(this._tzm);
        } else if (typeof this._i === "string") {
            this.utcOffset(offsetFromString(this._i));
        }
        return this;
    }
    function hasAlignedHourOffset(input) {
        input = input ? local__createLocal(input).utcOffset() : 0;
        return (this.utcOffset() - input) % 60 === 0;
    }
    function isDaylightSavingTime() {
        return this.utcOffset() > this.clone().month(0).utcOffset() || this.utcOffset() > this.clone().month(5).utcOffset();
    }
    function isDaylightSavingTimeShifted() {
        if (typeof this._isDSTShifted !== "undefined") {
            return this._isDSTShifted;
        }
        var c = {};
        copyConfig(c, this);
        c = prepareConfig(c);
        if (c._a) {
            var other = c._isUTC ? create_utc__createUTC(c._a) : local__createLocal(c._a);
            this._isDSTShifted = this.isValid() && compareArrays(c._a, other.toArray()) > 0;
        } else {
            this._isDSTShifted = false;
        }
        return this._isDSTShifted;
    }
    function isLocal() {
        return !this._isUTC;
    }
    function isUtcOffset() {
        return this._isUTC;
    }
    function isUtc() {
        return this._isUTC && this._offset === 0;
    }
    var aspNetRegex = /(\-)?(?:(\d*)\.)?(\d+)\:(\d+)(?:\:(\d+)\.?(\d{3})?)?/;
    var create__isoRegex = /^(-)?P(?:(?:([0-9,.]*)Y)?(?:([0-9,.]*)M)?(?:([0-9,.]*)D)?(?:T(?:([0-9,.]*)H)?(?:([0-9,.]*)M)?(?:([0-9,.]*)S)?)?|([0-9,.]*)W)$/;
    function create__createDuration(input, key) {
        var duration = input, match = null, sign, ret, diffRes;
        if (isDuration(input)) {
            duration = {
                ms: input._milliseconds,
                d: input._days,
                M: input._months
            };
        } else if (typeof input === "number") {
            duration = {};
            if (key) {
                duration[key] = input;
            } else {
                duration.milliseconds = input;
            }
        } else if (!!(match = aspNetRegex.exec(input))) {
            sign = match[1] === "-" ? -1 : 1;
            duration = {
                y: 0,
                d: toInt(match[DATE]) * sign,
                h: toInt(match[HOUR]) * sign,
                m: toInt(match[MINUTE]) * sign,
                s: toInt(match[SECOND]) * sign,
                ms: toInt(match[MILLISECOND]) * sign
            };
        } else if (!!(match = create__isoRegex.exec(input))) {
            sign = match[1] === "-" ? -1 : 1;
            duration = {
                y: parseIso(match[2], sign),
                M: parseIso(match[3], sign),
                d: parseIso(match[4], sign),
                h: parseIso(match[5], sign),
                m: parseIso(match[6], sign),
                s: parseIso(match[7], sign),
                w: parseIso(match[8], sign)
            };
        } else if (duration == null) {
            duration = {};
        } else if (typeof duration === "object" && ("from" in duration || "to" in duration)) {
            diffRes = momentsDifference(local__createLocal(duration.from), local__createLocal(duration.to));
            duration = {};
            duration.ms = diffRes.milliseconds;
            duration.M = diffRes.months;
        }
        ret = new Duration(duration);
        if (isDuration(input) && hasOwnProp(input, "_locale")) {
            ret._locale = input._locale;
        }
        return ret;
    }
    create__createDuration.fn = Duration.prototype;
    function parseIso(inp, sign) {
        var res = inp && parseFloat(inp.replace(",", "."));
        return (isNaN(res) ? 0 : res) * sign;
    }
    function positiveMomentsDifference(base, other) {
        var res = {
            milliseconds: 0,
            months: 0
        };
        res.months = other.month() - base.month() + (other.year() - base.year()) * 12;
        if (base.clone().add(res.months, "M").isAfter(other)) {
            --res.months;
        }
        res.milliseconds = +other - +base.clone().add(res.months, "M");
        return res;
    }
    function momentsDifference(base, other) {
        var res;
        other = cloneWithOffset(other, base);
        if (base.isBefore(other)) {
            res = positiveMomentsDifference(base, other);
        } else {
            res = positiveMomentsDifference(other, base);
            res.milliseconds = -res.milliseconds;
            res.months = -res.months;
        }
        return res;
    }
    function createAdder(direction, name) {
        return function(val, period) {
            var dur, tmp;
            if (period !== null && !isNaN(+period)) {
                deprecateSimple(name, "moment()." + name + "(period, number) is deprecated. Please use moment()." + name + "(number, period).");
                tmp = val;
                val = period;
                period = tmp;
            }
            val = typeof val === "string" ? +val : val;
            dur = create__createDuration(val, period);
            add_subtract__addSubtract(this, dur, direction);
            return this;
        };
    }
    function add_subtract__addSubtract(mom, duration, isAdding, updateOffset) {
        var milliseconds = duration._milliseconds, days = duration._days, months = duration._months;
        updateOffset = updateOffset == null ? true : updateOffset;
        if (milliseconds) {
            mom._d.setTime(+mom._d + milliseconds * isAdding);
        }
        if (days) {
            get_set__set(mom, "Date", get_set__get(mom, "Date") + days * isAdding);
        }
        if (months) {
            setMonth(mom, get_set__get(mom, "Month") + months * isAdding);
        }
        if (updateOffset) {
            utils_hooks__hooks.updateOffset(mom, days || months);
        }
    }
    var add_subtract__add = createAdder(1, "add");
    var add_subtract__subtract = createAdder(-1, "subtract");
    function moment_calendar__calendar(time, formats) {
        var now = time || local__createLocal(), sod = cloneWithOffset(now, this).startOf("day"), diff = this.diff(sod, "days", true), format = diff < -6 ? "sameElse" : diff < -1 ? "lastWeek" : diff < 0 ? "lastDay" : diff < 1 ? "sameDay" : diff < 2 ? "nextDay" : diff < 7 ? "nextWeek" : "sameElse";
        return this.format(formats && formats[format] || this.localeData().calendar(format, this, local__createLocal(now)));
    }
    function clone() {
        return new Moment(this);
    }
    function isAfter(input, units) {
        var inputMs;
        units = normalizeUnits(typeof units !== "undefined" ? units : "millisecond");
        if (units === "millisecond") {
            input = isMoment(input) ? input : local__createLocal(input);
            return +this > +input;
        } else {
            inputMs = isMoment(input) ? +input : +local__createLocal(input);
            return inputMs < +this.clone().startOf(units);
        }
    }
    function isBefore(input, units) {
        var inputMs;
        units = normalizeUnits(typeof units !== "undefined" ? units : "millisecond");
        if (units === "millisecond") {
            input = isMoment(input) ? input : local__createLocal(input);
            return +this < +input;
        } else {
            inputMs = isMoment(input) ? +input : +local__createLocal(input);
            return +this.clone().endOf(units) < inputMs;
        }
    }
    function isBetween(from, to, units) {
        return this.isAfter(from, units) && this.isBefore(to, units);
    }
    function isSame(input, units) {
        var inputMs;
        units = normalizeUnits(units || "millisecond");
        if (units === "millisecond") {
            input = isMoment(input) ? input : local__createLocal(input);
            return +this === +input;
        } else {
            inputMs = +local__createLocal(input);
            return +this.clone().startOf(units) <= inputMs && inputMs <= +this.clone().endOf(units);
        }
    }
    function diff(input, units, asFloat) {
        var that = cloneWithOffset(input, this), zoneDelta = (that.utcOffset() - this.utcOffset()) * 6e4, delta, output;
        units = normalizeUnits(units);
        if (units === "year" || units === "month" || units === "quarter") {
            output = monthDiff(this, that);
            if (units === "quarter") {
                output = output / 3;
            } else if (units === "year") {
                output = output / 12;
            }
        } else {
            delta = this - that;
            output = units === "second" ? delta / 1e3 : units === "minute" ? delta / 6e4 : units === "hour" ? delta / 36e5 : units === "day" ? (delta - zoneDelta) / 864e5 : units === "week" ? (delta - zoneDelta) / 6048e5 : delta;
        }
        return asFloat ? output : absFloor(output);
    }
    function monthDiff(a, b) {
        var wholeMonthDiff = (b.year() - a.year()) * 12 + (b.month() - a.month()), anchor = a.clone().add(wholeMonthDiff, "months"), anchor2, adjust;
        if (b - anchor < 0) {
            anchor2 = a.clone().add(wholeMonthDiff - 1, "months");
            adjust = (b - anchor) / (anchor - anchor2);
        } else {
            anchor2 = a.clone().add(wholeMonthDiff + 1, "months");
            adjust = (b - anchor) / (anchor2 - anchor);
        }
        return -(wholeMonthDiff + adjust);
    }
    utils_hooks__hooks.defaultFormat = "YYYY-MM-DDTHH:mm:ssZ";
    function toString() {
        return this.clone().locale("en").format("ddd MMM DD YYYY HH:mm:ss [GMT]ZZ");
    }
    function moment_format__toISOString() {
        var m = this.clone().utc();
        if (0 < m.year() && m.year() <= 9999) {
            if ("function" === typeof Date.prototype.toISOString) {
                return this.toDate().toISOString();
            } else {
                return formatMoment(m, "YYYY-MM-DD[T]HH:mm:ss.SSS[Z]");
            }
        } else {
            return formatMoment(m, "YYYYYY-MM-DD[T]HH:mm:ss.SSS[Z]");
        }
    }
    function moment_format__format(inputString) {
        var output = formatMoment(this, inputString || utils_hooks__hooks.defaultFormat);
        return this.localeData().postformat(output);
    }
    function from(time, withoutSuffix) {
        if (!this.isValid()) {
            return this.localeData().invalidDate();
        }
        return create__createDuration({
            to: this,
            from: time
        }).locale(this.locale()).humanize(!withoutSuffix);
    }
    function fromNow(withoutSuffix) {
        return this.from(local__createLocal(), withoutSuffix);
    }
    function to(time, withoutSuffix) {
        if (!this.isValid()) {
            return this.localeData().invalidDate();
        }
        return create__createDuration({
            from: this,
            to: time
        }).locale(this.locale()).humanize(!withoutSuffix);
    }
    function toNow(withoutSuffix) {
        return this.to(local__createLocal(), withoutSuffix);
    }
    function locale(key) {
        var newLocaleData;
        if (key === undefined) {
            return this._locale._abbr;
        } else {
            newLocaleData = locale_locales__getLocale(key);
            if (newLocaleData != null) {
                this._locale = newLocaleData;
            }
            return this;
        }
    }
    var lang = deprecate("moment().lang() is deprecated. Instead, use moment().localeData() to get the language configuration. Use moment().locale() to change languages.", function(key) {
        if (key === undefined) {
            return this.localeData();
        } else {
            return this.locale(key);
        }
    });
    function localeData() {
        return this._locale;
    }
    function startOf(units) {
        units = normalizeUnits(units);
        switch (units) {
          case "year":
            this.month(0);

          case "quarter":
          case "month":
            this.date(1);

          case "week":
          case "isoWeek":
          case "day":
            this.hours(0);

          case "hour":
            this.minutes(0);

          case "minute":
            this.seconds(0);

          case "second":
            this.milliseconds(0);
        }
        if (units === "week") {
            this.weekday(0);
        }
        if (units === "isoWeek") {
            this.isoWeekday(1);
        }
        if (units === "quarter") {
            this.month(Math.floor(this.month() / 3) * 3);
        }
        return this;
    }
    function endOf(units) {
        units = normalizeUnits(units);
        if (units === undefined || units === "millisecond") {
            return this;
        }
        return this.startOf(units).add(1, units === "isoWeek" ? "week" : units).subtract(1, "ms");
    }
    function to_type__valueOf() {
        return +this._d - (this._offset || 0) * 6e4;
    }
    function unix() {
        return Math.floor(+this / 1e3);
    }
    function toDate() {
        return this._offset ? new Date((+this)) : this._d;
    }
    function toArray() {
        var m = this;
        return [ m.year(), m.month(), m.date(), m.hour(), m.minute(), m.second(), m.millisecond() ];
    }
    function toObject() {
        var m = this;
        return {
            years: m.year(),
            months: m.month(),
            date: m.date(),
            hours: m.hours(),
            minutes: m.minutes(),
            seconds: m.seconds(),
            milliseconds: m.milliseconds()
        };
    }
    function moment_valid__isValid() {
        return valid__isValid(this);
    }
    function parsingFlags() {
        return extend({}, getParsingFlags(this));
    }
    function invalidAt() {
        return getParsingFlags(this).overflow;
    }
    addFormatToken(0, [ "gg", 2 ], 0, function() {
        return this.weekYear() % 100;
    });
    addFormatToken(0, [ "GG", 2 ], 0, function() {
        return this.isoWeekYear() % 100;
    });
    function addWeekYearFormatToken(token, getter) {
        addFormatToken(0, [ token, token.length ], 0, getter);
    }
    addWeekYearFormatToken("gggg", "weekYear");
    addWeekYearFormatToken("ggggg", "weekYear");
    addWeekYearFormatToken("GGGG", "isoWeekYear");
    addWeekYearFormatToken("GGGGG", "isoWeekYear");
    addUnitAlias("weekYear", "gg");
    addUnitAlias("isoWeekYear", "GG");
    addRegexToken("G", matchSigned);
    addRegexToken("g", matchSigned);
    addRegexToken("GG", match1to2, match2);
    addRegexToken("gg", match1to2, match2);
    addRegexToken("GGGG", match1to4, match4);
    addRegexToken("gggg", match1to4, match4);
    addRegexToken("GGGGG", match1to6, match6);
    addRegexToken("ggggg", match1to6, match6);
    addWeekParseToken([ "gggg", "ggggg", "GGGG", "GGGGG" ], function(input, week, config, token) {
        week[token.substr(0, 2)] = toInt(input);
    });
    addWeekParseToken([ "gg", "GG" ], function(input, week, config, token) {
        week[token] = utils_hooks__hooks.parseTwoDigitYear(input);
    });
    function weeksInYear(year, dow, doy) {
        return weekOfYear(local__createLocal([ year, 11, 31 + dow - doy ]), dow, doy).week;
    }
    function getSetWeekYear(input) {
        var year = weekOfYear(this, this.localeData()._week.dow, this.localeData()._week.doy).year;
        return input == null ? year : this.add(input - year, "y");
    }
    function getSetISOWeekYear(input) {
        var year = weekOfYear(this, 1, 4).year;
        return input == null ? year : this.add(input - year, "y");
    }
    function getISOWeeksInYear() {
        return weeksInYear(this.year(), 1, 4);
    }
    function getWeeksInYear() {
        var weekInfo = this.localeData()._week;
        return weeksInYear(this.year(), weekInfo.dow, weekInfo.doy);
    }
    addFormatToken("Q", 0, 0, "quarter");
    addUnitAlias("quarter", "Q");
    addRegexToken("Q", match1);
    addParseToken("Q", function(input, array) {
        array[MONTH] = (toInt(input) - 1) * 3;
    });
    function getSetQuarter(input) {
        return input == null ? Math.ceil((this.month() + 1) / 3) : this.month((input - 1) * 3 + this.month() % 3);
    }
    addFormatToken("D", [ "DD", 2 ], "Do", "date");
    addUnitAlias("date", "D");
    addRegexToken("D", match1to2);
    addRegexToken("DD", match1to2, match2);
    addRegexToken("Do", function(isStrict, locale) {
        return isStrict ? locale._ordinalParse : locale._ordinalParseLenient;
    });
    addParseToken([ "D", "DD" ], DATE);
    addParseToken("Do", function(input, array) {
        array[DATE] = toInt(input.match(match1to2)[0], 10);
    });
    var getSetDayOfMonth = makeGetSet("Date", true);
    addFormatToken("d", 0, "do", "day");
    addFormatToken("dd", 0, 0, function(format) {
        return this.localeData().weekdaysMin(this, format);
    });
    addFormatToken("ddd", 0, 0, function(format) {
        return this.localeData().weekdaysShort(this, format);
    });
    addFormatToken("dddd", 0, 0, function(format) {
        return this.localeData().weekdays(this, format);
    });
    addFormatToken("e", 0, 0, "weekday");
    addFormatToken("E", 0, 0, "isoWeekday");
    addUnitAlias("day", "d");
    addUnitAlias("weekday", "e");
    addUnitAlias("isoWeekday", "E");
    addRegexToken("d", match1to2);
    addRegexToken("e", match1to2);
    addRegexToken("E", match1to2);
    addRegexToken("dd", matchWord);
    addRegexToken("ddd", matchWord);
    addRegexToken("dddd", matchWord);
    addWeekParseToken([ "dd", "ddd", "dddd" ], function(input, week, config) {
        var weekday = config._locale.weekdaysParse(input);
        if (weekday != null) {
            week.d = weekday;
        } else {
            getParsingFlags(config).invalidWeekday = input;
        }
    });
    addWeekParseToken([ "d", "e", "E" ], function(input, week, config, token) {
        week[token] = toInt(input);
    });
    function parseWeekday(input, locale) {
        if (typeof input !== "string") {
            return input;
        }
        if (!isNaN(input)) {
            return parseInt(input, 10);
        }
        input = locale.weekdaysParse(input);
        if (typeof input === "number") {
            return input;
        }
        return null;
    }
    var defaultLocaleWeekdays = "Sunday_Monday_Tuesday_Wednesday_Thursday_Friday_Saturday".split("_");
    function localeWeekdays(m) {
        return this._weekdays[m.day()];
    }
    var defaultLocaleWeekdaysShort = "Sun_Mon_Tue_Wed_Thu_Fri_Sat".split("_");
    function localeWeekdaysShort(m) {
        return this._weekdaysShort[m.day()];
    }
    var defaultLocaleWeekdaysMin = "Su_Mo_Tu_We_Th_Fr_Sa".split("_");
    function localeWeekdaysMin(m) {
        return this._weekdaysMin[m.day()];
    }
    function localeWeekdaysParse(weekdayName) {
        var i, mom, regex;
        this._weekdaysParse = this._weekdaysParse || [];
        for (i = 0; i < 7; i++) {
            if (!this._weekdaysParse[i]) {
                mom = local__createLocal([ 2e3, 1 ]).day(i);
                regex = "^" + this.weekdays(mom, "") + "|^" + this.weekdaysShort(mom, "") + "|^" + this.weekdaysMin(mom, "");
                this._weekdaysParse[i] = new RegExp(regex.replace(".", ""), "i");
            }
            if (this._weekdaysParse[i].test(weekdayName)) {
                return i;
            }
        }
    }
    function getSetDayOfWeek(input) {
        var day = this._isUTC ? this._d.getUTCDay() : this._d.getDay();
        if (input != null) {
            input = parseWeekday(input, this.localeData());
            return this.add(input - day, "d");
        } else {
            return day;
        }
    }
    function getSetLocaleDayOfWeek(input) {
        var weekday = (this.day() + 7 - this.localeData()._week.dow) % 7;
        return input == null ? weekday : this.add(input - weekday, "d");
    }
    function getSetISODayOfWeek(input) {
        return input == null ? this.day() || 7 : this.day(this.day() % 7 ? input : input - 7);
    }
    addFormatToken("H", [ "HH", 2 ], 0, "hour");
    addFormatToken("h", [ "hh", 2 ], 0, function() {
        return this.hours() % 12 || 12;
    });
    function meridiem(token, lowercase) {
        addFormatToken(token, 0, 0, function() {
            return this.localeData().meridiem(this.hours(), this.minutes(), lowercase);
        });
    }
    meridiem("a", true);
    meridiem("A", false);
    addUnitAlias("hour", "h");
    function matchMeridiem(isStrict, locale) {
        return locale._meridiemParse;
    }
    addRegexToken("a", matchMeridiem);
    addRegexToken("A", matchMeridiem);
    addRegexToken("H", match1to2);
    addRegexToken("h", match1to2);
    addRegexToken("HH", match1to2, match2);
    addRegexToken("hh", match1to2, match2);
    addParseToken([ "H", "HH" ], HOUR);
    addParseToken([ "a", "A" ], function(input, array, config) {
        config._isPm = config._locale.isPM(input);
        config._meridiem = input;
    });
    addParseToken([ "h", "hh" ], function(input, array, config) {
        array[HOUR] = toInt(input);
        getParsingFlags(config).bigHour = true;
    });
    function localeIsPM(input) {
        return (input + "").toLowerCase().charAt(0) === "p";
    }
    var defaultLocaleMeridiemParse = /[ap]\.?m?\.?/i;
    function localeMeridiem(hours, minutes, isLower) {
        if (hours > 11) {
            return isLower ? "pm" : "PM";
        } else {
            return isLower ? "am" : "AM";
        }
    }
    var getSetHour = makeGetSet("Hours", true);
    addFormatToken("m", [ "mm", 2 ], 0, "minute");
    addUnitAlias("minute", "m");
    addRegexToken("m", match1to2);
    addRegexToken("mm", match1to2, match2);
    addParseToken([ "m", "mm" ], MINUTE);
    var getSetMinute = makeGetSet("Minutes", false);
    addFormatToken("s", [ "ss", 2 ], 0, "second");
    addUnitAlias("second", "s");
    addRegexToken("s", match1to2);
    addRegexToken("ss", match1to2, match2);
    addParseToken([ "s", "ss" ], SECOND);
    var getSetSecond = makeGetSet("Seconds", false);
    addFormatToken("S", 0, 0, function() {
        return ~~(this.millisecond() / 100);
    });
    addFormatToken(0, [ "SS", 2 ], 0, function() {
        return ~~(this.millisecond() / 10);
    });
    addFormatToken(0, [ "SSS", 3 ], 0, "millisecond");
    addFormatToken(0, [ "SSSS", 4 ], 0, function() {
        return this.millisecond() * 10;
    });
    addFormatToken(0, [ "SSSSS", 5 ], 0, function() {
        return this.millisecond() * 100;
    });
    addFormatToken(0, [ "SSSSSS", 6 ], 0, function() {
        return this.millisecond() * 1e3;
    });
    addFormatToken(0, [ "SSSSSSS", 7 ], 0, function() {
        return this.millisecond() * 1e4;
    });
    addFormatToken(0, [ "SSSSSSSS", 8 ], 0, function() {
        return this.millisecond() * 1e5;
    });
    addFormatToken(0, [ "SSSSSSSSS", 9 ], 0, function() {
        return this.millisecond() * 1e6;
    });
    addUnitAlias("millisecond", "ms");
    addRegexToken("S", match1to3, match1);
    addRegexToken("SS", match1to3, match2);
    addRegexToken("SSS", match1to3, match3);
    var token;
    for (token = "SSSS"; token.length <= 9; token += "S") {
        addRegexToken(token, matchUnsigned);
    }
    function parseMs(input, array) {
        array[MILLISECOND] = toInt(("0." + input) * 1e3);
    }
    for (token = "S"; token.length <= 9; token += "S") {
        addParseToken(token, parseMs);
    }
    var getSetMillisecond = makeGetSet("Milliseconds", false);
    addFormatToken("z", 0, 0, "zoneAbbr");
    addFormatToken("zz", 0, 0, "zoneName");
    function getZoneAbbr() {
        return this._isUTC ? "UTC" : "";
    }
    function getZoneName() {
        return this._isUTC ? "Coordinated Universal Time" : "";
    }
    var momentPrototype__proto = Moment.prototype;
    momentPrototype__proto.add = add_subtract__add;
    momentPrototype__proto.calendar = moment_calendar__calendar;
    momentPrototype__proto.clone = clone;
    momentPrototype__proto.diff = diff;
    momentPrototype__proto.endOf = endOf;
    momentPrototype__proto.format = moment_format__format;
    momentPrototype__proto.from = from;
    momentPrototype__proto.fromNow = fromNow;
    momentPrototype__proto.to = to;
    momentPrototype__proto.toNow = toNow;
    momentPrototype__proto.get = getSet;
    momentPrototype__proto.invalidAt = invalidAt;
    momentPrototype__proto.isAfter = isAfter;
    momentPrototype__proto.isBefore = isBefore;
    momentPrototype__proto.isBetween = isBetween;
    momentPrototype__proto.isSame = isSame;
    momentPrototype__proto.isValid = moment_valid__isValid;
    momentPrototype__proto.lang = lang;
    momentPrototype__proto.locale = locale;
    momentPrototype__proto.localeData = localeData;
    momentPrototype__proto.max = prototypeMax;
    momentPrototype__proto.min = prototypeMin;
    momentPrototype__proto.parsingFlags = parsingFlags;
    momentPrototype__proto.set = getSet;
    momentPrototype__proto.startOf = startOf;
    momentPrototype__proto.subtract = add_subtract__subtract;
    momentPrototype__proto.toArray = toArray;
    momentPrototype__proto.toObject = toObject;
    momentPrototype__proto.toDate = toDate;
    momentPrototype__proto.toISOString = moment_format__toISOString;
    momentPrototype__proto.toJSON = moment_format__toISOString;
    momentPrototype__proto.toString = toString;
    momentPrototype__proto.unix = unix;
    momentPrototype__proto.valueOf = to_type__valueOf;
    momentPrototype__proto.year = getSetYear;
    momentPrototype__proto.isLeapYear = getIsLeapYear;
    momentPrototype__proto.weekYear = getSetWeekYear;
    momentPrototype__proto.isoWeekYear = getSetISOWeekYear;
    momentPrototype__proto.quarter = momentPrototype__proto.quarters = getSetQuarter;
    momentPrototype__proto.month = getSetMonth;
    momentPrototype__proto.daysInMonth = getDaysInMonth;
    momentPrototype__proto.week = momentPrototype__proto.weeks = getSetWeek;
    momentPrototype__proto.isoWeek = momentPrototype__proto.isoWeeks = getSetISOWeek;
    momentPrototype__proto.weeksInYear = getWeeksInYear;
    momentPrototype__proto.isoWeeksInYear = getISOWeeksInYear;
    momentPrototype__proto.date = getSetDayOfMonth;
    momentPrototype__proto.day = momentPrototype__proto.days = getSetDayOfWeek;
    momentPrototype__proto.weekday = getSetLocaleDayOfWeek;
    momentPrototype__proto.isoWeekday = getSetISODayOfWeek;
    momentPrototype__proto.dayOfYear = getSetDayOfYear;
    momentPrototype__proto.hour = momentPrototype__proto.hours = getSetHour;
    momentPrototype__proto.minute = momentPrototype__proto.minutes = getSetMinute;
    momentPrototype__proto.second = momentPrototype__proto.seconds = getSetSecond;
    momentPrototype__proto.millisecond = momentPrototype__proto.milliseconds = getSetMillisecond;
    momentPrototype__proto.utcOffset = getSetOffset;
    momentPrototype__proto.utc = setOffsetToUTC;
    momentPrototype__proto.local = setOffsetToLocal;
    momentPrototype__proto.parseZone = setOffsetToParsedOffset;
    momentPrototype__proto.hasAlignedHourOffset = hasAlignedHourOffset;
    momentPrototype__proto.isDST = isDaylightSavingTime;
    momentPrototype__proto.isDSTShifted = isDaylightSavingTimeShifted;
    momentPrototype__proto.isLocal = isLocal;
    momentPrototype__proto.isUtcOffset = isUtcOffset;
    momentPrototype__proto.isUtc = isUtc;
    momentPrototype__proto.isUTC = isUtc;
    momentPrototype__proto.zoneAbbr = getZoneAbbr;
    momentPrototype__proto.zoneName = getZoneName;
    momentPrototype__proto.dates = deprecate("dates accessor is deprecated. Use date instead.", getSetDayOfMonth);
    momentPrototype__proto.months = deprecate("months accessor is deprecated. Use month instead", getSetMonth);
    momentPrototype__proto.years = deprecate("years accessor is deprecated. Use year instead", getSetYear);
    momentPrototype__proto.zone = deprecate("moment().zone is deprecated, use moment().utcOffset instead. https://github.com/moment/moment/issues/1779", getSetZone);
    var momentPrototype = momentPrototype__proto;
    function moment_moment__createUnix(input) {
        return local__createLocal(input * 1e3);
    }
    function moment_moment__createInZone() {
        return local__createLocal.apply(null, arguments).parseZone();
    }
    var defaultCalendar = {
        sameDay: "[Today at] LT",
        nextDay: "[Tomorrow at] LT",
        nextWeek: "dddd [at] LT",
        lastDay: "[Yesterday at] LT",
        lastWeek: "[Last] dddd [at] LT",
        sameElse: "L"
    };
    function locale_calendar__calendar(key, mom, now) {
        var output = this._calendar[key];
        return typeof output === "function" ? output.call(mom, now) : output;
    }
    var defaultLongDateFormat = {
        LTS: "h:mm:ss A",
        LT: "h:mm A",
        L: "MM/DD/YYYY",
        LL: "MMMM D, YYYY",
        LLL: "MMMM D, YYYY h:mm A",
        LLLL: "dddd, MMMM D, YYYY h:mm A"
    };
    function longDateFormat(key) {
        var format = this._longDateFormat[key], formatUpper = this._longDateFormat[key.toUpperCase()];
        if (format || !formatUpper) {
            return format;
        }
        this._longDateFormat[key] = formatUpper.replace(/MMMM|MM|DD|dddd/g, function(val) {
            return val.slice(1);
        });
        return this._longDateFormat[key];
    }
    var defaultInvalidDate = "Invalid date";
    function invalidDate() {
        return this._invalidDate;
    }
    var defaultOrdinal = "%d";
    var defaultOrdinalParse = /\d{1,2}/;
    function ordinal(number) {
        return this._ordinal.replace("%d", number);
    }
    function preParsePostFormat(string) {
        return string;
    }
    var defaultRelativeTime = {
        future: "in %s",
        past: "%s ago",
        s: "a few seconds",
        m: "a minute",
        mm: "%d minutes",
        h: "an hour",
        hh: "%d hours",
        d: "a day",
        dd: "%d days",
        M: "a month",
        MM: "%d months",
        y: "a year",
        yy: "%d years"
    };
    function relative__relativeTime(number, withoutSuffix, string, isFuture) {
        var output = this._relativeTime[string];
        return typeof output === "function" ? output(number, withoutSuffix, string, isFuture) : output.replace(/%d/i, number);
    }
    function pastFuture(diff, output) {
        var format = this._relativeTime[diff > 0 ? "future" : "past"];
        return typeof format === "function" ? format(output) : format.replace(/%s/i, output);
    }
    function locale_set__set(config) {
        var prop, i;
        for (i in config) {
            prop = config[i];
            if (typeof prop === "function") {
                this[i] = prop;
            } else {
                this["_" + i] = prop;
            }
        }
        this._ordinalParseLenient = new RegExp(this._ordinalParse.source + "|" + /\d{1,2}/.source);
    }
    var prototype__proto = Locale.prototype;
    prototype__proto._calendar = defaultCalendar;
    prototype__proto.calendar = locale_calendar__calendar;
    prototype__proto._longDateFormat = defaultLongDateFormat;
    prototype__proto.longDateFormat = longDateFormat;
    prototype__proto._invalidDate = defaultInvalidDate;
    prototype__proto.invalidDate = invalidDate;
    prototype__proto._ordinal = defaultOrdinal;
    prototype__proto.ordinal = ordinal;
    prototype__proto._ordinalParse = defaultOrdinalParse;
    prototype__proto.preparse = preParsePostFormat;
    prototype__proto.postformat = preParsePostFormat;
    prototype__proto._relativeTime = defaultRelativeTime;
    prototype__proto.relativeTime = relative__relativeTime;
    prototype__proto.pastFuture = pastFuture;
    prototype__proto.set = locale_set__set;
    prototype__proto.months = localeMonths;
    prototype__proto._months = defaultLocaleMonths;
    prototype__proto.monthsShort = localeMonthsShort;
    prototype__proto._monthsShort = defaultLocaleMonthsShort;
    prototype__proto.monthsParse = localeMonthsParse;
    prototype__proto.week = localeWeek;
    prototype__proto._week = defaultLocaleWeek;
    prototype__proto.firstDayOfYear = localeFirstDayOfYear;
    prototype__proto.firstDayOfWeek = localeFirstDayOfWeek;
    prototype__proto.weekdays = localeWeekdays;
    prototype__proto._weekdays = defaultLocaleWeekdays;
    prototype__proto.weekdaysMin = localeWeekdaysMin;
    prototype__proto._weekdaysMin = defaultLocaleWeekdaysMin;
    prototype__proto.weekdaysShort = localeWeekdaysShort;
    prototype__proto._weekdaysShort = defaultLocaleWeekdaysShort;
    prototype__proto.weekdaysParse = localeWeekdaysParse;
    prototype__proto.isPM = localeIsPM;
    prototype__proto._meridiemParse = defaultLocaleMeridiemParse;
    prototype__proto.meridiem = localeMeridiem;
    function lists__get(format, index, field, setter) {
        var locale = locale_locales__getLocale();
        var utc = create_utc__createUTC().set(setter, index);
        return locale[field](utc, format);
    }
    function list(format, index, field, count, setter) {
        if (typeof format === "number") {
            index = format;
            format = undefined;
        }
        format = format || "";
        if (index != null) {
            return lists__get(format, index, field, setter);
        }
        var i;
        var out = [];
        for (i = 0; i < count; i++) {
            out[i] = lists__get(format, i, field, setter);
        }
        return out;
    }
    function lists__listMonths(format, index) {
        return list(format, index, "months", 12, "month");
    }
    function lists__listMonthsShort(format, index) {
        return list(format, index, "monthsShort", 12, "month");
    }
    function lists__listWeekdays(format, index) {
        return list(format, index, "weekdays", 7, "day");
    }
    function lists__listWeekdaysShort(format, index) {
        return list(format, index, "weekdaysShort", 7, "day");
    }
    function lists__listWeekdaysMin(format, index) {
        return list(format, index, "weekdaysMin", 7, "day");
    }
    locale_locales__getSetGlobalLocale("en", {
        ordinalParse: /\d{1,2}(th|st|nd|rd)/,
        ordinal: function(number) {
            var b = number % 10, output = toInt(number % 100 / 10) === 1 ? "th" : b === 1 ? "st" : b === 2 ? "nd" : b === 3 ? "rd" : "th";
            return number + output;
        }
    });
    utils_hooks__hooks.lang = deprecate("moment.lang is deprecated. Use moment.locale instead.", locale_locales__getSetGlobalLocale);
    utils_hooks__hooks.langData = deprecate("moment.langData is deprecated. Use moment.localeData instead.", locale_locales__getLocale);
    var mathAbs = Math.abs;
    function duration_abs__abs() {
        var data = this._data;
        this._milliseconds = mathAbs(this._milliseconds);
        this._days = mathAbs(this._days);
        this._months = mathAbs(this._months);
        data.milliseconds = mathAbs(data.milliseconds);
        data.seconds = mathAbs(data.seconds);
        data.minutes = mathAbs(data.minutes);
        data.hours = mathAbs(data.hours);
        data.months = mathAbs(data.months);
        data.years = mathAbs(data.years);
        return this;
    }
    function duration_add_subtract__addSubtract(duration, input, value, direction) {
        var other = create__createDuration(input, value);
        duration._milliseconds += direction * other._milliseconds;
        duration._days += direction * other._days;
        duration._months += direction * other._months;
        return duration._bubble();
    }
    function duration_add_subtract__add(input, value) {
        return duration_add_subtract__addSubtract(this, input, value, 1);
    }
    function duration_add_subtract__subtract(input, value) {
        return duration_add_subtract__addSubtract(this, input, value, -1);
    }
    function absCeil(number) {
        if (number < 0) {
            return Math.floor(number);
        } else {
            return Math.ceil(number);
        }
    }
    function bubble() {
        var milliseconds = this._milliseconds;
        var days = this._days;
        var months = this._months;
        var data = this._data;
        var seconds, minutes, hours, years, monthsFromDays;
        if (!(milliseconds >= 0 && days >= 0 && months >= 0 || milliseconds <= 0 && days <= 0 && months <= 0)) {
            milliseconds += absCeil(monthsToDays(months) + days) * 864e5;
            days = 0;
            months = 0;
        }
        data.milliseconds = milliseconds % 1e3;
        seconds = absFloor(milliseconds / 1e3);
        data.seconds = seconds % 60;
        minutes = absFloor(seconds / 60);
        data.minutes = minutes % 60;
        hours = absFloor(minutes / 60);
        data.hours = hours % 24;
        days += absFloor(hours / 24);
        monthsFromDays = absFloor(daysToMonths(days));
        months += monthsFromDays;
        days -= absCeil(monthsToDays(monthsFromDays));
        years = absFloor(months / 12);
        months %= 12;
        data.days = days;
        data.months = months;
        data.years = years;
        return this;
    }
    function daysToMonths(days) {
        return days * 4800 / 146097;
    }
    function monthsToDays(months) {
        return months * 146097 / 4800;
    }
    function as(units) {
        var days;
        var months;
        var milliseconds = this._milliseconds;
        units = normalizeUnits(units);
        if (units === "month" || units === "year") {
            days = this._days + milliseconds / 864e5;
            months = this._months + daysToMonths(days);
            return units === "month" ? months : months / 12;
        } else {
            days = this._days + Math.round(monthsToDays(this._months));
            switch (units) {
              case "week":
                return days / 7 + milliseconds / 6048e5;

              case "day":
                return days + milliseconds / 864e5;

              case "hour":
                return days * 24 + milliseconds / 36e5;

              case "minute":
                return days * 1440 + milliseconds / 6e4;

              case "second":
                return days * 86400 + milliseconds / 1e3;

              case "millisecond":
                return Math.floor(days * 864e5) + milliseconds;

              default:
                throw new Error("Unknown unit " + units);
            }
        }
    }
    function duration_as__valueOf() {
        return this._milliseconds + this._days * 864e5 + this._months % 12 * 2592e6 + toInt(this._months / 12) * 31536e6;
    }
    function makeAs(alias) {
        return function() {
            return this.as(alias);
        };
    }
    var asMilliseconds = makeAs("ms");
    var asSeconds = makeAs("s");
    var asMinutes = makeAs("m");
    var asHours = makeAs("h");
    var asDays = makeAs("d");
    var asWeeks = makeAs("w");
    var asMonths = makeAs("M");
    var asYears = makeAs("y");
    function duration_get__get(units) {
        units = normalizeUnits(units);
        return this[units + "s"]();
    }
    function makeGetter(name) {
        return function() {
            return this._data[name];
        };
    }
    var milliseconds = makeGetter("milliseconds");
    var seconds = makeGetter("seconds");
    var minutes = makeGetter("minutes");
    var hours = makeGetter("hours");
    var days = makeGetter("days");
    var duration_get__months = makeGetter("months");
    var years = makeGetter("years");
    function weeks() {
        return absFloor(this.days() / 7);
    }
    var round = Math.round;
    var thresholds = {
        s: 45,
        m: 45,
        h: 22,
        d: 26,
        M: 11
    };
    function substituteTimeAgo(string, number, withoutSuffix, isFuture, locale) {
        return locale.relativeTime(number || 1, !!withoutSuffix, string, isFuture);
    }
    function duration_humanize__relativeTime(posNegDuration, withoutSuffix, locale) {
        var duration = create__createDuration(posNegDuration).abs();
        var seconds = round(duration.as("s"));
        var minutes = round(duration.as("m"));
        var hours = round(duration.as("h"));
        var days = round(duration.as("d"));
        var months = round(duration.as("M"));
        var years = round(duration.as("y"));
        var a = seconds < thresholds.s && [ "s", seconds ] || minutes === 1 && [ "m" ] || minutes < thresholds.m && [ "mm", minutes ] || hours === 1 && [ "h" ] || hours < thresholds.h && [ "hh", hours ] || days === 1 && [ "d" ] || days < thresholds.d && [ "dd", days ] || months === 1 && [ "M" ] || months < thresholds.M && [ "MM", months ] || years === 1 && [ "y" ] || [ "yy", years ];
        a[2] = withoutSuffix;
        a[3] = +posNegDuration > 0;
        a[4] = locale;
        return substituteTimeAgo.apply(null, a);
    }
    function duration_humanize__getSetRelativeTimeThreshold(threshold, limit) {
        if (thresholds[threshold] === undefined) {
            return false;
        }
        if (limit === undefined) {
            return thresholds[threshold];
        }
        thresholds[threshold] = limit;
        return true;
    }
    function humanize(withSuffix) {
        var locale = this.localeData();
        var output = duration_humanize__relativeTime(this, !withSuffix, locale);
        if (withSuffix) {
            output = locale.pastFuture(+this, output);
        }
        return locale.postformat(output);
    }
    var iso_string__abs = Math.abs;
    function iso_string__toISOString() {
        var seconds = iso_string__abs(this._milliseconds) / 1e3;
        var days = iso_string__abs(this._days);
        var months = iso_string__abs(this._months);
        var minutes, hours, years;
        minutes = absFloor(seconds / 60);
        hours = absFloor(minutes / 60);
        seconds %= 60;
        minutes %= 60;
        years = absFloor(months / 12);
        months %= 12;
        var Y = years;
        var M = months;
        var D = days;
        var h = hours;
        var m = minutes;
        var s = seconds;
        var total = this.asSeconds();
        if (!total) {
            return "P0D";
        }
        return (total < 0 ? "-" : "") + "P" + (Y ? Y + "Y" : "") + (M ? M + "M" : "") + (D ? D + "D" : "") + (h || m || s ? "T" : "") + (h ? h + "H" : "") + (m ? m + "M" : "") + (s ? s + "S" : "");
    }
    var duration_prototype__proto = Duration.prototype;
    duration_prototype__proto.abs = duration_abs__abs;
    duration_prototype__proto.add = duration_add_subtract__add;
    duration_prototype__proto.subtract = duration_add_subtract__subtract;
    duration_prototype__proto.as = as;
    duration_prototype__proto.asMilliseconds = asMilliseconds;
    duration_prototype__proto.asSeconds = asSeconds;
    duration_prototype__proto.asMinutes = asMinutes;
    duration_prototype__proto.asHours = asHours;
    duration_prototype__proto.asDays = asDays;
    duration_prototype__proto.asWeeks = asWeeks;
    duration_prototype__proto.asMonths = asMonths;
    duration_prototype__proto.asYears = asYears;
    duration_prototype__proto.valueOf = duration_as__valueOf;
    duration_prototype__proto._bubble = bubble;
    duration_prototype__proto.get = duration_get__get;
    duration_prototype__proto.milliseconds = milliseconds;
    duration_prototype__proto.seconds = seconds;
    duration_prototype__proto.minutes = minutes;
    duration_prototype__proto.hours = hours;
    duration_prototype__proto.days = days;
    duration_prototype__proto.weeks = weeks;
    duration_prototype__proto.months = duration_get__months;
    duration_prototype__proto.years = years;
    duration_prototype__proto.humanize = humanize;
    duration_prototype__proto.toISOString = iso_string__toISOString;
    duration_prototype__proto.toString = iso_string__toISOString;
    duration_prototype__proto.toJSON = iso_string__toISOString;
    duration_prototype__proto.locale = locale;
    duration_prototype__proto.localeData = localeData;
    duration_prototype__proto.toIsoString = deprecate("toIsoString() is deprecated. Please use toISOString() instead (notice the capitals)", iso_string__toISOString);
    duration_prototype__proto.lang = lang;
    addFormatToken("X", 0, 0, "unix");
    addFormatToken("x", 0, 0, "valueOf");
    addRegexToken("x", matchSigned);
    addRegexToken("X", matchTimestamp);
    addParseToken("X", function(input, array, config) {
        config._d = new Date(parseFloat(input, 10) * 1e3);
    });
    addParseToken("x", function(input, array, config) {
        config._d = new Date(toInt(input));
    });
    utils_hooks__hooks.version = "2.10.6";
    setHookCallback(local__createLocal);
    utils_hooks__hooks.fn = momentPrototype;
    utils_hooks__hooks.min = min;
    utils_hooks__hooks.max = max;
    utils_hooks__hooks.utc = create_utc__createUTC;
    utils_hooks__hooks.unix = moment_moment__createUnix;
    utils_hooks__hooks.months = lists__listMonths;
    utils_hooks__hooks.isDate = isDate;
    utils_hooks__hooks.locale = locale_locales__getSetGlobalLocale;
    utils_hooks__hooks.invalid = valid__createInvalid;
    utils_hooks__hooks.duration = create__createDuration;
    utils_hooks__hooks.isMoment = isMoment;
    utils_hooks__hooks.weekdays = lists__listWeekdays;
    utils_hooks__hooks.parseZone = moment_moment__createInZone;
    utils_hooks__hooks.localeData = locale_locales__getLocale;
    utils_hooks__hooks.isDuration = isDuration;
    utils_hooks__hooks.monthsShort = lists__listMonthsShort;
    utils_hooks__hooks.weekdaysMin = lists__listWeekdaysMin;
    utils_hooks__hooks.defineLocale = defineLocale;
    utils_hooks__hooks.weekdaysShort = lists__listWeekdaysShort;
    utils_hooks__hooks.normalizeUnits = normalizeUnits;
    utils_hooks__hooks.relativeTimeThreshold = duration_humanize__getSetRelativeTimeThreshold;
    var _moment__default = utils_hooks__hooks;
    var af = _moment__default.defineLocale("af", {
        months: "Januarie_Februarie_Maart_April_Mei_Junie_Julie_Augustus_September_Oktober_November_Desember".split("_"),
        monthsShort: "Jan_Feb_Mar_Apr_Mei_Jun_Jul_Aug_Sep_Okt_Nov_Des".split("_"),
        weekdays: "Sondag_Maandag_Dinsdag_Woensdag_Donderdag_Vrydag_Saterdag".split("_"),
        weekdaysShort: "Son_Maa_Din_Woe_Don_Vry_Sat".split("_"),
        weekdaysMin: "So_Ma_Di_Wo_Do_Vr_Sa".split("_"),
        meridiemParse: /vm|nm/i,
        isPM: function(input) {
            return /^nm$/i.test(input);
        },
        meridiem: function(hours, minutes, isLower) {
            if (hours < 12) {
                return isLower ? "vm" : "VM";
            } else {
                return isLower ? "nm" : "NM";
            }
        },
        longDateFormat: {
            LT: "HH:mm",
            LTS: "HH:mm:ss",
            L: "DD/MM/YYYY",
            LL: "D MMMM YYYY",
            LLL: "D MMMM YYYY HH:mm",
            LLLL: "dddd, D MMMM YYYY HH:mm"
        },
        calendar: {
            sameDay: "[Vandag om] LT",
            nextDay: "[MÃ´re om] LT",
            nextWeek: "dddd [om] LT",
            lastDay: "[Gister om] LT",
            lastWeek: "[Laas] dddd [om] LT",
            sameElse: "L"
        },
        relativeTime: {
            future: "oor %s",
            past: "%s gelede",
            s: "'n paar sekondes",
            m: "'n minuut",
            mm: "%d minute",
            h: "'n uur",
            hh: "%d ure",
            d: "'n dag",
            dd: "%d dae",
            M: "'n maand",
            MM: "%d maande",
            y: "'n jaar",
            yy: "%d jaar"
        },
        ordinalParse: /\d{1,2}(ste|de)/,
        ordinal: function(number) {
            return number + (number === 1 || number === 8 || number >= 20 ? "ste" : "de");
        },
        week: {
            dow: 1,
            doy: 4
        }
    });
    var ar_ma = _moment__default.defineLocale("ar-ma", {
        months: "ÙÙØ§ÙØ±_ÙØ¨Ø±Ø§ÙØ±_ÙØ§Ø±Ø³_Ø£Ø¨Ø±ÙÙ_ÙØ§Ù_ÙÙÙÙÙ_ÙÙÙÙÙØ²_ØºØ´Øª_Ø´ØªÙØ¨Ø±_Ø£ÙØªÙØ¨Ø±_ÙÙÙØ¨Ø±_Ø¯Ø¬ÙØ¨Ø±".split("_"),
        monthsShort: "ÙÙØ§ÙØ±_ÙØ¨Ø±Ø§ÙØ±_ÙØ§Ø±Ø³_Ø£Ø¨Ø±ÙÙ_ÙØ§Ù_ÙÙÙÙÙ_ÙÙÙÙÙØ²_ØºØ´Øª_Ø´ØªÙØ¨Ø±_Ø£ÙØªÙØ¨Ø±_ÙÙÙØ¨Ø±_Ø¯Ø¬ÙØ¨Ø±".split("_"),
        weekdays: "Ø§ÙØ£Ø­Ø¯_Ø§ÙØ¥ØªÙÙÙ_Ø§ÙØ«ÙØ§Ø«Ø§Ø¡_Ø§ÙØ£Ø±Ø¨Ø¹Ø§Ø¡_Ø§ÙØ®ÙÙØ³_Ø§ÙØ¬ÙØ¹Ø©_Ø§ÙØ³Ø¨Øª".split("_"),
        weekdaysShort: "Ø§Ø­Ø¯_Ø§ØªÙÙÙ_Ø«ÙØ§Ø«Ø§Ø¡_Ø§Ø±Ø¨Ø¹Ø§Ø¡_Ø®ÙÙØ³_Ø¬ÙØ¹Ø©_Ø³Ø¨Øª".split("_"),
        weekdaysMin: "Ø­_Ù_Ø«_Ø±_Ø®_Ø¬_Ø³".split("_"),
        longDateFormat: {
            LT: "HH:mm",
            LTS: "HH:mm:ss",
            L: "DD/MM/YYYY",
            LL: "D MMMM YYYY",
            LLL: "D MMMM YYYY HH:mm",
            LLLL: "dddd D MMMM YYYY HH:mm"
        },
        calendar: {
            sameDay: "[Ø§ÙÙÙÙ Ø¹ÙÙ Ø§ÙØ³Ø§Ø¹Ø©] LT",
            nextDay: "[ØºØ¯Ø§ Ø¹ÙÙ Ø§ÙØ³Ø§Ø¹Ø©] LT",
            nextWeek: "dddd [Ø¹ÙÙ Ø§ÙØ³Ø§Ø¹Ø©] LT",
            lastDay: "[Ø£ÙØ³ Ø¹ÙÙ Ø§ÙØ³Ø§Ø¹Ø©] LT",
            lastWeek: "dddd [Ø¹ÙÙ Ø§ÙØ³Ø§Ø¹Ø©] LT",
            sameElse: "L"
        },
        relativeTime: {
            future: "ÙÙ %s",
            past: "ÙÙØ° %s",
            s: "Ø«ÙØ§Ù",
            m: "Ø¯ÙÙÙØ©",
            mm: "%d Ø¯ÙØ§Ø¦Ù",
            h: "Ø³Ø§Ø¹Ø©",
            hh: "%d Ø³Ø§Ø¹Ø§Øª",
            d: "ÙÙÙ",
            dd: "%d Ø£ÙØ§Ù",
            M: "Ø´ÙØ±",
            MM: "%d Ø£Ø´ÙØ±",
            y: "Ø³ÙØ©",
            yy: "%d Ø³ÙÙØ§Øª"
        },
        week: {
            dow: 6,
            doy: 12
        }
    });
    var ar_sa__symbolMap = {
        "1": "Ù¡",
        "2": "Ù¢",
        "3": "Ù£",
        "4": "Ù¤",
        "5": "Ù¥",
        "6": "Ù¦",
        "7": "Ù§",
        "8": "Ù¨",
        "9": "Ù©",
        "0": "Ù "
    }, ar_sa__numberMap = {
        "Ù¡": "1",
        "Ù¢": "2",
        "Ù£": "3",
        "Ù¤": "4",
        "Ù¥": "5",
        "Ù¦": "6",
        "Ù§": "7",
        "Ù¨": "8",
        "Ù©": "9",
        "Ù ": "0"
    };
    var ar_sa = _moment__default.defineLocale("ar-sa", {
        months: "ÙÙØ§ÙØ±_ÙØ¨Ø±Ø§ÙØ±_ÙØ§Ø±Ø³_Ø£Ø¨Ø±ÙÙ_ÙØ§ÙÙ_ÙÙÙÙÙ_ÙÙÙÙÙ_Ø£ØºØ³Ø·Ø³_Ø³Ø¨ØªÙØ¨Ø±_Ø£ÙØªÙØ¨Ø±_ÙÙÙÙØ¨Ø±_Ø¯ÙØ³ÙØ¨Ø±".split("_"),
        monthsShort: "ÙÙØ§ÙØ±_ÙØ¨Ø±Ø§ÙØ±_ÙØ§Ø±Ø³_Ø£Ø¨Ø±ÙÙ_ÙØ§ÙÙ_ÙÙÙÙÙ_ÙÙÙÙÙ_Ø£ØºØ³Ø·Ø³_Ø³Ø¨ØªÙØ¨Ø±_Ø£ÙØªÙØ¨Ø±_ÙÙÙÙØ¨Ø±_Ø¯ÙØ³ÙØ¨Ø±".split("_"),
        weekdays: "Ø§ÙØ£Ø­Ø¯_Ø§ÙØ¥Ø«ÙÙÙ_Ø§ÙØ«ÙØ§Ø«Ø§Ø¡_Ø§ÙØ£Ø±Ø¨Ø¹Ø§Ø¡_Ø§ÙØ®ÙÙØ³_Ø§ÙØ¬ÙØ¹Ø©_Ø§ÙØ³Ø¨Øª".split("_"),
        weekdaysShort: "Ø£Ø­Ø¯_Ø¥Ø«ÙÙÙ_Ø«ÙØ§Ø«Ø§Ø¡_Ø£Ø±Ø¨Ø¹Ø§Ø¡_Ø®ÙÙØ³_Ø¬ÙØ¹Ø©_Ø³Ø¨Øª".split("_"),
        weekdaysMin: "Ø­_Ù_Ø«_Ø±_Ø®_Ø¬_Ø³".split("_"),
        longDateFormat: {
            LT: "HH:mm",
            LTS: "HH:mm:ss",
            L: "DD/MM/YYYY",
            LL: "D MMMM YYYY",
            LLL: "D MMMM YYYY HH:mm",
            LLLL: "dddd D MMMM YYYY HH:mm"
        },
        meridiemParse: /Øµ|Ù/,
        isPM: function(input) {
            return "Ù" === input;
        },
        meridiem: function(hour, minute, isLower) {
            if (hour < 12) {
                return "Øµ";
            } else {
                return "Ù";
            }
        },
        calendar: {
            sameDay: "[Ø§ÙÙÙÙ Ø¹ÙÙ Ø§ÙØ³Ø§Ø¹Ø©] LT",
            nextDay: "[ØºØ¯Ø§ Ø¹ÙÙ Ø§ÙØ³Ø§Ø¹Ø©] LT",
            nextWeek: "dddd [Ø¹ÙÙ Ø§ÙØ³Ø§Ø¹Ø©] LT",
            lastDay: "[Ø£ÙØ³ Ø¹ÙÙ Ø§ÙØ³Ø§Ø¹Ø©] LT",
            lastWeek: "dddd [Ø¹ÙÙ Ø§ÙØ³Ø§Ø¹Ø©] LT",
            sameElse: "L"
        },
        relativeTime: {
            future: "ÙÙ %s",
            past: "ÙÙØ° %s",
            s: "Ø«ÙØ§Ù",
            m: "Ø¯ÙÙÙØ©",
            mm: "%d Ø¯ÙØ§Ø¦Ù",
            h: "Ø³Ø§Ø¹Ø©",
            hh: "%d Ø³Ø§Ø¹Ø§Øª",
            d: "ÙÙÙ",
            dd: "%d Ø£ÙØ§Ù",
            M: "Ø´ÙØ±",
            MM: "%d Ø£Ø´ÙØ±",
            y: "Ø³ÙØ©",
            yy: "%d Ø³ÙÙØ§Øª"
        },
        preparse: function(string) {
            return string.replace(/[Ù¡Ù¢Ù£Ù¤Ù¥Ù¦Ù§Ù¨Ù©Ù ]/g, function(match) {
                return ar_sa__numberMap[match];
            }).replace(/Ø/g, ",");
        },
        postformat: function(string) {
            return string.replace(/\d/g, function(match) {
                return ar_sa__symbolMap[match];
            }).replace(/,/g, "Ø");
        },
        week: {
            dow: 6,
            doy: 12
        }
    });
    var ar_tn = _moment__default.defineLocale("ar-tn", {
        months: "Ø¬Ø§ÙÙÙ_ÙÙÙØ±Ù_ÙØ§Ø±Ø³_Ø£ÙØ±ÙÙ_ÙØ§Ù_Ø¬ÙØ§Ù_Ø¬ÙÙÙÙØ©_Ø£ÙØª_Ø³Ø¨ØªÙØ¨Ø±_Ø£ÙØªÙØ¨Ø±_ÙÙÙÙØ¨Ø±_Ø¯ÙØ³ÙØ¨Ø±".split("_"),
        monthsShort: "Ø¬Ø§ÙÙÙ_ÙÙÙØ±Ù_ÙØ§Ø±Ø³_Ø£ÙØ±ÙÙ_ÙØ§Ù_Ø¬ÙØ§Ù_Ø¬ÙÙÙÙØ©_Ø£ÙØª_Ø³Ø¨ØªÙØ¨Ø±_Ø£ÙØªÙØ¨Ø±_ÙÙÙÙØ¨Ø±_Ø¯ÙØ³ÙØ¨Ø±".split("_"),
        weekdays: "Ø§ÙØ£Ø­Ø¯_Ø§ÙØ¥Ø«ÙÙÙ_Ø§ÙØ«ÙØ§Ø«Ø§Ø¡_Ø§ÙØ£Ø±Ø¨Ø¹Ø§Ø¡_Ø§ÙØ®ÙÙØ³_Ø§ÙØ¬ÙØ¹Ø©_Ø§ÙØ³Ø¨Øª".split("_"),
        weekdaysShort: "Ø£Ø­Ø¯_Ø¥Ø«ÙÙÙ_Ø«ÙØ§Ø«Ø§Ø¡_Ø£Ø±Ø¨Ø¹Ø§Ø¡_Ø®ÙÙØ³_Ø¬ÙØ¹Ø©_Ø³Ø¨Øª".split("_"),
        weekdaysMin: "Ø­_Ù_Ø«_Ø±_Ø®_Ø¬_Ø³".split("_"),
        longDateFormat: {
            LT: "HH:mm",
            LTS: "HH:mm:ss",
            L: "DD/MM/YYYY",
            LL: "D MMMM YYYY",
            LLL: "D MMMM YYYY HH:mm",
            LLLL: "dddd D MMMM YYYY HH:mm"
        },
        calendar: {
            sameDay: "[Ø§ÙÙÙÙ Ø¹ÙÙ Ø§ÙØ³Ø§Ø¹Ø©] LT",
            nextDay: "[ØºØ¯Ø§ Ø¹ÙÙ Ø§ÙØ³Ø§Ø¹Ø©] LT",
            nextWeek: "dddd [Ø¹ÙÙ Ø§ÙØ³Ø§Ø¹Ø©] LT",
            lastDay: "[Ø£ÙØ³ Ø¹ÙÙ Ø§ÙØ³Ø§Ø¹Ø©] LT",
            lastWeek: "dddd [Ø¹ÙÙ Ø§ÙØ³Ø§Ø¹Ø©] LT",
            sameElse: "L"
        },
        relativeTime: {
            future: "ÙÙ %s",
            past: "ÙÙØ° %s",
            s: "Ø«ÙØ§Ù",
            m: "Ø¯ÙÙÙØ©",
            mm: "%d Ø¯ÙØ§Ø¦Ù",
            h: "Ø³Ø§Ø¹Ø©",
            hh: "%d Ø³Ø§Ø¹Ø§Øª",
            d: "ÙÙÙ",
            dd: "%d Ø£ÙØ§Ù",
            M: "Ø´ÙØ±",
            MM: "%d Ø£Ø´ÙØ±",
            y: "Ø³ÙØ©",
            yy: "%d Ø³ÙÙØ§Øª"
        },
        week: {
            dow: 1,
            doy: 4
        }
    });
    var ar__symbolMap = {
        "1": "Ù¡",
        "2": "Ù¢",
        "3": "Ù£",
        "4": "Ù¤",
        "5": "Ù¥",
        "6": "Ù¦",
        "7": "Ù§",
        "8": "Ù¨",
        "9": "Ù©",
        "0": "Ù "
    }, ar__numberMap = {
        "Ù¡": "1",
        "Ù¢": "2",
        "Ù£": "3",
        "Ù¤": "4",
        "Ù¥": "5",
        "Ù¦": "6",
        "Ù§": "7",
        "Ù¨": "8",
        "Ù©": "9",
        "Ù ": "0"
    }, pluralForm = function(n) {
        return n === 0 ? 0 : n === 1 ? 1 : n === 2 ? 2 : n % 100 >= 3 && n % 100 <= 10 ? 3 : n % 100 >= 11 ? 4 : 5;
    }, plurals = {
        s: [ "Ø£ÙÙ ÙÙ Ø«Ø§ÙÙØ©", "Ø«Ø§ÙÙØ© ÙØ§Ø­Ø¯Ø©", [ "Ø«Ø§ÙÙØªØ§Ù", "Ø«Ø§ÙÙØªÙÙ" ], "%d Ø«ÙØ§Ù", "%d Ø«Ø§ÙÙØ©", "%d Ø«Ø§ÙÙØ©" ],
        m: [ "Ø£ÙÙ ÙÙ Ø¯ÙÙÙØ©", "Ø¯ÙÙÙØ© ÙØ§Ø­Ø¯Ø©", [ "Ø¯ÙÙÙØªØ§Ù", "Ø¯ÙÙÙØªÙÙ" ], "%d Ø¯ÙØ§Ø¦Ù", "%d Ø¯ÙÙÙØ©", "%d Ø¯ÙÙÙØ©" ],
        h: [ "Ø£ÙÙ ÙÙ Ø³Ø§Ø¹Ø©", "Ø³Ø§Ø¹Ø© ÙØ§Ø­Ø¯Ø©", [ "Ø³Ø§Ø¹ØªØ§Ù", "Ø³Ø§Ø¹ØªÙÙ" ], "%d Ø³Ø§Ø¹Ø§Øª", "%d Ø³Ø§Ø¹Ø©", "%d Ø³Ø§Ø¹Ø©" ],
        d: [ "Ø£ÙÙ ÙÙ ÙÙÙ", "ÙÙÙ ÙØ§Ø­Ø¯", [ "ÙÙÙØ§Ù", "ÙÙÙÙÙ" ], "%d Ø£ÙØ§Ù", "%d ÙÙÙÙØ§", "%d ÙÙÙ" ],
        M: [ "Ø£ÙÙ ÙÙ Ø´ÙØ±", "Ø´ÙØ± ÙØ§Ø­Ø¯", [ "Ø´ÙØ±Ø§Ù", "Ø´ÙØ±ÙÙ" ], "%d Ø£Ø´ÙØ±", "%d Ø´ÙØ±Ø§", "%d Ø´ÙØ±" ],
        y: [ "Ø£ÙÙ ÙÙ Ø¹Ø§Ù", "Ø¹Ø§Ù ÙØ§Ø­Ø¯", [ "Ø¹Ø§ÙØ§Ù", "Ø¹Ø§ÙÙÙ" ], "%d Ø£Ø¹ÙØ§Ù", "%d Ø¹Ø§ÙÙØ§", "%d Ø¹Ø§Ù" ]
    }, pluralize = function(u) {
        return function(number, withoutSuffix, string, isFuture) {
            var f = pluralForm(number), str = plurals[u][pluralForm(number)];
            if (f === 2) {
                str = str[withoutSuffix ? 0 : 1];
            }
            return str.replace(/%d/i, number);
        };
    }, ar__months = [ "ÙØ§ÙÙÙ Ø§ÙØ«Ø§ÙÙ ÙÙØ§ÙØ±", "Ø´Ø¨Ø§Ø· ÙØ¨Ø±Ø§ÙØ±", "Ø¢Ø°Ø§Ø± ÙØ§Ø±Ø³", "ÙÙØ³Ø§Ù Ø£Ø¨Ø±ÙÙ", "Ø£ÙØ§Ø± ÙØ§ÙÙ", "Ø­Ø²ÙØ±Ø§Ù ÙÙÙÙÙ", "ØªÙÙØ² ÙÙÙÙÙ", "Ø¢Ø¨ Ø£ØºØ³Ø·Ø³", "Ø£ÙÙÙÙ Ø³Ø¨ØªÙØ¨Ø±", "ØªØ´Ø±ÙÙ Ø§ÙØ£ÙÙ Ø£ÙØªÙØ¨Ø±", "ØªØ´Ø±ÙÙ Ø§ÙØ«Ø§ÙÙ ÙÙÙÙØ¨Ø±", "ÙØ§ÙÙÙ Ø§ÙØ£ÙÙ Ø¯ÙØ³ÙØ¨Ø±" ];
    var ar = _moment__default.defineLocale("ar", {
        months: ar__months,
        monthsShort: ar__months,
        weekdays: "Ø§ÙØ£Ø­Ø¯_Ø§ÙØ¥Ø«ÙÙÙ_Ø§ÙØ«ÙØ§Ø«Ø§Ø¡_Ø§ÙØ£Ø±Ø¨Ø¹Ø§Ø¡_Ø§ÙØ®ÙÙØ³_Ø§ÙØ¬ÙØ¹Ø©_Ø§ÙØ³Ø¨Øª".split("_"),
        weekdaysShort: "Ø£Ø­Ø¯_Ø¥Ø«ÙÙÙ_Ø«ÙØ§Ø«Ø§Ø¡_Ø£Ø±Ø¨Ø¹Ø§Ø¡_Ø®ÙÙØ³_Ø¬ÙØ¹Ø©_Ø³Ø¨Øª".split("_"),
        weekdaysMin: "Ø­_Ù_Ø«_Ø±_Ø®_Ø¬_Ø³".split("_"),
        longDateFormat: {
            LT: "HH:mm",
            LTS: "HH:mm:ss",
            L: "D/âM/âYYYY",
            LL: "D MMMM YYYY",
            LLL: "D MMMM YYYY HH:mm",
            LLLL: "dddd D MMMM YYYY HH:mm"
        },
        meridiemParse: /Øµ|Ù/,
        isPM: function(input) {
            return "Ù" === input;
        },
        meridiem: function(hour, minute, isLower) {
            if (hour < 12) {
                return "Øµ";
            } else {
                return "Ù";
            }
        },
        calendar: {
            sameDay: "[Ø§ÙÙÙÙ Ø¹ÙØ¯ Ø§ÙØ³Ø§Ø¹Ø©] LT",
            nextDay: "[ØºØ¯ÙØ§ Ø¹ÙØ¯ Ø§ÙØ³Ø§Ø¹Ø©] LT",
            nextWeek: "dddd [Ø¹ÙØ¯ Ø§ÙØ³Ø§Ø¹Ø©] LT",
            lastDay: "[Ø£ÙØ³ Ø¹ÙØ¯ Ø§ÙØ³Ø§Ø¹Ø©] LT",
            lastWeek: "dddd [Ø¹ÙØ¯ Ø§ÙØ³Ø§Ø¹Ø©] LT",
            sameElse: "L"
        },
        relativeTime: {
            future: "Ø¨Ø¹Ø¯ %s",
            past: "ÙÙØ° %s",
            s: pluralize("s"),
            m: pluralize("m"),
            mm: pluralize("m"),
            h: pluralize("h"),
            hh: pluralize("h"),
            d: pluralize("d"),
            dd: pluralize("d"),
            M: pluralize("M"),
            MM: pluralize("M"),
            y: pluralize("y"),
            yy: pluralize("y")
        },
        preparse: function(string) {
            return string.replace(/\u200f/g, "").replace(/[Ù¡Ù¢Ù£Ù¤Ù¥Ù¦Ù§Ù¨Ù©Ù ]/g, function(match) {
                return ar__numberMap[match];
            }).replace(/Ø/g, ",");
        },
        postformat: function(string) {
            return string.replace(/\d/g, function(match) {
                return ar__symbolMap[match];
            }).replace(/,/g, "Ø");
        },
        week: {
            dow: 6,
            doy: 12
        }
    });
    var az__suffixes = {
        1: "-inci",
        5: "-inci",
        8: "-inci",
        70: "-inci",
        80: "-inci",
        2: "-nci",
        7: "-nci",
        20: "-nci",
        50: "-nci",
        3: "-Ã¼ncÃ¼",
        4: "-Ã¼ncÃ¼",
        100: "-Ã¼ncÃ¼",
        6: "-ncÄ±",
        9: "-uncu",
        10: "-uncu",
        30: "-uncu",
        60: "-Ä±ncÄ±",
        90: "-Ä±ncÄ±"
    };
    var az = _moment__default.defineLocale("az", {
        months: "yanvar_fevral_mart_aprel_may_iyun_iyul_avqust_sentyabr_oktyabr_noyabr_dekabr".split("_"),
        monthsShort: "yan_fev_mar_apr_may_iyn_iyl_avq_sen_okt_noy_dek".split("_"),
        weekdays: "Bazar_Bazar ertÉsi_ÃÉrÅÉnbÉ axÅamÄ±_ÃÉrÅÉnbÉ_CÃ¼mÉ axÅamÄ±_CÃ¼mÉ_ÅÉnbÉ".split("_"),
        weekdaysShort: "Baz_BzE_ÃAx_ÃÉr_CAx_CÃ¼m_ÅÉn".split("_"),
        weekdaysMin: "Bz_BE_ÃA_ÃÉ_CA_CÃ¼_ÅÉ".split("_"),
        longDateFormat: {
            LT: "HH:mm",
            LTS: "HH:mm:ss",
            L: "DD.MM.YYYY",
            LL: "D MMMM YYYY",
            LLL: "D MMMM YYYY HH:mm",
            LLLL: "dddd, D MMMM YYYY HH:mm"
        },
        calendar: {
            sameDay: "[bugÃ¼n saat] LT",
            nextDay: "[sabah saat] LT",
            nextWeek: "[gÉlÉn hÉftÉ] dddd [saat] LT",
            lastDay: "[dÃ¼nÉn] LT",
            lastWeek: "[keÃ§Én hÉftÉ] dddd [saat] LT",
            sameElse: "L"
        },
        relativeTime: {
            future: "%s sonra",
            past: "%s ÉvvÉl",
            s: "birneÃ§É saniyyÉ",
            m: "bir dÉqiqÉ",
            mm: "%d dÉqiqÉ",
            h: "bir saat",
            hh: "%d saat",
            d: "bir gÃ¼n",
            dd: "%d gÃ¼n",
            M: "bir ay",
            MM: "%d ay",
            y: "bir il",
            yy: "%d il"
        },
        meridiemParse: /gecÉ|sÉhÉr|gÃ¼ndÃ¼z|axÅam/,
        isPM: function(input) {
            return /^(gÃ¼ndÃ¼z|axÅam)$/.test(input);
        },
        meridiem: function(hour, minute, isLower) {
            if (hour < 4) {
                return "gecÉ";
            } else if (hour < 12) {
                return "sÉhÉr";
            } else if (hour < 17) {
                return "gÃ¼ndÃ¼z";
            } else {
                return "axÅam";
            }
        },
        ordinalParse: /\d{1,2}-(Ä±ncÄ±|inci|nci|Ã¼ncÃ¼|ncÄ±|uncu)/,
        ordinal: function(number) {
            if (number === 0) {
                return number + "-Ä±ncÄ±";
            }
            var a = number % 10, b = number % 100 - a, c = number >= 100 ? 100 : null;
            return number + (az__suffixes[a] || az__suffixes[b] || az__suffixes[c]);
        },
        week: {
            dow: 1,
            doy: 7
        }
    });
    function be__plural(word, num) {
        var forms = word.split("_");
        return num % 10 === 1 && num % 100 !== 11 ? forms[0] : num % 10 >= 2 && num % 10 <= 4 && (num % 100 < 10 || num % 100 >= 20) ? forms[1] : forms[2];
    }
    function be__relativeTimeWithPlural(number, withoutSuffix, key) {
        var format = {
            mm: withoutSuffix ? "ÑÐ²ÑÐ»ÑÐ½Ð°_ÑÐ²ÑÐ»ÑÐ½Ñ_ÑÐ²ÑÐ»ÑÐ½" : "ÑÐ²ÑÐ»ÑÐ½Ñ_ÑÐ²ÑÐ»ÑÐ½Ñ_ÑÐ²ÑÐ»ÑÐ½",
            hh: withoutSuffix ? "Ð³Ð°Ð´Ð·ÑÐ½Ð°_Ð³Ð°Ð´Ð·ÑÐ½Ñ_Ð³Ð°Ð´Ð·ÑÐ½" : "Ð³Ð°Ð´Ð·ÑÐ½Ñ_Ð³Ð°Ð´Ð·ÑÐ½Ñ_Ð³Ð°Ð´Ð·ÑÐ½",
            dd: "Ð´Ð·ÐµÐ½Ñ_Ð´Ð½Ñ_Ð´Ð·ÑÐ½",
            MM: "Ð¼ÐµÑÑÑ_Ð¼ÐµÑÑÑÑ_Ð¼ÐµÑÑÑÐ°Ñ",
            yy: "Ð³Ð¾Ð´_Ð³Ð°Ð´Ñ_Ð³Ð°Ð´Ð¾Ñ"
        };
        if (key === "m") {
            return withoutSuffix ? "ÑÐ²ÑÐ»ÑÐ½Ð°" : "ÑÐ²ÑÐ»ÑÐ½Ñ";
        } else if (key === "h") {
            return withoutSuffix ? "Ð³Ð°Ð´Ð·ÑÐ½Ð°" : "Ð³Ð°Ð´Ð·ÑÐ½Ñ";
        } else {
            return number + " " + be__plural(format[key], +number);
        }
    }
    function be__monthsCaseReplace(m, format) {
        var months = {
            nominative: "ÑÑÑÐ´Ð·ÐµÐ½Ñ_Ð»ÑÑÑ_ÑÐ°ÐºÐ°Ð²ÑÐº_ÐºÑÐ°ÑÐ°Ð²ÑÐº_ÑÑÐ°Ð²ÐµÐ½Ñ_ÑÑÑÐ²ÐµÐ½Ñ_Ð»ÑÐ¿ÐµÐ½Ñ_Ð¶Ð½ÑÐ²ÐµÐ½Ñ_Ð²ÐµÑÐ°ÑÐµÐ½Ñ_ÐºÐ°ÑÑÑÑÑÐ½ÑÐº_Ð»ÑÑÑÐ°Ð¿Ð°Ð´_ÑÐ½ÐµÐ¶Ð°Ð½Ñ".split("_"),
            accusative: "ÑÑÑÐ´Ð·ÐµÐ½Ñ_Ð»ÑÑÐ°Ð³Ð°_ÑÐ°ÐºÐ°Ð²ÑÐºÐ°_ÐºÑÐ°ÑÐ°Ð²ÑÐºÐ°_ÑÑÐ°ÑÐ½Ñ_ÑÑÑÐ²ÐµÐ½Ñ_Ð»ÑÐ¿ÐµÐ½Ñ_Ð¶Ð½ÑÑÐ½Ñ_Ð²ÐµÑÐ°ÑÐ½Ñ_ÐºÐ°ÑÑÑÑÑÐ½ÑÐºÐ°_Ð»ÑÑÑÐ°Ð¿Ð°Ð´Ð°_ÑÐ½ÐµÐ¶Ð½Ñ".split("_")
        }, nounCase = /D[oD]?(\[[^\[\]]*\]|\s+)+MMMM?/.test(format) ? "accusative" : "nominative";
        return months[nounCase][m.month()];
    }
    function be__weekdaysCaseReplace(m, format) {
        var weekdays = {
            nominative: "Ð½ÑÐ´Ð·ÐµÐ»Ñ_Ð¿Ð°Ð½ÑÐ´Ð·ÐµÐ»Ð°Ðº_Ð°ÑÑÐ¾ÑÐ°Ðº_ÑÐµÑÐ°Ð´Ð°_ÑÐ°ÑÐ²ÐµÑ_Ð¿ÑÑÐ½ÑÑÐ°_ÑÑÐ±Ð¾ÑÐ°".split("_"),
            accusative: "Ð½ÑÐ´Ð·ÐµÐ»Ñ_Ð¿Ð°Ð½ÑÐ´Ð·ÐµÐ»Ð°Ðº_Ð°ÑÑÐ¾ÑÐ°Ðº_ÑÐµÑÐ°Ð´Ñ_ÑÐ°ÑÐ²ÐµÑ_Ð¿ÑÑÐ½ÑÑÑ_ÑÑÐ±Ð¾ÑÑ".split("_")
        }, nounCase = /\[ ?[ÐÐ²] ?(?:Ð¼ÑÐ½ÑÐ»ÑÑ|Ð½Ð°ÑÑÑÐ¿Ð½ÑÑ)? ?\] ?dddd/.test(format) ? "accusative" : "nominative";
        return weekdays[nounCase][m.day()];
    }
    var be = _moment__default.defineLocale("be", {
        months: be__monthsCaseReplace,
        monthsShort: "ÑÑÑÐ´_Ð»ÑÑ_ÑÐ°Ðº_ÐºÑÐ°Ñ_ÑÑÐ°Ð²_ÑÑÑÐ²_Ð»ÑÐ¿_Ð¶Ð½ÑÐ²_Ð²ÐµÑ_ÐºÐ°ÑÑ_Ð»ÑÑÑ_ÑÐ½ÐµÐ¶".split("_"),
        weekdays: be__weekdaysCaseReplace,
        weekdaysShort: "Ð½Ð´_Ð¿Ð½_Ð°Ñ_ÑÑ_ÑÑ_Ð¿Ñ_ÑÐ±".split("_"),
        weekdaysMin: "Ð½Ð´_Ð¿Ð½_Ð°Ñ_ÑÑ_ÑÑ_Ð¿Ñ_ÑÐ±".split("_"),
        longDateFormat: {
            LT: "HH:mm",
            LTS: "HH:mm:ss",
            L: "DD.MM.YYYY",
            LL: "D MMMM YYYY Ð³.",
            LLL: "D MMMM YYYY Ð³., HH:mm",
            LLLL: "dddd, D MMMM YYYY Ð³., HH:mm"
        },
        calendar: {
            sameDay: "[Ð¡ÑÐ½Ð½Ñ Ñ] LT",
            nextDay: "[ÐÐ°ÑÑÑÐ° Ñ] LT",
            lastDay: "[Ð£ÑÐ¾ÑÐ° Ñ] LT",
            nextWeek: function() {
                return "[Ð£] dddd [Ñ] LT";
            },
            lastWeek: function() {
                switch (this.day()) {
                  case 0:
                  case 3:
                  case 5:
                  case 6:
                    return "[Ð£ Ð¼ÑÐ½ÑÐ»ÑÑ] dddd [Ñ] LT";

                  case 1:
                  case 2:
                  case 4:
                    return "[Ð£ Ð¼ÑÐ½ÑÐ»Ñ] dddd [Ñ] LT";
                }
            },
            sameElse: "L"
        },
        relativeTime: {
            future: "Ð¿ÑÐ°Ð· %s",
            past: "%s ÑÐ°Ð¼Ñ",
            s: "Ð½ÐµÐºÐ°Ð»ÑÐºÑ ÑÐµÐºÑÐ½Ð´",
            m: be__relativeTimeWithPlural,
            mm: be__relativeTimeWithPlural,
            h: be__relativeTimeWithPlural,
            hh: be__relativeTimeWithPlural,
            d: "Ð´Ð·ÐµÐ½Ñ",
            dd: be__relativeTimeWithPlural,
            M: "Ð¼ÐµÑÑÑ",
            MM: be__relativeTimeWithPlural,
            y: "Ð³Ð¾Ð´",
            yy: be__relativeTimeWithPlural
        },
        meridiemParse: /Ð½Ð¾ÑÑ|ÑÐ°Ð½ÑÑÑ|Ð´Ð½Ñ|Ð²ÐµÑÐ°ÑÐ°/,
        isPM: function(input) {
            return /^(Ð´Ð½Ñ|Ð²ÐµÑÐ°ÑÐ°)$/.test(input);
        },
        meridiem: function(hour, minute, isLower) {
            if (hour < 4) {
                return "Ð½Ð¾ÑÑ";
            } else if (hour < 12) {
                return "ÑÐ°Ð½ÑÑÑ";
            } else if (hour < 17) {
                return "Ð´Ð½Ñ";
            } else {
                return "Ð²ÐµÑÐ°ÑÐ°";
            }
        },
        ordinalParse: /\d{1,2}-(Ñ|Ñ|Ð³Ð°)/,
        ordinal: function(number, period) {
            switch (period) {
              case "M":
              case "d":
              case "DDD":
              case "w":
              case "W":
                return (number % 10 === 2 || number % 10 === 3) && (number % 100 !== 12 && number % 100 !== 13) ? number + "-Ñ" : number + "-Ñ";

              case "D":
                return number + "-Ð³Ð°";

              default:
                return number;
            }
        },
        week: {
            dow: 1,
            doy: 7
        }
    });
    var bg = _moment__default.defineLocale("bg", {
        months: "ÑÐ½ÑÐ°ÑÐ¸_ÑÐµÐ²ÑÑÐ°ÑÐ¸_Ð¼Ð°ÑÑ_Ð°Ð¿ÑÐ¸Ð»_Ð¼Ð°Ð¹_ÑÐ½Ð¸_ÑÐ»Ð¸_Ð°Ð²Ð³ÑÑÑ_ÑÐµÐ¿ÑÐµÐ¼Ð²ÑÐ¸_Ð¾ÐºÑÐ¾Ð¼Ð²ÑÐ¸_Ð½Ð¾ÐµÐ¼Ð²ÑÐ¸_Ð´ÐµÐºÐµÐ¼Ð²ÑÐ¸".split("_"),
        monthsShort: "ÑÐ½Ñ_ÑÐµÐ²_Ð¼Ð°Ñ_Ð°Ð¿Ñ_Ð¼Ð°Ð¹_ÑÐ½Ð¸_ÑÐ»Ð¸_Ð°Ð²Ð³_ÑÐµÐ¿_Ð¾ÐºÑ_Ð½Ð¾Ðµ_Ð´ÐµÐº".split("_"),
        weekdays: "Ð½ÐµÐ´ÐµÐ»Ñ_Ð¿Ð¾Ð½ÐµÐ´ÐµÐ»Ð½Ð¸Ðº_Ð²ÑÐ¾ÑÐ½Ð¸Ðº_ÑÑÑÐ´Ð°_ÑÐµÑÐ²ÑÑÑÑÐº_Ð¿ÐµÑÑÐº_ÑÑÐ±Ð¾ÑÐ°".split("_"),
        weekdaysShort: "Ð½ÐµÐ´_Ð¿Ð¾Ð½_Ð²ÑÐ¾_ÑÑÑ_ÑÐµÑ_Ð¿ÐµÑ_ÑÑÐ±".split("_"),
        weekdaysMin: "Ð½Ð´_Ð¿Ð½_Ð²Ñ_ÑÑ_ÑÑ_Ð¿Ñ_ÑÐ±".split("_"),
        longDateFormat: {
            LT: "H:mm",
            LTS: "H:mm:ss",
            L: "D.MM.YYYY",
            LL: "D MMMM YYYY",
            LLL: "D MMMM YYYY H:mm",
            LLLL: "dddd, D MMMM YYYY H:mm"
        },
        calendar: {
            sameDay: "[ÐÐ½ÐµÑ Ð²] LT",
            nextDay: "[Ð£ÑÑÐµ Ð²] LT",
            nextWeek: "dddd [Ð²] LT",
            lastDay: "[ÐÑÐµÑÐ° Ð²] LT",
            lastWeek: function() {
                switch (this.day()) {
                  case 0:
                  case 3:
                  case 6:
                    return "[Ð Ð¸Ð·Ð¼Ð¸Ð½Ð°Ð»Ð°ÑÐ°] dddd [Ð²] LT";

                  case 1:
                  case 2:
                  case 4:
                  case 5:
                    return "[Ð Ð¸Ð·Ð¼Ð¸Ð½Ð°Ð»Ð¸Ñ] dddd [Ð²] LT";
                }
            },
            sameElse: "L"
        },
        relativeTime: {
            future: "ÑÐ»ÐµÐ´ %s",
            past: "Ð¿ÑÐµÐ´Ð¸ %s",
            s: "Ð½ÑÐºÐ¾Ð»ÐºÐ¾ ÑÐµÐºÑÐ½Ð´Ð¸",
            m: "Ð¼Ð¸Ð½ÑÑÐ°",
            mm: "%d Ð¼Ð¸Ð½ÑÑÐ¸",
            h: "ÑÐ°Ñ",
            hh: "%d ÑÐ°ÑÐ°",
            d: "Ð´ÐµÐ½",
            dd: "%d Ð´Ð½Ð¸",
            M: "Ð¼ÐµÑÐµÑ",
            MM: "%d Ð¼ÐµÑÐµÑÐ°",
            y: "Ð³Ð¾Ð´Ð¸Ð½Ð°",
            yy: "%d Ð³Ð¾Ð´Ð¸Ð½Ð¸"
        },
        ordinalParse: /\d{1,2}-(ÐµÐ²|ÐµÐ½|ÑÐ¸|Ð²Ð¸|ÑÐ¸|Ð¼Ð¸)/,
        ordinal: function(number) {
            var lastDigit = number % 10, last2Digits = number % 100;
            if (number === 0) {
                return number + "-ÐµÐ²";
            } else if (last2Digits === 0) {
                return number + "-ÐµÐ½";
            } else if (last2Digits > 10 && last2Digits < 20) {
                return number + "-ÑÐ¸";
            } else if (lastDigit === 1) {
                return number + "-Ð²Ð¸";
            } else if (lastDigit === 2) {
                return number + "-ÑÐ¸";
            } else if (lastDigit === 7 || lastDigit === 8) {
                return number + "-Ð¼Ð¸";
            } else {
                return number + "-ÑÐ¸";
            }
        },
        week: {
            dow: 1,
            doy: 7
        }
    });
    var bn__symbolMap = {
        "1": "à§§",
        "2": "à§¨",
        "3": "à§©",
        "4": "à§ª",
        "5": "à§«",
        "6": "à§¬",
        "7": "à§­",
        "8": "à§®",
        "9": "à§¯",
        "0": "à§¦"
    }, bn__numberMap = {
        "à§§": "1",
        "à§¨": "2",
        "à§©": "3",
        "à§ª": "4",
        "à§«": "5",
        "à§¬": "6",
        "à§­": "7",
        "à§®": "8",
        "à§¯": "9",
        "à§¦": "0"
    };
    var bn = _moment__default.defineLocale("bn", {
        months: "à¦à¦¾à¦¨à§à§à¦¾à¦°à§_à¦«à§à¦¬à§à§à¦¾à¦°à§_à¦®à¦¾à¦°à§à¦_à¦à¦ªà§à¦°à¦¿à¦²_à¦®à§_à¦à§à¦¨_à¦à§à¦²à¦¾à¦_à¦à¦à¦¾à¦¸à§à¦_à¦¸à§à¦ªà§à¦à§à¦®à§à¦¬à¦°_à¦à¦à§à¦à§à¦¬à¦°_à¦¨à¦­à§à¦®à§à¦¬à¦°_à¦¡à¦¿à¦¸à§à¦®à§à¦¬à¦°".split("_"),
        monthsShort: "à¦à¦¾à¦¨à§_à¦«à§à¦¬_à¦®à¦¾à¦°à§à¦_à¦à¦ªà¦°_à¦®à§_à¦à§à¦¨_à¦à§à¦²_à¦à¦_à¦¸à§à¦ªà§à¦_à¦à¦à§à¦à§_à¦¨à¦­_à¦¡à¦¿à¦¸à§à¦®à§".split("_"),
        weekdays: "à¦°à¦¬à¦¿à¦¬à¦¾à¦°_à¦¸à§à¦®à¦¬à¦¾à¦°_à¦®à¦à§à¦à¦²à¦¬à¦¾à¦°_à¦¬à§à¦§à¦¬à¦¾à¦°_à¦¬à§à¦¹à¦¸à§à¦ªà¦¤à§à¦¤à¦¿à¦¬à¦¾à¦°_à¦¶à§à¦à§à¦°à§à¦¬à¦¾à¦°_à¦¶à¦¨à¦¿à¦¬à¦¾à¦°".split("_"),
        weekdaysShort: "à¦°à¦¬à¦¿_à¦¸à§à¦®_à¦®à¦à§à¦à¦²_à¦¬à§à¦§_à¦¬à§à¦¹à¦¸à§à¦ªà¦¤à§à¦¤à¦¿_à¦¶à§à¦à§à¦°à§_à¦¶à¦¨à¦¿".split("_"),
        weekdaysMin: "à¦°à¦¬_à¦¸à¦®_à¦®à¦à§à¦_à¦¬à§_à¦¬à§à¦°à¦¿à¦¹_à¦¶à§_à¦¶à¦¨à¦¿".split("_"),
        longDateFormat: {
            LT: "A h:mm à¦¸à¦®à§",
            LTS: "A h:mm:ss à¦¸à¦®à§",
            L: "DD/MM/YYYY",
            LL: "D MMMM YYYY",
            LLL: "D MMMM YYYY, A h:mm à¦¸à¦®à§",
            LLLL: "dddd, D MMMM YYYY, A h:mm à¦¸à¦®à§"
        },
        calendar: {
            sameDay: "[à¦à¦] LT",
            nextDay: "[à¦à¦à¦¾à¦®à§à¦à¦¾à¦²] LT",
            nextWeek: "dddd, LT",
            lastDay: "[à¦à¦¤à¦à¦¾à¦²] LT",
            lastWeek: "[à¦à¦¤] dddd, LT",
            sameElse: "L"
        },
        relativeTime: {
            future: "%s à¦ªà¦°à§",
            past: "%s à¦à¦à§",
            s: "à¦à¦à¦ à¦¸à§à¦à§à¦¨à§à¦¡",
            m: "à¦à¦ à¦®à¦¿à¦¨à¦¿à¦",
            mm: "%d à¦®à¦¿à¦¨à¦¿à¦",
            h: "à¦à¦ à¦à¦¨à§à¦à¦¾",
            hh: "%d à¦à¦¨à§à¦à¦¾",
            d: "à¦à¦ à¦¦à¦¿à¦¨",
            dd: "%d à¦¦à¦¿à¦¨",
            M: "à¦à¦ à¦®à¦¾à¦¸",
            MM: "%d à¦®à¦¾à¦¸",
            y: "à¦à¦ à¦¬à¦à¦°",
            yy: "%d à¦¬à¦à¦°"
        },
        preparse: function(string) {
            return string.replace(/[à§§à§¨à§©à§ªà§«à§¬à§­à§®à§¯à§¦]/g, function(match) {
                return bn__numberMap[match];
            });
        },
        postformat: function(string) {
            return string.replace(/\d/g, function(match) {
                return bn__symbolMap[match];
            });
        },
        meridiemParse: /à¦°à¦¾à¦¤|à¦¸à¦à¦¾à¦²|à¦¦à§à¦ªà§à¦°|à¦¬à¦¿à¦à§à¦²|à¦°à¦¾à¦¤/,
        isPM: function(input) {
            return /^(à¦¦à§à¦ªà§à¦°|à¦¬à¦¿à¦à§à¦²|à¦°à¦¾à¦¤)$/.test(input);
        },
        meridiem: function(hour, minute, isLower) {
            if (hour < 4) {
                return "à¦°à¦¾à¦¤";
            } else if (hour < 10) {
                return "à¦¸à¦à¦¾à¦²";
            } else if (hour < 17) {
                return "à¦¦à§à¦ªà§à¦°";
            } else if (hour < 20) {
                return "à¦¬à¦¿à¦à§à¦²";
            } else {
                return "à¦°à¦¾à¦¤";
            }
        },
        week: {
            dow: 0,
            doy: 6
        }
    });
    var bo__symbolMap = {
        "1": "à¼¡",
        "2": "à¼¢",
        "3": "à¼£",
        "4": "à¼¤",
        "5": "à¼¥",
        "6": "à¼¦",
        "7": "à¼§",
        "8": "à¼¨",
        "9": "à¼©",
        "0": "à¼ "
    }, bo__numberMap = {
        "à¼¡": "1",
        "à¼¢": "2",
        "à¼£": "3",
        "à¼¤": "4",
        "à¼¥": "5",
        "à¼¦": "6",
        "à¼§": "7",
        "à¼¨": "8",
        "à¼©": "9",
        "à¼ ": "0"
    };
    var bo = _moment__default.defineLocale("bo", {
        months: "à½à¾³à¼à½à¼à½à½à¼à½à½¼_à½à¾³à¼à½à¼à½à½à½²à½¦à¼à½_à½à¾³à¼à½à¼à½à½¦à½´à½à¼à½_à½à¾³à¼à½à¼à½à½à½²à¼à½_à½à¾³à¼à½à¼à½£à¾à¼à½_à½à¾³à¼à½à¼à½à¾²à½´à½à¼à½_à½à¾³à¼à½à¼à½à½à½´à½à¼à½_à½à¾³à¼à½à¼à½à½¢à¾à¾±à½à¼à½_à½à¾³à¼à½à¼à½à½à½´à¼à½_à½à¾³à¼à½à¼à½à½à½´à¼à½_à½à¾³à¼à½à¼à½à½à½´à¼à½à½à½²à½à¼à½_à½à¾³à¼à½à¼à½à½à½´à¼à½à½à½²à½¦à¼à½".split("_"),
        monthsShort: "à½à¾³à¼à½à¼à½à½à¼à½à½¼_à½à¾³à¼à½à¼à½à½à½²à½¦à¼à½_à½à¾³à¼à½à¼à½à½¦à½´à½à¼à½_à½à¾³à¼à½à¼à½à½à½²à¼à½_à½à¾³à¼à½à¼à½£à¾à¼à½_à½à¾³à¼à½à¼à½à¾²à½´à½à¼à½_à½à¾³à¼à½à¼à½à½à½´à½à¼à½_à½à¾³à¼à½à¼à½à½¢à¾à¾±à½à¼à½_à½à¾³à¼à½à¼à½à½à½´à¼à½_à½à¾³à¼à½à¼à½à½à½´à¼à½_à½à¾³à¼à½à¼à½à½à½´à¼à½à½à½²à½à¼à½_à½à¾³à¼à½à¼à½à½à½´à¼à½à½à½²à½¦à¼à½".split("_"),
        weekdays: "à½à½à½ à¼à½à½²à¼à½à¼_à½à½à½ à¼à½à¾³à¼à½à¼_à½à½à½ à¼à½à½²à½à¼à½à½à½¢à¼_à½à½à½ à¼à½£à¾·à½à¼à½à¼_à½à½à½ à¼à½à½´à½¢à¼à½à½´_à½à½à½ à¼à½à¼à½¦à½à½¦à¼_à½à½à½ à¼à½¦à¾¤à½ºà½à¼à½à¼".split("_"),
        weekdaysShort: "à½à½²à¼à½à¼_à½à¾³à¼à½à¼_à½à½²à½à¼à½à½à½¢à¼_à½£à¾·à½à¼à½à¼_à½à½´à½¢à¼à½à½´_à½à¼à½¦à½à½¦à¼_à½¦à¾¤à½ºà½à¼à½à¼".split("_"),
        weekdaysMin: "à½à½²à¼à½à¼_à½à¾³à¼à½à¼_à½à½²à½à¼à½à½à½¢à¼_à½£à¾·à½à¼à½à¼_à½à½´à½¢à¼à½à½´_à½à¼à½¦à½à½¦à¼_à½¦à¾¤à½ºà½à¼à½à¼".split("_"),
        longDateFormat: {
            LT: "A h:mm",
            LTS: "A h:mm:ss",
            L: "DD/MM/YYYY",
            LL: "D MMMM YYYY",
            LLL: "D MMMM YYYY, A h:mm",
            LLLL: "dddd, D MMMM YYYY, A h:mm"
        },
        calendar: {
            sameDay: "[à½à½²à¼à½¢à½²à½] LT",
            nextDay: "[à½¦à½à¼à½à½²à½] LT",
            nextWeek: "[à½à½à½´à½à¼à½à¾²à½à¼à½¢à¾à½ºà½¦à¼à½], LT",
            lastDay: "[à½à¼à½¦à½] LT",
            lastWeek: "[à½à½à½´à½à¼à½à¾²à½à¼à½à½à½ à¼à½] dddd, LT",
            sameElse: "L"
        },
        relativeTime: {
            future: "%s à½£à¼",
            past: "%s à½¦à¾à½à¼à½£",
            s: "à½£à½à¼à½¦à½",
            m: "à½¦à¾à½¢à¼à½à¼à½à½à½²à½",
            mm: "%d à½¦à¾à½¢à¼à½",
            h: "à½à½´à¼à½à½¼à½à¼à½à½à½²à½",
            hh: "%d à½à½´à¼à½à½¼à½",
            d: "à½à½²à½à¼à½à½à½²à½",
            dd: "%d à½à½²à½à¼",
            M: "à½à¾³à¼à½à¼à½à½à½²à½",
            MM: "%d à½à¾³à¼à½",
            y: "à½£à½¼à¼à½à½à½²à½",
            yy: "%d à½£à½¼"
        },
        preparse: function(string) {
            return string.replace(/[à¼¡à¼¢à¼£à¼¤à¼¥à¼¦à¼§à¼¨à¼©à¼ ]/g, function(match) {
                return bo__numberMap[match];
            });
        },
        postformat: function(string) {
            return string.replace(/\d/g, function(match) {
                return bo__symbolMap[match];
            });
        },
        meridiemParse: /à½à½à½à¼à½à½¼|à½à½¼à½à½¦à¼à½à½¦|à½à½²à½à¼à½à½´à½|à½à½à½¼à½à¼à½à½|à½à½à½à¼à½à½¼/,
        isPM: function(input) {
            return /^(à½à½²à½à¼à½à½´à½|à½à½à½¼à½à¼à½à½|à½à½à½à¼à½à½¼)$/.test(input);
        },
        meridiem: function(hour, minute, isLower) {
            if (hour < 4) {
                return "à½à½à½à¼à½à½¼";
            } else if (hour < 10) {
                return "à½à½¼à½à½¦à¼à½à½¦";
            } else if (hour < 17) {
                return "à½à½²à½à¼à½à½´à½";
            } else if (hour < 20) {
                return "à½à½à½¼à½à¼à½à½";
            } else {
                return "à½à½à½à¼à½à½¼";
            }
        },
        week: {
            dow: 0,
            doy: 6
        }
    });
    function relativeTimeWithMutation(number, withoutSuffix, key) {
        var format = {
            mm: "munutenn",
            MM: "miz",
            dd: "devezh"
        };
        return number + " " + mutation(format[key], number);
    }
    function specialMutationForYears(number) {
        switch (lastNumber(number)) {
          case 1:
          case 3:
          case 4:
          case 5:
          case 9:
            return number + " bloaz";

          default:
            return number + " vloaz";
        }
    }
    function lastNumber(number) {
        if (number > 9) {
            return lastNumber(number % 10);
        }
        return number;
    }
    function mutation(text, number) {
        if (number === 2) {
            return softMutation(text);
        }
        return text;
    }
    function softMutation(text) {
        var mutationTable = {
            m: "v",
            b: "v",
            d: "z"
        };
        if (mutationTable[text.charAt(0)] === undefined) {
            return text;
        }
        return mutationTable[text.charAt(0)] + text.substring(1);
    }
    var br = _moment__default.defineLocale("br", {
        months: "Genver_C'hwevrer_Meurzh_Ebrel_Mae_Mezheven_Gouere_Eost_Gwengolo_Here_Du_Kerzu".split("_"),
        monthsShort: "Gen_C'hwe_Meu_Ebr_Mae_Eve_Gou_Eos_Gwe_Her_Du_Ker".split("_"),
        weekdays: "Sul_Lun_Meurzh_Merc'her_Yaou_Gwener_Sadorn".split("_"),
        weekdaysShort: "Sul_Lun_Meu_Mer_Yao_Gwe_Sad".split("_"),
        weekdaysMin: "Su_Lu_Me_Mer_Ya_Gw_Sa".split("_"),
        longDateFormat: {
            LT: "h[e]mm A",
            LTS: "h[e]mm:ss A",
            L: "DD/MM/YYYY",
            LL: "D [a viz] MMMM YYYY",
            LLL: "D [a viz] MMMM YYYY h[e]mm A",
            LLLL: "dddd, D [a viz] MMMM YYYY h[e]mm A"
        },
        calendar: {
            sameDay: "[Hiziv da] LT",
            nextDay: "[Warc'hoazh da] LT",
            nextWeek: "dddd [da] LT",
            lastDay: "[Dec'h da] LT",
            lastWeek: "dddd [paset da] LT",
            sameElse: "L"
        },
        relativeTime: {
            future: "a-benn %s",
            past: "%s 'zo",
            s: "un nebeud segondennoÃ¹",
            m: "ur vunutenn",
            mm: relativeTimeWithMutation,
            h: "un eur",
            hh: "%d eur",
            d: "un devezh",
            dd: relativeTimeWithMutation,
            M: "ur miz",
            MM: relativeTimeWithMutation,
            y: "ur bloaz",
            yy: specialMutationForYears
        },
        ordinalParse: /\d{1,2}(aÃ±|vet)/,
        ordinal: function(number) {
            var output = number === 1 ? "aÃ±" : "vet";
            return number + output;
        },
        week: {
            dow: 1,
            doy: 4
        }
    });
    function bs__translate(number, withoutSuffix, key) {
        var result = number + " ";
        switch (key) {
          case "m":
            return withoutSuffix ? "jedna minuta" : "jedne minute";

          case "mm":
            if (number === 1) {
                result += "minuta";
            } else if (number === 2 || number === 3 || number === 4) {
                result += "minute";
            } else {
                result += "minuta";
            }
            return result;

          case "h":
            return withoutSuffix ? "jedan sat" : "jednog sata";

          case "hh":
            if (number === 1) {
                result += "sat";
            } else if (number === 2 || number === 3 || number === 4) {
                result += "sata";
            } else {
                result += "sati";
            }
            return result;

          case "dd":
            if (number === 1) {
                result += "dan";
            } else {
                result += "dana";
            }
            return result;

          case "MM":
            if (number === 1) {
                result += "mjesec";
            } else if (number === 2 || number === 3 || number === 4) {
                result += "mjeseca";
            } else {
                result += "mjeseci";
            }
            return result;

          case "yy":
            if (number === 1) {
                result += "godina";
            } else if (number === 2 || number === 3 || number === 4) {
                result += "godine";
            } else {
                result += "godina";
            }
            return result;
        }
    }
    var bs = _moment__default.defineLocale("bs", {
        months: "januar_februar_mart_april_maj_juni_juli_august_septembar_oktobar_novembar_decembar".split("_"),
        monthsShort: "jan._feb._mar._apr._maj._jun._jul._aug._sep._okt._nov._dec.".split("_"),
        weekdays: "nedjelja_ponedjeljak_utorak_srijeda_Äetvrtak_petak_subota".split("_"),
        weekdaysShort: "ned._pon._uto._sri._Äet._pet._sub.".split("_"),
        weekdaysMin: "ne_po_ut_sr_Äe_pe_su".split("_"),
        longDateFormat: {
            LT: "H:mm",
            LTS: "H:mm:ss",
            L: "DD. MM. YYYY",
            LL: "D. MMMM YYYY",
            LLL: "D. MMMM YYYY H:mm",
            LLLL: "dddd, D. MMMM YYYY H:mm"
        },
        calendar: {
            sameDay: "[danas u] LT",
            nextDay: "[sutra u] LT",
            nextWeek: function() {
                switch (this.day()) {
                  case 0:
                    return "[u] [nedjelju] [u] LT";

                  case 3:
                    return "[u] [srijedu] [u] LT";

                  case 6:
                    return "[u] [subotu] [u] LT";

                  case 1:
                  case 2:
                  case 4:
                  case 5:
                    return "[u] dddd [u] LT";
                }
            },
            lastDay: "[juÄer u] LT",
            lastWeek: function() {
                switch (this.day()) {
                  case 0:
                  case 3:
                    return "[proÅ¡lu] dddd [u] LT";

                  case 6:
                    return "[proÅ¡le] [subote] [u] LT";

                  case 1:
                  case 2:
                  case 4:
                  case 5:
                    return "[proÅ¡li] dddd [u] LT";
                }
            },
            sameElse: "L"
        },
        relativeTime: {
            future: "za %s",
            past: "prije %s",
            s: "par sekundi",
            m: bs__translate,
            mm: bs__translate,
            h: bs__translate,
            hh: bs__translate,
            d: "dan",
            dd: bs__translate,
            M: "mjesec",
            MM: bs__translate,
            y: "godinu",
            yy: bs__translate
        },
        ordinalParse: /\d{1,2}\./,
        ordinal: "%d.",
        week: {
            dow: 1,
            doy: 7
        }
    });
    var ca = _moment__default.defineLocale("ca", {
        months: "gener_febrer_marÃ§_abril_maig_juny_juliol_agost_setembre_octubre_novembre_desembre".split("_"),
        monthsShort: "gen._febr._mar._abr._mai._jun._jul._ag._set._oct._nov._des.".split("_"),
        weekdays: "diumenge_dilluns_dimarts_dimecres_dijous_divendres_dissabte".split("_"),
        weekdaysShort: "dg._dl._dt._dc._dj._dv._ds.".split("_"),
        weekdaysMin: "Dg_Dl_Dt_Dc_Dj_Dv_Ds".split("_"),
        longDateFormat: {
            LT: "H:mm",
            LTS: "LT:ss",
            L: "DD/MM/YYYY",
            LL: "D MMMM YYYY",
            LLL: "D MMMM YYYY H:mm",
            LLLL: "dddd D MMMM YYYY H:mm"
        },
        calendar: {
            sameDay: function() {
                return "[avui a " + (this.hours() !== 1 ? "les" : "la") + "] LT";
            },
            nextDay: function() {
                return "[demÃ  a " + (this.hours() !== 1 ? "les" : "la") + "] LT";
            },
            nextWeek: function() {
                return "dddd [a " + (this.hours() !== 1 ? "les" : "la") + "] LT";
            },
            lastDay: function() {
                return "[ahir a " + (this.hours() !== 1 ? "les" : "la") + "] LT";
            },
            lastWeek: function() {
                return "[el] dddd [passat a " + (this.hours() !== 1 ? "les" : "la") + "] LT";
            },
            sameElse: "L"
        },
        relativeTime: {
            future: "en %s",
            past: "fa %s",
            s: "uns segons",
            m: "un minut",
            mm: "%d minuts",
            h: "una hora",
            hh: "%d hores",
            d: "un dia",
            dd: "%d dies",
            M: "un mes",
            MM: "%d mesos",
            y: "un any",
            yy: "%d anys"
        },
        ordinalParse: /\d{1,2}(r|n|t|Ã¨|a)/,
        ordinal: function(number, period) {
            var output = number === 1 ? "r" : number === 2 ? "n" : number === 3 ? "r" : number === 4 ? "t" : "Ã¨";
            if (period === "w" || period === "W") {
                output = "a";
            }
            return number + output;
        },
        week: {
            dow: 1,
            doy: 4
        }
    });
    var cs__months = "leden_Ãºnor_bÅezen_duben_kvÄten_Äerven_Äervenec_srpen_zÃ¡ÅÃ­_ÅÃ­jen_listopad_prosinec".split("_"), cs__monthsShort = "led_Ãºno_bÅe_dub_kvÄ_Ävn_Ävc_srp_zÃ¡Å_ÅÃ­j_lis_pro".split("_");
    function cs__plural(n) {
        return n > 1 && n < 5 && ~~(n / 10) !== 1;
    }
    function cs__translate(number, withoutSuffix, key, isFuture) {
        var result = number + " ";
        switch (key) {
          case "s":
            return withoutSuffix || isFuture ? "pÃ¡r sekund" : "pÃ¡r sekundami";

          case "m":
            return withoutSuffix ? "minuta" : isFuture ? "minutu" : "minutou";

          case "mm":
            if (withoutSuffix || isFuture) {
                return result + (cs__plural(number) ? "minuty" : "minut");
            } else {
                return result + "minutami";
            }
            break;

          case "h":
            return withoutSuffix ? "hodina" : isFuture ? "hodinu" : "hodinou";

          case "hh":
            if (withoutSuffix || isFuture) {
                return result + (cs__plural(number) ? "hodiny" : "hodin");
            } else {
                return result + "hodinami";
            }
            break;

          case "d":
            return withoutSuffix || isFuture ? "den" : "dnem";

          case "dd":
            if (withoutSuffix || isFuture) {
                return result + (cs__plural(number) ? "dny" : "dnÃ­");
            } else {
                return result + "dny";
            }
            break;

          case "M":
            return withoutSuffix || isFuture ? "mÄsÃ­c" : "mÄsÃ­cem";

          case "MM":
            if (withoutSuffix || isFuture) {
                return result + (cs__plural(number) ? "mÄsÃ­ce" : "mÄsÃ­cÅ¯");
            } else {
                return result + "mÄsÃ­ci";
            }
            break;

          case "y":
            return withoutSuffix || isFuture ? "rok" : "rokem";

          case "yy":
            if (withoutSuffix || isFuture) {
                return result + (cs__plural(number) ? "roky" : "let");
            } else {
                return result + "lety";
            }
            break;
        }
    }
    var cs = _moment__default.defineLocale("cs", {
        months: cs__months,
        monthsShort: cs__monthsShort,
        monthsParse: function(months, monthsShort) {
            var i, _monthsParse = [];
            for (i = 0; i < 12; i++) {
                _monthsParse[i] = new RegExp("^" + months[i] + "$|^" + monthsShort[i] + "$", "i");
            }
            return _monthsParse;
        }(cs__months, cs__monthsShort),
        weekdays: "nedÄle_pondÄlÃ­_ÃºterÃ½_stÅeda_Ätvrtek_pÃ¡tek_sobota".split("_"),
        weekdaysShort: "ne_po_Ãºt_st_Ät_pÃ¡_so".split("_"),
        weekdaysMin: "ne_po_Ãºt_st_Ät_pÃ¡_so".split("_"),
        longDateFormat: {
            LT: "H:mm",
            LTS: "H:mm:ss",
            L: "DD.MM.YYYY",
            LL: "D. MMMM YYYY",
            LLL: "D. MMMM YYYY H:mm",
            LLLL: "dddd D. MMMM YYYY H:mm"
        },
        calendar: {
            sameDay: "[dnes v] LT",
            nextDay: "[zÃ­tra v] LT",
            nextWeek: function() {
                switch (this.day()) {
                  case 0:
                    return "[v nedÄli v] LT";

                  case 1:
                  case 2:
                    return "[v] dddd [v] LT";

                  case 3:
                    return "[ve stÅedu v] LT";

                  case 4:
                    return "[ve Ätvrtek v] LT";

                  case 5:
                    return "[v pÃ¡tek v] LT";

                  case 6:
                    return "[v sobotu v] LT";
                }
            },
            lastDay: "[vÄera v] LT",
            lastWeek: function() {
                switch (this.day()) {
                  case 0:
                    return "[minulou nedÄli v] LT";

                  case 1:
                  case 2:
                    return "[minulÃ©] dddd [v] LT";

                  case 3:
                    return "[minulou stÅedu v] LT";

                  case 4:
                  case 5:
                    return "[minulÃ½] dddd [v] LT";

                  case 6:
                    return "[minulou sobotu v] LT";
                }
            },
            sameElse: "L"
        },
        relativeTime: {
            future: "za %s",
            past: "pÅed %s",
            s: cs__translate,
            m: cs__translate,
            mm: cs__translate,
            h: cs__translate,
            hh: cs__translate,
            d: cs__translate,
            dd: cs__translate,
            M: cs__translate,
            MM: cs__translate,
            y: cs__translate,
            yy: cs__translate
        },
        ordinalParse: /\d{1,2}\./,
        ordinal: "%d.",
        week: {
            dow: 1,
            doy: 4
        }
    });
    var cv = _moment__default.defineLocale("cv", {
        months: "ÐºÓÑÐ»Ð°Ñ_Ð½Ð°ÑÓÑ_Ð¿ÑÑ_Ð°ÐºÐ°_Ð¼Ð°Ð¹_Ò«ÓÑÑÐ¼Ðµ_ÑÑÓ_Ò«ÑÑÐ»Ð°_Ð°Ð²ÓÐ½_ÑÐ¿Ð°_ÑÓ³Ðº_ÑÐ°ÑÑÐ°Ð²".split("_"),
        monthsShort: "ÐºÓÑ_Ð½Ð°Ñ_Ð¿ÑÑ_Ð°ÐºÐ°_Ð¼Ð°Ð¹_Ò«ÓÑ_ÑÑÓ_Ò«ÑÑ_Ð°Ð²Ð½_ÑÐ¿Ð°_ÑÓ³Ðº_ÑÐ°Ñ".split("_"),
        weekdays: "Ð²ÑÑÑÐ°ÑÐ½Ð¸ÐºÑÐ½_ÑÑÐ½ÑÐ¸ÐºÑÐ½_ÑÑÐ»Ð°ÑÐ¸ÐºÑÐ½_ÑÐ½ÐºÑÐ½_ÐºÓÒ«Ð½ÐµÑÐ½Ð¸ÐºÑÐ½_ÑÑÐ½ÐµÐºÑÐ½_ÑÓÐ¼Ð°ÑÐºÑÐ½".split("_"),
        weekdaysShort: "Ð²ÑÑ_ÑÑÐ½_ÑÑÐ»_ÑÐ½_ÐºÓÒ«_ÑÑÐ½_ÑÓÐ¼".split("_"),
        weekdaysMin: "Ð²Ñ_ÑÐ½_ÑÑ_ÑÐ½_ÐºÒ«_ÑÑ_ÑÐ¼".split("_"),
        longDateFormat: {
            LT: "HH:mm",
            LTS: "HH:mm:ss",
            L: "DD-MM-YYYY",
            LL: "YYYY [Ò«ÑÐ»ÑÐ¸] MMMM [ÑÐ¹ÓÑÓÐ½] D[-Ð¼ÓÑÓ]",
            LLL: "YYYY [Ò«ÑÐ»ÑÐ¸] MMMM [ÑÐ¹ÓÑÓÐ½] D[-Ð¼ÓÑÓ], HH:mm",
            LLLL: "dddd, YYYY [Ò«ÑÐ»ÑÐ¸] MMMM [ÑÐ¹ÓÑÓÐ½] D[-Ð¼ÓÑÓ], HH:mm"
        },
        calendar: {
            sameDay: "[ÐÐ°ÑÐ½] LT [ÑÐµÑÐµÑÑÐµ]",
            nextDay: "[Ð«ÑÐ°Ð½] LT [ÑÐµÑÐµÑÑÐµ]",
            lastDay: "[ÓÐ½ÐµÑ] LT [ÑÐµÑÐµÑÑÐµ]",
            nextWeek: "[ÒªÐ¸ÑÐµÑ] dddd LT [ÑÐµÑÐµÑÑÐµ]",
            lastWeek: "[ÐÑÑÐ½Ó] dddd LT [ÑÐµÑÐµÑÑÐµ]",
            sameElse: "L"
        },
        relativeTime: {
            future: function(output) {
                var affix = /ÑÐµÑÐµÑ$/i.exec(output) ? "ÑÐµÐ½" : /Ò«ÑÐ»$/i.exec(output) ? "ÑÐ°Ð½" : "ÑÐ°Ð½";
                return output + affix;
            },
            past: "%s ÐºÐ°ÑÐ»Ð»Ð°",
            s: "Ð¿ÓÑ-Ð¸Ðº Ò«ÐµÐºÐºÑÐ½Ñ",
            m: "Ð¿ÓÑ Ð¼Ð¸Ð½ÑÑ",
            mm: "%d Ð¼Ð¸Ð½ÑÑ",
            h: "Ð¿ÓÑ ÑÐµÑÐµÑ",
            hh: "%d ÑÐµÑÐµÑ",
            d: "Ð¿ÓÑ ÐºÑÐ½",
            dd: "%d ÐºÑÐ½",
            M: "Ð¿ÓÑ ÑÐ¹ÓÑ",
            MM: "%d ÑÐ¹ÓÑ",
            y: "Ð¿ÓÑ Ò«ÑÐ»",
            yy: "%d Ò«ÑÐ»"
        },
        ordinalParse: /\d{1,2}-Ð¼ÓÑ/,
        ordinal: "%d-Ð¼ÓÑ",
        week: {
            dow: 1,
            doy: 7
        }
    });
    var cy = _moment__default.defineLocale("cy", {
        months: "Ionawr_Chwefror_Mawrth_Ebrill_Mai_Mehefin_Gorffennaf_Awst_Medi_Hydref_Tachwedd_Rhagfyr".split("_"),
        monthsShort: "Ion_Chwe_Maw_Ebr_Mai_Meh_Gor_Aws_Med_Hyd_Tach_Rhag".split("_"),
        weekdays: "Dydd Sul_Dydd Llun_Dydd Mawrth_Dydd Mercher_Dydd Iau_Dydd Gwener_Dydd Sadwrn".split("_"),
        weekdaysShort: "Sul_Llun_Maw_Mer_Iau_Gwe_Sad".split("_"),
        weekdaysMin: "Su_Ll_Ma_Me_Ia_Gw_Sa".split("_"),
        longDateFormat: {
            LT: "HH:mm",
            LTS: "HH:mm:ss",
            L: "DD/MM/YYYY",
            LL: "D MMMM YYYY",
            LLL: "D MMMM YYYY HH:mm",
            LLLL: "dddd, D MMMM YYYY HH:mm"
        },
        calendar: {
            sameDay: "[Heddiw am] LT",
            nextDay: "[Yfory am] LT",
            nextWeek: "dddd [am] LT",
            lastDay: "[Ddoe am] LT",
            lastWeek: "dddd [diwethaf am] LT",
            sameElse: "L"
        },
        relativeTime: {
            future: "mewn %s",
            past: "%s yn Ã´l",
            s: "ychydig eiliadau",
            m: "munud",
            mm: "%d munud",
            h: "awr",
            hh: "%d awr",
            d: "diwrnod",
            dd: "%d diwrnod",
            M: "mis",
            MM: "%d mis",
            y: "blwyddyn",
            yy: "%d flynedd"
        },
        ordinalParse: /\d{1,2}(fed|ain|af|il|ydd|ed|eg)/,
        ordinal: function(number) {
            var b = number, output = "", lookup = [ "", "af", "il", "ydd", "ydd", "ed", "ed", "ed", "fed", "fed", "fed", "eg", "fed", "eg", "eg", "fed", "eg", "eg", "fed", "eg", "fed" ];
            if (b > 20) {
                if (b === 40 || b === 50 || b === 60 || b === 80 || b === 100) {
                    output = "fed";
                } else {
                    output = "ain";
                }
            } else if (b > 0) {
                output = lookup[b];
            }
            return number + output;
        },
        week: {
            dow: 1,
            doy: 4
        }
    });
    var da = _moment__default.defineLocale("da", {
        months: "januar_februar_marts_april_maj_juni_juli_august_september_oktober_november_december".split("_"),
        monthsShort: "jan_feb_mar_apr_maj_jun_jul_aug_sep_okt_nov_dec".split("_"),
        weekdays: "sÃ¸ndag_mandag_tirsdag_onsdag_torsdag_fredag_lÃ¸rdag".split("_"),
        weekdaysShort: "sÃ¸n_man_tir_ons_tor_fre_lÃ¸r".split("_"),
        weekdaysMin: "sÃ¸_ma_ti_on_to_fr_lÃ¸".split("_"),
        longDateFormat: {
            LT: "HH:mm",
            LTS: "HH:mm:ss",
            L: "DD/MM/YYYY",
            LL: "D. MMMM YYYY",
            LLL: "D. MMMM YYYY HH:mm",
            LLLL: "dddd [d.] D. MMMM YYYY HH:mm"
        },
        calendar: {
            sameDay: "[I dag kl.] LT",
            nextDay: "[I morgen kl.] LT",
            nextWeek: "dddd [kl.] LT",
            lastDay: "[I gÃ¥r kl.] LT",
            lastWeek: "[sidste] dddd [kl] LT",
            sameElse: "L"
        },
        relativeTime: {
            future: "om %s",
            past: "%s siden",
            s: "fÃ¥ sekunder",
            m: "et minut",
            mm: "%d minutter",
            h: "en time",
            hh: "%d timer",
            d: "en dag",
            dd: "%d dage",
            M: "en mÃ¥ned",
            MM: "%d mÃ¥neder",
            y: "et Ã¥r",
            yy: "%d Ã¥r"
        },
        ordinalParse: /\d{1,2}\./,
        ordinal: "%d.",
        week: {
            dow: 1,
            doy: 4
        }
    });
    function de_at__processRelativeTime(number, withoutSuffix, key, isFuture) {
        var format = {
            m: [ "eine Minute", "einer Minute" ],
            h: [ "eine Stunde", "einer Stunde" ],
            d: [ "ein Tag", "einem Tag" ],
            dd: [ number + " Tage", number + " Tagen" ],
            M: [ "ein Monat", "einem Monat" ],
            MM: [ number + " Monate", number + " Monaten" ],
            y: [ "ein Jahr", "einem Jahr" ],
            yy: [ number + " Jahre", number + " Jahren" ]
        };
        return withoutSuffix ? format[key][0] : format[key][1];
    }
    var de_at = _moment__default.defineLocale("de-at", {
        months: "JÃ¤nner_Februar_MÃ¤rz_April_Mai_Juni_Juli_August_September_Oktober_November_Dezember".split("_"),
        monthsShort: "JÃ¤n._Febr._Mrz._Apr._Mai_Jun._Jul._Aug._Sept._Okt._Nov._Dez.".split("_"),
        weekdays: "Sonntag_Montag_Dienstag_Mittwoch_Donnerstag_Freitag_Samstag".split("_"),
        weekdaysShort: "So._Mo._Di._Mi._Do._Fr._Sa.".split("_"),
        weekdaysMin: "So_Mo_Di_Mi_Do_Fr_Sa".split("_"),
        longDateFormat: {
            LT: "HH:mm",
            LTS: "HH:mm:ss",
            L: "DD.MM.YYYY",
            LL: "D. MMMM YYYY",
            LLL: "D. MMMM YYYY HH:mm",
            LLLL: "dddd, D. MMMM YYYY HH:mm"
        },
        calendar: {
            sameDay: "[Heute um] LT [Uhr]",
            sameElse: "L",
            nextDay: "[Morgen um] LT [Uhr]",
            nextWeek: "dddd [um] LT [Uhr]",
            lastDay: "[Gestern um] LT [Uhr]",
            lastWeek: "[letzten] dddd [um] LT [Uhr]"
        },
        relativeTime: {
            future: "in %s",
            past: "vor %s",
            s: "ein paar Sekunden",
            m: de_at__processRelativeTime,
            mm: "%d Minuten",
            h: de_at__processRelativeTime,
            hh: "%d Stunden",
            d: de_at__processRelativeTime,
            dd: de_at__processRelativeTime,
            M: de_at__processRelativeTime,
            MM: de_at__processRelativeTime,
            y: de_at__processRelativeTime,
            yy: de_at__processRelativeTime
        },
        ordinalParse: /\d{1,2}\./,
        ordinal: "%d.",
        week: {
            dow: 1,
            doy: 4
        }
    });
    function de__processRelativeTime(number, withoutSuffix, key, isFuture) {
        var format = {
            m: [ "eine Minute", "einer Minute" ],
            h: [ "eine Stunde", "einer Stunde" ],
            d: [ "ein Tag", "einem Tag" ],
            dd: [ number + " Tage", number + " Tagen" ],
            M: [ "ein Monat", "einem Monat" ],
            MM: [ number + " Monate", number + " Monaten" ],
            y: [ "ein Jahr", "einem Jahr" ],
            yy: [ number + " Jahre", number + " Jahren" ]
        };
        return withoutSuffix ? format[key][0] : format[key][1];
    }
    var de = _moment__default.defineLocale("de", {
        months: "Januar_Februar_MÃ¤rz_April_Mai_Juni_Juli_August_September_Oktober_November_Dezember".split("_"),
        monthsShort: "Jan._Febr._Mrz._Apr._Mai_Jun._Jul._Aug._Sept._Okt._Nov._Dez.".split("_"),
        weekdays: "Sonntag_Montag_Dienstag_Mittwoch_Donnerstag_Freitag_Samstag".split("_"),
        weekdaysShort: "So._Mo._Di._Mi._Do._Fr._Sa.".split("_"),
        weekdaysMin: "So_Mo_Di_Mi_Do_Fr_Sa".split("_"),
        longDateFormat: {
            LT: "HH:mm",
            LTS: "HH:mm:ss",
            L: "DD.MM.YYYY",
            LL: "D. MMMM YYYY",
            LLL: "D. MMMM YYYY HH:mm",
            LLLL: "dddd, D. MMMM YYYY HH:mm"
        },
        calendar: {
            sameDay: "[Heute um] LT [Uhr]",
            sameElse: "L",
            nextDay: "[Morgen um] LT [Uhr]",
            nextWeek: "dddd [um] LT [Uhr]",
            lastDay: "[Gestern um] LT [Uhr]",
            lastWeek: "[letzten] dddd [um] LT [Uhr]"
        },
        relativeTime: {
            future: "in %s",
            past: "vor %s",
            s: "ein paar Sekunden",
            m: de__processRelativeTime,
            mm: "%d Minuten",
            h: de__processRelativeTime,
            hh: "%d Stunden",
            d: de__processRelativeTime,
            dd: de__processRelativeTime,
            M: de__processRelativeTime,
            MM: de__processRelativeTime,
            y: de__processRelativeTime,
            yy: de__processRelativeTime
        },
        ordinalParse: /\d{1,2}\./,
        ordinal: "%d.",
        week: {
            dow: 1,
            doy: 4
        }
    });
    var el = _moment__default.defineLocale("el", {
        monthsNominativeEl: "ÎÎ±Î½Î¿ÏÎ¬ÏÎ¹Î¿Ï_Î¦ÎµÎ²ÏÎ¿ÏÎ¬ÏÎ¹Î¿Ï_ÎÎ¬ÏÏÎ¹Î¿Ï_ÎÏÏÎ¯Î»Î¹Î¿Ï_ÎÎ¬Î¹Î¿Ï_ÎÎ¿ÏÎ½Î¹Î¿Ï_ÎÎ¿ÏÎ»Î¹Î¿Ï_ÎÏÎ³Î¿ÏÏÏÎ¿Ï_Î£ÎµÏÏÎ­Î¼Î²ÏÎ¹Î¿Ï_ÎÎºÏÏÎ²ÏÎ¹Î¿Ï_ÎÎ¿Î­Î¼Î²ÏÎ¹Î¿Ï_ÎÎµÎºÎ­Î¼Î²ÏÎ¹Î¿Ï".split("_"),
        monthsGenitiveEl: "ÎÎ±Î½Î¿ÏÎ±ÏÎ¯Î¿Ï_Î¦ÎµÎ²ÏÎ¿ÏÎ±ÏÎ¯Î¿Ï_ÎÎ±ÏÏÎ¯Î¿Ï_ÎÏÏÎ¹Î»Î¯Î¿Ï_ÎÎ±ÎÎ¿Ï_ÎÎ¿ÏÎ½Î¯Î¿Ï_ÎÎ¿ÏÎ»Î¯Î¿Ï_ÎÏÎ³Î¿ÏÏÏÎ¿Ï_Î£ÎµÏÏÎµÎ¼Î²ÏÎ¯Î¿Ï_ÎÎºÏÏÎ²ÏÎ¯Î¿Ï_ÎÎ¿ÎµÎ¼Î²ÏÎ¯Î¿Ï_ÎÎµÎºÎµÎ¼Î²ÏÎ¯Î¿Ï".split("_"),
        months: function(momentToFormat, format) {
            if (/D/.test(format.substring(0, format.indexOf("MMMM")))) {
                return this._monthsGenitiveEl[momentToFormat.month()];
            } else {
                return this._monthsNominativeEl[momentToFormat.month()];
            }
        },
        monthsShort: "ÎÎ±Î½_Î¦ÎµÎ²_ÎÎ±Ï_ÎÏÏ_ÎÎ±Ï_ÎÎ¿ÏÎ½_ÎÎ¿ÏÎ»_ÎÏÎ³_Î£ÎµÏ_ÎÎºÏ_ÎÎ¿Îµ_ÎÎµÎº".split("_"),
        weekdays: "ÎÏÏÎ¹Î±ÎºÎ®_ÎÎµÏÏÎ­ÏÎ±_Î¤ÏÎ¯ÏÎ·_Î¤ÎµÏÎ¬ÏÏÎ·_Î Î­Î¼ÏÏÎ·_Î Î±ÏÎ±ÏÎºÎµÏÎ®_Î£Î¬Î²Î²Î±ÏÎ¿".split("_"),
        weekdaysShort: "ÎÏÏ_ÎÎµÏ_Î¤ÏÎ¹_Î¤ÎµÏ_Î ÎµÎ¼_Î Î±Ï_Î£Î±Î²".split("_"),
        weekdaysMin: "ÎÏ_ÎÎµ_Î¤Ï_Î¤Îµ_Î Îµ_Î Î±_Î£Î±".split("_"),
        meridiem: function(hours, minutes, isLower) {
            if (hours > 11) {
                return isLower ? "Î¼Î¼" : "ÎÎ";
            } else {
                return isLower ? "ÏÎ¼" : "Î Î";
            }
        },
        isPM: function(input) {
            return (input + "").toLowerCase()[0] === "Î¼";
        },
        meridiemParse: /[Î Î]\.?Î?\.?/i,
        longDateFormat: {
            LT: "h:mm A",
            LTS: "h:mm:ss A",
            L: "DD/MM/YYYY",
            LL: "D MMMM YYYY",
            LLL: "D MMMM YYYY h:mm A",
            LLLL: "dddd, D MMMM YYYY h:mm A"
        },
        calendarEl: {
            sameDay: "[Î£Î®Î¼ÎµÏÎ± {}] LT",
            nextDay: "[ÎÏÏÎ¹Î¿ {}] LT",
            nextWeek: "dddd [{}] LT",
            lastDay: "[Î§Î¸ÎµÏ {}] LT",
            lastWeek: function() {
                switch (this.day()) {
                  case 6:
                    return "[ÏÎ¿ ÏÏÎ¿Î·Î³Î¿ÏÎ¼ÎµÎ½Î¿] dddd [{}] LT";

                  default:
                    return "[ÏÎ·Î½ ÏÏÎ¿Î·Î³Î¿ÏÎ¼ÎµÎ½Î·] dddd [{}] LT";
                }
            },
            sameElse: "L"
        },
        calendar: function(key, mom) {
            var output = this._calendarEl[key], hours = mom && mom.hours();
            if (typeof output === "function") {
                output = output.apply(mom);
            }
            return output.replace("{}", hours % 12 === 1 ? "ÏÏÎ·" : "ÏÏÎ¹Ï");
        },
        relativeTime: {
            future: "ÏÎµ %s",
            past: "%s ÏÏÎ¹Î½",
            s: "Î»Î¯Î³Î± Î´ÎµÏÏÎµÏÏÎ»ÎµÏÏÎ±",
            m: "Î­Î½Î± Î»ÎµÏÏÏ",
            mm: "%d Î»ÎµÏÏÎ¬",
            h: "Î¼Î¯Î± ÏÏÎ±",
            hh: "%d ÏÏÎµÏ",
            d: "Î¼Î¯Î± Î¼Î­ÏÎ±",
            dd: "%d Î¼Î­ÏÎµÏ",
            M: "Î­Î½Î±Ï Î¼Î®Î½Î±Ï",
            MM: "%d Î¼Î®Î½ÎµÏ",
            y: "Î­Î½Î±Ï ÏÏÏÎ½Î¿Ï",
            yy: "%d ÏÏÏÎ½Î¹Î±"
        },
        ordinalParse: /\d{1,2}Î·/,
        ordinal: "%dÎ·",
        week: {
            dow: 1,
            doy: 4
        }
    });
    var en_au = _moment__default.defineLocale("en-au", {
        months: "January_February_March_April_May_June_July_August_September_October_November_December".split("_"),
        monthsShort: "Jan_Feb_Mar_Apr_May_Jun_Jul_Aug_Sep_Oct_Nov_Dec".split("_"),
        weekdays: "Sunday_Monday_Tuesday_Wednesday_Thursday_Friday_Saturday".split("_"),
        weekdaysShort: "Sun_Mon_Tue_Wed_Thu_Fri_Sat".split("_"),
        weekdaysMin: "Su_Mo_Tu_We_Th_Fr_Sa".split("_"),
        longDateFormat: {
            LT: "h:mm A",
            LTS: "h:mm:ss A",
            L: "DD/MM/YYYY",
            LL: "D MMMM YYYY",
            LLL: "D MMMM YYYY h:mm A",
            LLLL: "dddd, D MMMM YYYY h:mm A"
        },
        calendar: {
            sameDay: "[Today at] LT",
            nextDay: "[Tomorrow at] LT",
            nextWeek: "dddd [at] LT",
            lastDay: "[Yesterday at] LT",
            lastWeek: "[Last] dddd [at] LT",
            sameElse: "L"
        },
        relativeTime: {
            future: "in %s",
            past: "%s ago",
            s: "a few seconds",
            m: "a minute",
            mm: "%d minutes",
            h: "an hour",
            hh: "%d hours",
            d: "a day",
            dd: "%d days",
            M: "a month",
            MM: "%d months",
            y: "a year",
            yy: "%d years"
        },
        ordinalParse: /\d{1,2}(st|nd|rd|th)/,
        ordinal: function(number) {
            var b = number % 10, output = ~~(number % 100 / 10) === 1 ? "th" : b === 1 ? "st" : b === 2 ? "nd" : b === 3 ? "rd" : "th";
            return number + output;
        },
        week: {
            dow: 1,
            doy: 4
        }
    });
    var en_ca = _moment__default.defineLocale("en-ca", {
        months: "January_February_March_April_May_June_July_August_September_October_November_December".split("_"),
        monthsShort: "Jan_Feb_Mar_Apr_May_Jun_Jul_Aug_Sep_Oct_Nov_Dec".split("_"),
        weekdays: "Sunday_Monday_Tuesday_Wednesday_Thursday_Friday_Saturday".split("_"),
        weekdaysShort: "Sun_Mon_Tue_Wed_Thu_Fri_Sat".split("_"),
        weekdaysMin: "Su_Mo_Tu_We_Th_Fr_Sa".split("_"),
        longDateFormat: {
            LT: "h:mm A",
            LTS: "h:mm:ss A",
            L: "YYYY-MM-DD",
            LL: "D MMMM, YYYY",
            LLL: "D MMMM, YYYY h:mm A",
            LLLL: "dddd, D MMMM, YYYY h:mm A"
        },
        calendar: {
            sameDay: "[Today at] LT",
            nextDay: "[Tomorrow at] LT",
            nextWeek: "dddd [at] LT",
            lastDay: "[Yesterday at] LT",
            lastWeek: "[Last] dddd [at] LT",
            sameElse: "L"
        },
        relativeTime: {
            future: "in %s",
            past: "%s ago",
            s: "a few seconds",
            m: "a minute",
            mm: "%d minutes",
            h: "an hour",
            hh: "%d hours",
            d: "a day",
            dd: "%d days",
            M: "a month",
            MM: "%d months",
            y: "a year",
            yy: "%d years"
        },
        ordinalParse: /\d{1,2}(st|nd|rd|th)/,
        ordinal: function(number) {
            var b = number % 10, output = ~~(number % 100 / 10) === 1 ? "th" : b === 1 ? "st" : b === 2 ? "nd" : b === 3 ? "rd" : "th";
            return number + output;
        }
    });
    var en_gb = _moment__default.defineLocale("en-gb", {
        months: "January_February_March_April_May_June_July_August_September_October_November_December".split("_"),
        monthsShort: "Jan_Feb_Mar_Apr_May_Jun_Jul_Aug_Sep_Oct_Nov_Dec".split("_"),
        weekdays: "Sunday_Monday_Tuesday_Wednesday_Thursday_Friday_Saturday".split("_"),
        weekdaysShort: "Sun_Mon_Tue_Wed_Thu_Fri_Sat".split("_"),
        weekdaysMin: "Su_Mo_Tu_We_Th_Fr_Sa".split("_"),
        longDateFormat: {
            LT: "HH:mm",
            LTS: "HH:mm:ss",
            L: "DD/MM/YYYY",
            LL: "D MMMM YYYY",
            LLL: "D MMMM YYYY HH:mm",
            LLLL: "dddd, D MMMM YYYY HH:mm"
        },
        calendar: {
            sameDay: "[Today at] LT",
            nextDay: "[Tomorrow at] LT",
            nextWeek: "dddd [at] LT",
            lastDay: "[Yesterday at] LT",
            lastWeek: "[Last] dddd [at] LT",
            sameElse: "L"
        },
        relativeTime: {
            future: "in %s",
            past: "%s ago",
            s: "a few seconds",
            m: "a minute",
            mm: "%d minutes",
            h: "an hour",
            hh: "%d hours",
            d: "a day",
            dd: "%d days",
            M: "a month",
            MM: "%d months",
            y: "a year",
            yy: "%d years"
        },
        ordinalParse: /\d{1,2}(st|nd|rd|th)/,
        ordinal: function(number) {
            var b = number % 10, output = ~~(number % 100 / 10) === 1 ? "th" : b === 1 ? "st" : b === 2 ? "nd" : b === 3 ? "rd" : "th";
            return number + output;
        },
        week: {
            dow: 1,
            doy: 4
        }
    });
    var eo = _moment__default.defineLocale("eo", {
        months: "januaro_februaro_marto_aprilo_majo_junio_julio_aÅ­gusto_septembro_oktobro_novembro_decembro".split("_"),
        monthsShort: "jan_feb_mar_apr_maj_jun_jul_aÅ­g_sep_okt_nov_dec".split("_"),
        weekdays: "DimanÄo_Lundo_Mardo_Merkredo_Ä´aÅ­do_Vendredo_Sabato".split("_"),
        weekdaysShort: "Dim_Lun_Mard_Merk_Ä´aÅ­_Ven_Sab".split("_"),
        weekdaysMin: "Di_Lu_Ma_Me_Ä´a_Ve_Sa".split("_"),
        longDateFormat: {
            LT: "HH:mm",
            LTS: "HH:mm:ss",
            L: "YYYY-MM-DD",
            LL: "D[-an de] MMMM, YYYY",
            LLL: "D[-an de] MMMM, YYYY HH:mm",
            LLLL: "dddd, [la] D[-an de] MMMM, YYYY HH:mm"
        },
        meridiemParse: /[ap]\.t\.m/i,
        isPM: function(input) {
            return input.charAt(0).toLowerCase() === "p";
        },
        meridiem: function(hours, minutes, isLower) {
            if (hours > 11) {
                return isLower ? "p.t.m." : "P.T.M.";
            } else {
                return isLower ? "a.t.m." : "A.T.M.";
            }
        },
        calendar: {
            sameDay: "[HodiaÅ­ je] LT",
            nextDay: "[MorgaÅ­ je] LT",
            nextWeek: "dddd [je] LT",
            lastDay: "[HieraÅ­ je] LT",
            lastWeek: "[pasinta] dddd [je] LT",
            sameElse: "L"
        },
        relativeTime: {
            future: "je %s",
            past: "antaÅ­ %s",
            s: "sekundoj",
            m: "minuto",
            mm: "%d minutoj",
            h: "horo",
            hh: "%d horoj",
            d: "tago",
            dd: "%d tagoj",
            M: "monato",
            MM: "%d monatoj",
            y: "jaro",
            yy: "%d jaroj"
        },
        ordinalParse: /\d{1,2}a/,
        ordinal: "%da",
        week: {
            dow: 1,
            doy: 7
        }
    });
    var monthsShortDot = "Ene._Feb._Mar._Abr._May._Jun._Jul._Ago._Sep._Oct._Nov._Dic.".split("_"), es__monthsShort = "Ene_Feb_Mar_Abr_May_Jun_Jul_Ago_Sep_Oct_Nov_Dic".split("_");
    var es = _moment__default.defineLocale("es", {
        months: "Enero_Febrero_Marzo_Abril_Mayo_Junio_Julio_Agosto_Septiembre_Octubre_Noviembre_Diciembre".split("_"),
        monthsShort: function(m, format) {
            if (/-MMM-/.test(format)) {
                return es__monthsShort[m.month()];
            } else {
                return monthsShortDot[m.month()];
            }
        },
        weekdays: "Domingo_Lunes_Martes_MiÃ©rcoles_Jueves_Viernes_SÃ¡bado".split("_"),
        weekdaysShort: "Dom._Lun._Mar._MiÃ©._Jue._Vie._SÃ¡b.".split("_"),
        weekdaysMin: "Do_Lu_Ma_Mi_Ju_Vi_SÃ¡".split("_"),
        longDateFormat: {
            LT: "H:mm",
            LTS: "H:mm:ss",
            L: "DD/MM/YYYY",
            LL: "D [de] MMMM [de] YYYY",
            LLL: "D [de] MMMM [de] YYYY H:mm",
            LLLL: "dddd, D [de] MMMM [de] YYYY H:mm"
        },
        calendar: {
            sameDay: function() {
                return "[hoy a la" + (this.hours() !== 1 ? "s" : "") + "] LT";
            },
            nextDay: function() {
                return "[maÃ±ana a la" + (this.hours() !== 1 ? "s" : "") + "] LT";
            },
            nextWeek: function() {
                return "dddd [a la" + (this.hours() !== 1 ? "s" : "") + "] LT";
            },
            lastDay: function() {
                return "[ayer a la" + (this.hours() !== 1 ? "s" : "") + "] LT";
            },
            lastWeek: function() {
                return "[el] dddd [pasado a la" + (this.hours() !== 1 ? "s" : "") + "] LT";
            },
            sameElse: "L"
        },
        relativeTime: {
            future: "en %s",
            past: "hace %s",
            s: "unos segundos",
            m: "un minuto",
            mm: "%d minutos",
            h: "una hora",
            hh: "%d horas",
            d: "un dÃ­a",
            dd: "%d dÃ­as",
            M: "un mes",
            MM: "%d meses",
            y: "un aÃ±o",
            yy: "%d aÃ±os"
        },
        ordinalParse: /\d{1,2}Âº/,
        ordinal: "%dÂº",
        week: {
            dow: 1,
            doy: 4
        }
    });
    function et__processRelativeTime(number, withoutSuffix, key, isFuture) {
        var format = {
            s: [ "mÃµne sekundi", "mÃµni sekund", "paar sekundit" ],
            m: [ "Ã¼he minuti", "Ã¼ks minut" ],
            mm: [ number + " minuti", number + " minutit" ],
            h: [ "Ã¼he tunni", "tund aega", "Ã¼ks tund" ],
            hh: [ number + " tunni", number + " tundi" ],
            d: [ "Ã¼he pÃ¤eva", "Ã¼ks pÃ¤ev" ],
            M: [ "kuu aja", "kuu aega", "Ã¼ks kuu" ],
            MM: [ number + " kuu", number + " kuud" ],
            y: [ "Ã¼he aasta", "aasta", "Ã¼ks aasta" ],
            yy: [ number + " aasta", number + " aastat" ]
        };
        if (withoutSuffix) {
            return format[key][2] ? format[key][2] : format[key][1];
        }
        return isFuture ? format[key][0] : format[key][1];
    }
    var et = _moment__default.defineLocale("et", {
        months: "jaanuar_veebruar_mÃ¤rts_aprill_mai_juuni_juuli_august_september_oktoober_november_detsember".split("_"),
        monthsShort: "jaan_veebr_mÃ¤rts_apr_mai_juuni_juuli_aug_sept_okt_nov_dets".split("_"),
        weekdays: "pÃ¼hapÃ¤ev_esmaspÃ¤ev_teisipÃ¤ev_kolmapÃ¤ev_neljapÃ¤ev_reede_laupÃ¤ev".split("_"),
        weekdaysShort: "P_E_T_K_N_R_L".split("_"),
        weekdaysMin: "P_E_T_K_N_R_L".split("_"),
        longDateFormat: {
            LT: "H:mm",
            LTS: "H:mm:ss",
            L: "DD.MM.YYYY",
            LL: "D. MMMM YYYY",
            LLL: "D. MMMM YYYY H:mm",
            LLLL: "dddd, D. MMMM YYYY H:mm"
        },
        calendar: {
            sameDay: "[TÃ¤na,] LT",
            nextDay: "[Homme,] LT",
            nextWeek: "[JÃ¤rgmine] dddd LT",
            lastDay: "[Eile,] LT",
            lastWeek: "[Eelmine] dddd LT",
            sameElse: "L"
        },
        relativeTime: {
            future: "%s pÃ¤rast",
            past: "%s tagasi",
            s: et__processRelativeTime,
            m: et__processRelativeTime,
            mm: et__processRelativeTime,
            h: et__processRelativeTime,
            hh: et__processRelativeTime,
            d: et__processRelativeTime,
            dd: "%d pÃ¤eva",
            M: et__processRelativeTime,
            MM: et__processRelativeTime,
            y: et__processRelativeTime,
            yy: et__processRelativeTime
        },
        ordinalParse: /\d{1,2}\./,
        ordinal: "%d.",
        week: {
            dow: 1,
            doy: 4
        }
    });
    var eu = _moment__default.defineLocale("eu", {
        months: "urtarrila_otsaila_martxoa_apirila_maiatza_ekaina_uztaila_abuztua_iraila_urria_azaroa_abendua".split("_"),
        monthsShort: "urt._ots._mar._api._mai._eka._uzt._abu._ira._urr._aza._abe.".split("_"),
        weekdays: "igandea_astelehena_asteartea_asteazkena_osteguna_ostirala_larunbata".split("_"),
        weekdaysShort: "ig._al._ar._az._og._ol._lr.".split("_"),
        weekdaysMin: "ig_al_ar_az_og_ol_lr".split("_"),
        longDateFormat: {
            LT: "HH:mm",
            LTS: "HH:mm:ss",
            L: "YYYY-MM-DD",
            LL: "YYYY[ko] MMMM[ren] D[a]",
            LLL: "YYYY[ko] MMMM[ren] D[a] HH:mm",
            LLLL: "dddd, YYYY[ko] MMMM[ren] D[a] HH:mm",
            l: "YYYY-M-D",
            ll: "YYYY[ko] MMM D[a]",
            lll: "YYYY[ko] MMM D[a] HH:mm",
            llll: "ddd, YYYY[ko] MMM D[a] HH:mm"
        },
        calendar: {
            sameDay: "[gaur] LT[etan]",
            nextDay: "[bihar] LT[etan]",
            nextWeek: "dddd LT[etan]",
            lastDay: "[atzo] LT[etan]",
            lastWeek: "[aurreko] dddd LT[etan]",
            sameElse: "L"
        },
        relativeTime: {
            future: "%s barru",
            past: "duela %s",
            s: "segundo batzuk",
            m: "minutu bat",
            mm: "%d minutu",
            h: "ordu bat",
            hh: "%d ordu",
            d: "egun bat",
            dd: "%d egun",
            M: "hilabete bat",
            MM: "%d hilabete",
            y: "urte bat",
            yy: "%d urte"
        },
        ordinalParse: /\d{1,2}\./,
        ordinal: "%d.",
        week: {
            dow: 1,
            doy: 7
        }
    });
    var fa__symbolMap = {
        "1": "Û±",
        "2": "Û²",
        "3": "Û³",
        "4": "Û´",
        "5": "Ûµ",
        "6": "Û¶",
        "7": "Û·",
        "8": "Û¸",
        "9": "Û¹",
        "0": "Û°"
    }, fa__numberMap = {
        "Û±": "1",
        "Û²": "2",
        "Û³": "3",
        "Û´": "4",
        "Ûµ": "5",
        "Û¶": "6",
        "Û·": "7",
        "Û¸": "8",
        "Û¹": "9",
        "Û°": "0"
    };
    var fa = _moment__default.defineLocale("fa", {
        months: "ÚØ§ÙÙÛÙ_ÙÙØ±ÛÙ_ÙØ§Ø±Ø³_Ø¢ÙØ±ÛÙ_ÙÙ_ÚÙØ¦Ù_ÚÙØ¦ÛÙ_Ø§ÙØª_Ø³Ù¾ØªØ§ÙØ¨Ø±_Ø§Ú©ØªØ¨Ø±_ÙÙØ§ÙØ¨Ø±_Ø¯Ø³Ø§ÙØ¨Ø±".split("_"),
        monthsShort: "ÚØ§ÙÙÛÙ_ÙÙØ±ÛÙ_ÙØ§Ø±Ø³_Ø¢ÙØ±ÛÙ_ÙÙ_ÚÙØ¦Ù_ÚÙØ¦ÛÙ_Ø§ÙØª_Ø³Ù¾ØªØ§ÙØ¨Ø±_Ø§Ú©ØªØ¨Ø±_ÙÙØ§ÙØ¨Ø±_Ø¯Ø³Ø§ÙØ¨Ø±".split("_"),
        weekdays: "ÛÚ©âØ´ÙØ¨Ù_Ø¯ÙØ´ÙØ¨Ù_Ø³ÙâØ´ÙØ¨Ù_ÚÙØ§Ø±Ø´ÙØ¨Ù_Ù¾ÙØ¬âØ´ÙØ¨Ù_Ø¬ÙØ¹Ù_Ø´ÙØ¨Ù".split("_"),
        weekdaysShort: "ÛÚ©âØ´ÙØ¨Ù_Ø¯ÙØ´ÙØ¨Ù_Ø³ÙâØ´ÙØ¨Ù_ÚÙØ§Ø±Ø´ÙØ¨Ù_Ù¾ÙØ¬âØ´ÙØ¨Ù_Ø¬ÙØ¹Ù_Ø´ÙØ¨Ù".split("_"),
        weekdaysMin: "Û_Ø¯_Ø³_Ú_Ù¾_Ø¬_Ø´".split("_"),
        longDateFormat: {
            LT: "HH:mm",
            LTS: "HH:mm:ss",
            L: "DD/MM/YYYY",
            LL: "D MMMM YYYY",
            LLL: "D MMMM YYYY HH:mm",
            LLLL: "dddd, D MMMM YYYY HH:mm"
        },
        meridiemParse: /ÙØ¨Ù Ø§Ø² Ø¸ÙØ±|Ø¨Ø¹Ø¯ Ø§Ø² Ø¸ÙØ±/,
        isPM: function(input) {
            return /Ø¨Ø¹Ø¯ Ø§Ø² Ø¸ÙØ±/.test(input);
        },
        meridiem: function(hour, minute, isLower) {
            if (hour < 12) {
                return "ÙØ¨Ù Ø§Ø² Ø¸ÙØ±";
            } else {
                return "Ø¨Ø¹Ø¯ Ø§Ø² Ø¸ÙØ±";
            }
        },
        calendar: {
            sameDay: "[Ø§ÙØ±ÙØ² Ø³Ø§Ø¹Øª] LT",
            nextDay: "[ÙØ±Ø¯Ø§ Ø³Ø§Ø¹Øª] LT",
            nextWeek: "dddd [Ø³Ø§Ø¹Øª] LT",
            lastDay: "[Ø¯ÛØ±ÙØ² Ø³Ø§Ø¹Øª] LT",
            lastWeek: "dddd [Ù¾ÛØ´] [Ø³Ø§Ø¹Øª] LT",
            sameElse: "L"
        },
        relativeTime: {
            future: "Ø¯Ø± %s",
            past: "%s Ù¾ÛØ´",
            s: "ÚÙØ¯ÛÙ Ø«Ø§ÙÛÙ",
            m: "ÛÚ© Ø¯ÙÛÙÙ",
            mm: "%d Ø¯ÙÛÙÙ",
            h: "ÛÚ© Ø³Ø§Ø¹Øª",
            hh: "%d Ø³Ø§Ø¹Øª",
            d: "ÛÚ© Ø±ÙØ²",
            dd: "%d Ø±ÙØ²",
            M: "ÛÚ© ÙØ§Ù",
            MM: "%d ÙØ§Ù",
            y: "ÛÚ© Ø³Ø§Ù",
            yy: "%d Ø³Ø§Ù"
        },
        preparse: function(string) {
            return string.replace(/[Û°-Û¹]/g, function(match) {
                return fa__numberMap[match];
            }).replace(/Ø/g, ",");
        },
        postformat: function(string) {
            return string.replace(/\d/g, function(match) {
                return fa__symbolMap[match];
            }).replace(/,/g, "Ø");
        },
        ordinalParse: /\d{1,2}Ù/,
        ordinal: "%dÙ",
        week: {
            dow: 6,
            doy: 12
        }
    });
    var numbersPast = "nolla yksi kaksi kolme neljÃ¤ viisi kuusi seitsemÃ¤n kahdeksan yhdeksÃ¤n".split(" "), numbersFuture = [ "nolla", "yhden", "kahden", "kolmen", "neljÃ¤n", "viiden", "kuuden", numbersPast[7], numbersPast[8], numbersPast[9] ];
    function fi__translate(number, withoutSuffix, key, isFuture) {
        var result = "";
        switch (key) {
          case "s":
            return isFuture ? "muutaman sekunnin" : "muutama sekunti";

          case "m":
            return isFuture ? "minuutin" : "minuutti";

          case "mm":
            result = isFuture ? "minuutin" : "minuuttia";
            break;

          case "h":
            return isFuture ? "tunnin" : "tunti";

          case "hh":
            result = isFuture ? "tunnin" : "tuntia";
            break;

          case "d":
            return isFuture ? "pÃ¤ivÃ¤n" : "pÃ¤ivÃ¤";

          case "dd":
            result = isFuture ? "pÃ¤ivÃ¤n" : "pÃ¤ivÃ¤Ã¤";
            break;

          case "M":
            return isFuture ? "kuukauden" : "kuukausi";

          case "MM":
            result = isFuture ? "kuukauden" : "kuukautta";
            break;

          case "y":
            return isFuture ? "vuoden" : "vuosi";

          case "yy":
            result = isFuture ? "vuoden" : "vuotta";
            break;
        }
        result = verbalNumber(number, isFuture) + " " + result;
        return result;
    }
    function verbalNumber(number, isFuture) {
        return number < 10 ? isFuture ? numbersFuture[number] : numbersPast[number] : number;
    }
    var fi = _moment__default.defineLocale("fi", {
        months: "tammikuu_helmikuu_maaliskuu_huhtikuu_toukokuu_kesÃ¤kuu_heinÃ¤kuu_elokuu_syyskuu_lokakuu_marraskuu_joulukuu".split("_"),
        monthsShort: "tammi_helmi_maalis_huhti_touko_kesÃ¤_heinÃ¤_elo_syys_loka_marras_joulu".split("_"),
        weekdays: "sunnuntai_maanantai_tiistai_keskiviikko_torstai_perjantai_lauantai".split("_"),
        weekdaysShort: "su_ma_ti_ke_to_pe_la".split("_"),
        weekdaysMin: "su_ma_ti_ke_to_pe_la".split("_"),
        longDateFormat: {
            LT: "HH.mm",
            LTS: "HH.mm.ss",
            L: "DD.MM.YYYY",
            LL: "Do MMMM[ta] YYYY",
            LLL: "Do MMMM[ta] YYYY, [klo] HH.mm",
            LLLL: "dddd, Do MMMM[ta] YYYY, [klo] HH.mm",
            l: "D.M.YYYY",
            ll: "Do MMM YYYY",
            lll: "Do MMM YYYY, [klo] HH.mm",
            llll: "ddd, Do MMM YYYY, [klo] HH.mm"
        },
        calendar: {
            sameDay: "[tÃ¤nÃ¤Ã¤n] [klo] LT",
            nextDay: "[huomenna] [klo] LT",
            nextWeek: "dddd [klo] LT",
            lastDay: "[eilen] [klo] LT",
            lastWeek: "[viime] dddd[na] [klo] LT",
            sameElse: "L"
        },
        relativeTime: {
            future: "%s pÃ¤Ã¤stÃ¤",
            past: "%s sitten",
            s: fi__translate,
            m: fi__translate,
            mm: fi__translate,
            h: fi__translate,
            hh: fi__translate,
            d: fi__translate,
            dd: fi__translate,
            M: fi__translate,
            MM: fi__translate,
            y: fi__translate,
            yy: fi__translate
        },
        ordinalParse: /\d{1,2}\./,
        ordinal: "%d.",
        week: {
            dow: 1,
            doy: 4
        }
    });
    var fo = _moment__default.defineLocale("fo", {
        months: "januar_februar_mars_aprÃ­l_mai_juni_juli_august_september_oktober_november_desember".split("_"),
        monthsShort: "jan_feb_mar_apr_mai_jun_jul_aug_sep_okt_nov_des".split("_"),
        weekdays: "sunnudagur_mÃ¡nadagur_tÃ½sdagur_mikudagur_hÃ³sdagur_frÃ­ggjadagur_leygardagur".split("_"),
        weekdaysShort: "sun_mÃ¡n_tÃ½s_mik_hÃ³s_frÃ­_ley".split("_"),
        weekdaysMin: "su_mÃ¡_tÃ½_mi_hÃ³_fr_le".split("_"),
        longDateFormat: {
            LT: "HH:mm",
            LTS: "HH:mm:ss",
            L: "DD/MM/YYYY",
            LL: "D MMMM YYYY",
            LLL: "D MMMM YYYY HH:mm",
            LLLL: "dddd D. MMMM, YYYY HH:mm"
        },
        calendar: {
            sameDay: "[Ã dag kl.] LT",
            nextDay: "[Ã morgin kl.] LT",
            nextWeek: "dddd [kl.] LT",
            lastDay: "[Ã gjÃ¡r kl.] LT",
            lastWeek: "[sÃ­Ã°stu] dddd [kl] LT",
            sameElse: "L"
        },
        relativeTime: {
            future: "um %s",
            past: "%s sÃ­Ã°ani",
            s: "fÃ¡ sekund",
            m: "ein minutt",
            mm: "%d minuttir",
            h: "ein tÃ­mi",
            hh: "%d tÃ­mar",
            d: "ein dagur",
            dd: "%d dagar",
            M: "ein mÃ¡naÃ°i",
            MM: "%d mÃ¡naÃ°ir",
            y: "eitt Ã¡r",
            yy: "%d Ã¡r"
        },
        ordinalParse: /\d{1,2}\./,
        ordinal: "%d.",
        week: {
            dow: 1,
            doy: 4
        }
    });
    var fr_ca = _moment__default.defineLocale("fr-ca", {
        months: "janvier_fÃ©vrier_mars_avril_mai_juin_juillet_aoÃ»t_septembre_octobre_novembre_dÃ©cembre".split("_"),
        monthsShort: "janv._fÃ©vr._mars_avr._mai_juin_juil._aoÃ»t_sept._oct._nov._dÃ©c.".split("_"),
        weekdays: "dimanche_lundi_mardi_mercredi_jeudi_vendredi_samedi".split("_"),
        weekdaysShort: "dim._lun._mar._mer._jeu._ven._sam.".split("_"),
        weekdaysMin: "Di_Lu_Ma_Me_Je_Ve_Sa".split("_"),
        longDateFormat: {
            LT: "HH:mm",
            LTS: "HH:mm:ss",
            L: "YYYY-MM-DD",
            LL: "D MMMM YYYY",
            LLL: "D MMMM YYYY HH:mm",
            LLLL: "dddd D MMMM YYYY HH:mm"
        },
        calendar: {
            sameDay: "[Aujourd'hui Ã ] LT",
            nextDay: "[Demain Ã ] LT",
            nextWeek: "dddd [Ã ] LT",
            lastDay: "[Hier Ã ] LT",
            lastWeek: "dddd [dernier Ã ] LT",
            sameElse: "L"
        },
        relativeTime: {
            future: "dans %s",
            past: "il y a %s",
            s: "quelques secondes",
            m: "une minute",
            mm: "%d minutes",
            h: "une heure",
            hh: "%d heures",
            d: "un jour",
            dd: "%d jours",
            M: "un mois",
            MM: "%d mois",
            y: "un an",
            yy: "%d ans"
        },
        ordinalParse: /\d{1,2}(er|e)/,
        ordinal: function(number) {
            return number + (number === 1 ? "er" : "e");
        }
    });
    var fr = _moment__default.defineLocale("fr", {
        months: "janvier_fÃ©vrier_mars_avril_mai_juin_juillet_aoÃ»t_septembre_octobre_novembre_dÃ©cembre".split("_"),
        monthsShort: "janv._fÃ©vr._mars_avr._mai_juin_juil._aoÃ»t_sept._oct._nov._dÃ©c.".split("_"),
        weekdays: "dimanche_lundi_mardi_mercredi_jeudi_vendredi_samedi".split("_"),
        weekdaysShort: "dim._lun._mar._mer._jeu._ven._sam.".split("_"),
        weekdaysMin: "Di_Lu_Ma_Me_Je_Ve_Sa".split("_"),
        longDateFormat: {
            LT: "HH:mm",
            LTS: "HH:mm:ss",
            L: "DD/MM/YYYY",
            LL: "D MMMM YYYY",
            LLL: "D MMMM YYYY HH:mm",
            LLLL: "dddd D MMMM YYYY HH:mm"
        },
        calendar: {
            sameDay: "[Aujourd'hui Ã ] LT",
            nextDay: "[Demain Ã ] LT",
            nextWeek: "dddd [Ã ] LT",
            lastDay: "[Hier Ã ] LT",
            lastWeek: "dddd [dernier Ã ] LT",
            sameElse: "L"
        },
        relativeTime: {
            future: "dans %s",
            past: "il y a %s",
            s: "quelques secondes",
            m: "une minute",
            mm: "%d minutes",
            h: "une heure",
            hh: "%d heures",
            d: "un jour",
            dd: "%d jours",
            M: "un mois",
            MM: "%d mois",
            y: "un an",
            yy: "%d ans"
        },
        ordinalParse: /\d{1,2}(er|)/,
        ordinal: function(number) {
            return number + (number === 1 ? "er" : "");
        },
        week: {
            dow: 1,
            doy: 4
        }
    });
    var fy__monthsShortWithDots = "jan._feb._mrt._apr._mai_jun._jul._aug._sep._okt._nov._des.".split("_"), fy__monthsShortWithoutDots = "jan_feb_mrt_apr_mai_jun_jul_aug_sep_okt_nov_des".split("_");
    var fy = _moment__default.defineLocale("fy", {
        months: "jannewaris_febrewaris_maart_april_maaie_juny_july_augustus_septimber_oktober_novimber_desimber".split("_"),
        monthsShort: function(m, format) {
            if (/-MMM-/.test(format)) {
                return fy__monthsShortWithoutDots[m.month()];
            } else {
                return fy__monthsShortWithDots[m.month()];
            }
        },
        weekdays: "snein_moandei_tiisdei_woansdei_tongersdei_freed_sneon".split("_"),
        weekdaysShort: "si._mo._ti._wo._to._fr._so.".split("_"),
        weekdaysMin: "Si_Mo_Ti_Wo_To_Fr_So".split("_"),
        longDateFormat: {
            LT: "HH:mm",
            LTS: "HH:mm:ss",
            L: "DD-MM-YYYY",
            LL: "D MMMM YYYY",
            LLL: "D MMMM YYYY HH:mm",
            LLLL: "dddd D MMMM YYYY HH:mm"
        },
        calendar: {
            sameDay: "[hjoed om] LT",
            nextDay: "[moarn om] LT",
            nextWeek: "dddd [om] LT",
            lastDay: "[juster om] LT",
            lastWeek: "[Ã´frÃ»ne] dddd [om] LT",
            sameElse: "L"
        },
        relativeTime: {
            future: "oer %s",
            past: "%s lyn",
            s: "in pear sekonden",
            m: "ien minÃºt",
            mm: "%d minuten",
            h: "ien oere",
            hh: "%d oeren",
            d: "ien dei",
            dd: "%d dagen",
            M: "ien moanne",
            MM: "%d moannen",
            y: "ien jier",
            yy: "%d jierren"
        },
        ordinalParse: /\d{1,2}(ste|de)/,
        ordinal: function(number) {
            return number + (number === 1 || number === 8 || number >= 20 ? "ste" : "de");
        },
        week: {
            dow: 1,
            doy: 4
        }
    });
    var gl = _moment__default.defineLocale("gl", {
        months: "Xaneiro_Febreiro_Marzo_Abril_Maio_XuÃ±o_Xullo_Agosto_Setembro_Outubro_Novembro_Decembro".split("_"),
        monthsShort: "Xan._Feb._Mar._Abr._Mai._XuÃ±._Xul._Ago._Set._Out._Nov._Dec.".split("_"),
        weekdays: "Domingo_Luns_Martes_MÃ©rcores_Xoves_Venres_SÃ¡bado".split("_"),
        weekdaysShort: "Dom._Lun._Mar._MÃ©r._Xov._Ven._SÃ¡b.".split("_"),
        weekdaysMin: "Do_Lu_Ma_MÃ©_Xo_Ve_SÃ¡".split("_"),
        longDateFormat: {
            LT: "H:mm",
            LTS: "H:mm:ss",
            L: "DD/MM/YYYY",
            LL: "D MMMM YYYY",
            LLL: "D MMMM YYYY H:mm",
            LLLL: "dddd D MMMM YYYY H:mm"
        },
        calendar: {
            sameDay: function() {
                return "[hoxe " + (this.hours() !== 1 ? "Ã¡s" : "Ã¡") + "] LT";
            },
            nextDay: function() {
                return "[maÃ±Ã¡ " + (this.hours() !== 1 ? "Ã¡s" : "Ã¡") + "] LT";
            },
            nextWeek: function() {
                return "dddd [" + (this.hours() !== 1 ? "Ã¡s" : "a") + "] LT";
            },
            lastDay: function() {
                return "[onte " + (this.hours() !== 1 ? "Ã¡" : "a") + "] LT";
            },
            lastWeek: function() {
                return "[o] dddd [pasado " + (this.hours() !== 1 ? "Ã¡s" : "a") + "] LT";
            },
            sameElse: "L"
        },
        relativeTime: {
            future: function(str) {
                if (str === "uns segundos") {
                    return "nuns segundos";
                }
                return "en " + str;
            },
            past: "hai %s",
            s: "uns segundos",
            m: "un minuto",
            mm: "%d minutos",
            h: "unha hora",
            hh: "%d horas",
            d: "un dÃ­a",
            dd: "%d dÃ­as",
            M: "un mes",
            MM: "%d meses",
            y: "un ano",
            yy: "%d anos"
        },
        ordinalParse: /\d{1,2}Âº/,
        ordinal: "%dÂº",
        week: {
            dow: 1,
            doy: 7
        }
    });
    var he = _moment__default.defineLocale("he", {
        months: "×× ×××¨_×¤××¨×××¨_××¨×¥_××¤×¨××_×××_××× ×_××××_×××××¡×_×¡×¤××××¨_×××§××××¨_× ×××××¨_××¦×××¨".split("_"),
        monthsShort: "×× ××³_×¤××¨×³_××¨×¥_××¤×¨×³_×××_××× ×_××××_××××³_×¡×¤××³_×××§×³_× ×××³_××¦××³".split("_"),
        weekdays: "×¨××©××_×©× ×_×©×××©×_×¨×××¢×_××××©×_×©××©×_×©××ª".split("_"),
        weekdaysShort: "××³_××³_××³_××³_××³_××³_×©×³".split("_"),
        weekdaysMin: "×_×_×_×_×_×_×©".split("_"),
        longDateFormat: {
            LT: "HH:mm",
            LTS: "HH:mm:ss",
            L: "DD/MM/YYYY",
            LL: "D [×]MMMM YYYY",
            LLL: "D [×]MMMM YYYY HH:mm",
            LLLL: "dddd, D [×]MMMM YYYY HH:mm",
            l: "D/M/YYYY",
            ll: "D MMM YYYY",
            lll: "D MMM YYYY HH:mm",
            llll: "ddd, D MMM YYYY HH:mm"
        },
        calendar: {
            sameDay: "[×××× ×Ö¾]LT",
            nextDay: "[×××¨ ×Ö¾]LT",
            nextWeek: "dddd [××©×¢×] LT",
            lastDay: "[××ª××× ×Ö¾]LT",
            lastWeek: "[××××] dddd [××××¨×× ××©×¢×] LT",
            sameElse: "L"
        },
        relativeTime: {
            future: "××¢×× %s",
            past: "××¤× × %s",
            s: "××¡×¤×¨ ×©× ×××ª",
            m: "××§×",
            mm: "%d ××§××ª",
            h: "×©×¢×",
            hh: function(number) {
                if (number === 2) {
                    return "×©×¢×ª×××";
                }
                return number + " ×©×¢××ª";
            },
            d: "×××",
            dd: function(number) {
                if (number === 2) {
                    return "××××××";
                }
                return number + " ××××";
            },
            M: "××××©",
            MM: function(number) {
                if (number === 2) {
                    return "××××©×××";
                }
                return number + " ××××©××";
            },
            y: "×©× ×",
            yy: function(number) {
                if (number === 2) {
                    return "×©× ×ª×××";
                } else if (number % 10 === 0 && number !== 10) {
                    return number + " ×©× ×";
                }
                return number + " ×©× ××";
            }
        }
    });
    var hi__symbolMap = {
        "1": "à¥§",
        "2": "à¥¨",
        "3": "à¥©",
        "4": "à¥ª",
        "5": "à¥«",
        "6": "à¥¬",
        "7": "à¥­",
        "8": "à¥®",
        "9": "à¥¯",
        "0": "à¥¦"
    }, hi__numberMap = {
        "à¥§": "1",
        "à¥¨": "2",
        "à¥©": "3",
        "à¥ª": "4",
        "à¥«": "5",
        "à¥¬": "6",
        "à¥­": "7",
        "à¥®": "8",
        "à¥¯": "9",
        "à¥¦": "0"
    };
    var hi = _moment__default.defineLocale("hi", {
        months: "à¤à¤¨à¤µà¤°à¥_à¤«à¤¼à¤°à¤µà¤°à¥_à¤®à¤¾à¤°à¥à¤_à¤à¤ªà¥à¤°à¥à¤²_à¤®à¤_à¤à¥à¤¨_à¤à¥à¤²à¤¾à¤_à¤à¤à¤¸à¥à¤¤_à¤¸à¤¿à¤¤à¤®à¥à¤¬à¤°_à¤à¤à¥à¤à¥à¤¬à¤°_à¤¨à¤µà¤®à¥à¤¬à¤°_à¤¦à¤¿à¤¸à¤®à¥à¤¬à¤°".split("_"),
        monthsShort: "à¤à¤¨._à¤«à¤¼à¤°._à¤®à¤¾à¤°à¥à¤_à¤à¤ªà¥à¤°à¥._à¤®à¤_à¤à¥à¤¨_à¤à¥à¤²._à¤à¤._à¤¸à¤¿à¤¤._à¤à¤à¥à¤à¥._à¤¨à¤µ._à¤¦à¤¿à¤¸.".split("_"),
        weekdays: "à¤°à¤µà¤¿à¤µà¤¾à¤°_à¤¸à¥à¤®à¤µà¤¾à¤°_à¤®à¤à¤à¤²à¤µà¤¾à¤°_à¤¬à¥à¤§à¤µà¤¾à¤°_à¤à¥à¤°à¥à¤µà¤¾à¤°_à¤¶à¥à¤à¥à¤°à¤µà¤¾à¤°_à¤¶à¤¨à¤¿à¤µà¤¾à¤°".split("_"),
        weekdaysShort: "à¤°à¤µà¤¿_à¤¸à¥à¤®_à¤®à¤à¤à¤²_à¤¬à¥à¤§_à¤à¥à¤°à¥_à¤¶à¥à¤à¥à¤°_à¤¶à¤¨à¤¿".split("_"),
        weekdaysMin: "à¤°_à¤¸à¥_à¤®à¤_à¤¬à¥_à¤à¥_à¤¶à¥_à¤¶".split("_"),
        longDateFormat: {
            LT: "A h:mm à¤¬à¤à¥",
            LTS: "A h:mm:ss à¤¬à¤à¥",
            L: "DD/MM/YYYY",
            LL: "D MMMM YYYY",
            LLL: "D MMMM YYYY, A h:mm à¤¬à¤à¥",
            LLLL: "dddd, D MMMM YYYY, A h:mm à¤¬à¤à¥"
        },
        calendar: {
            sameDay: "[à¤à¤] LT",
            nextDay: "[à¤à¤²] LT",
            nextWeek: "dddd, LT",
            lastDay: "[à¤à¤²] LT",
            lastWeek: "[à¤ªà¤¿à¤à¤²à¥] dddd, LT",
            sameElse: "L"
        },
        relativeTime: {
            future: "%s à¤®à¥à¤",
            past: "%s à¤ªà¤¹à¤²à¥",
            s: "à¤à¥à¤ à¤¹à¥ à¤à¥à¤·à¤£",
            m: "à¤à¤ à¤®à¤¿à¤¨à¤",
            mm: "%d à¤®à¤¿à¤¨à¤",
            h: "à¤à¤ à¤à¤à¤à¤¾",
            hh: "%d à¤à¤à¤à¥",
            d: "à¤à¤ à¤¦à¤¿à¤¨",
            dd: "%d à¤¦à¤¿à¤¨",
            M: "à¤à¤ à¤®à¤¹à¥à¤¨à¥",
            MM: "%d à¤®à¤¹à¥à¤¨à¥",
            y: "à¤à¤ à¤µà¤°à¥à¤·",
            yy: "%d à¤µà¤°à¥à¤·"
        },
        preparse: function(string) {
            return string.replace(/[à¥§à¥¨à¥©à¥ªà¥«à¥¬à¥­à¥®à¥¯à¥¦]/g, function(match) {
                return hi__numberMap[match];
            });
        },
        postformat: function(string) {
            return string.replace(/\d/g, function(match) {
                return hi__symbolMap[match];
            });
        },
        meridiemParse: /à¤°à¤¾à¤¤|à¤¸à¥à¤¬à¤¹|à¤¦à¥à¤ªà¤¹à¤°|à¤¶à¤¾à¤®/,
        meridiemHour: function(hour, meridiem) {
            if (hour === 12) {
                hour = 0;
            }
            if (meridiem === "à¤°à¤¾à¤¤") {
                return hour < 4 ? hour : hour + 12;
            } else if (meridiem === "à¤¸à¥à¤¬à¤¹") {
                return hour;
            } else if (meridiem === "à¤¦à¥à¤ªà¤¹à¤°") {
                return hour >= 10 ? hour : hour + 12;
            } else if (meridiem === "à¤¶à¤¾à¤®") {
                return hour + 12;
            }
        },
        meridiem: function(hour, minute, isLower) {
            if (hour < 4) {
                return "à¤°à¤¾à¤¤";
            } else if (hour < 10) {
                return "à¤¸à¥à¤¬à¤¹";
            } else if (hour < 17) {
                return "à¤¦à¥à¤ªà¤¹à¤°";
            } else if (hour < 20) {
                return "à¤¶à¤¾à¤®";
            } else {
                return "à¤°à¤¾à¤¤";
            }
        },
        week: {
            dow: 0,
            doy: 6
        }
    });
    function hr__translate(number, withoutSuffix, key) {
        var result = number + " ";
        switch (key) {
          case "m":
            return withoutSuffix ? "jedna minuta" : "jedne minute";

          case "mm":
            if (number === 1) {
                result += "minuta";
            } else if (number === 2 || number === 3 || number === 4) {
                result += "minute";
            } else {
                result += "minuta";
            }
            return result;

          case "h":
            return withoutSuffix ? "jedan sat" : "jednog sata";

          case "hh":
            if (number === 1) {
                result += "sat";
            } else if (number === 2 || number === 3 || number === 4) {
                result += "sata";
            } else {
                result += "sati";
            }
            return result;

          case "dd":
            if (number === 1) {
                result += "dan";
            } else {
                result += "dana";
            }
            return result;

          case "MM":
            if (number === 1) {
                result += "mjesec";
            } else if (number === 2 || number === 3 || number === 4) {
                result += "mjeseca";
            } else {
                result += "mjeseci";
            }
            return result;

          case "yy":
            if (number === 1) {
                result += "godina";
            } else if (number === 2 || number === 3 || number === 4) {
                result += "godine";
            } else {
                result += "godina";
            }
            return result;
        }
    }
    var hr = _moment__default.defineLocale("hr", {
        months: "sijeÄanj_veljaÄa_oÅ¾ujak_travanj_svibanj_lipanj_srpanj_kolovoz_rujan_listopad_studeni_prosinac".split("_"),
        monthsShort: "sij._velj._oÅ¾u._tra._svi._lip._srp._kol._ruj._lis._stu._pro.".split("_"),
        weekdays: "nedjelja_ponedjeljak_utorak_srijeda_Äetvrtak_petak_subota".split("_"),
        weekdaysShort: "ned._pon._uto._sri._Äet._pet._sub.".split("_"),
        weekdaysMin: "ne_po_ut_sr_Äe_pe_su".split("_"),
        longDateFormat: {
            LT: "H:mm",
            LTS: "H:mm:ss",
            L: "DD. MM. YYYY",
            LL: "D. MMMM YYYY",
            LLL: "D. MMMM YYYY H:mm",
            LLLL: "dddd, D. MMMM YYYY H:mm"
        },
        calendar: {
            sameDay: "[danas u] LT",
            nextDay: "[sutra u] LT",
            nextWeek: function() {
                switch (this.day()) {
                  case 0:
                    return "[u] [nedjelju] [u] LT";

                  case 3:
                    return "[u] [srijedu] [u] LT";

                  case 6:
                    return "[u] [subotu] [u] LT";

                  case 1:
                  case 2:
                  case 4:
                  case 5:
                    return "[u] dddd [u] LT";
                }
            },
            lastDay: "[juÄer u] LT",
            lastWeek: function() {
                switch (this.day()) {
                  case 0:
                  case 3:
                    return "[proÅ¡lu] dddd [u] LT";

                  case 6:
                    return "[proÅ¡le] [subote] [u] LT";

                  case 1:
                  case 2:
                  case 4:
                  case 5:
                    return "[proÅ¡li] dddd [u] LT";
                }
            },
            sameElse: "L"
        },
        relativeTime: {
            future: "za %s",
            past: "prije %s",
            s: "par sekundi",
            m: hr__translate,
            mm: hr__translate,
            h: hr__translate,
            hh: hr__translate,
            d: "dan",
            dd: hr__translate,
            M: "mjesec",
            MM: hr__translate,
            y: "godinu",
            yy: hr__translate
        },
        ordinalParse: /\d{1,2}\./,
        ordinal: "%d.",
        week: {
            dow: 1,
            doy: 7
        }
    });
    var weekEndings = "vasÃ¡rnap hÃ©tfÅn kedden szerdÃ¡n csÃ¼tÃ¶rtÃ¶kÃ¶n pÃ©nteken szombaton".split(" ");
    function hu__translate(number, withoutSuffix, key, isFuture) {
        var num = number, suffix;
        switch (key) {
          case "s":
            return isFuture || withoutSuffix ? "nÃ©hÃ¡ny mÃ¡sodperc" : "nÃ©hÃ¡ny mÃ¡sodperce";

          case "m":
            return "egy" + (isFuture || withoutSuffix ? " perc" : " perce");

          case "mm":
            return num + (isFuture || withoutSuffix ? " perc" : " perce");

          case "h":
            return "egy" + (isFuture || withoutSuffix ? " Ã³ra" : " Ã³rÃ¡ja");

          case "hh":
            return num + (isFuture || withoutSuffix ? " Ã³ra" : " Ã³rÃ¡ja");

          case "d":
            return "egy" + (isFuture || withoutSuffix ? " nap" : " napja");

          case "dd":
            return num + (isFuture || withoutSuffix ? " nap" : " napja");

          case "M":
            return "egy" + (isFuture || withoutSuffix ? " hÃ³nap" : " hÃ³napja");

          case "MM":
            return num + (isFuture || withoutSuffix ? " hÃ³nap" : " hÃ³napja");

          case "y":
            return "egy" + (isFuture || withoutSuffix ? " Ã©v" : " Ã©ve");

          case "yy":
            return num + (isFuture || withoutSuffix ? " Ã©v" : " Ã©ve");
        }
        return "";
    }
    function week(isFuture) {
        return (isFuture ? "" : "[mÃºlt] ") + "[" + weekEndings[this.day()] + "] LT[-kor]";
    }
    var hu = _moment__default.defineLocale("hu", {
        months: "januÃ¡r_februÃ¡r_mÃ¡rcius_Ã¡prilis_mÃ¡jus_jÃºnius_jÃºlius_augusztus_szeptember_oktÃ³ber_november_december".split("_"),
        monthsShort: "jan_feb_mÃ¡rc_Ã¡pr_mÃ¡j_jÃºn_jÃºl_aug_szept_okt_nov_dec".split("_"),
        weekdays: "vasÃ¡rnap_hÃ©tfÅ_kedd_szerda_csÃ¼tÃ¶rtÃ¶k_pÃ©ntek_szombat".split("_"),
        weekdaysShort: "vas_hÃ©t_kedd_sze_csÃ¼t_pÃ©n_szo".split("_"),
        weekdaysMin: "v_h_k_sze_cs_p_szo".split("_"),
        longDateFormat: {
            LT: "H:mm",
            LTS: "H:mm:ss",
            L: "YYYY.MM.DD.",
            LL: "YYYY. MMMM D.",
            LLL: "YYYY. MMMM D. H:mm",
            LLLL: "YYYY. MMMM D., dddd H:mm"
        },
        meridiemParse: /de|du/i,
        isPM: function(input) {
            return input.charAt(1).toLowerCase() === "u";
        },
        meridiem: function(hours, minutes, isLower) {
            if (hours < 12) {
                return isLower === true ? "de" : "DE";
            } else {
                return isLower === true ? "du" : "DU";
            }
        },
        calendar: {
            sameDay: "[ma] LT[-kor]",
            nextDay: "[holnap] LT[-kor]",
            nextWeek: function() {
                return week.call(this, true);
            },
            lastDay: "[tegnap] LT[-kor]",
            lastWeek: function() {
                return week.call(this, false);
            },
            sameElse: "L"
        },
        relativeTime: {
            future: "%s mÃºlva",
            past: "%s",
            s: hu__translate,
            m: hu__translate,
            mm: hu__translate,
            h: hu__translate,
            hh: hu__translate,
            d: hu__translate,
            dd: hu__translate,
            M: hu__translate,
            MM: hu__translate,
            y: hu__translate,
            yy: hu__translate
        },
        ordinalParse: /\d{1,2}\./,
        ordinal: "%d.",
        week: {
            dow: 1,
            doy: 7
        }
    });
    function hy_am__monthsCaseReplace(m, format) {
        var months = {
            nominative: "Õ°Õ¸ÖÕ¶Õ¾Õ¡Ö_ÖÕ¥Õ¿ÖÕ¾Õ¡Ö_Õ´Õ¡ÖÕ¿_Õ¡ÕºÖÕ«Õ¬_Õ´Õ¡ÕµÕ«Õ½_Õ°Õ¸ÖÕ¶Õ«Õ½_Õ°Õ¸ÖÕ¬Õ«Õ½_ÖÕ£Õ¸Õ½Õ¿Õ¸Õ½_Õ½Õ¥ÕºÕ¿Õ¥Õ´Õ¢Õ¥Ö_Õ°Õ¸Õ¯Õ¿Õ¥Õ´Õ¢Õ¥Ö_Õ¶Õ¸ÕµÕ¥Õ´Õ¢Õ¥Ö_Õ¤Õ¥Õ¯Õ¿Õ¥Õ´Õ¢Õ¥Ö".split("_"),
            accusative: "Õ°Õ¸ÖÕ¶Õ¾Õ¡ÖÕ«_ÖÕ¥Õ¿ÖÕ¾Õ¡ÖÕ«_Õ´Õ¡ÖÕ¿Õ«_Õ¡ÕºÖÕ«Õ¬Õ«_Õ´Õ¡ÕµÕ«Õ½Õ«_Õ°Õ¸ÖÕ¶Õ«Õ½Õ«_Õ°Õ¸ÖÕ¬Õ«Õ½Õ«_ÖÕ£Õ¸Õ½Õ¿Õ¸Õ½Õ«_Õ½Õ¥ÕºÕ¿Õ¥Õ´Õ¢Õ¥ÖÕ«_Õ°Õ¸Õ¯Õ¿Õ¥Õ´Õ¢Õ¥ÖÕ«_Õ¶Õ¸ÕµÕ¥Õ´Õ¢Õ¥ÖÕ«_Õ¤Õ¥Õ¯Õ¿Õ¥Õ´Õ¢Õ¥ÖÕ«".split("_")
        }, nounCase = /D[oD]?(\[[^\[\]]*\]|\s+)+MMMM?/.test(format) ? "accusative" : "nominative";
        return months[nounCase][m.month()];
    }
    function hy_am__monthsShortCaseReplace(m, format) {
        var monthsShort = "Õ°Õ¶Õ¾_ÖÕ¿Ö_Õ´ÖÕ¿_Õ¡ÕºÖ_Õ´ÕµÕ½_Õ°Õ¶Õ½_Õ°Õ¬Õ½_ÖÕ£Õ½_Õ½ÕºÕ¿_Õ°Õ¯Õ¿_Õ¶Õ´Õ¢_Õ¤Õ¯Õ¿".split("_");
        return monthsShort[m.month()];
    }
    function hy_am__weekdaysCaseReplace(m, format) {
        var weekdays = "Õ¯Õ«ÖÕ¡Õ¯Õ«_Õ¥ÖÕ¯Õ¸ÖÕ·Õ¡Õ¢Õ©Õ«_Õ¥ÖÕ¥ÖÕ·Õ¡Õ¢Õ©Õ«_Õ¹Õ¸ÖÕ¥ÖÕ·Õ¡Õ¢Õ©Õ«_Õ°Õ«Õ¶Õ£Õ·Õ¡Õ¢Õ©Õ«_Õ¸ÖÖÕ¢Õ¡Õ©_Õ·Õ¡Õ¢Õ¡Õ©".split("_");
        return weekdays[m.day()];
    }
    var hy_am = _moment__default.defineLocale("hy-am", {
        months: hy_am__monthsCaseReplace,
        monthsShort: hy_am__monthsShortCaseReplace,
        weekdays: hy_am__weekdaysCaseReplace,
        weekdaysShort: "Õ¯ÖÕ¯_Õ¥ÖÕ¯_Õ¥ÖÖ_Õ¹ÖÖ_Õ°Õ¶Õ£_Õ¸ÖÖÕ¢_Õ·Õ¢Õ©".split("_"),
        weekdaysMin: "Õ¯ÖÕ¯_Õ¥ÖÕ¯_Õ¥ÖÖ_Õ¹ÖÖ_Õ°Õ¶Õ£_Õ¸ÖÖÕ¢_Õ·Õ¢Õ©".split("_"),
        longDateFormat: {
            LT: "HH:mm",
            LTS: "HH:mm:ss",
            L: "DD.MM.YYYY",
            LL: "D MMMM YYYY Õ©.",
            LLL: "D MMMM YYYY Õ©., HH:mm",
            LLLL: "dddd, D MMMM YYYY Õ©., HH:mm"
        },
        calendar: {
            sameDay: "[Õ¡ÕµÕ½ÖÖ] LT",
            nextDay: "[Õ¾Õ¡Õ²Õ¨] LT",
            lastDay: "[Õ¥ÖÕ¥Õ¯] LT",
            nextWeek: function() {
                return "dddd [ÖÖÕ¨ ÕªÕ¡Õ´Õ¨] LT";
            },
            lastWeek: function() {
                return "[Õ¡Õ¶ÖÕ¡Õ®] dddd [ÖÖÕ¨ ÕªÕ¡Õ´Õ¨] LT";
            },
            sameElse: "L"
        },
        relativeTime: {
            future: "%s Õ°Õ¥Õ¿Õ¸",
            past: "%s Õ¡Õ¼Õ¡Õ»",
            s: "Õ´Õ« ÖÕ¡Õ¶Õ« Õ¾Õ¡ÕµÖÕ¯ÕµÕ¡Õ¶",
            m: "ÖÕ¸ÕºÕ¥",
            mm: "%d ÖÕ¸ÕºÕ¥",
            h: "ÕªÕ¡Õ´",
            hh: "%d ÕªÕ¡Õ´",
            d: "ÖÖ",
            dd: "%d ÖÖ",
            M: "Õ¡Õ´Õ«Õ½",
            MM: "%d Õ¡Õ´Õ«Õ½",
            y: "Õ¿Õ¡ÖÕ«",
            yy: "%d Õ¿Õ¡ÖÕ«"
        },
        meridiemParse: /Õ£Õ«Õ·Õ¥ÖÕ¾Õ¡|Õ¡Õ¼Õ¡Õ¾Õ¸Õ¿Õ¾Õ¡|ÖÕ¥ÖÕ¥Õ¯Õ¾Õ¡|Õ¥ÖÕ¥Õ¯Õ¸ÕµÕ¡Õ¶/,
        isPM: function(input) {
            return /^(ÖÕ¥ÖÕ¥Õ¯Õ¾Õ¡|Õ¥ÖÕ¥Õ¯Õ¸ÕµÕ¡Õ¶)$/.test(input);
        },
        meridiem: function(hour) {
            if (hour < 4) {
                return "Õ£Õ«Õ·Õ¥ÖÕ¾Õ¡";
            } else if (hour < 12) {
                return "Õ¡Õ¼Õ¡Õ¾Õ¸Õ¿Õ¾Õ¡";
            } else if (hour < 17) {
                return "ÖÕ¥ÖÕ¥Õ¯Õ¾Õ¡";
            } else {
                return "Õ¥ÖÕ¥Õ¯Õ¸ÕµÕ¡Õ¶";
            }
        },
        ordinalParse: /\d{1,2}|\d{1,2}-(Õ«Õ¶|ÖÕ¤)/,
        ordinal: function(number, period) {
            switch (period) {
              case "DDD":
              case "w":
              case "W":
              case "DDDo":
                if (number === 1) {
                    return number + "-Õ«Õ¶";
                }
                return number + "-ÖÕ¤";

              default:
                return number;
            }
        },
        week: {
            dow: 1,
            doy: 7
        }
    });
    var id = _moment__default.defineLocale("id", {
        months: "Januari_Februari_Maret_April_Mei_Juni_Juli_Agustus_September_Oktober_November_Desember".split("_"),
        monthsShort: "Jan_Feb_Mar_Apr_Mei_Jun_Jul_Ags_Sep_Okt_Nov_Des".split("_"),
        weekdays: "Minggu_Senin_Selasa_Rabu_Kamis_Jumat_Sabtu".split("_"),
        weekdaysShort: "Min_Sen_Sel_Rab_Kam_Jum_Sab".split("_"),
        weekdaysMin: "Mg_Sn_Sl_Rb_Km_Jm_Sb".split("_"),
        longDateFormat: {
            LT: "HH.mm",
            LTS: "HH.mm.ss",
            L: "DD/MM/YYYY",
            LL: "D MMMM YYYY",
            LLL: "D MMMM YYYY [pukul] HH.mm",
            LLLL: "dddd, D MMMM YYYY [pukul] HH.mm"
        },
        meridiemParse: /pagi|siang|sore|malam/,
        meridiemHour: function(hour, meridiem) {
            if (hour === 12) {
                hour = 0;
            }
            if (meridiem === "pagi") {
                return hour;
            } else if (meridiem === "siang") {
                return hour >= 11 ? hour : hour + 12;
            } else if (meridiem === "sore" || meridiem === "malam") {
                return hour + 12;
            }
        },
        meridiem: function(hours, minutes, isLower) {
            if (hours < 11) {
                return "pagi";
            } else if (hours < 15) {
                return "siang";
            } else if (hours < 19) {
                return "sore";
            } else {
                return "malam";
            }
        },
        calendar: {
            sameDay: "[Hari ini pukul] LT",
            nextDay: "[Besok pukul] LT",
            nextWeek: "dddd [pukul] LT",
            lastDay: "[Kemarin pukul] LT",
            lastWeek: "dddd [lalu pukul] LT",
            sameElse: "L"
        },
        relativeTime: {
            future: "dalam %s",
            past: "%s yang lalu",
            s: "beberapa detik",
            m: "semenit",
            mm: "%d menit",
            h: "sejam",
            hh: "%d jam",
            d: "sehari",
            dd: "%d hari",
            M: "sebulan",
            MM: "%d bulan",
            y: "setahun",
            yy: "%d tahun"
        },
        week: {
            dow: 1,
            doy: 7
        }
    });
    function is__plural(n) {
        if (n % 100 === 11) {
            return true;
        } else if (n % 10 === 1) {
            return false;
        }
        return true;
    }
    function is__translate(number, withoutSuffix, key, isFuture) {
        var result = number + " ";
        switch (key) {
          case "s":
            return withoutSuffix || isFuture ? "nokkrar sekÃºndur" : "nokkrum sekÃºndum";

          case "m":
            return withoutSuffix ? "mÃ­nÃºta" : "mÃ­nÃºtu";

          case "mm":
            if (is__plural(number)) {
                return result + (withoutSuffix || isFuture ? "mÃ­nÃºtur" : "mÃ­nÃºtum");
            } else if (withoutSuffix) {
                return result + "mÃ­nÃºta";
            }
            return result + "mÃ­nÃºtu";

          case "hh":
            if (is__plural(number)) {
                return result + (withoutSuffix || isFuture ? "klukkustundir" : "klukkustundum");
            }
            return result + "klukkustund";

          case "d":
            if (withoutSuffix) {
                return "dagur";
            }
            return isFuture ? "dag" : "degi";

          case "dd":
            if (is__plural(number)) {
                if (withoutSuffix) {
                    return result + "dagar";
                }
                return result + (isFuture ? "daga" : "dÃ¶gum");
            } else if (withoutSuffix) {
                return result + "dagur";
            }
            return result + (isFuture ? "dag" : "degi");

          case "M":
            if (withoutSuffix) {
                return "mÃ¡nuÃ°ur";
            }
            return isFuture ? "mÃ¡nuÃ°" : "mÃ¡nuÃ°i";

          case "MM":
            if (is__plural(number)) {
                if (withoutSuffix) {
                    return result + "mÃ¡nuÃ°ir";
                }
                return result + (isFuture ? "mÃ¡nuÃ°i" : "mÃ¡nuÃ°um");
            } else if (withoutSuffix) {
                return result + "mÃ¡nuÃ°ur";
            }
            return result + (isFuture ? "mÃ¡nuÃ°" : "mÃ¡nuÃ°i");

          case "y":
            return withoutSuffix || isFuture ? "Ã¡r" : "Ã¡ri";

          case "yy":
            if (is__plural(number)) {
                return result + (withoutSuffix || isFuture ? "Ã¡r" : "Ã¡rum");
            }
            return result + (withoutSuffix || isFuture ? "Ã¡r" : "Ã¡ri");
        }
    }
    var is = _moment__default.defineLocale("is", {
        months: "janÃºar_febrÃºar_mars_aprÃ­l_maÃ­_jÃºnÃ­_jÃºlÃ­_Ã¡gÃºst_september_oktÃ³ber_nÃ³vember_desember".split("_"),
        monthsShort: "jan_feb_mar_apr_maÃ­_jÃºn_jÃºl_Ã¡gÃº_sep_okt_nÃ³v_des".split("_"),
        weekdays: "sunnudagur_mÃ¡nudagur_Ã¾riÃ°judagur_miÃ°vikudagur_fimmtudagur_fÃ¶studagur_laugardagur".split("_"),
        weekdaysShort: "sun_mÃ¡n_Ã¾ri_miÃ°_fim_fÃ¶s_lau".split("_"),
        weekdaysMin: "Su_MÃ¡_Ãr_Mi_Fi_FÃ¶_La".split("_"),
        longDateFormat: {
            LT: "H:mm",
            LTS: "H:mm:ss",
            L: "DD/MM/YYYY",
            LL: "D. MMMM YYYY",
            LLL: "D. MMMM YYYY [kl.] H:mm",
            LLLL: "dddd, D. MMMM YYYY [kl.] H:mm"
        },
        calendar: {
            sameDay: "[Ã­ dag kl.] LT",
            nextDay: "[Ã¡ morgun kl.] LT",
            nextWeek: "dddd [kl.] LT",
            lastDay: "[Ã­ gÃ¦r kl.] LT",
            lastWeek: "[sÃ­Ã°asta] dddd [kl.] LT",
            sameElse: "L"
        },
        relativeTime: {
            future: "eftir %s",
            past: "fyrir %s sÃ­Ã°an",
            s: is__translate,
            m: is__translate,
            mm: is__translate,
            h: "klukkustund",
            hh: is__translate,
            d: is__translate,
            dd: is__translate,
            M: is__translate,
            MM: is__translate,
            y: is__translate,
            yy: is__translate
        },
        ordinalParse: /\d{1,2}\./,
        ordinal: "%d.",
        week: {
            dow: 1,
            doy: 4
        }
    });
    var it = _moment__default.defineLocale("it", {
        months: "gennaio_febbraio_marzo_aprile_maggio_giugno_luglio_agosto_settembre_ottobre_novembre_dicembre".split("_"),
        monthsShort: "gen_feb_mar_apr_mag_giu_lug_ago_set_ott_nov_dic".split("_"),
        weekdays: "Domenica_LunedÃ¬_MartedÃ¬_MercoledÃ¬_GiovedÃ¬_VenerdÃ¬_Sabato".split("_"),
        weekdaysShort: "Dom_Lun_Mar_Mer_Gio_Ven_Sab".split("_"),
        weekdaysMin: "D_L_Ma_Me_G_V_S".split("_"),
        longDateFormat: {
            LT: "HH:mm",
            LTS: "HH:mm:ss",
            L: "DD/MM/YYYY",
            LL: "D MMMM YYYY",
            LLL: "D MMMM YYYY HH:mm",
            LLLL: "dddd, D MMMM YYYY HH:mm"
        },
        calendar: {
            sameDay: "[Oggi alle] LT",
            nextDay: "[Domani alle] LT",
            nextWeek: "dddd [alle] LT",
            lastDay: "[Ieri alle] LT",
            lastWeek: function() {
                switch (this.day()) {
                  case 0:
                    return "[la scorsa] dddd [alle] LT";

                  default:
                    return "[lo scorso] dddd [alle] LT";
                }
            },
            sameElse: "L"
        },
        relativeTime: {
            future: function(s) {
                return (/^[0-9].+$/.test(s) ? "tra" : "in") + " " + s;
            },
            past: "%s fa",
            s: "alcuni secondi",
            m: "un minuto",
            mm: "%d minuti",
            h: "un'ora",
            hh: "%d ore",
            d: "un giorno",
            dd: "%d giorni",
            M: "un mese",
            MM: "%d mesi",
            y: "un anno",
            yy: "%d anni"
        },
        ordinalParse: /\d{1,2}Âº/,
        ordinal: "%dÂº",
        week: {
            dow: 1,
            doy: 4
        }
    });
    var ja = _moment__default.defineLocale("ja", {
        months: "1æ_2æ_3æ_4æ_5æ_6æ_7æ_8æ_9æ_10æ_11æ_12æ".split("_"),
        monthsShort: "1æ_2æ_3æ_4æ_5æ_6æ_7æ_8æ_9æ_10æ_11æ_12æ".split("_"),
        weekdays: "æ¥ææ¥_æææ¥_ç«ææ¥_æ°´ææ¥_æ¨ææ¥_éææ¥_åææ¥".split("_"),
        weekdaysShort: "æ¥_æ_ç«_æ°´_æ¨_é_å".split("_"),
        weekdaysMin: "æ¥_æ_ç«_æ°´_æ¨_é_å".split("_"),
        longDateFormat: {
            LT: "Ahæmå",
            LTS: "Ahæmåsç§",
            L: "YYYY/MM/DD",
            LL: "YYYYå¹´MæDæ¥",
            LLL: "YYYYå¹´MæDæ¥Ahæmå",
            LLLL: "YYYYå¹´MæDæ¥Ahæmå dddd"
        },
        meridiemParse: /åå|åå¾/i,
        isPM: function(input) {
            return input === "åå¾";
        },
        meridiem: function(hour, minute, isLower) {
            if (hour < 12) {
                return "åå";
            } else {
                return "åå¾";
            }
        },
        calendar: {
            sameDay: "[ä»æ¥] LT",
            nextDay: "[ææ¥] LT",
            nextWeek: "[æ¥é±]dddd LT",
            lastDay: "[æ¨æ¥] LT",
            lastWeek: "[åé±]dddd LT",
            sameElse: "L"
        },
        relativeTime: {
            future: "%så¾",
            past: "%så",
            s: "æ°ç§",
            m: "1å",
            mm: "%då",
            h: "1æé",
            hh: "%dæé",
            d: "1æ¥",
            dd: "%dæ¥",
            M: "1ã¶æ",
            MM: "%dã¶æ",
            y: "1å¹´",
            yy: "%då¹´"
        }
    });
    var jv = _moment__default.defineLocale("jv", {
        months: "Januari_Februari_Maret_April_Mei_Juni_Juli_Agustus_September_Oktober_Nopember_Desember".split("_"),
        monthsShort: "Jan_Feb_Mar_Apr_Mei_Jun_Jul_Ags_Sep_Okt_Nop_Des".split("_"),
        weekdays: "Minggu_Senen_Seloso_Rebu_Kemis_Jemuwah_Septu".split("_"),
        weekdaysShort: "Min_Sen_Sel_Reb_Kem_Jem_Sep".split("_"),
        weekdaysMin: "Mg_Sn_Sl_Rb_Km_Jm_Sp".split("_"),
        longDateFormat: {
            LT: "HH.mm",
            LTS: "HH.mm.ss",
            L: "DD/MM/YYYY",
            LL: "D MMMM YYYY",
            LLL: "D MMMM YYYY [pukul] HH.mm",
            LLLL: "dddd, D MMMM YYYY [pukul] HH.mm"
        },
        meridiemParse: /enjing|siyang|sonten|ndalu/,
        meridiemHour: function(hour, meridiem) {
            if (hour === 12) {
                hour = 0;
            }
            if (meridiem === "enjing") {
                return hour;
            } else if (meridiem === "siyang") {
                return hour >= 11 ? hour : hour + 12;
            } else if (meridiem === "sonten" || meridiem === "ndalu") {
                return hour + 12;
            }
        },
        meridiem: function(hours, minutes, isLower) {
            if (hours < 11) {
                return "enjing";
            } else if (hours < 15) {
                return "siyang";
            } else if (hours < 19) {
                return "sonten";
            } else {
                return "ndalu";
            }
        },
        calendar: {
            sameDay: "[Dinten puniko pukul] LT",
            nextDay: "[Mbenjang pukul] LT",
            nextWeek: "dddd [pukul] LT",
            lastDay: "[Kala wingi pukul] LT",
            lastWeek: "dddd [kepengker pukul] LT",
            sameElse: "L"
        },
        relativeTime: {
            future: "wonten ing %s",
            past: "%s ingkang kepengker",
            s: "sawetawis detik",
            m: "setunggal menit",
            mm: "%d menit",
            h: "setunggal jam",
            hh: "%d jam",
            d: "sedinten",
            dd: "%d dinten",
            M: "sewulan",
            MM: "%d wulan",
            y: "setaun",
            yy: "%d taun"
        },
        week: {
            dow: 1,
            doy: 7
        }
    });
    function ka__monthsCaseReplace(m, format) {
        var months = {
            nominative: "áááááá á_ááááá áááá_ááá á¢á_ááá ááá_áááá¡á_ááááá¡á_ááááá¡á_ááááá¡á¢á_á¡áá¥á¢ááááá á_áá¥á¢ááááá á_ááááááá á_áááááááá á".split("_"),
            accusative: "áááááá á¡_ááááá áááá¡_ááá á¢á¡_ááá áááá¡_áááá¡á¡_ááááá¡á¡_ááááá¡á¡_ááááá¡á¢á¡_á¡áá¥á¢ááááá á¡_áá¥á¢ááááá á¡_ááááááá á¡_áááááááá á¡".split("_")
        }, nounCase = /D[oD] *MMMM?/.test(format) ? "accusative" : "nominative";
        return months[nounCase][m.month()];
    }
    function ka__weekdaysCaseReplace(m, format) {
        var weekdays = {
            nominative: "áááá á_áá á¨ááááá_á¡ááá¨ááááá_ááá®á¨ááááá_á®á£áá¨ááááá_ááá áá¡áááá_á¨ááááá".split("_"),
            accusative: "áááá áá¡_áá á¨ááááá¡_á¡ááá¨ááááá¡_ááá®á¨ááááá¡_á®á£áá¨ááááá¡_ááá áá¡áááá¡_á¨ááááá¡".split("_")
        }, nounCase = /(á¬ááá|á¨ááááá)/.test(format) ? "accusative" : "nominative";
        return weekdays[nounCase][m.day()];
    }
    var ka = _moment__default.defineLocale("ka", {
        months: ka__monthsCaseReplace,
        monthsShort: "ááá_ááá_ááá _ááá _ááá_ááá_ááá_ááá_á¡áá¥_áá¥á¢_ááá_ááá".split("_"),
        weekdays: ka__weekdaysCaseReplace,
        weekdaysShort: "ááá_áá á¨_á¡áá_ááá®_á®á£á_ááá _á¨áá".split("_"),
        weekdaysMin: "áá_áá _á¡á_áá_á®á£_áá_á¨á".split("_"),
        longDateFormat: {
            LT: "h:mm A",
            LTS: "h:mm:ss A",
            L: "DD/MM/YYYY",
            LL: "D MMMM YYYY",
            LLL: "D MMMM YYYY h:mm A",
            LLLL: "dddd, D MMMM YYYY h:mm A"
        },
        calendar: {
            sameDay: "[áá¦áá¡] LT[-áá]",
            nextDay: "[á®ááá] LT[-áá]",
            lastDay: "[áá£á¨áá] LT[-áá]",
            nextWeek: "[á¨ááááá] dddd LT[-áá]",
            lastWeek: "[á¬ááá] dddd LT-áá",
            sameElse: "L"
        },
        relativeTime: {
            future: function(s) {
                return /(á¬ááá|á¬á£áá|á¡áááá|á¬ááá)/.test(s) ? s.replace(/á$/, "á¨á") : s + "á¨á";
            },
            past: function(s) {
                if (/(á¬ááá|á¬á£áá|á¡áááá|áá¦á|ááá)/.test(s)) {
                    return s.replace(/(á|á)$/, "áá¡ á¬áá");
                }
                if (/á¬ááá/.test(s)) {
                    return s.replace(/á¬ááá$/, "á¬ááá¡ á¬áá");
                }
            },
            s: "á áááááááá á¬ááá",
            m: "á¬á£áá",
            mm: "%d á¬á£áá",
            h: "á¡áááá",
            hh: "%d á¡áááá",
            d: "áá¦á",
            dd: "%d áá¦á",
            M: "ááá",
            MM: "%d ááá",
            y: "á¬ááá",
            yy: "%d á¬ááá"
        },
        ordinalParse: /0|1-áá|áá-\d{1,2}|\d{1,2}-á/,
        ordinal: function(number) {
            if (number === 0) {
                return number;
            }
            if (number === 1) {
                return number + "-áá";
            }
            if (number < 20 || number <= 100 && number % 20 === 0 || number % 100 === 0) {
                return "áá-" + number;
            }
            return number + "-á";
        },
        week: {
            dow: 1,
            doy: 7
        }
    });
    var km = _moment__default.defineLocale("km", {
        months: "áááá¶_áá»áááá_áá·áá¶_áááá¶_á§ááá¶_áá·áá»áá¶_áááááá¶_áá¸á á¶_ááááá¶_áá»áá¶_áá·áááá·áá¶_áááá¼".split("_"),
        monthsShort: "áááá¶_áá»áááá_áá·áá¶_áááá¶_á§ááá¶_áá·áá»áá¶_áááááá¶_áá¸á á¶_ááááá¶_áá»áá¶_áá·áááá·áá¶_áááá¼".split("_"),
        weekdays: "á¢á¶áá·ááá_ááááá_á¢áááá¶á_áá»á_áááá ááááá·á_áá»ááá_áááá".split("_"),
        weekdaysShort: "á¢á¶áá·ááá_ááááá_á¢áááá¶á_áá»á_áááá ááááá·á_áá»ááá_áááá".split("_"),
        weekdaysMin: "á¢á¶áá·ááá_ááááá_á¢áááá¶á_áá»á_áááá ááááá·á_áá»ááá_áááá".split("_"),
        longDateFormat: {
            LT: "HH:mm",
            LTS: "HH:mm:ss",
            L: "DD/MM/YYYY",
            LL: "D MMMM YYYY",
            LLL: "D MMMM YYYY HH:mm",
            LLLL: "dddd, D MMMM YYYY HH:mm"
        },
        calendar: {
            sameDay: "[áááááá áááá] LT",
            nextDay: "[ááá¢áá áááá] LT",
            nextWeek: "dddd [áááá] LT",
            lastDay: "[áááá·ááá·á áááá] LT",
            lastWeek: "dddd [ááááá¶á ááá»á] [áááá] LT",
            sameElse: "L"
        },
        relativeTime: {
            future: "%sááá",
            past: "%sáá»á",
            s: "ááá»áááá¶ááá·áá¶áá¸",
            m: "áá½ááá¶áá¸",
            mm: "%d áá¶áá¸",
            h: "áá½ááááá",
            hh: "%d áááá",
            d: "áá½ááááá",
            dd: "%d áááá",
            M: "áá½ááá",
            MM: "%d áá",
            y: "áá½ááááá¶á",
            yy: "%d áááá¶á"
        },
        week: {
            dow: 1,
            doy: 4
        }
    });
    var ko = _moment__default.defineLocale("ko", {
        months: "1ì_2ì_3ì_4ì_5ì_6ì_7ì_8ì_9ì_10ì_11ì_12ì".split("_"),
        monthsShort: "1ì_2ì_3ì_4ì_5ì_6ì_7ì_8ì_9ì_10ì_11ì_12ì".split("_"),
        weekdays: "ì¼ìì¼_ììì¼_íìì¼_ììì¼_ëª©ìì¼_ê¸ìì¼_í ìì¼".split("_"),
        weekdaysShort: "ì¼_ì_í_ì_ëª©_ê¸_í ".split("_"),
        weekdaysMin: "ì¼_ì_í_ì_ëª©_ê¸_í ".split("_"),
        longDateFormat: {
            LT: "A hì më¶",
            LTS: "A hì më¶ sì´",
            L: "YYYY.MM.DD",
            LL: "YYYYë MMMM Dì¼",
            LLL: "YYYYë MMMM Dì¼ A hì më¶",
            LLLL: "YYYYë MMMM Dì¼ dddd A hì më¶"
        },
        calendar: {
            sameDay: "ì¤ë LT",
            nextDay: "ë´ì¼ LT",
            nextWeek: "dddd LT",
            lastDay: "ì´ì  LT",
            lastWeek: "ì§ëì£¼ dddd LT",
            sameElse: "L"
        },
        relativeTime: {
            future: "%s í",
            past: "%s ì ",
            s: "ëªì´",
            ss: "%dì´",
            m: "ì¼ë¶",
            mm: "%dë¶",
            h: "íìê°",
            hh: "%dìê°",
            d: "íë£¨",
            dd: "%dì¼",
            M: "íë¬",
            MM: "%dë¬",
            y: "ì¼ë",
            yy: "%dë"
        },
        ordinalParse: /\d{1,2}ì¼/,
        ordinal: "%dì¼",
        meridiemParse: /ì¤ì |ì¤í/,
        isPM: function(token) {
            return token === "ì¤í";
        },
        meridiem: function(hour, minute, isUpper) {
            return hour < 12 ? "ì¤ì " : "ì¤í";
        }
    });
    function lb__processRelativeTime(number, withoutSuffix, key, isFuture) {
        var format = {
            m: [ "eng Minutt", "enger Minutt" ],
            h: [ "eng Stonn", "enger Stonn" ],
            d: [ "een Dag", "engem Dag" ],
            M: [ "ee Mount", "engem Mount" ],
            y: [ "ee Joer", "engem Joer" ]
        };
        return withoutSuffix ? format[key][0] : format[key][1];
    }
    function processFutureTime(string) {
        var number = string.substr(0, string.indexOf(" "));
        if (eifelerRegelAppliesToNumber(number)) {
            return "a " + string;
        }
        return "an " + string;
    }
    function processPastTime(string) {
        var number = string.substr(0, string.indexOf(" "));
        if (eifelerRegelAppliesToNumber(number)) {
            return "viru " + string;
        }
        return "virun " + string;
    }
    function eifelerRegelAppliesToNumber(number) {
        number = parseInt(number, 10);
        if (isNaN(number)) {
            return false;
        }
        if (number < 0) {
            return true;
        } else if (number < 10) {
            if (4 <= number && number <= 7) {
                return true;
            }
            return false;
        } else if (number < 100) {
            var lastDigit = number % 10, firstDigit = number / 10;
            if (lastDigit === 0) {
                return eifelerRegelAppliesToNumber(firstDigit);
            }
            return eifelerRegelAppliesToNumber(lastDigit);
        } else if (number < 1e4) {
            while (number >= 10) {
                number = number / 10;
            }
            return eifelerRegelAppliesToNumber(number);
        } else {
            number = number / 1e3;
            return eifelerRegelAppliesToNumber(number);
        }
    }
    var lb = _moment__default.defineLocale("lb", {
        months: "Januar_Februar_MÃ¤erz_AbrÃ«ll_Mee_Juni_Juli_August_September_Oktober_November_Dezember".split("_"),
        monthsShort: "Jan._Febr._Mrz._Abr._Mee_Jun._Jul._Aug._Sept._Okt._Nov._Dez.".split("_"),
        weekdays: "Sonndeg_MÃ©indeg_DÃ«nschdeg_MÃ«ttwoch_Donneschdeg_Freideg_Samschdeg".split("_"),
        weekdaysShort: "So._MÃ©._DÃ«._MÃ«._Do._Fr._Sa.".split("_"),
        weekdaysMin: "So_MÃ©_DÃ«_MÃ«_Do_Fr_Sa".split("_"),
        longDateFormat: {
            LT: "H:mm [Auer]",
            LTS: "H:mm:ss [Auer]",
            L: "DD.MM.YYYY",
            LL: "D. MMMM YYYY",
            LLL: "D. MMMM YYYY H:mm [Auer]",
            LLLL: "dddd, D. MMMM YYYY H:mm [Auer]"
        },
        calendar: {
            sameDay: "[Haut um] LT",
            sameElse: "L",
            nextDay: "[Muer um] LT",
            nextWeek: "dddd [um] LT",
            lastDay: "[GÃ«schter um] LT",
            lastWeek: function() {
                switch (this.day()) {
                  case 2:
                  case 4:
                    return "[Leschten] dddd [um] LT";

                  default:
                    return "[Leschte] dddd [um] LT";
                }
            }
        },
        relativeTime: {
            future: processFutureTime,
            past: processPastTime,
            s: "e puer Sekonnen",
            m: lb__processRelativeTime,
            mm: "%d Minutten",
            h: lb__processRelativeTime,
            hh: "%d Stonnen",
            d: lb__processRelativeTime,
            dd: "%d Deeg",
            M: lb__processRelativeTime,
            MM: "%d MÃ©int",
            y: lb__processRelativeTime,
            yy: "%d Joer"
        },
        ordinalParse: /\d{1,2}\./,
        ordinal: "%d.",
        week: {
            dow: 1,
            doy: 4
        }
    });
    var lt__units = {
        m: "minutÄ_minutÄs_minutÄ",
        mm: "minutÄs_minuÄiÅ³_minutes",
        h: "valanda_valandos_valandÄ",
        hh: "valandos_valandÅ³_valandas",
        d: "diena_dienos_dienÄ",
        dd: "dienos_dienÅ³_dienas",
        M: "mÄnuo_mÄnesio_mÄnesÄ¯",
        MM: "mÄnesiai_mÄnesiÅ³_mÄnesius",
        y: "metai_metÅ³_metus",
        yy: "metai_metÅ³_metus"
    }, weekDays = "sekmadienis_pirmadienis_antradienis_treÄiadienis_ketvirtadienis_penktadienis_Å¡eÅ¡tadienis".split("_");
    function translateSeconds(number, withoutSuffix, key, isFuture) {
        if (withoutSuffix) {
            return "kelios sekundÄs";
        } else {
            return isFuture ? "keliÅ³ sekundÅ¾iÅ³" : "kelias sekundes";
        }
    }
    function lt__monthsCaseReplace(m, format) {
        var months = {
            nominative: "sausis_vasaris_kovas_balandis_geguÅ¾Ä_birÅ¾elis_liepa_rugpjÅ«tis_rugsÄjis_spalis_lapkritis_gruodis".split("_"),
            accusative: "sausio_vasario_kovo_balandÅ¾io_geguÅ¾Äs_birÅ¾elio_liepos_rugpjÅ«Äio_rugsÄjo_spalio_lapkriÄio_gruodÅ¾io".split("_")
        }, nounCase = /D[oD]?(\[[^\[\]]*\]|\s+)+MMMM?/.test(format) ? "accusative" : "nominative";
        return months[nounCase][m.month()];
    }
    function translateSingular(number, withoutSuffix, key, isFuture) {
        return withoutSuffix ? forms(key)[0] : isFuture ? forms(key)[1] : forms(key)[2];
    }
    function special(number) {
        return number % 10 === 0 || number > 10 && number < 20;
    }
    function forms(key) {
        return lt__units[key].split("_");
    }
    function lt__translate(number, withoutSuffix, key, isFuture) {
        var result = number + " ";
        if (number === 1) {
            return result + translateSingular(number, withoutSuffix, key[0], isFuture);
        } else if (withoutSuffix) {
            return result + (special(number) ? forms(key)[1] : forms(key)[0]);
        } else {
            if (isFuture) {
                return result + forms(key)[1];
            } else {
                return result + (special(number) ? forms(key)[1] : forms(key)[2]);
            }
        }
    }
    function relativeWeekDay(moment, format) {
        var nominative = format.indexOf("dddd HH:mm") === -1, weekDay = weekDays[moment.day()];
        return nominative ? weekDay : weekDay.substring(0, weekDay.length - 2) + "Ä¯";
    }
    var lt = _moment__default.defineLocale("lt", {
        months: lt__monthsCaseReplace,
        monthsShort: "sau_vas_kov_bal_geg_bir_lie_rgp_rgs_spa_lap_grd".split("_"),
        weekdays: relativeWeekDay,
        weekdaysShort: "Sek_Pir_Ant_Tre_Ket_Pen_Å eÅ¡".split("_"),
        weekdaysMin: "S_P_A_T_K_Pn_Å ".split("_"),
        longDateFormat: {
            LT: "HH:mm",
            LTS: "HH:mm:ss",
            L: "YYYY-MM-DD",
            LL: "YYYY [m.] MMMM D [d.]",
            LLL: "YYYY [m.] MMMM D [d.], HH:mm [val.]",
            LLLL: "YYYY [m.] MMMM D [d.], dddd, HH:mm [val.]",
            l: "YYYY-MM-DD",
            ll: "YYYY [m.] MMMM D [d.]",
            lll: "YYYY [m.] MMMM D [d.], HH:mm [val.]",
            llll: "YYYY [m.] MMMM D [d.], ddd, HH:mm [val.]"
        },
        calendar: {
            sameDay: "[Å iandien] LT",
            nextDay: "[Rytoj] LT",
            nextWeek: "dddd LT",
            lastDay: "[Vakar] LT",
            lastWeek: "[PraÄjusÄ¯] dddd LT",
            sameElse: "L"
        },
        relativeTime: {
            future: "po %s",
            past: "prieÅ¡ %s",
            s: translateSeconds,
            m: translateSingular,
            mm: lt__translate,
            h: translateSingular,
            hh: lt__translate,
            d: translateSingular,
            dd: lt__translate,
            M: translateSingular,
            MM: lt__translate,
            y: translateSingular,
            yy: lt__translate
        },
        ordinalParse: /\d{1,2}-oji/,
        ordinal: function(number) {
            return number + "-oji";
        },
        week: {
            dow: 1,
            doy: 4
        }
    });
    var lv__units = {
        m: "minÅ«tes_minÅ«tÄm_minÅ«te_minÅ«tes".split("_"),
        mm: "minÅ«tes_minÅ«tÄm_minÅ«te_minÅ«tes".split("_"),
        h: "stundas_stundÄm_stunda_stundas".split("_"),
        hh: "stundas_stundÄm_stunda_stundas".split("_"),
        d: "dienas_dienÄm_diena_dienas".split("_"),
        dd: "dienas_dienÄm_diena_dienas".split("_"),
        M: "mÄneÅ¡a_mÄneÅ¡iem_mÄnesis_mÄneÅ¡i".split("_"),
        MM: "mÄneÅ¡a_mÄneÅ¡iem_mÄnesis_mÄneÅ¡i".split("_"),
        y: "gada_gadiem_gads_gadi".split("_"),
        yy: "gada_gadiem_gads_gadi".split("_")
    };
    function lv__format(forms, number, withoutSuffix) {
        if (withoutSuffix) {
            return number % 10 === 1 && number !== 11 ? forms[2] : forms[3];
        } else {
            return number % 10 === 1 && number !== 11 ? forms[0] : forms[1];
        }
    }
    function lv__relativeTimeWithPlural(number, withoutSuffix, key) {
        return number + " " + lv__format(lv__units[key], number, withoutSuffix);
    }
    function relativeTimeWithSingular(number, withoutSuffix, key) {
        return lv__format(lv__units[key], number, withoutSuffix);
    }
    function relativeSeconds(number, withoutSuffix) {
        return withoutSuffix ? "daÅ¾as sekundes" : "daÅ¾Äm sekundÄm";
    }
    var lv = _moment__default.defineLocale("lv", {
        months: "janvÄris_februÄris_marts_aprÄ«lis_maijs_jÅ«nijs_jÅ«lijs_augusts_septembris_oktobris_novembris_decembris".split("_"),
        monthsShort: "jan_feb_mar_apr_mai_jÅ«n_jÅ«l_aug_sep_okt_nov_dec".split("_"),
        weekdays: "svÄtdiena_pirmdiena_otrdiena_treÅ¡diena_ceturtdiena_piektdiena_sestdiena".split("_"),
        weekdaysShort: "Sv_P_O_T_C_Pk_S".split("_"),
        weekdaysMin: "Sv_P_O_T_C_Pk_S".split("_"),
        longDateFormat: {
            LT: "HH:mm",
            LTS: "HH:mm:ss",
            L: "DD.MM.YYYY.",
            LL: "YYYY. [gada] D. MMMM",
            LLL: "YYYY. [gada] D. MMMM, HH:mm",
            LLLL: "YYYY. [gada] D. MMMM, dddd, HH:mm"
        },
        calendar: {
            sameDay: "[Å odien pulksten] LT",
            nextDay: "[RÄ«t pulksten] LT",
            nextWeek: "dddd [pulksten] LT",
            lastDay: "[Vakar pulksten] LT",
            lastWeek: "[PagÄjuÅ¡Ä] dddd [pulksten] LT",
            sameElse: "L"
        },
        relativeTime: {
            future: "pÄc %s",
            past: "pirms %s",
            s: relativeSeconds,
            m: relativeTimeWithSingular,
            mm: lv__relativeTimeWithPlural,
            h: relativeTimeWithSingular,
            hh: lv__relativeTimeWithPlural,
            d: relativeTimeWithSingular,
            dd: lv__relativeTimeWithPlural,
            M: relativeTimeWithSingular,
            MM: lv__relativeTimeWithPlural,
            y: relativeTimeWithSingular,
            yy: lv__relativeTimeWithPlural
        },
        ordinalParse: /\d{1,2}\./,
        ordinal: "%d.",
        week: {
            dow: 1,
            doy: 4
        }
    });
    var me__translator = {
        words: {
            m: [ "jedan minut", "jednog minuta" ],
            mm: [ "minut", "minuta", "minuta" ],
            h: [ "jedan sat", "jednog sata" ],
            hh: [ "sat", "sata", "sati" ],
            dd: [ "dan", "dana", "dana" ],
            MM: [ "mjesec", "mjeseca", "mjeseci" ],
            yy: [ "godina", "godine", "godina" ]
        },
        correctGrammaticalCase: function(number, wordKey) {
            return number === 1 ? wordKey[0] : number >= 2 && number <= 4 ? wordKey[1] : wordKey[2];
        },
        translate: function(number, withoutSuffix, key) {
            var wordKey = me__translator.words[key];
            if (key.length === 1) {
                return withoutSuffix ? wordKey[0] : wordKey[1];
            } else {
                return number + " " + me__translator.correctGrammaticalCase(number, wordKey);
            }
        }
    };
    var me = _moment__default.defineLocale("me", {
        months: [ "januar", "februar", "mart", "april", "maj", "jun", "jul", "avgust", "septembar", "oktobar", "novembar", "decembar" ],
        monthsShort: [ "jan.", "feb.", "mar.", "apr.", "maj", "jun", "jul", "avg.", "sep.", "okt.", "nov.", "dec." ],
        weekdays: [ "nedjelja", "ponedjeljak", "utorak", "srijeda", "Äetvrtak", "petak", "subota" ],
        weekdaysShort: [ "ned.", "pon.", "uto.", "sri.", "Äet.", "pet.", "sub." ],
        weekdaysMin: [ "ne", "po", "ut", "sr", "Äe", "pe", "su" ],
        longDateFormat: {
            LT: "H:mm",
            LTS: "H:mm:ss",
            L: "DD. MM. YYYY",
            LL: "D. MMMM YYYY",
            LLL: "D. MMMM YYYY H:mm",
            LLLL: "dddd, D. MMMM YYYY H:mm"
        },
        calendar: {
            sameDay: "[danas u] LT",
            nextDay: "[sjutra u] LT",
            nextWeek: function() {
                switch (this.day()) {
                  case 0:
                    return "[u] [nedjelju] [u] LT";

                  case 3:
                    return "[u] [srijedu] [u] LT";

                  case 6:
                    return "[u] [subotu] [u] LT";

                  case 1:
                  case 2:
                  case 4:
                  case 5:
                    return "[u] dddd [u] LT";
                }
            },
            lastDay: "[juÄe u] LT",
            lastWeek: function() {
                var lastWeekDays = [ "[proÅ¡le] [nedjelje] [u] LT", "[proÅ¡log] [ponedjeljka] [u] LT", "[proÅ¡log] [utorka] [u] LT", "[proÅ¡le] [srijede] [u] LT", "[proÅ¡log] [Äetvrtka] [u] LT", "[proÅ¡log] [petka] [u] LT", "[proÅ¡le] [subote] [u] LT" ];
                return lastWeekDays[this.day()];
            },
            sameElse: "L"
        },
        relativeTime: {
            future: "za %s",
            past: "prije %s",
            s: "nekoliko sekundi",
            m: me__translator.translate,
            mm: me__translator.translate,
            h: me__translator.translate,
            hh: me__translator.translate,
            d: "dan",
            dd: me__translator.translate,
            M: "mjesec",
            MM: me__translator.translate,
            y: "godinu",
            yy: me__translator.translate
        },
        ordinalParse: /\d{1,2}\./,
        ordinal: "%d.",
        week: {
            dow: 1,
            doy: 7
        }
    });
    var mk = _moment__default.defineLocale("mk", {
        months: "ÑÐ°Ð½ÑÐ°ÑÐ¸_ÑÐµÐ²ÑÑÐ°ÑÐ¸_Ð¼Ð°ÑÑ_Ð°Ð¿ÑÐ¸Ð»_Ð¼Ð°Ñ_ÑÑÐ½Ð¸_ÑÑÐ»Ð¸_Ð°Ð²Ð³ÑÑÑ_ÑÐµÐ¿ÑÐµÐ¼Ð²ÑÐ¸_Ð¾ÐºÑÐ¾Ð¼Ð²ÑÐ¸_Ð½Ð¾ÐµÐ¼Ð²ÑÐ¸_Ð´ÐµÐºÐµÐ¼Ð²ÑÐ¸".split("_"),
        monthsShort: "ÑÐ°Ð½_ÑÐµÐ²_Ð¼Ð°Ñ_Ð°Ð¿Ñ_Ð¼Ð°Ñ_ÑÑÐ½_ÑÑÐ»_Ð°Ð²Ð³_ÑÐµÐ¿_Ð¾ÐºÑ_Ð½Ð¾Ðµ_Ð´ÐµÐº".split("_"),
        weekdays: "Ð½ÐµÐ´ÐµÐ»Ð°_Ð¿Ð¾Ð½ÐµÐ´ÐµÐ»Ð½Ð¸Ðº_Ð²ÑÐ¾ÑÐ½Ð¸Ðº_ÑÑÐµÐ´Ð°_ÑÐµÑÐ²ÑÑÐ¾Ðº_Ð¿ÐµÑÐ¾Ðº_ÑÐ°Ð±Ð¾ÑÐ°".split("_"),
        weekdaysShort: "Ð½ÐµÐ´_Ð¿Ð¾Ð½_Ð²ÑÐ¾_ÑÑÐµ_ÑÐµÑ_Ð¿ÐµÑ_ÑÐ°Ð±".split("_"),
        weekdaysMin: "Ð½e_Ð¿o_Ð²Ñ_ÑÑ_ÑÐµ_Ð¿Ðµ_Ña".split("_"),
        longDateFormat: {
            LT: "H:mm",
            LTS: "H:mm:ss",
            L: "D.MM.YYYY",
            LL: "D MMMM YYYY",
            LLL: "D MMMM YYYY H:mm",
            LLLL: "dddd, D MMMM YYYY H:mm"
        },
        calendar: {
            sameDay: "[ÐÐµÐ½ÐµÑ Ð²Ð¾] LT",
            nextDay: "[Ð£ÑÑÐµ Ð²Ð¾] LT",
            nextWeek: "dddd [Ð²Ð¾] LT",
            lastDay: "[ÐÑÐµÑÐ° Ð²Ð¾] LT",
            lastWeek: function() {
                switch (this.day()) {
                  case 0:
                  case 3:
                  case 6:
                    return "[ÐÐ¾ Ð¸Ð·Ð¼Ð¸Ð½Ð°ÑÐ°ÑÐ°] dddd [Ð²Ð¾] LT";

                  case 1:
                  case 2:
                  case 4:
                  case 5:
                    return "[ÐÐ¾ Ð¸Ð·Ð¼Ð¸Ð½Ð°ÑÐ¸Ð¾Ñ] dddd [Ð²Ð¾] LT";
                }
            },
            sameElse: "L"
        },
        relativeTime: {
            future: "Ð¿Ð¾ÑÐ»Ðµ %s",
            past: "Ð¿ÑÐµÐ´ %s",
            s: "Ð½ÐµÐºÐ¾Ð»ÐºÑ ÑÐµÐºÑÐ½Ð´Ð¸",
            m: "Ð¼Ð¸Ð½ÑÑÐ°",
            mm: "%d Ð¼Ð¸Ð½ÑÑÐ¸",
            h: "ÑÐ°Ñ",
            hh: "%d ÑÐ°ÑÐ°",
            d: "Ð´ÐµÐ½",
            dd: "%d Ð´ÐµÐ½Ð°",
            M: "Ð¼ÐµÑÐµÑ",
            MM: "%d Ð¼ÐµÑÐµÑÐ¸",
            y: "Ð³Ð¾Ð´Ð¸Ð½Ð°",
            yy: "%d Ð³Ð¾Ð´Ð¸Ð½Ð¸"
        },
        ordinalParse: /\d{1,2}-(ÐµÐ²|ÐµÐ½|ÑÐ¸|Ð²Ð¸|ÑÐ¸|Ð¼Ð¸)/,
        ordinal: function(number) {
            var lastDigit = number % 10, last2Digits = number % 100;
            if (number === 0) {
                return number + "-ÐµÐ²";
            } else if (last2Digits === 0) {
                return number + "-ÐµÐ½";
            } else if (last2Digits > 10 && last2Digits < 20) {
                return number + "-ÑÐ¸";
            } else if (lastDigit === 1) {
                return number + "-Ð²Ð¸";
            } else if (lastDigit === 2) {
                return number + "-ÑÐ¸";
            } else if (lastDigit === 7 || lastDigit === 8) {
                return number + "-Ð¼Ð¸";
            } else {
                return number + "-ÑÐ¸";
            }
        },
        week: {
            dow: 1,
            doy: 7
        }
    });
    var ml = _moment__default.defineLocale("ml", {
        months: "à´à´¨àµà´µà´°à´¿_à´«àµà´¬àµà´°àµà´µà´°à´¿_à´®à´¾àµ¼à´àµà´àµ_à´à´ªàµà´°à´¿àµ½_à´®àµà´¯àµ_à´àµàµº_à´àµà´²àµ_à´à´à´¸àµà´±àµà´±àµ_à´¸àµà´ªàµà´±àµà´±à´à´¬àµ¼_à´à´àµà´àµà´¬àµ¼_à´¨à´µà´à´¬àµ¼_à´¡à´¿à´¸à´à´¬àµ¼".split("_"),
        monthsShort: "à´à´¨àµ._à´«àµà´¬àµà´°àµ._à´®à´¾àµ¼._à´à´ªàµà´°à´¿._à´®àµà´¯àµ_à´àµàµº_à´àµà´²àµ._à´à´._à´¸àµà´ªàµà´±àµà´±._à´à´àµà´àµ._à´¨à´µà´._à´¡à´¿à´¸à´.".split("_"),
        weekdays: "à´à´¾à´¯à´±à´¾à´´àµà´_à´¤à´¿à´àµà´à´³à´¾à´´àµà´_à´àµà´µàµà´µà´¾à´´àµà´_à´¬àµà´§à´¨à´¾à´´àµà´_à´µàµà´¯à´¾à´´à´¾à´´àµà´_à´µàµà´³àµà´³à´¿à´¯à´¾à´´àµà´_à´¶à´¨à´¿à´¯à´¾à´´àµà´".split("_"),
        weekdaysShort: "à´à´¾à´¯àµ¼_à´¤à´¿à´àµà´àµ¾_à´àµà´µàµà´µ_à´¬àµà´§àµ»_à´µàµà´¯à´¾à´´à´_à´µàµà´³àµà´³à´¿_à´¶à´¨à´¿".split("_"),
        weekdaysMin: "à´à´¾_à´¤à´¿_à´àµ_à´¬àµ_à´µàµà´¯à´¾_à´µàµ_à´¶".split("_"),
        longDateFormat: {
            LT: "A h:mm -à´¨àµ",
            LTS: "A h:mm:ss -à´¨àµ",
            L: "DD/MM/YYYY",
            LL: "D MMMM YYYY",
            LLL: "D MMMM YYYY, A h:mm -à´¨àµ",
            LLLL: "dddd, D MMMM YYYY, A h:mm -à´¨àµ"
        },
        calendar: {
            sameDay: "[à´à´¨àµà´¨àµ] LT",
            nextDay: "[à´¨à´¾à´³àµ] LT",
            nextWeek: "dddd, LT",
            lastDay: "[à´à´¨àµà´¨à´²àµ] LT",
            lastWeek: "[à´à´´à´¿à´àµà´] dddd, LT",
            sameElse: "L"
        },
        relativeTime: {
            future: "%s à´à´´à´¿à´àµà´àµ",
            past: "%s à´®àµàµ»à´ªàµ",
            s: "à´àµ½à´ª à´¨à´¿à´®à´¿à´·à´àµà´àµ¾",
            m: "à´à´°àµ à´®à´¿à´¨à´¿à´±àµà´±àµ",
            mm: "%d à´®à´¿à´¨à´¿à´±àµà´±àµ",
            h: "à´à´°àµ à´®à´£à´¿à´àµà´àµàµ¼",
            hh: "%d à´®à´£à´¿à´àµà´àµàµ¼",
            d: "à´à´°àµ à´¦à´¿à´µà´¸à´",
            dd: "%d à´¦à´¿à´µà´¸à´",
            M: "à´à´°àµ à´®à´¾à´¸à´",
            MM: "%d à´®à´¾à´¸à´",
            y: "à´à´°àµ à´µàµ¼à´·à´",
            yy: "%d à´µàµ¼à´·à´"
        },
        meridiemParse: /à´°à´¾à´¤àµà´°à´¿|à´°à´¾à´µà´¿à´²àµ|à´à´àµà´ à´à´´à´¿à´àµà´àµ|à´µàµà´àµà´¨àµà´¨àµà´°à´|à´°à´¾à´¤àµà´°à´¿/i,
        isPM: function(input) {
            return /^(à´à´àµà´ à´à´´à´¿à´àµà´àµ|à´µàµà´àµà´¨àµà´¨àµà´°à´|à´°à´¾à´¤àµà´°à´¿)$/.test(input);
        },
        meridiem: function(hour, minute, isLower) {
            if (hour < 4) {
                return "à´°à´¾à´¤àµà´°à´¿";
            } else if (hour < 12) {
                return "à´°à´¾à´µà´¿à´²àµ";
            } else if (hour < 17) {
                return "à´à´àµà´ à´à´´à´¿à´àµà´àµ";
            } else if (hour < 20) {
                return "à´µàµà´àµà´¨àµà´¨àµà´°à´";
            } else {
                return "à´°à´¾à´¤àµà´°à´¿";
            }
        }
    });
    var mr__symbolMap = {
        "1": "à¥§",
        "2": "à¥¨",
        "3": "à¥©",
        "4": "à¥ª",
        "5": "à¥«",
        "6": "à¥¬",
        "7": "à¥­",
        "8": "à¥®",
        "9": "à¥¯",
        "0": "à¥¦"
    }, mr__numberMap = {
        "à¥§": "1",
        "à¥¨": "2",
        "à¥©": "3",
        "à¥ª": "4",
        "à¥«": "5",
        "à¥¬": "6",
        "à¥­": "7",
        "à¥®": "8",
        "à¥¯": "9",
        "à¥¦": "0"
    };
    var mr = _moment__default.defineLocale("mr", {
        months: "à¤à¤¾à¤¨à¥à¤µà¤¾à¤°à¥_à¤«à¥à¤¬à¥à¤°à¥à¤µà¤¾à¤°à¥_à¤®à¤¾à¤°à¥à¤_à¤à¤ªà¥à¤°à¤¿à¤²_à¤®à¥_à¤à¥à¤¨_à¤à¥à¤²à¥_à¤à¤à¤¸à¥à¤_à¤¸à¤ªà¥à¤à¥à¤à¤¬à¤°_à¤à¤à¥à¤à¥à¤¬à¤°_à¤¨à¥à¤µà¥à¤¹à¥à¤à¤¬à¤°_à¤¡à¤¿à¤¸à¥à¤à¤¬à¤°".split("_"),
        monthsShort: "à¤à¤¾à¤¨à¥._à¤«à¥à¤¬à¥à¤°à¥._à¤®à¤¾à¤°à¥à¤._à¤à¤ªà¥à¤°à¤¿._à¤®à¥._à¤à¥à¤¨._à¤à¥à¤²à¥._à¤à¤._à¤¸à¤ªà¥à¤à¥à¤._à¤à¤à¥à¤à¥._à¤¨à¥à¤µà¥à¤¹à¥à¤._à¤¡à¤¿à¤¸à¥à¤.".split("_"),
        weekdays: "à¤°à¤µà¤¿à¤µà¤¾à¤°_à¤¸à¥à¤®à¤µà¤¾à¤°_à¤®à¤à¤à¤³à¤µà¤¾à¤°_à¤¬à¥à¤§à¤µà¤¾à¤°_à¤à¥à¤°à¥à¤µà¤¾à¤°_à¤¶à¥à¤à¥à¤°à¤µà¤¾à¤°_à¤¶à¤¨à¤¿à¤µà¤¾à¤°".split("_"),
        weekdaysShort: "à¤°à¤µà¤¿_à¤¸à¥à¤®_à¤®à¤à¤à¤³_à¤¬à¥à¤§_à¤à¥à¤°à¥_à¤¶à¥à¤à¥à¤°_à¤¶à¤¨à¤¿".split("_"),
        weekdaysMin: "à¤°_à¤¸à¥_à¤®à¤_à¤¬à¥_à¤à¥_à¤¶à¥_à¤¶".split("_"),
        longDateFormat: {
            LT: "A h:mm à¤µà¤¾à¤à¤¤à¤¾",
            LTS: "A h:mm:ss à¤µà¤¾à¤à¤¤à¤¾",
            L: "DD/MM/YYYY",
            LL: "D MMMM YYYY",
            LLL: "D MMMM YYYY, A h:mm à¤µà¤¾à¤à¤¤à¤¾",
            LLLL: "dddd, D MMMM YYYY, A h:mm à¤µà¤¾à¤à¤¤à¤¾"
        },
        calendar: {
            sameDay: "[à¤à¤] LT",
            nextDay: "[à¤à¤¦à¥à¤¯à¤¾] LT",
            nextWeek: "dddd, LT",
            lastDay: "[à¤à¤¾à¤²] LT",
            lastWeek: "[à¤®à¤¾à¤à¥à¤²] dddd, LT",
            sameElse: "L"
        },
        relativeTime: {
            future: "%s à¤¨à¤à¤¤à¤°",
            past: "%s à¤ªà¥à¤°à¥à¤µà¥",
            s: "à¤¸à¥à¤à¤à¤¦",
            m: "à¤à¤ à¤®à¤¿à¤¨à¤¿à¤",
            mm: "%d à¤®à¤¿à¤¨à¤¿à¤à¥",
            h: "à¤à¤ à¤¤à¤¾à¤¸",
            hh: "%d à¤¤à¤¾à¤¸",
            d: "à¤à¤ à¤¦à¤¿à¤µà¤¸",
            dd: "%d à¤¦à¤¿à¤µà¤¸",
            M: "à¤à¤ à¤®à¤¹à¤¿à¤¨à¤¾",
            MM: "%d à¤®à¤¹à¤¿à¤¨à¥",
            y: "à¤à¤ à¤µà¤°à¥à¤·",
            yy: "%d à¤µà¤°à¥à¤·à¥"
        },
        preparse: function(string) {
            return string.replace(/[à¥§à¥¨à¥©à¥ªà¥«à¥¬à¥­à¥®à¥¯à¥¦]/g, function(match) {
                return mr__numberMap[match];
            });
        },
        postformat: function(string) {
            return string.replace(/\d/g, function(match) {
                return mr__symbolMap[match];
            });
        },
        meridiemParse: /à¤°à¤¾à¤¤à¥à¤°à¥|à¤¸à¤à¤¾à¤³à¥|à¤¦à¥à¤ªà¤¾à¤°à¥|à¤¸à¤¾à¤¯à¤à¤à¤¾à¤³à¥/,
        meridiemHour: function(hour, meridiem) {
            if (hour === 12) {
                hour = 0;
            }
            if (meridiem === "à¤°à¤¾à¤¤à¥à¤°à¥") {
                return hour < 4 ? hour : hour + 12;
            } else if (meridiem === "à¤¸à¤à¤¾à¤³à¥") {
                return hour;
            } else if (meridiem === "à¤¦à¥à¤ªà¤¾à¤°à¥") {
                return hour >= 10 ? hour : hour + 12;
            } else if (meridiem === "à¤¸à¤¾à¤¯à¤à¤à¤¾à¤³à¥") {
                return hour + 12;
            }
        },
        meridiem: function(hour, minute, isLower) {
            if (hour < 4) {
                return "à¤°à¤¾à¤¤à¥à¤°à¥";
            } else if (hour < 10) {
                return "à¤¸à¤à¤¾à¤³à¥";
            } else if (hour < 17) {
                return "à¤¦à¥à¤ªà¤¾à¤°à¥";
            } else if (hour < 20) {
                return "à¤¸à¤¾à¤¯à¤à¤à¤¾à¤³à¥";
            } else {
                return "à¤°à¤¾à¤¤à¥à¤°à¥";
            }
        },
        week: {
            dow: 0,
            doy: 6
        }
    });
    var ms_my = _moment__default.defineLocale("ms-my", {
        months: "Januari_Februari_Mac_April_Mei_Jun_Julai_Ogos_September_Oktober_November_Disember".split("_"),
        monthsShort: "Jan_Feb_Mac_Apr_Mei_Jun_Jul_Ogs_Sep_Okt_Nov_Dis".split("_"),
        weekdays: "Ahad_Isnin_Selasa_Rabu_Khamis_Jumaat_Sabtu".split("_"),
        weekdaysShort: "Ahd_Isn_Sel_Rab_Kha_Jum_Sab".split("_"),
        weekdaysMin: "Ah_Is_Sl_Rb_Km_Jm_Sb".split("_"),
        longDateFormat: {
            LT: "HH.mm",
            LTS: "HH.mm.ss",
            L: "DD/MM/YYYY",
            LL: "D MMMM YYYY",
            LLL: "D MMMM YYYY [pukul] HH.mm",
            LLLL: "dddd, D MMMM YYYY [pukul] HH.mm"
        },
        meridiemParse: /pagi|tengahari|petang|malam/,
        meridiemHour: function(hour, meridiem) {
            if (hour === 12) {
                hour = 0;
            }
            if (meridiem === "pagi") {
                return hour;
            } else if (meridiem === "tengahari") {
                return hour >= 11 ? hour : hour + 12;
            } else if (meridiem === "petang" || meridiem === "malam") {
                return hour + 12;
            }
        },
        meridiem: function(hours, minutes, isLower) {
            if (hours < 11) {
                return "pagi";
            } else if (hours < 15) {
                return "tengahari";
            } else if (hours < 19) {
                return "petang";
            } else {
                return "malam";
            }
        },
        calendar: {
            sameDay: "[Hari ini pukul] LT",
            nextDay: "[Esok pukul] LT",
            nextWeek: "dddd [pukul] LT",
            lastDay: "[Kelmarin pukul] LT",
            lastWeek: "dddd [lepas pukul] LT",
            sameElse: "L"
        },
        relativeTime: {
            future: "dalam %s",
            past: "%s yang lepas",
            s: "beberapa saat",
            m: "seminit",
            mm: "%d minit",
            h: "sejam",
            hh: "%d jam",
            d: "sehari",
            dd: "%d hari",
            M: "sebulan",
            MM: "%d bulan",
            y: "setahun",
            yy: "%d tahun"
        },
        week: {
            dow: 1,
            doy: 7
        }
    });
    var locale_ms = _moment__default.defineLocale("ms", {
        months: "Januari_Februari_Mac_April_Mei_Jun_Julai_Ogos_September_Oktober_November_Disember".split("_"),
        monthsShort: "Jan_Feb_Mac_Apr_Mei_Jun_Jul_Ogs_Sep_Okt_Nov_Dis".split("_"),
        weekdays: "Ahad_Isnin_Selasa_Rabu_Khamis_Jumaat_Sabtu".split("_"),
        weekdaysShort: "Ahd_Isn_Sel_Rab_Kha_Jum_Sab".split("_"),
        weekdaysMin: "Ah_Is_Sl_Rb_Km_Jm_Sb".split("_"),
        longDateFormat: {
            LT: "HH.mm",
            LTS: "HH.mm.ss",
            L: "DD/MM/YYYY",
            LL: "D MMMM YYYY",
            LLL: "D MMMM YYYY [pukul] HH.mm",
            LLLL: "dddd, D MMMM YYYY [pukul] HH.mm"
        },
        meridiemParse: /pagi|tengahari|petang|malam/,
        meridiemHour: function(hour, meridiem) {
            if (hour === 12) {
                hour = 0;
            }
            if (meridiem === "pagi") {
                return hour;
            } else if (meridiem === "tengahari") {
                return hour >= 11 ? hour : hour + 12;
            } else if (meridiem === "petang" || meridiem === "malam") {
                return hour + 12;
            }
        },
        meridiem: function(hours, minutes, isLower) {
            if (hours < 11) {
                return "pagi";
            } else if (hours < 15) {
                return "tengahari";
            } else if (hours < 19) {
                return "petang";
            } else {
                return "malam";
            }
        },
        calendar: {
            sameDay: "[Hari ini pukul] LT",
            nextDay: "[Esok pukul] LT",
            nextWeek: "dddd [pukul] LT",
            lastDay: "[Kelmarin pukul] LT",
            lastWeek: "dddd [lepas pukul] LT",
            sameElse: "L"
        },
        relativeTime: {
            future: "dalam %s",
            past: "%s yang lepas",
            s: "beberapa saat",
            m: "seminit",
            mm: "%d minit",
            h: "sejam",
            hh: "%d jam",
            d: "sehari",
            dd: "%d hari",
            M: "sebulan",
            MM: "%d bulan",
            y: "setahun",
            yy: "%d tahun"
        },
        week: {
            dow: 1,
            doy: 7
        }
    });
    var my__symbolMap = {
        "1": "á",
        "2": "á",
        "3": "á",
        "4": "á",
        "5": "á",
        "6": "á",
        "7": "á",
        "8": "á",
        "9": "á",
        "0": "á"
    }, my__numberMap = {
        "á": "1",
        "á": "2",
        "á": "3",
        "á": "4",
        "á": "5",
        "á": "6",
        "á": "7",
        "á": "8",
        "á": "9",
        "á": "0"
    };
    var my = _moment__default.defineLocale("my", {
        months: "áááºááá«áá®_áá±áá±á¬áºáá«áá®_áááº_á§áá¼á®_áá±_áá½ááº_áá°áá­á¯ááº_áá¼áá¯ááº_áááºáááºáá¬_á¡á±á¬ááºáá­á¯áá¬_áá­á¯áááºáá¬_áá®áááºáá¬".split("_"),
        monthsShort: "áááº_áá±_áááº_áá¼á®_áá±_áá½ááº_áá­á¯ááº_áá¼_áááº_á¡á±á¬ááº_áá­á¯_áá®".split("_"),
        weekdays: "ááááºá¹ááá½á±_ááááºá¹áá¬_á¡ááºá¹áá«_áá¯áá¹ááá°á¸_áá¼á¬áááá±á¸_áá±á¬áá¼á¬_ááá±".split("_"),
        weekdaysShort: "áá½á±_áá¬_áá«_áá°á¸_áá¼á¬_áá±á¬_áá±".split("_"),
        weekdaysMin: "áá½á±_áá¬_áá«_áá°á¸_áá¼á¬_áá±á¬_áá±".split("_"),
        longDateFormat: {
            LT: "HH:mm",
            LTS: "HH:mm:ss",
            L: "DD/MM/YYYY",
            LL: "D MMMM YYYY",
            LLL: "D MMMM YYYY HH:mm",
            LLLL: "dddd D MMMM YYYY HH:mm"
        },
        calendar: {
            sameDay: "[ááá±.] LT [áá¾á¬]",
            nextDay: "[ááááºáá¼ááº] LT [áá¾á¬]",
            nextWeek: "dddd LT [áá¾á¬]",
            lastDay: "[ááá±.á] LT [áá¾á¬]",
            lastWeek: "[áá¼á®á¸áá²á·áá±á¬] dddd LT [áá¾á¬]",
            sameElse: "L"
        },
        relativeTime: {
            future: "áá¬áááºá· %s áá¾á¬",
            past: "áá½ááºáá²á·áá±á¬ %s á",
            s: "ááá¹áááº.á¡áááºá¸áááº",
            m: "áááºáá­áááº",
            mm: "%d áá­áááº",
            h: "áááºáá¬áá®",
            hh: "%d áá¬áá®",
            d: "áááºáááº",
            dd: "%d áááº",
            M: "áááºá",
            MM: "%d á",
            y: "áááºáá¾ááº",
            yy: "%d áá¾ááº"
        },
        preparse: function(string) {
            return string.replace(/[áááááááááá]/g, function(match) {
                return my__numberMap[match];
            });
        },
        postformat: function(string) {
            return string.replace(/\d/g, function(match) {
                return my__symbolMap[match];
            });
        },
        week: {
            dow: 1,
            doy: 4
        }
    });
    var nb = _moment__default.defineLocale("nb", {
        months: "januar_februar_mars_april_mai_juni_juli_august_september_oktober_november_desember".split("_"),
        monthsShort: "jan_feb_mar_apr_mai_jun_jul_aug_sep_okt_nov_des".split("_"),
        weekdays: "sÃ¸ndag_mandag_tirsdag_onsdag_torsdag_fredag_lÃ¸rdag".split("_"),
        weekdaysShort: "sÃ¸n_man_tirs_ons_tors_fre_lÃ¸r".split("_"),
        weekdaysMin: "sÃ¸_ma_ti_on_to_fr_lÃ¸".split("_"),
        longDateFormat: {
            LT: "H.mm",
            LTS: "H.mm.ss",
            L: "DD.MM.YYYY",
            LL: "D. MMMM YYYY",
            LLL: "D. MMMM YYYY [kl.] H.mm",
            LLLL: "dddd D. MMMM YYYY [kl.] H.mm"
        },
        calendar: {
            sameDay: "[i dag kl.] LT",
            nextDay: "[i morgen kl.] LT",
            nextWeek: "dddd [kl.] LT",
            lastDay: "[i gÃ¥r kl.] LT",
            lastWeek: "[forrige] dddd [kl.] LT",
            sameElse: "L"
        },
        relativeTime: {
            future: "om %s",
            past: "for %s siden",
            s: "noen sekunder",
            m: "ett minutt",
            mm: "%d minutter",
            h: "en time",
            hh: "%d timer",
            d: "en dag",
            dd: "%d dager",
            M: "en mÃ¥ned",
            MM: "%d mÃ¥neder",
            y: "ett Ã¥r",
            yy: "%d Ã¥r"
        },
        ordinalParse: /\d{1,2}\./,
        ordinal: "%d.",
        week: {
            dow: 1,
            doy: 4
        }
    });
    var ne__symbolMap = {
        "1": "à¥§",
        "2": "à¥¨",
        "3": "à¥©",
        "4": "à¥ª",
        "5": "à¥«",
        "6": "à¥¬",
        "7": "à¥­",
        "8": "à¥®",
        "9": "à¥¯",
        "0": "à¥¦"
    }, ne__numberMap = {
        "à¥§": "1",
        "à¥¨": "2",
        "à¥©": "3",
        "à¥ª": "4",
        "à¥«": "5",
        "à¥¬": "6",
        "à¥­": "7",
        "à¥®": "8",
        "à¥¯": "9",
        "à¥¦": "0"
    };
    var ne = _moment__default.defineLocale("ne", {
        months: "à¤à¤¨à¤µà¤°à¥_à¤«à¥à¤¬à¥à¤°à¥à¤µà¤°à¥_à¤®à¤¾à¤°à¥à¤_à¤à¤ªà¥à¤°à¤¿à¤²_à¤®à¤_à¤à¥à¤¨_à¤à¥à¤²à¤¾à¤_à¤à¤à¤·à¥à¤_à¤¸à¥à¤ªà¥à¤à¥à¤®à¥à¤¬à¤°_à¤à¤à¥à¤à¥à¤¬à¤°_à¤¨à¥à¤­à¥à¤®à¥à¤¬à¤°_à¤¡à¤¿à¤¸à¥à¤®à¥à¤¬à¤°".split("_"),
        monthsShort: "à¤à¤¨._à¤«à¥à¤¬à¥à¤°à¥._à¤®à¤¾à¤°à¥à¤_à¤à¤ªà¥à¤°à¤¿._à¤®à¤_à¤à¥à¤¨_à¤à¥à¤²à¤¾à¤._à¤à¤._à¤¸à¥à¤ªà¥à¤._à¤à¤à¥à¤à¥._à¤¨à¥à¤­à¥._à¤¡à¤¿à¤¸à¥.".split("_"),
        weekdays: "à¤à¤à¤¤à¤¬à¤¾à¤°_à¤¸à¥à¤®à¤¬à¤¾à¤°_à¤®à¤à¥à¤à¤²à¤¬à¤¾à¤°_à¤¬à¥à¤§à¤¬à¤¾à¤°_à¤¬à¤¿à¤¹à¤¿à¤¬à¤¾à¤°_à¤¶à¥à¤à¥à¤°à¤¬à¤¾à¤°_à¤¶à¤¨à¤¿à¤¬à¤¾à¤°".split("_"),
        weekdaysShort: "à¤à¤à¤¤._à¤¸à¥à¤®._à¤®à¤à¥à¤à¤²._à¤¬à¥à¤§._à¤¬à¤¿à¤¹à¤¿._à¤¶à¥à¤à¥à¤°._à¤¶à¤¨à¤¿.".split("_"),
        weekdaysMin: "à¤à¤._à¤¸à¥._à¤®à¤à¥_à¤¬à¥._à¤¬à¤¿._à¤¶à¥._à¤¶.".split("_"),
        longDateFormat: {
            LT: "Aà¤à¥ h:mm à¤¬à¤à¥",
            LTS: "Aà¤à¥ h:mm:ss à¤¬à¤à¥",
            L: "DD/MM/YYYY",
            LL: "D MMMM YYYY",
            LLL: "D MMMM YYYY, Aà¤à¥ h:mm à¤¬à¤à¥",
            LLLL: "dddd, D MMMM YYYY, Aà¤à¥ h:mm à¤¬à¤à¥"
        },
        preparse: function(string) {
            return string.replace(/[à¥§à¥¨à¥©à¥ªà¥«à¥¬à¥­à¥®à¥¯à¥¦]/g, function(match) {
                return ne__numberMap[match];
            });
        },
        postformat: function(string) {
            return string.replace(/\d/g, function(match) {
                return ne__symbolMap[match];
            });
        },
        meridiemParse: /à¤°à¤¾à¤¤à¥|à¤¬à¤¿à¤¹à¤¾à¤¨|à¤¦à¤¿à¤à¤à¤¸à¥|à¤¬à¥à¤²à¥à¤à¤¾|à¤¸à¤¾à¤à¤|à¤°à¤¾à¤¤à¥/,
        meridiemHour: function(hour, meridiem) {
            if (hour === 12) {
                hour = 0;
            }
            if (meridiem === "à¤°à¤¾à¤¤à¥") {
                return hour < 3 ? hour : hour + 12;
            } else if (meridiem === "à¤¬à¤¿à¤¹à¤¾à¤¨") {
                return hour;
            } else if (meridiem === "à¤¦à¤¿à¤à¤à¤¸à¥") {
                return hour >= 10 ? hour : hour + 12;
            } else if (meridiem === "à¤¬à¥à¤²à¥à¤à¤¾" || meridiem === "à¤¸à¤¾à¤à¤") {
                return hour + 12;
            }
        },
        meridiem: function(hour, minute, isLower) {
            if (hour < 3) {
                return "à¤°à¤¾à¤¤à¥";
            } else if (hour < 10) {
                return "à¤¬à¤¿à¤¹à¤¾à¤¨";
            } else if (hour < 15) {
                return "à¤¦à¤¿à¤à¤à¤¸à¥";
            } else if (hour < 18) {
                return "à¤¬à¥à¤²à¥à¤à¤¾";
            } else if (hour < 20) {
                return "à¤¸à¤¾à¤à¤";
            } else {
                return "à¤°à¤¾à¤¤à¥";
            }
        },
        calendar: {
            sameDay: "[à¤à¤] LT",
            nextDay: "[à¤­à¥à¤²à¥] LT",
            nextWeek: "[à¤à¤à¤à¤¦à¥] dddd[,] LT",
            lastDay: "[à¤¹à¤¿à¤à¥] LT",
            lastWeek: "[à¤à¤à¤à¥] dddd[,] LT",
            sameElse: "L"
        },
        relativeTime: {
            future: "%sà¤®à¤¾",
            past: "%s à¤à¤à¤¾à¤¡à¥",
            s: "à¤à¥à¤¹à¥ à¤¸à¤®à¤¯",
            m: "à¤à¤ à¤®à¤¿à¤¨à¥à¤",
            mm: "%d à¤®à¤¿à¤¨à¥à¤",
            h: "à¤à¤ à¤à¤£à¥à¤à¤¾",
            hh: "%d à¤à¤£à¥à¤à¤¾",
            d: "à¤à¤ à¤¦à¤¿à¤¨",
            dd: "%d à¤¦à¤¿à¤¨",
            M: "à¤à¤ à¤®à¤¹à¤¿à¤¨à¤¾",
            MM: "%d à¤®à¤¹à¤¿à¤¨à¤¾",
            y: "à¤à¤ à¤¬à¤°à¥à¤·",
            yy: "%d à¤¬à¤°à¥à¤·"
        },
        week: {
            dow: 1,
            doy: 7
        }
    });
    var nl__monthsShortWithDots = "jan._feb._mrt._apr._mei_jun._jul._aug._sep._okt._nov._dec.".split("_"), nl__monthsShortWithoutDots = "jan_feb_mrt_apr_mei_jun_jul_aug_sep_okt_nov_dec".split("_");
    var nl = _moment__default.defineLocale("nl", {
        months: "januari_februari_maart_april_mei_juni_juli_augustus_september_oktober_november_december".split("_"),
        monthsShort: function(m, format) {
            if (/-MMM-/.test(format)) {
                return nl__monthsShortWithoutDots[m.month()];
            } else {
                return nl__monthsShortWithDots[m.month()];
            }
        },
        weekdays: "zondag_maandag_dinsdag_woensdag_donderdag_vrijdag_zaterdag".split("_"),
        weekdaysShort: "zo._ma._di._wo._do._vr._za.".split("_"),
        weekdaysMin: "Zo_Ma_Di_Wo_Do_Vr_Za".split("_"),
        longDateFormat: {
            LT: "HH:mm",
            LTS: "HH:mm:ss",
            L: "DD-MM-YYYY",
            LL: "D MMMM YYYY",
            LLL: "D MMMM YYYY HH:mm",
            LLLL: "dddd D MMMM YYYY HH:mm"
        },
        calendar: {
            sameDay: "[vandaag om] LT",
            nextDay: "[morgen om] LT",
            nextWeek: "dddd [om] LT",
            lastDay: "[gisteren om] LT",
            lastWeek: "[afgelopen] dddd [om] LT",
            sameElse: "L"
        },
        relativeTime: {
            future: "over %s",
            past: "%s geleden",
            s: "een paar seconden",
            m: "Ã©Ã©n minuut",
            mm: "%d minuten",
            h: "Ã©Ã©n uur",
            hh: "%d uur",
            d: "Ã©Ã©n dag",
            dd: "%d dagen",
            M: "Ã©Ã©n maand",
            MM: "%d maanden",
            y: "Ã©Ã©n jaar",
            yy: "%d jaar"
        },
        ordinalParse: /\d{1,2}(ste|de)/,
        ordinal: function(number) {
            return number + (number === 1 || number === 8 || number >= 20 ? "ste" : "de");
        },
        week: {
            dow: 1,
            doy: 4
        }
    });
    var nn = _moment__default.defineLocale("nn", {
        months: "januar_februar_mars_april_mai_juni_juli_august_september_oktober_november_desember".split("_"),
        monthsShort: "jan_feb_mar_apr_mai_jun_jul_aug_sep_okt_nov_des".split("_"),
        weekdays: "sundag_mÃ¥ndag_tysdag_onsdag_torsdag_fredag_laurdag".split("_"),
        weekdaysShort: "sun_mÃ¥n_tys_ons_tor_fre_lau".split("_"),
        weekdaysMin: "su_mÃ¥_ty_on_to_fr_lÃ¸".split("_"),
        longDateFormat: {
            LT: "HH:mm",
            LTS: "HH:mm:ss",
            L: "DD.MM.YYYY",
            LL: "D MMMM YYYY",
            LLL: "D MMMM YYYY HH:mm",
            LLLL: "dddd D MMMM YYYY HH:mm"
        },
        calendar: {
            sameDay: "[I dag klokka] LT",
            nextDay: "[I morgon klokka] LT",
            nextWeek: "dddd [klokka] LT",
            lastDay: "[I gÃ¥r klokka] LT",
            lastWeek: "[FÃ¸regÃ¥ande] dddd [klokka] LT",
            sameElse: "L"
        },
        relativeTime: {
            future: "om %s",
            past: "for %s sidan",
            s: "nokre sekund",
            m: "eit minutt",
            mm: "%d minutt",
            h: "ein time",
            hh: "%d timar",
            d: "ein dag",
            dd: "%d dagar",
            M: "ein mÃ¥nad",
            MM: "%d mÃ¥nader",
            y: "eit Ã¥r",
            yy: "%d Ã¥r"
        },
        ordinalParse: /\d{1,2}\./,
        ordinal: "%d.",
        week: {
            dow: 1,
            doy: 4
        }
    });
    var monthsNominative = "styczeÅ_luty_marzec_kwiecieÅ_maj_czerwiec_lipiec_sierpieÅ_wrzesieÅ_paÅºdziernik_listopad_grudzieÅ".split("_"), monthsSubjective = "stycznia_lutego_marca_kwietnia_maja_czerwca_lipca_sierpnia_wrzeÅnia_paÅºdziernika_listopada_grudnia".split("_");
    function pl__plural(n) {
        return n % 10 < 5 && n % 10 > 1 && ~~(n / 10) % 10 !== 1;
    }
    function pl__translate(number, withoutSuffix, key) {
        var result = number + " ";
        switch (key) {
          case "m":
            return withoutSuffix ? "minuta" : "minutÄ";

          case "mm":
            return result + (pl__plural(number) ? "minuty" : "minut");

          case "h":
            return withoutSuffix ? "godzina" : "godzinÄ";

          case "hh":
            return result + (pl__plural(number) ? "godziny" : "godzin");

          case "MM":
            return result + (pl__plural(number) ? "miesiÄce" : "miesiÄcy");

          case "yy":
            return result + (pl__plural(number) ? "lata" : "lat");
        }
    }
    var pl = _moment__default.defineLocale("pl", {
        months: function(momentToFormat, format) {
            if (format === "") {
                return "(" + monthsSubjective[momentToFormat.month()] + "|" + monthsNominative[momentToFormat.month()] + ")";
            } else if (/D MMMM/.test(format)) {
                return monthsSubjective[momentToFormat.month()];
            } else {
                return monthsNominative[momentToFormat.month()];
            }
        },
        monthsShort: "sty_lut_mar_kwi_maj_cze_lip_sie_wrz_paÅº_lis_gru".split("_"),
        weekdays: "niedziela_poniedziaÅek_wtorek_Åroda_czwartek_piÄtek_sobota".split("_"),
        weekdaysShort: "nie_pon_wt_År_czw_pt_sb".split("_"),
        weekdaysMin: "N_Pn_Wt_År_Cz_Pt_So".split("_"),
        longDateFormat: {
            LT: "HH:mm",
            LTS: "HH:mm:ss",
            L: "DD.MM.YYYY",
            LL: "D MMMM YYYY",
            LLL: "D MMMM YYYY HH:mm",
            LLLL: "dddd, D MMMM YYYY HH:mm"
        },
        calendar: {
            sameDay: "[DziÅ o] LT",
            nextDay: "[Jutro o] LT",
            nextWeek: "[W] dddd [o] LT",
            lastDay: "[Wczoraj o] LT",
            lastWeek: function() {
                switch (this.day()) {
                  case 0:
                    return "[W zeszÅÄ niedzielÄ o] LT";

                  case 3:
                    return "[W zeszÅÄ ÅrodÄ o] LT";

                  case 6:
                    return "[W zeszÅÄ sobotÄ o] LT";

                  default:
                    return "[W zeszÅy] dddd [o] LT";
                }
            },
            sameElse: "L"
        },
        relativeTime: {
            future: "za %s",
            past: "%s temu",
            s: "kilka sekund",
            m: pl__translate,
            mm: pl__translate,
            h: pl__translate,
            hh: pl__translate,
            d: "1 dzieÅ",
            dd: "%d dni",
            M: "miesiÄc",
            MM: pl__translate,
            y: "rok",
            yy: pl__translate
        },
        ordinalParse: /\d{1,2}\./,
        ordinal: "%d.",
        week: {
            dow: 1,
            doy: 4
        }
    });
    var pt_br = _moment__default.defineLocale("pt-br", {
        months: "Janeiro_Fevereiro_MarÃ§o_Abril_Maio_Junho_Julho_Agosto_Setembro_Outubro_Novembro_Dezembro".split("_"),
        monthsShort: "Jan_Fev_Mar_Abr_Mai_Jun_Jul_Ago_Set_Out_Nov_Dez".split("_"),
        weekdays: "Domingo_Segunda-Feira_TerÃ§a-Feira_Quarta-Feira_Quinta-Feira_Sexta-Feira_SÃ¡bado".split("_"),
        weekdaysShort: "Dom_Seg_Ter_Qua_Qui_Sex_SÃ¡b".split("_"),
        weekdaysMin: "Dom_2Âª_3Âª_4Âª_5Âª_6Âª_SÃ¡b".split("_"),
        longDateFormat: {
            LT: "HH:mm",
            LTS: "HH:mm:ss",
            L: "DD/MM/YYYY",
            LL: "D [de] MMMM [de] YYYY",
            LLL: "D [de] MMMM [de] YYYY [Ã s] HH:mm",
            LLLL: "dddd, D [de] MMMM [de] YYYY [Ã s] HH:mm"
        },
        calendar: {
            sameDay: "[Hoje Ã s] LT",
            nextDay: "[AmanhÃ£ Ã s] LT",
            nextWeek: "dddd [Ã s] LT",
            lastDay: "[Ontem Ã s] LT",
            lastWeek: function() {
                return this.day() === 0 || this.day() === 6 ? "[Ãltimo] dddd [Ã s] LT" : "[Ãltima] dddd [Ã s] LT";
            },
            sameElse: "L"
        },
        relativeTime: {
            future: "em %s",
            past: "%s atrÃ¡s",
            s: "poucos segundos",
            m: "um minuto",
            mm: "%d minutos",
            h: "uma hora",
            hh: "%d horas",
            d: "um dia",
            dd: "%d dias",
            M: "um mÃªs",
            MM: "%d meses",
            y: "um ano",
            yy: "%d anos"
        },
        ordinalParse: /\d{1,2}Âº/,
        ordinal: "%dÂº"
    });
    var pt = _moment__default.defineLocale("pt", {
        months: "Janeiro_Fevereiro_MarÃ§o_Abril_Maio_Junho_Julho_Agosto_Setembro_Outubro_Novembro_Dezembro".split("_"),
        monthsShort: "Jan_Fev_Mar_Abr_Mai_Jun_Jul_Ago_Set_Out_Nov_Dez".split("_"),
        weekdays: "Domingo_Segunda-Feira_TerÃ§a-Feira_Quarta-Feira_Quinta-Feira_Sexta-Feira_SÃ¡bado".split("_"),
        weekdaysShort: "Dom_Seg_Ter_Qua_Qui_Sex_SÃ¡b".split("_"),
        weekdaysMin: "Dom_2Âª_3Âª_4Âª_5Âª_6Âª_SÃ¡b".split("_"),
        longDateFormat: {
            LT: "HH:mm",
            LTS: "HH:mm:ss",
            L: "DD/MM/YYYY",
            LL: "D [de] MMMM [de] YYYY",
            LLL: "D [de] MMMM [de] YYYY HH:mm",
            LLLL: "dddd, D [de] MMMM [de] YYYY HH:mm"
        },
        calendar: {
            sameDay: "[Hoje Ã s] LT",
            nextDay: "[AmanhÃ£ Ã s] LT",
            nextWeek: "dddd [Ã s] LT",
            lastDay: "[Ontem Ã s] LT",
            lastWeek: function() {
                return this.day() === 0 || this.day() === 6 ? "[Ãltimo] dddd [Ã s] LT" : "[Ãltima] dddd [Ã s] LT";
            },
            sameElse: "L"
        },
        relativeTime: {
            future: "em %s",
            past: "hÃ¡ %s",
            s: "segundos",
            m: "um minuto",
            mm: "%d minutos",
            h: "uma hora",
            hh: "%d horas",
            d: "um dia",
            dd: "%d dias",
            M: "um mÃªs",
            MM: "%d meses",
            y: "um ano",
            yy: "%d anos"
        },
        ordinalParse: /\d{1,2}Âº/,
        ordinal: "%dÂº",
        week: {
            dow: 1,
            doy: 4
        }
    });
    function ro__relativeTimeWithPlural(number, withoutSuffix, key) {
        var format = {
            mm: "minute",
            hh: "ore",
            dd: "zile",
            MM: "luni",
            yy: "ani"
        }, separator = " ";
        if (number % 100 >= 20 || number >= 100 && number % 100 === 0) {
            separator = " de ";
        }
        return number + separator + format[key];
    }
    var ro = _moment__default.defineLocale("ro", {
        months: "ianuarie_februarie_martie_aprilie_mai_iunie_iulie_august_septembrie_octombrie_noiembrie_decembrie".split("_"),
        monthsShort: "ian._febr._mart._apr._mai_iun._iul._aug._sept._oct._nov._dec.".split("_"),
        weekdays: "duminicÄ_luni_marÈi_miercuri_joi_vineri_sÃ¢mbÄtÄ".split("_"),
        weekdaysShort: "Dum_Lun_Mar_Mie_Joi_Vin_SÃ¢m".split("_"),
        weekdaysMin: "Du_Lu_Ma_Mi_Jo_Vi_SÃ¢".split("_"),
        longDateFormat: {
            LT: "H:mm",
            LTS: "H:mm:ss",
            L: "DD.MM.YYYY",
            LL: "D MMMM YYYY",
            LLL: "D MMMM YYYY H:mm",
            LLLL: "dddd, D MMMM YYYY H:mm"
        },
        calendar: {
            sameDay: "[azi la] LT",
            nextDay: "[mÃ¢ine la] LT",
            nextWeek: "dddd [la] LT",
            lastDay: "[ieri la] LT",
            lastWeek: "[fosta] dddd [la] LT",
            sameElse: "L"
        },
        relativeTime: {
            future: "peste %s",
            past: "%s Ã®n urmÄ",
            s: "cÃ¢teva secunde",
            m: "un minut",
            mm: ro__relativeTimeWithPlural,
            h: "o orÄ",
            hh: ro__relativeTimeWithPlural,
            d: "o zi",
            dd: ro__relativeTimeWithPlural,
            M: "o lunÄ",
            MM: ro__relativeTimeWithPlural,
            y: "un an",
            yy: ro__relativeTimeWithPlural
        },
        week: {
            dow: 1,
            doy: 7
        }
    });
    function ru__plural(word, num) {
        var forms = word.split("_");
        return num % 10 === 1 && num % 100 !== 11 ? forms[0] : num % 10 >= 2 && num % 10 <= 4 && (num % 100 < 10 || num % 100 >= 20) ? forms[1] : forms[2];
    }
    function ru__relativeTimeWithPlural(number, withoutSuffix, key) {
        var format = {
            mm: withoutSuffix ? "Ð¼Ð¸Ð½ÑÑÐ°_Ð¼Ð¸Ð½ÑÑÑ_Ð¼Ð¸Ð½ÑÑ" : "Ð¼Ð¸Ð½ÑÑÑ_Ð¼Ð¸Ð½ÑÑÑ_Ð¼Ð¸Ð½ÑÑ",
            hh: "ÑÐ°Ñ_ÑÐ°ÑÐ°_ÑÐ°ÑÐ¾Ð²",
            dd: "Ð´ÐµÐ½Ñ_Ð´Ð½Ñ_Ð´Ð½ÐµÐ¹",
            MM: "Ð¼ÐµÑÑÑ_Ð¼ÐµÑÑÑÐ°_Ð¼ÐµÑÑÑÐµÐ²",
            yy: "Ð³Ð¾Ð´_Ð³Ð¾Ð´Ð°_Ð»ÐµÑ"
        };
        if (key === "m") {
            return withoutSuffix ? "Ð¼Ð¸Ð½ÑÑÐ°" : "Ð¼Ð¸Ð½ÑÑÑ";
        } else {
            return number + " " + ru__plural(format[key], +number);
        }
    }
    function ru__monthsCaseReplace(m, format) {
        var months = {
            nominative: "ÑÐ½Ð²Ð°ÑÑ_ÑÐµÐ²ÑÐ°Ð»Ñ_Ð¼Ð°ÑÑ_Ð°Ð¿ÑÐµÐ»Ñ_Ð¼Ð°Ð¹_Ð¸ÑÐ½Ñ_Ð¸ÑÐ»Ñ_Ð°Ð²Ð³ÑÑÑ_ÑÐµÐ½ÑÑÐ±ÑÑ_Ð¾ÐºÑÑÐ±ÑÑ_Ð½Ð¾ÑÐ±ÑÑ_Ð´ÐµÐºÐ°Ð±ÑÑ".split("_"),
            accusative: "ÑÐ½Ð²Ð°ÑÑ_ÑÐµÐ²ÑÐ°Ð»Ñ_Ð¼Ð°ÑÑÐ°_Ð°Ð¿ÑÐµÐ»Ñ_Ð¼Ð°Ñ_Ð¸ÑÐ½Ñ_Ð¸ÑÐ»Ñ_Ð°Ð²Ð³ÑÑÑÐ°_ÑÐµÐ½ÑÑÐ±ÑÑ_Ð¾ÐºÑÑÐ±ÑÑ_Ð½Ð¾ÑÐ±ÑÑ_Ð´ÐµÐºÐ°Ð±ÑÑ".split("_")
        }, nounCase = /D[oD]?(\[[^\[\]]*\]|\s+)+MMMM?/.test(format) ? "accusative" : "nominative";
        return months[nounCase][m.month()];
    }
    function ru__monthsShortCaseReplace(m, format) {
        var monthsShort = {
            nominative: "ÑÐ½Ð²_ÑÐµÐ²_Ð¼Ð°ÑÑ_Ð°Ð¿Ñ_Ð¼Ð°Ð¹_Ð¸ÑÐ½Ñ_Ð¸ÑÐ»Ñ_Ð°Ð²Ð³_ÑÐµÐ½_Ð¾ÐºÑ_Ð½Ð¾Ñ_Ð´ÐµÐº".split("_"),
            accusative: "ÑÐ½Ð²_ÑÐµÐ²_Ð¼Ð°Ñ_Ð°Ð¿Ñ_Ð¼Ð°Ñ_Ð¸ÑÐ½Ñ_Ð¸ÑÐ»Ñ_Ð°Ð²Ð³_ÑÐµÐ½_Ð¾ÐºÑ_Ð½Ð¾Ñ_Ð´ÐµÐº".split("_")
        }, nounCase = /D[oD]?(\[[^\[\]]*\]|\s+)+MMMM?/.test(format) ? "accusative" : "nominative";
        return monthsShort[nounCase][m.month()];
    }
    function ru__weekdaysCaseReplace(m, format) {
        var weekdays = {
            nominative: "Ð²Ð¾ÑÐºÑÐµÑÐµÐ½ÑÐµ_Ð¿Ð¾Ð½ÐµÐ´ÐµÐ»ÑÐ½Ð¸Ðº_Ð²ÑÐ¾ÑÐ½Ð¸Ðº_ÑÑÐµÐ´Ð°_ÑÐµÑÐ²ÐµÑÐ³_Ð¿ÑÑÐ½Ð¸ÑÐ°_ÑÑÐ±Ð±Ð¾ÑÐ°".split("_"),
            accusative: "Ð²Ð¾ÑÐºÑÐµÑÐµÐ½ÑÐµ_Ð¿Ð¾Ð½ÐµÐ´ÐµÐ»ÑÐ½Ð¸Ðº_Ð²ÑÐ¾ÑÐ½Ð¸Ðº_ÑÑÐµÐ´Ñ_ÑÐµÑÐ²ÐµÑÐ³_Ð¿ÑÑÐ½Ð¸ÑÑ_ÑÑÐ±Ð±Ð¾ÑÑ".split("_")
        }, nounCase = /\[ ?[ÐÐ²] ?(?:Ð¿ÑÐ¾ÑÐ»ÑÑ|ÑÐ»ÐµÐ´ÑÑÑÑÑ|ÑÑÑ)? ?\] ?dddd/.test(format) ? "accusative" : "nominative";
        return weekdays[nounCase][m.day()];
    }
    var ru = _moment__default.defineLocale("ru", {
        months: ru__monthsCaseReplace,
        monthsShort: ru__monthsShortCaseReplace,
        weekdays: ru__weekdaysCaseReplace,
        weekdaysShort: "Ð²Ñ_Ð¿Ð½_Ð²Ñ_ÑÑ_ÑÑ_Ð¿Ñ_ÑÐ±".split("_"),
        weekdaysMin: "Ð²Ñ_Ð¿Ð½_Ð²Ñ_ÑÑ_ÑÑ_Ð¿Ñ_ÑÐ±".split("_"),
        monthsParse: [ /^ÑÐ½Ð²/i, /^ÑÐµÐ²/i, /^Ð¼Ð°Ñ/i, /^Ð°Ð¿Ñ/i, /^Ð¼Ð°[Ð¹|Ñ]/i, /^Ð¸ÑÐ½/i, /^Ð¸ÑÐ»/i, /^Ð°Ð²Ð³/i, /^ÑÐµÐ½/i, /^Ð¾ÐºÑ/i, /^Ð½Ð¾Ñ/i, /^Ð´ÐµÐº/i ],
        longDateFormat: {
            LT: "HH:mm",
            LTS: "HH:mm:ss",
            L: "DD.MM.YYYY",
            LL: "D MMMM YYYY Ð³.",
            LLL: "D MMMM YYYY Ð³., HH:mm",
            LLLL: "dddd, D MMMM YYYY Ð³., HH:mm"
        },
        calendar: {
            sameDay: "[Ð¡ÐµÐ³Ð¾Ð´Ð½Ñ Ð²] LT",
            nextDay: "[ÐÐ°Ð²ÑÑÐ° Ð²] LT",
            lastDay: "[ÐÑÐµÑÐ° Ð²] LT",
            nextWeek: function() {
                return this.day() === 2 ? "[ÐÐ¾] dddd [Ð²] LT" : "[Ð] dddd [Ð²] LT";
            },
            lastWeek: function(now) {
                if (now.week() !== this.week()) {
                    switch (this.day()) {
                      case 0:
                        return "[Ð Ð¿ÑÐ¾ÑÐ»Ð¾Ðµ] dddd [Ð²] LT";

                      case 1:
                      case 2:
                      case 4:
                        return "[Ð Ð¿ÑÐ¾ÑÐ»ÑÐ¹] dddd [Ð²] LT";

                      case 3:
                      case 5:
                      case 6:
                        return "[Ð Ð¿ÑÐ¾ÑÐ»ÑÑ] dddd [Ð²] LT";
                    }
                } else {
                    if (this.day() === 2) {
                        return "[ÐÐ¾] dddd [Ð²] LT";
                    } else {
                        return "[Ð] dddd [Ð²] LT";
                    }
                }
            },
            sameElse: "L"
        },
        relativeTime: {
            future: "ÑÐµÑÐµÐ· %s",
            past: "%s Ð½Ð°Ð·Ð°Ð´",
            s: "Ð½ÐµÑÐºÐ¾Ð»ÑÐºÐ¾ ÑÐµÐºÑÐ½Ð´",
            m: ru__relativeTimeWithPlural,
            mm: ru__relativeTimeWithPlural,
            h: "ÑÐ°Ñ",
            hh: ru__relativeTimeWithPlural,
            d: "Ð´ÐµÐ½Ñ",
            dd: ru__relativeTimeWithPlural,
            M: "Ð¼ÐµÑÑÑ",
            MM: ru__relativeTimeWithPlural,
            y: "Ð³Ð¾Ð´",
            yy: ru__relativeTimeWithPlural
        },
        meridiemParse: /Ð½Ð¾ÑÐ¸|ÑÑÑÐ°|Ð´Ð½Ñ|Ð²ÐµÑÐµÑÐ°/i,
        isPM: function(input) {
            return /^(Ð´Ð½Ñ|Ð²ÐµÑÐµÑÐ°)$/.test(input);
        },
        meridiem: function(hour, minute, isLower) {
            if (hour < 4) {
                return "Ð½Ð¾ÑÐ¸";
            } else if (hour < 12) {
                return "ÑÑÑÐ°";
            } else if (hour < 17) {
                return "Ð´Ð½Ñ";
            } else {
                return "Ð²ÐµÑÐµÑÐ°";
            }
        },
        ordinalParse: /\d{1,2}-(Ð¹|Ð³Ð¾|Ñ)/,
        ordinal: function(number, period) {
            switch (period) {
              case "M":
              case "d":
              case "DDD":
                return number + "-Ð¹";

              case "D":
                return number + "-Ð³Ð¾";

              case "w":
              case "W":
                return number + "-Ñ";

              default:
                return number;
            }
        },
        week: {
            dow: 1,
            doy: 7
        }
    });
    var si = _moment__default.defineLocale("si", {
        months: "à¶¢à¶±à·à·à¶»à·_à¶´à·à¶¶à¶»à·à·à¶»à·_à¶¸à·à¶»à·à¶­à·_à¶à¶´à·âà¶»à·à¶½à·_à¶¸à·à¶ºà·_à¶¢à·à¶±à·_à¶¢à·à¶½à·_à¶à¶à·à·à·à¶­à·_à·à·à¶´à·à¶­à·à¶¸à·à¶¶à¶»à·_à¶à¶à·à¶­à·à¶¶à¶»à·_à¶±à·à·à·à¶¸à·à¶¶à¶»à·_à¶¯à·à·à·à¶¸à·à¶¶à¶»à·".split("_"),
        monthsShort: "à¶¢à¶±_à¶´à·à¶¶_à¶¸à·à¶»à·_à¶à¶´à·_à¶¸à·à¶ºà·_à¶¢à·à¶±à·_à¶¢à·à¶½à·_à¶à¶à·_à·à·à¶´à·_à¶à¶à·_à¶±à·à·à·_à¶¯à·à·à·".split("_"),
        weekdays: "à¶à¶»à·à¶¯à·_à·à¶³à·à¶¯à·_à¶à¶à·à¶»à·à·à·à¶¯à·_à¶¶à¶¯à·à¶¯à·_à¶¶à·âà¶»à·à·à·à¶´à¶­à·à¶±à·à¶¯à·_à·à·à¶à·à¶»à·à¶¯à·_à·à·à¶±à·à·à¶»à·à¶¯à·".split("_"),
        weekdaysShort: "à¶à¶»à·_à·à¶³à·_à¶à¶_à¶¶à¶¯à·_à¶¶à·âà¶»à·_à·à·à¶à·_à·à·à¶±".split("_"),
        weekdaysMin: "à¶_à·_à¶_à¶¶_à¶¶à·âà¶»_à·à·_à·à·".split("_"),
        longDateFormat: {
            LT: "a h:mm",
            LTS: "a h:mm:ss",
            L: "YYYY/MM/DD",
            LL: "YYYY MMMM D",
            LLL: "YYYY MMMM D, a h:mm",
            LLLL: "YYYY MMMM D [à·à·à¶±à·] dddd, a h:mm:ss"
        },
        calendar: {
            sameDay: "[à¶à¶¯] LT[à¶§]",
            nextDay: "[à·à·à¶§] LT[à¶§]",
            nextWeek: "dddd LT[à¶§]",
            lastDay: "[à¶à¶ºà·] LT[à¶§]",
            lastWeek: "[à¶´à·à·à¶à·à¶º] dddd LT[à¶§]",
            sameElse: "L"
        },
        relativeTime: {
            future: "%sà¶à·à¶±à·",
            past: "%sà¶à¶§ à¶´à·à¶»",
            s: "à¶­à¶­à·à¶´à¶» à¶à·à·à·à¶´à¶º",
            m: "à¶¸à·à¶±à·à¶­à·à¶­à·à·",
            mm: "à¶¸à·à¶±à·à¶­à·à¶­à· %d",
            h: "à¶´à·à¶º",
            hh: "à¶´à·à¶º %d",
            d: "à¶¯à·à¶±à¶º",
            dd: "à¶¯à·à¶± %d",
            M: "à¶¸à·à·à¶º",
            MM: "à¶¸à·à· %d",
            y: "à·à·à¶»",
            yy: "à·à·à¶» %d"
        },
        ordinalParse: /\d{1,2} à·à·à¶±à·/,
        ordinal: function(number) {
            return number + " à·à·à¶±à·";
        },
        meridiem: function(hours, minutes, isLower) {
            if (hours > 11) {
                return isLower ? "à¶´.à·." : "à¶´à·à· à·à¶»à·";
            } else {
                return isLower ? "à¶´à·.à·." : "à¶´à·à¶» à·à¶»à·";
            }
        }
    });
    var sk__months = "januÃ¡r_februÃ¡r_marec_aprÃ­l_mÃ¡j_jÃºn_jÃºl_august_september_oktÃ³ber_november_december".split("_"), sk__monthsShort = "jan_feb_mar_apr_mÃ¡j_jÃºn_jÃºl_aug_sep_okt_nov_dec".split("_");
    function sk__plural(n) {
        return n > 1 && n < 5;
    }
    function sk__translate(number, withoutSuffix, key, isFuture) {
        var result = number + " ";
        switch (key) {
          case "s":
            return withoutSuffix || isFuture ? "pÃ¡r sekÃºnd" : "pÃ¡r sekundami";

          case "m":
            return withoutSuffix ? "minÃºta" : isFuture ? "minÃºtu" : "minÃºtou";

          case "mm":
            if (withoutSuffix || isFuture) {
                return result + (sk__plural(number) ? "minÃºty" : "minÃºt");
            } else {
                return result + "minÃºtami";
            }
            break;

          case "h":
            return withoutSuffix ? "hodina" : isFuture ? "hodinu" : "hodinou";

          case "hh":
            if (withoutSuffix || isFuture) {
                return result + (sk__plural(number) ? "hodiny" : "hodÃ­n");
            } else {
                return result + "hodinami";
            }
            break;

          case "d":
            return withoutSuffix || isFuture ? "deÅ" : "dÅom";

          case "dd":
            if (withoutSuffix || isFuture) {
                return result + (sk__plural(number) ? "dni" : "dnÃ­");
            } else {
                return result + "dÅami";
            }
            break;

          case "M":
            return withoutSuffix || isFuture ? "mesiac" : "mesiacom";

          case "MM":
            if (withoutSuffix || isFuture) {
                return result + (sk__plural(number) ? "mesiace" : "mesiacov");
            } else {
                return result + "mesiacmi";
            }
            break;

          case "y":
            return withoutSuffix || isFuture ? "rok" : "rokom";

          case "yy":
            if (withoutSuffix || isFuture) {
                return result + (sk__plural(number) ? "roky" : "rokov");
            } else {
                return result + "rokmi";
            }
            break;
        }
    }
    var sk = _moment__default.defineLocale("sk", {
        months: sk__months,
        monthsShort: sk__monthsShort,
        monthsParse: function(months, monthsShort) {
            var i, _monthsParse = [];
            for (i = 0; i < 12; i++) {
                _monthsParse[i] = new RegExp("^" + months[i] + "$|^" + monthsShort[i] + "$", "i");
            }
            return _monthsParse;
        }(sk__months, sk__monthsShort),
        weekdays: "nedeÄ¾a_pondelok_utorok_streda_Å¡tvrtok_piatok_sobota".split("_"),
        weekdaysShort: "ne_po_ut_st_Å¡t_pi_so".split("_"),
        weekdaysMin: "ne_po_ut_st_Å¡t_pi_so".split("_"),
        longDateFormat: {
            LT: "H:mm",
            LTS: "H:mm:ss",
            L: "DD.MM.YYYY",
            LL: "D. MMMM YYYY",
            LLL: "D. MMMM YYYY H:mm",
            LLLL: "dddd D. MMMM YYYY H:mm"
        },
        calendar: {
            sameDay: "[dnes o] LT",
            nextDay: "[zajtra o] LT",
            nextWeek: function() {
                switch (this.day()) {
                  case 0:
                    return "[v nedeÄ¾u o] LT";

                  case 1:
                  case 2:
                    return "[v] dddd [o] LT";

                  case 3:
                    return "[v stredu o] LT";

                  case 4:
                    return "[vo Å¡tvrtok o] LT";

                  case 5:
                    return "[v piatok o] LT";

                  case 6:
                    return "[v sobotu o] LT";
                }
            },
            lastDay: "[vÄera o] LT",
            lastWeek: function() {
                switch (this.day()) {
                  case 0:
                    return "[minulÃº nedeÄ¾u o] LT";

                  case 1:
                  case 2:
                    return "[minulÃ½] dddd [o] LT";

                  case 3:
                    return "[minulÃº stredu o] LT";

                  case 4:
                  case 5:
                    return "[minulÃ½] dddd [o] LT";

                  case 6:
                    return "[minulÃº sobotu o] LT";
                }
            },
            sameElse: "L"
        },
        relativeTime: {
            future: "za %s",
            past: "pred %s",
            s: sk__translate,
            m: sk__translate,
            mm: sk__translate,
            h: sk__translate,
            hh: sk__translate,
            d: sk__translate,
            dd: sk__translate,
            M: sk__translate,
            MM: sk__translate,
            y: sk__translate,
            yy: sk__translate
        },
        ordinalParse: /\d{1,2}\./,
        ordinal: "%d.",
        week: {
            dow: 1,
            doy: 4
        }
    });
    function sl__processRelativeTime(number, withoutSuffix, key, isFuture) {
        var result = number + " ";
        switch (key) {
          case "s":
            return withoutSuffix || isFuture ? "nekaj sekund" : "nekaj sekundami";

          case "m":
            return withoutSuffix ? "ena minuta" : "eno minuto";

          case "mm":
            if (number === 1) {
                result += withoutSuffix ? "minuta" : "minuto";
            } else if (number === 2) {
                result += withoutSuffix || isFuture ? "minuti" : "minutama";
            } else if (number < 5) {
                result += withoutSuffix || isFuture ? "minute" : "minutami";
            } else {
                result += withoutSuffix || isFuture ? "minut" : "minutami";
            }
            return result;

          case "h":
            return withoutSuffix ? "ena ura" : "eno uro";

          case "hh":
            if (number === 1) {
                result += withoutSuffix ? "ura" : "uro";
            } else if (number === 2) {
                result += withoutSuffix || isFuture ? "uri" : "urama";
            } else if (number < 5) {
                result += withoutSuffix || isFuture ? "ure" : "urami";
            } else {
                result += withoutSuffix || isFuture ? "ur" : "urami";
            }
            return result;

          case "d":
            return withoutSuffix || isFuture ? "en dan" : "enim dnem";

          case "dd":
            if (number === 1) {
                result += withoutSuffix || isFuture ? "dan" : "dnem";
            } else if (number === 2) {
                result += withoutSuffix || isFuture ? "dni" : "dnevoma";
            } else {
                result += withoutSuffix || isFuture ? "dni" : "dnevi";
            }
            return result;

          case "M":
            return withoutSuffix || isFuture ? "en mesec" : "enim mesecem";

          case "MM":
            if (number === 1) {
                result += withoutSuffix || isFuture ? "mesec" : "mesecem";
            } else if (number === 2) {
                result += withoutSuffix || isFuture ? "meseca" : "mesecema";
            } else if (number < 5) {
                result += withoutSuffix || isFuture ? "mesece" : "meseci";
            } else {
                result += withoutSuffix || isFuture ? "mesecev" : "meseci";
            }
            return result;

          case "y":
            return withoutSuffix || isFuture ? "eno leto" : "enim letom";

          case "yy":
            if (number === 1) {
                result += withoutSuffix || isFuture ? "leto" : "letom";
            } else if (number === 2) {
                result += withoutSuffix || isFuture ? "leti" : "letoma";
            } else if (number < 5) {
                result += withoutSuffix || isFuture ? "leta" : "leti";
            } else {
                result += withoutSuffix || isFuture ? "let" : "leti";
            }
            return result;
        }
    }
    var sl = _moment__default.defineLocale("sl", {
        months: "januar_februar_marec_april_maj_junij_julij_avgust_september_oktober_november_december".split("_"),
        monthsShort: "jan._feb._mar._apr._maj._jun._jul._avg._sep._okt._nov._dec.".split("_"),
        weekdays: "nedelja_ponedeljek_torek_sreda_Äetrtek_petek_sobota".split("_"),
        weekdaysShort: "ned._pon._tor._sre._Äet._pet._sob.".split("_"),
        weekdaysMin: "ne_po_to_sr_Äe_pe_so".split("_"),
        longDateFormat: {
            LT: "H:mm",
            LTS: "H:mm:ss",
            L: "DD. MM. YYYY",
            LL: "D. MMMM YYYY",
            LLL: "D. MMMM YYYY H:mm",
            LLLL: "dddd, D. MMMM YYYY H:mm"
        },
        calendar: {
            sameDay: "[danes ob] LT",
            nextDay: "[jutri ob] LT",
            nextWeek: function() {
                switch (this.day()) {
                  case 0:
                    return "[v] [nedeljo] [ob] LT";

                  case 3:
                    return "[v] [sredo] [ob] LT";

                  case 6:
                    return "[v] [soboto] [ob] LT";

                  case 1:
                  case 2:
                  case 4:
                  case 5:
                    return "[v] dddd [ob] LT";
                }
            },
            lastDay: "[vÄeraj ob] LT",
            lastWeek: function() {
                switch (this.day()) {
                  case 0:
                    return "[prejÅ¡njo] [nedeljo] [ob] LT";

                  case 3:
                    return "[prejÅ¡njo] [sredo] [ob] LT";

                  case 6:
                    return "[prejÅ¡njo] [soboto] [ob] LT";

                  case 1:
                  case 2:
                  case 4:
                  case 5:
                    return "[prejÅ¡nji] dddd [ob] LT";
                }
            },
            sameElse: "L"
        },
        relativeTime: {
            future: "Äez %s",
            past: "pred %s",
            s: sl__processRelativeTime,
            m: sl__processRelativeTime,
            mm: sl__processRelativeTime,
            h: sl__processRelativeTime,
            hh: sl__processRelativeTime,
            d: sl__processRelativeTime,
            dd: sl__processRelativeTime,
            M: sl__processRelativeTime,
            MM: sl__processRelativeTime,
            y: sl__processRelativeTime,
            yy: sl__processRelativeTime
        },
        ordinalParse: /\d{1,2}\./,
        ordinal: "%d.",
        week: {
            dow: 1,
            doy: 7
        }
    });
    var sq = _moment__default.defineLocale("sq", {
        months: "Janar_Shkurt_Mars_Prill_Maj_Qershor_Korrik_Gusht_Shtator_Tetor_NÃ«ntor_Dhjetor".split("_"),
        monthsShort: "Jan_Shk_Mar_Pri_Maj_Qer_Kor_Gus_Sht_Tet_NÃ«n_Dhj".split("_"),
        weekdays: "E Diel_E HÃ«nÃ«_E MartÃ«_E MÃ«rkurÃ«_E Enjte_E Premte_E ShtunÃ«".split("_"),
        weekdaysShort: "Die_HÃ«n_Mar_MÃ«r_Enj_Pre_Sht".split("_"),
        weekdaysMin: "D_H_Ma_MÃ«_E_P_Sh".split("_"),
        meridiemParse: /PD|MD/,
        isPM: function(input) {
            return input.charAt(0) === "M";
        },
        meridiem: function(hours, minutes, isLower) {
            return hours < 12 ? "PD" : "MD";
        },
        longDateFormat: {
            LT: "HH:mm",
            LTS: "HH:mm:ss",
            L: "DD/MM/YYYY",
            LL: "D MMMM YYYY",
            LLL: "D MMMM YYYY HH:mm",
            LLLL: "dddd, D MMMM YYYY HH:mm"
        },
        calendar: {
            sameDay: "[Sot nÃ«] LT",
            nextDay: "[NesÃ«r nÃ«] LT",
            nextWeek: "dddd [nÃ«] LT",
            lastDay: "[Dje nÃ«] LT",
            lastWeek: "dddd [e kaluar nÃ«] LT",
            sameElse: "L"
        },
        relativeTime: {
            future: "nÃ« %s",
            past: "%s mÃ« parÃ«",
            s: "disa sekonda",
            m: "njÃ« minutÃ«",
            mm: "%d minuta",
            h: "njÃ« orÃ«",
            hh: "%d orÃ«",
            d: "njÃ« ditÃ«",
            dd: "%d ditÃ«",
            M: "njÃ« muaj",
            MM: "%d muaj",
            y: "njÃ« vit",
            yy: "%d vite"
        },
        ordinalParse: /\d{1,2}\./,
        ordinal: "%d.",
        week: {
            dow: 1,
            doy: 4
        }
    });
    var sr_cyrl__translator = {
        words: {
            m: [ "ÑÐµÐ´Ð°Ð½ Ð¼Ð¸Ð½ÑÑ", "ÑÐµÐ´Ð½Ðµ Ð¼Ð¸Ð½ÑÑÐµ" ],
            mm: [ "Ð¼Ð¸Ð½ÑÑ", "Ð¼Ð¸Ð½ÑÑÐµ", "Ð¼Ð¸Ð½ÑÑÐ°" ],
            h: [ "ÑÐµÐ´Ð°Ð½ ÑÐ°Ñ", "ÑÐµÐ´Ð½Ð¾Ð³ ÑÐ°ÑÐ°" ],
            hh: [ "ÑÐ°Ñ", "ÑÐ°ÑÐ°", "ÑÐ°ÑÐ¸" ],
            dd: [ "Ð´Ð°Ð½", "Ð´Ð°Ð½Ð°", "Ð´Ð°Ð½Ð°" ],
            MM: [ "Ð¼ÐµÑÐµÑ", "Ð¼ÐµÑÐµÑÐ°", "Ð¼ÐµÑÐµÑÐ¸" ],
            yy: [ "Ð³Ð¾Ð´Ð¸Ð½Ð°", "Ð³Ð¾Ð´Ð¸Ð½Ðµ", "Ð³Ð¾Ð´Ð¸Ð½Ð°" ]
        },
        correctGrammaticalCase: function(number, wordKey) {
            return number === 1 ? wordKey[0] : number >= 2 && number <= 4 ? wordKey[1] : wordKey[2];
        },
        translate: function(number, withoutSuffix, key) {
            var wordKey = sr_cyrl__translator.words[key];
            if (key.length === 1) {
                return withoutSuffix ? wordKey[0] : wordKey[1];
            } else {
                return number + " " + sr_cyrl__translator.correctGrammaticalCase(number, wordKey);
            }
        }
    };
    var sr_cyrl = _moment__default.defineLocale("sr-cyrl", {
        months: [ "ÑÐ°Ð½ÑÐ°Ñ", "ÑÐµÐ±ÑÑÐ°Ñ", "Ð¼Ð°ÑÑ", "Ð°Ð¿ÑÐ¸Ð»", "Ð¼Ð°Ñ", "ÑÑÐ½", "ÑÑÐ»", "Ð°Ð²Ð³ÑÑÑ", "ÑÐµÐ¿ÑÐµÐ¼Ð±Ð°Ñ", "Ð¾ÐºÑÐ¾Ð±Ð°Ñ", "Ð½Ð¾Ð²ÐµÐ¼Ð±Ð°Ñ", "Ð´ÐµÑÐµÐ¼Ð±Ð°Ñ" ],
        monthsShort: [ "ÑÐ°Ð½.", "ÑÐµÐ±.", "Ð¼Ð°Ñ.", "Ð°Ð¿Ñ.", "Ð¼Ð°Ñ", "ÑÑÐ½", "ÑÑÐ»", "Ð°Ð²Ð³.", "ÑÐµÐ¿.", "Ð¾ÐºÑ.", "Ð½Ð¾Ð².", "Ð´ÐµÑ." ],
        weekdays: [ "Ð½ÐµÐ´ÐµÑÐ°", "Ð¿Ð¾Ð½ÐµÐ´ÐµÑÐ°Ðº", "ÑÑÐ¾ÑÐ°Ðº", "ÑÑÐµÐ´Ð°", "ÑÐµÑÐ²ÑÑÐ°Ðº", "Ð¿ÐµÑÐ°Ðº", "ÑÑÐ±Ð¾ÑÐ°" ],
        weekdaysShort: [ "Ð½ÐµÐ´.", "Ð¿Ð¾Ð½.", "ÑÑÐ¾.", "ÑÑÐµ.", "ÑÐµÑ.", "Ð¿ÐµÑ.", "ÑÑÐ±." ],
        weekdaysMin: [ "Ð½Ðµ", "Ð¿Ð¾", "ÑÑ", "ÑÑ", "ÑÐµ", "Ð¿Ðµ", "ÑÑ" ],
        longDateFormat: {
            LT: "H:mm",
            LTS: "H:mm:ss",
            L: "DD. MM. YYYY",
            LL: "D. MMMM YYYY",
            LLL: "D. MMMM YYYY H:mm",
            LLLL: "dddd, D. MMMM YYYY H:mm"
        },
        calendar: {
            sameDay: "[Ð´Ð°Ð½Ð°Ñ Ñ] LT",
            nextDay: "[ÑÑÑÑÐ° Ñ] LT",
            nextWeek: function() {
                switch (this.day()) {
                  case 0:
                    return "[Ñ] [Ð½ÐµÐ´ÐµÑÑ] [Ñ] LT";

                  case 3:
                    return "[Ñ] [ÑÑÐµÐ´Ñ] [Ñ] LT";

                  case 6:
                    return "[Ñ] [ÑÑÐ±Ð¾ÑÑ] [Ñ] LT";

                  case 1:
                  case 2:
                  case 4:
                  case 5:
                    return "[Ñ] dddd [Ñ] LT";
                }
            },
            lastDay: "[ÑÑÑÐµ Ñ] LT",
            lastWeek: function() {
                var lastWeekDays = [ "[Ð¿ÑÐ¾ÑÐ»Ðµ] [Ð½ÐµÐ´ÐµÑÐµ] [Ñ] LT", "[Ð¿ÑÐ¾ÑÐ»Ð¾Ð³] [Ð¿Ð¾Ð½ÐµÐ´ÐµÑÐºÐ°] [Ñ] LT", "[Ð¿ÑÐ¾ÑÐ»Ð¾Ð³] [ÑÑÐ¾ÑÐºÐ°] [Ñ] LT", "[Ð¿ÑÐ¾ÑÐ»Ðµ] [ÑÑÐµÐ´Ðµ] [Ñ] LT", "[Ð¿ÑÐ¾ÑÐ»Ð¾Ð³] [ÑÐµÑÐ²ÑÑÐºÐ°] [Ñ] LT", "[Ð¿ÑÐ¾ÑÐ»Ð¾Ð³] [Ð¿ÐµÑÐºÐ°] [Ñ] LT", "[Ð¿ÑÐ¾ÑÐ»Ðµ] [ÑÑÐ±Ð¾ÑÐµ] [Ñ] LT" ];
                return lastWeekDays[this.day()];
            },
            sameElse: "L"
        },
        relativeTime: {
            future: "Ð·Ð° %s",
            past: "Ð¿ÑÐµ %s",
            s: "Ð½ÐµÐºÐ¾Ð»Ð¸ÐºÐ¾ ÑÐµÐºÑÐ½Ð´Ð¸",
            m: sr_cyrl__translator.translate,
            mm: sr_cyrl__translator.translate,
            h: sr_cyrl__translator.translate,
            hh: sr_cyrl__translator.translate,
            d: "Ð´Ð°Ð½",
            dd: sr_cyrl__translator.translate,
            M: "Ð¼ÐµÑÐµÑ",
            MM: sr_cyrl__translator.translate,
            y: "Ð³Ð¾Ð´Ð¸Ð½Ñ",
            yy: sr_cyrl__translator.translate
        },
        ordinalParse: /\d{1,2}\./,
        ordinal: "%d.",
        week: {
            dow: 1,
            doy: 7
        }
    });
    var sr__translator = {
        words: {
            m: [ "jedan minut", "jedne minute" ],
            mm: [ "minut", "minute", "minuta" ],
            h: [ "jedan sat", "jednog sata" ],
            hh: [ "sat", "sata", "sati" ],
            dd: [ "dan", "dana", "dana" ],
            MM: [ "mesec", "meseca", "meseci" ],
            yy: [ "godina", "godine", "godina" ]
        },
        correctGrammaticalCase: function(number, wordKey) {
            return number === 1 ? wordKey[0] : number >= 2 && number <= 4 ? wordKey[1] : wordKey[2];
        },
        translate: function(number, withoutSuffix, key) {
            var wordKey = sr__translator.words[key];
            if (key.length === 1) {
                return withoutSuffix ? wordKey[0] : wordKey[1];
            } else {
                return number + " " + sr__translator.correctGrammaticalCase(number, wordKey);
            }
        }
    };
    var sr = _moment__default.defineLocale("sr", {
        months: [ "januar", "februar", "mart", "april", "maj", "jun", "jul", "avgust", "septembar", "oktobar", "novembar", "decembar" ],
        monthsShort: [ "jan.", "feb.", "mar.", "apr.", "maj", "jun", "jul", "avg.", "sep.", "okt.", "nov.", "dec." ],
        weekdays: [ "nedelja", "ponedeljak", "utorak", "sreda", "Äetvrtak", "petak", "subota" ],
        weekdaysShort: [ "ned.", "pon.", "uto.", "sre.", "Äet.", "pet.", "sub." ],
        weekdaysMin: [ "ne", "po", "ut", "sr", "Äe", "pe", "su" ],
        longDateFormat: {
            LT: "H:mm",
            LTS: "H:mm:ss",
            L: "DD. MM. YYYY",
            LL: "D. MMMM YYYY",
            LLL: "D. MMMM YYYY H:mm",
            LLLL: "dddd, D. MMMM YYYY H:mm"
        },
        calendar: {
            sameDay: "[danas u] LT",
            nextDay: "[sutra u] LT",
            nextWeek: function() {
                switch (this.day()) {
                  case 0:
                    return "[u] [nedelju] [u] LT";

                  case 3:
                    return "[u] [sredu] [u] LT";

                  case 6:
                    return "[u] [subotu] [u] LT";

                  case 1:
                  case 2:
                  case 4:
                  case 5:
                    return "[u] dddd [u] LT";
                }
            },
            lastDay: "[juÄe u] LT",
            lastWeek: function() {
                var lastWeekDays = [ "[proÅ¡le] [nedelje] [u] LT", "[proÅ¡log] [ponedeljka] [u] LT", "[proÅ¡log] [utorka] [u] LT", "[proÅ¡le] [srede] [u] LT", "[proÅ¡log] [Äetvrtka] [u] LT", "[proÅ¡log] [petka] [u] LT", "[proÅ¡le] [subote] [u] LT" ];
                return lastWeekDays[this.day()];
            },
            sameElse: "L"
        },
        relativeTime: {
            future: "za %s",
            past: "pre %s",
            s: "nekoliko sekundi",
            m: sr__translator.translate,
            mm: sr__translator.translate,
            h: sr__translator.translate,
            hh: sr__translator.translate,
            d: "dan",
            dd: sr__translator.translate,
            M: "mesec",
            MM: sr__translator.translate,
            y: "godinu",
            yy: sr__translator.translate
        },
        ordinalParse: /\d{1,2}\./,
        ordinal: "%d.",
        week: {
            dow: 1,
            doy: 7
        }
    });
    var sv = _moment__default.defineLocale("sv", {
        months: "januari_februari_mars_april_maj_juni_juli_augusti_september_oktober_november_december".split("_"),
        monthsShort: "jan_feb_mar_apr_maj_jun_jul_aug_sep_okt_nov_dec".split("_"),
        weekdays: "sÃ¶ndag_mÃ¥ndag_tisdag_onsdag_torsdag_fredag_lÃ¶rdag".split("_"),
        weekdaysShort: "sÃ¶n_mÃ¥n_tis_ons_tor_fre_lÃ¶r".split("_"),
        weekdaysMin: "sÃ¶_mÃ¥_ti_on_to_fr_lÃ¶".split("_"),
        longDateFormat: {
            LT: "HH:mm",
            LTS: "HH:mm:ss",
            L: "YYYY-MM-DD",
            LL: "D MMMM YYYY",
            LLL: "D MMMM YYYY HH:mm",
            LLLL: "dddd D MMMM YYYY HH:mm"
        },
        calendar: {
            sameDay: "[Idag] LT",
            nextDay: "[Imorgon] LT",
            lastDay: "[IgÃ¥r] LT",
            nextWeek: "[PÃ¥] dddd LT",
            lastWeek: "[I] dddd[s] LT",
            sameElse: "L"
        },
        relativeTime: {
            future: "om %s",
            past: "fÃ¶r %s sedan",
            s: "nÃ¥gra sekunder",
            m: "en minut",
            mm: "%d minuter",
            h: "en timme",
            hh: "%d timmar",
            d: "en dag",
            dd: "%d dagar",
            M: "en mÃ¥nad",
            MM: "%d mÃ¥nader",
            y: "ett Ã¥r",
            yy: "%d Ã¥r"
        },
        ordinalParse: /\d{1,2}(e|a)/,
        ordinal: function(number) {
            var b = number % 10, output = ~~(number % 100 / 10) === 1 ? "e" : b === 1 ? "a" : b === 2 ? "a" : b === 3 ? "e" : "e";
            return number + output;
        },
        week: {
            dow: 1,
            doy: 4
        }
    });
    var ta = _moment__default.defineLocale("ta", {
        months: "à®à®©à®µà®°à®¿_à®ªà®¿à®ªà¯à®°à®µà®°à®¿_à®®à®¾à®°à¯à®à¯_à®à®ªà¯à®°à®²à¯_à®®à¯_à®à¯à®©à¯_à®à¯à®²à¯_à®à®à®¸à¯à®à¯_à®à¯à®ªà¯à®à¯à®®à¯à®ªà®°à¯_à®à®à¯à®à¯à®¾à®ªà®°à¯_à®¨à®µà®®à¯à®ªà®°à¯_à®à®¿à®à®®à¯à®ªà®°à¯".split("_"),
        monthsShort: "à®à®©à®µà®°à®¿_à®ªà®¿à®ªà¯à®°à®µà®°à®¿_à®®à®¾à®°à¯à®à¯_à®à®ªà¯à®°à®²à¯_à®®à¯_à®à¯à®©à¯_à®à¯à®²à¯_à®à®à®¸à¯à®à¯_à®à¯à®ªà¯à®à¯à®®à¯à®ªà®°à¯_à®à®à¯à®à¯à®¾à®ªà®°à¯_à®¨à®µà®®à¯à®ªà®°à¯_à®à®¿à®à®®à¯à®ªà®°à¯".split("_"),
        weekdays: "à®à®¾à®¯à®¿à®±à¯à®±à¯à®à¯à®à®¿à®´à®®à¯_à®¤à®¿à®à¯à®à®à¯à®à®¿à®´à®®à¯_à®à¯à®µà¯à®µà®¾à®¯à¯à®à®¿à®´à®®à¯_à®ªà¯à®¤à®©à¯à®à®¿à®´à®®à¯_à®µà®¿à®¯à®¾à®´à®à¯à®à®¿à®´à®®à¯_à®µà¯à®³à¯à®³à®¿à®à¯à®à®¿à®´à®®à¯_à®à®©à®¿à®à¯à®à®¿à®´à®®à¯".split("_"),
        weekdaysShort: "à®à®¾à®¯à®¿à®±à¯_à®¤à®¿à®à¯à®à®³à¯_à®à¯à®µà¯à®µà®¾à®¯à¯_à®ªà¯à®¤à®©à¯_à®µà®¿à®¯à®¾à®´à®©à¯_à®µà¯à®³à¯à®³à®¿_à®à®©à®¿".split("_"),
        weekdaysMin: "à®à®¾_à®¤à®¿_à®à¯_à®ªà¯_à®µà®¿_à®µà¯_à®".split("_"),
        longDateFormat: {
            LT: "HH:mm",
            LTS: "HH:mm:ss",
            L: "DD/MM/YYYY",
            LL: "D MMMM YYYY",
            LLL: "D MMMM YYYY, HH:mm",
            LLLL: "dddd, D MMMM YYYY, HH:mm"
        },
        calendar: {
            sameDay: "[à®à®©à¯à®±à¯] LT",
            nextDay: "[à®¨à®¾à®³à¯] LT",
            nextWeek: "dddd, LT",
            lastDay: "[à®¨à¯à®±à¯à®±à¯] LT",
            lastWeek: "[à®à®à®¨à¯à®¤ à®µà®¾à®°à®®à¯] dddd, LT",
            sameElse: "L"
        },
        relativeTime: {
            future: "%s à®à®²à¯",
            past: "%s à®®à¯à®©à¯",
            s: "à®à®°à¯ à®à®¿à®² à®µà®¿à®¨à®¾à®à®¿à®à®³à¯",
            m: "à®à®°à¯ à®¨à®¿à®®à®¿à®à®®à¯",
            mm: "%d à®¨à®¿à®®à®¿à®à®à¯à®à®³à¯",
            h: "à®à®°à¯ à®®à®£à®¿ à®¨à¯à®°à®®à¯",
            hh: "%d à®®à®£à®¿ à®¨à¯à®°à®®à¯",
            d: "à®à®°à¯ à®¨à®¾à®³à¯",
            dd: "%d à®¨à®¾à®à¯à®à®³à¯",
            M: "à®à®°à¯ à®®à®¾à®¤à®®à¯",
            MM: "%d à®®à®¾à®¤à®à¯à®à®³à¯",
            y: "à®à®°à¯ à®µà®°à¯à®à®®à¯",
            yy: "%d à®à®£à¯à®à¯à®à®³à¯"
        },
        ordinalParse: /\d{1,2}à®µà®¤à¯/,
        ordinal: function(number) {
            return number + "à®µà®¤à¯";
        },
        meridiemParse: /à®¯à®¾à®®à®®à¯|à®µà¯à®à®±à¯|à®à®¾à®²à¯|à®¨à®£à¯à®ªà®à®²à¯|à®à®±à¯à®ªà®¾à®à¯|à®®à®¾à®²à¯/,
        meridiem: function(hour, minute, isLower) {
            if (hour < 2) {
                return " à®¯à®¾à®®à®®à¯";
            } else if (hour < 6) {
                return " à®µà¯à®à®±à¯";
            } else if (hour < 10) {
                return " à®à®¾à®²à¯";
            } else if (hour < 14) {
                return " à®¨à®£à¯à®ªà®à®²à¯";
            } else if (hour < 18) {
                return " à®à®±à¯à®ªà®¾à®à¯";
            } else if (hour < 22) {
                return " à®®à®¾à®²à¯";
            } else {
                return " à®¯à®¾à®®à®®à¯";
            }
        },
        meridiemHour: function(hour, meridiem) {
            if (hour === 12) {
                hour = 0;
            }
            if (meridiem === "à®¯à®¾à®®à®®à¯") {
                return hour < 2 ? hour : hour + 12;
            } else if (meridiem === "à®µà¯à®à®±à¯" || meridiem === "à®à®¾à®²à¯") {
                return hour;
            } else if (meridiem === "à®¨à®£à¯à®ªà®à®²à¯") {
                return hour >= 10 ? hour : hour + 12;
            } else {
                return hour + 12;
            }
        },
        week: {
            dow: 0,
            doy: 6
        }
    });
    var th = _moment__default.defineLocale("th", {
        months: "à¸¡à¸à¸£à¸²à¸à¸¡_à¸à¸¸à¸¡à¸ à¸²à¸à¸±à¸à¸à¹_à¸¡à¸µà¸à¸²à¸à¸¡_à¹à¸¡à¸©à¸²à¸¢à¸_à¸à¸¤à¸©à¸ à¸²à¸à¸¡_à¸¡à¸´à¸à¸¸à¸à¸²à¸¢à¸_à¸à¸£à¸à¸à¸²à¸à¸¡_à¸ªà¸´à¸à¸«à¸²à¸à¸¡_à¸à¸±à¸à¸¢à¸²à¸¢à¸_à¸à¸¸à¸¥à¸²à¸à¸¡_à¸à¸¤à¸¨à¸à¸´à¸à¸²à¸¢à¸_à¸à¸±à¸à¸§à¸²à¸à¸¡".split("_"),
        monthsShort: "à¸¡à¸à¸£à¸²_à¸à¸¸à¸¡à¸ à¸²_à¸¡à¸µà¸à¸²_à¹à¸¡à¸©à¸²_à¸à¸¤à¸©à¸ à¸²_à¸¡à¸´à¸à¸¸à¸à¸²_à¸à¸£à¸à¸à¸²_à¸ªà¸´à¸à¸«à¸²_à¸à¸±à¸à¸¢à¸²_à¸à¸¸à¸¥à¸²_à¸à¸¤à¸¨à¸à¸´à¸à¸²_à¸à¸±à¸à¸§à¸²".split("_"),
        weekdays: "à¸­à¸²à¸à¸´à¸à¸¢à¹_à¸à¸±à¸à¸à¸£à¹_à¸­à¸±à¸à¸à¸²à¸£_à¸à¸¸à¸_à¸à¸¤à¸«à¸±à¸ªà¸à¸à¸µ_à¸¨à¸¸à¸à¸£à¹_à¹à¸ªà¸²à¸£à¹".split("_"),
        weekdaysShort: "à¸­à¸²à¸à¸´à¸à¸¢à¹_à¸à¸±à¸à¸à¸£à¹_à¸­à¸±à¸à¸à¸²à¸£_à¸à¸¸à¸_à¸à¸¤à¸«à¸±à¸ª_à¸¨à¸¸à¸à¸£à¹_à¹à¸ªà¸²à¸£à¹".split("_"),
        weekdaysMin: "à¸­à¸²._à¸._à¸­._à¸._à¸à¸¤._à¸¨._à¸ª.".split("_"),
        longDateFormat: {
            LT: "H à¸à¸²à¸¬à¸´à¸à¸² m à¸à¸²à¸à¸µ",
            LTS: "H à¸à¸²à¸¬à¸´à¸à¸² m à¸à¸²à¸à¸µ s à¸§à¸´à¸à¸²à¸à¸µ",
            L: "YYYY/MM/DD",
            LL: "D MMMM YYYY",
            LLL: "D MMMM YYYY à¹à¸§à¸¥à¸² H à¸à¸²à¸¬à¸´à¸à¸² m à¸à¸²à¸à¸µ",
            LLLL: "à¸§à¸±à¸ddddà¸à¸µà¹ D MMMM YYYY à¹à¸§à¸¥à¸² H à¸à¸²à¸¬à¸´à¸à¸² m à¸à¸²à¸à¸µ"
        },
        meridiemParse: /à¸à¹à¸­à¸à¹à¸à¸µà¹à¸¢à¸|à¸«à¸¥à¸±à¸à¹à¸à¸µà¹à¸¢à¸/,
        isPM: function(input) {
            return input === "à¸«à¸¥à¸±à¸à¹à¸à¸µà¹à¸¢à¸";
        },
        meridiem: function(hour, minute, isLower) {
            if (hour < 12) {
                return "à¸à¹à¸­à¸à¹à¸à¸µà¹à¸¢à¸";
            } else {
                return "à¸«à¸¥à¸±à¸à¹à¸à¸µà¹à¸¢à¸";
            }
        },
        calendar: {
            sameDay: "[à¸§à¸±à¸à¸à¸µà¹ à¹à¸§à¸¥à¸²] LT",
            nextDay: "[à¸à¸£à¸¸à¹à¸à¸à¸µà¹ à¹à¸§à¸¥à¸²] LT",
            nextWeek: "dddd[à¸«à¸à¹à¸² à¹à¸§à¸¥à¸²] LT",
            lastDay: "[à¹à¸¡à¸·à¹à¸­à¸§à¸²à¸à¸à¸µà¹ à¹à¸§à¸¥à¸²] LT",
            lastWeek: "[à¸§à¸±à¸]dddd[à¸à¸µà¹à¹à¸¥à¹à¸§ à¹à¸§à¸¥à¸²] LT",
            sameElse: "L"
        },
        relativeTime: {
            future: "à¸­à¸µà¸ %s",
            past: "%sà¸à¸µà¹à¹à¸¥à¹à¸§",
            s: "à¹à¸¡à¹à¸à¸µà¹à¸§à¸´à¸à¸²à¸à¸µ",
            m: "1 à¸à¸²à¸à¸µ",
            mm: "%d à¸à¸²à¸à¸µ",
            h: "1 à¸à¸±à¹à¸§à¹à¸¡à¸",
            hh: "%d à¸à¸±à¹à¸§à¹à¸¡à¸",
            d: "1 à¸§à¸±à¸",
            dd: "%d à¸§à¸±à¸",
            M: "1 à¹à¸à¸·à¸­à¸",
            MM: "%d à¹à¸à¸·à¸­à¸",
            y: "1 à¸à¸µ",
            yy: "%d à¸à¸µ"
        }
    });
    var tl_ph = _moment__default.defineLocale("tl-ph", {
        months: "Enero_Pebrero_Marso_Abril_Mayo_Hunyo_Hulyo_Agosto_Setyembre_Oktubre_Nobyembre_Disyembre".split("_"),
        monthsShort: "Ene_Peb_Mar_Abr_May_Hun_Hul_Ago_Set_Okt_Nob_Dis".split("_"),
        weekdays: "Linggo_Lunes_Martes_Miyerkules_Huwebes_Biyernes_Sabado".split("_"),
        weekdaysShort: "Lin_Lun_Mar_Miy_Huw_Biy_Sab".split("_"),
        weekdaysMin: "Li_Lu_Ma_Mi_Hu_Bi_Sab".split("_"),
        longDateFormat: {
            LT: "HH:mm",
            LTS: "HH:mm:ss",
            L: "MM/D/YYYY",
            LL: "MMMM D, YYYY",
            LLL: "MMMM D, YYYY HH:mm",
            LLLL: "dddd, MMMM DD, YYYY HH:mm"
        },
        calendar: {
            sameDay: "[Ngayon sa] LT",
            nextDay: "[Bukas sa] LT",
            nextWeek: "dddd [sa] LT",
            lastDay: "[Kahapon sa] LT",
            lastWeek: "dddd [huling linggo] LT",
            sameElse: "L"
        },
        relativeTime: {
            future: "sa loob ng %s",
            past: "%s ang nakalipas",
            s: "ilang segundo",
            m: "isang minuto",
            mm: "%d minuto",
            h: "isang oras",
            hh: "%d oras",
            d: "isang araw",
            dd: "%d araw",
            M: "isang buwan",
            MM: "%d buwan",
            y: "isang taon",
            yy: "%d taon"
        },
        ordinalParse: /\d{1,2}/,
        ordinal: function(number) {
            return number;
        },
        week: {
            dow: 1,
            doy: 4
        }
    });
    var tr__suffixes = {
        1: "'inci",
        5: "'inci",
        8: "'inci",
        70: "'inci",
        80: "'inci",
        2: "'nci",
        7: "'nci",
        20: "'nci",
        50: "'nci",
        3: "'Ã¼ncÃ¼",
        4: "'Ã¼ncÃ¼",
        100: "'Ã¼ncÃ¼",
        6: "'ncÄ±",
        9: "'uncu",
        10: "'uncu",
        30: "'uncu",
        60: "'Ä±ncÄ±",
        90: "'Ä±ncÄ±"
    };
    var tr = _moment__default.defineLocale("tr", {
        months: "Ocak_Åubat_Mart_Nisan_MayÄ±s_Haziran_Temmuz_AÄustos_EylÃ¼l_Ekim_KasÄ±m_AralÄ±k".split("_"),
        monthsShort: "Oca_Åub_Mar_Nis_May_Haz_Tem_AÄu_Eyl_Eki_Kas_Ara".split("_"),
        weekdays: "Pazar_Pazartesi_SalÄ±_ÃarÅamba_PerÅembe_Cuma_Cumartesi".split("_"),
        weekdaysShort: "Paz_Pts_Sal_Ãar_Per_Cum_Cts".split("_"),
        weekdaysMin: "Pz_Pt_Sa_Ãa_Pe_Cu_Ct".split("_"),
        longDateFormat: {
            LT: "HH:mm",
            LTS: "HH:mm:ss",
            L: "DD.MM.YYYY",
            LL: "D MMMM YYYY",
            LLL: "D MMMM YYYY HH:mm",
            LLLL: "dddd, D MMMM YYYY HH:mm"
        },
        calendar: {
            sameDay: "[bugÃ¼n saat] LT",
            nextDay: "[yarÄ±n saat] LT",
            nextWeek: "[haftaya] dddd [saat] LT",
            lastDay: "[dÃ¼n] LT",
            lastWeek: "[geÃ§en hafta] dddd [saat] LT",
            sameElse: "L"
        },
        relativeTime: {
            future: "%s sonra",
            past: "%s Ã¶nce",
            s: "birkaÃ§ saniye",
            m: "bir dakika",
            mm: "%d dakika",
            h: "bir saat",
            hh: "%d saat",
            d: "bir gÃ¼n",
            dd: "%d gÃ¼n",
            M: "bir ay",
            MM: "%d ay",
            y: "bir yÄ±l",
            yy: "%d yÄ±l"
        },
        ordinalParse: /\d{1,2}'(inci|nci|Ã¼ncÃ¼|ncÄ±|uncu|Ä±ncÄ±)/,
        ordinal: function(number) {
            if (number === 0) {
                return number + "'Ä±ncÄ±";
            }
            var a = number % 10, b = number % 100 - a, c = number >= 100 ? 100 : null;
            return number + (tr__suffixes[a] || tr__suffixes[b] || tr__suffixes[c]);
        },
        week: {
            dow: 1,
            doy: 7
        }
    });
    var tzl = _moment__default.defineLocale("tzl", {
        months: "Januar_Fevraglh_MarÃ§_AvrÃ¯u_Mai_GÃ¼n_Julia_Guscht_Setemvar_ListopÃ¤ts_Noemvar_Zecemvar".split("_"),
        monthsShort: "Jan_Fev_Mar_Avr_Mai_GÃ¼n_Jul_Gus_Set_Lis_Noe_Zec".split("_"),
        weekdays: "SÃºladi_LÃºneÃ§i_Maitzi_MÃ¡rcuri_XhÃºadi_ViÃ©nerÃ§i_SÃ¡turi".split("_"),
        weekdaysShort: "SÃºl_LÃºn_Mai_MÃ¡r_XhÃº_ViÃ©_SÃ¡t".split("_"),
        weekdaysMin: "SÃº_LÃº_Ma_MÃ¡_Xh_Vi_SÃ¡".split("_"),
        longDateFormat: {
            LT: "HH.mm",
            LTS: "LT.ss",
            L: "DD.MM.YYYY",
            LL: "D. MMMM [dallas] YYYY",
            LLL: "D. MMMM [dallas] YYYY LT",
            LLLL: "dddd, [li] D. MMMM [dallas] YYYY LT"
        },
        meridiem: function(hours, minutes, isLower) {
            if (hours > 11) {
                return isLower ? "d'o" : "D'O";
            } else {
                return isLower ? "d'a" : "D'A";
            }
        },
        calendar: {
            sameDay: "[oxhi Ã ] LT",
            nextDay: "[demÃ  Ã ] LT",
            nextWeek: "dddd [Ã ] LT",
            lastDay: "[ieiri Ã ] LT",
            lastWeek: "[sÃ¼r el] dddd [lasteu Ã ] LT",
            sameElse: "L"
        },
        relativeTime: {
            future: "osprei %s",
            past: "ja%s",
            s: tzl__processRelativeTime,
            m: tzl__processRelativeTime,
            mm: tzl__processRelativeTime,
            h: tzl__processRelativeTime,
            hh: tzl__processRelativeTime,
            d: tzl__processRelativeTime,
            dd: tzl__processRelativeTime,
            M: tzl__processRelativeTime,
            MM: tzl__processRelativeTime,
            y: tzl__processRelativeTime,
            yy: tzl__processRelativeTime
        },
        ordinalParse: /\d{1,2}\./,
        ordinal: "%d.",
        week: {
            dow: 1,
            doy: 4
        }
    });
    function tzl__processRelativeTime(number, withoutSuffix, key, isFuture) {
        var format = {
            s: [ "viensas secunds", "'iensas secunds" ],
            m: [ "'n mÃ­ut", "'iens mÃ­ut" ],
            mm: [ number + " mÃ­uts", " " + number + " mÃ­uts" ],
            h: [ "'n Ã¾ora", "'iensa Ã¾ora" ],
            hh: [ number + " Ã¾oras", " " + number + " Ã¾oras" ],
            d: [ "'n ziua", "'iensa ziua" ],
            dd: [ number + " ziuas", " " + number + " ziuas" ],
            M: [ "'n mes", "'iens mes" ],
            MM: [ number + " mesen", " " + number + " mesen" ],
            y: [ "'n ar", "'iens ar" ],
            yy: [ number + " ars", " " + number + " ars" ]
        };
        return isFuture ? format[key][0] : withoutSuffix ? format[key][0] : format[key][1].trim();
    }
    var tzm_latn = _moment__default.defineLocale("tzm-latn", {
        months: "innayr_brË¤ayrË¤_marË¤sË¤_ibrir_mayyw_ywnyw_ywlywz_É£wÅ¡t_Å¡wtanbir_ktË¤wbrË¤_nwwanbir_dwjnbir".split("_"),
        monthsShort: "innayr_brË¤ayrË¤_marË¤sË¤_ibrir_mayyw_ywnyw_ywlywz_É£wÅ¡t_Å¡wtanbir_ktË¤wbrË¤_nwwanbir_dwjnbir".split("_"),
        weekdays: "asamas_aynas_asinas_akras_akwas_asimwas_asiá¸yas".split("_"),
        weekdaysShort: "asamas_aynas_asinas_akras_akwas_asimwas_asiá¸yas".split("_"),
        weekdaysMin: "asamas_aynas_asinas_akras_akwas_asimwas_asiá¸yas".split("_"),
        longDateFormat: {
            LT: "HH:mm",
            LTS: "HH:mm:ss",
            L: "DD/MM/YYYY",
            LL: "D MMMM YYYY",
            LLL: "D MMMM YYYY HH:mm",
            LLLL: "dddd D MMMM YYYY HH:mm"
        },
        calendar: {
            sameDay: "[asdkh g] LT",
            nextDay: "[aska g] LT",
            nextWeek: "dddd [g] LT",
            lastDay: "[assant g] LT",
            lastWeek: "dddd [g] LT",
            sameElse: "L"
        },
        relativeTime: {
            future: "dadkh s yan %s",
            past: "yan %s",
            s: "imik",
            m: "minuá¸",
            mm: "%d minuá¸",
            h: "saÉa",
            hh: "%d tassaÉin",
            d: "ass",
            dd: "%d ossan",
            M: "ayowr",
            MM: "%d iyyirn",
            y: "asgas",
            yy: "%d isgasn"
        },
        week: {
            dow: 6,
            doy: 12
        }
    });
    var tzm = _moment__default.defineLocale("tzm", {
        months: "âµâµâµâ´°âµ¢âµ_â´±âµâ´°âµ¢âµ_âµâ´°âµâµ_âµâ´±âµâµâµ_âµâ´°âµ¢âµ¢âµ_âµ¢âµâµâµ¢âµ_âµ¢âµâµâµ¢âµâµ£_âµâµâµâµ_âµâµâµâ´°âµâ´±âµâµ_â´½âµâµâ´±âµ_âµâµâµ¡â´°âµâ´±âµâµ_â´·âµâµâµâ´±âµâµ".split("_"),
        monthsShort: "âµâµâµâ´°âµ¢âµ_â´±âµâ´°âµ¢âµ_âµâ´°âµâµ_âµâ´±âµâµâµ_âµâ´°âµ¢âµ¢âµ_âµ¢âµâµâµ¢âµ_âµ¢âµâµâµ¢âµâµ£_âµâµâµâµ_âµâµâµâ´°âµâ´±âµâµ_â´½âµâµâ´±âµ_âµâµâµ¡â´°âµâ´±âµâµ_â´·âµâµâµâ´±âµâµ".split("_"),
        weekdays: "â´°âµâ´°âµâ´°âµ_â´°âµ¢âµâ´°âµ_â´°âµâµâµâ´°âµ_â´°â´½âµâ´°âµ_â´°â´½âµ¡â´°âµ_â´°âµâµâµâµ¡â´°âµ_â´°âµâµâ´¹âµ¢â´°âµ".split("_"),
        weekdaysShort: "â´°âµâ´°âµâ´°âµ_â´°âµ¢âµâ´°âµ_â´°âµâµâµâ´°âµ_â´°â´½âµâ´°âµ_â´°â´½âµ¡â´°âµ_â´°âµâµâµâµ¡â´°âµ_â´°âµâµâ´¹âµ¢â´°âµ".split("_"),
        weekdaysMin: "â´°âµâ´°âµâ´°âµ_â´°âµ¢âµâ´°âµ_â´°âµâµâµâ´°âµ_â´°â´½âµâ´°âµ_â´°â´½âµ¡â´°âµ_â´°âµâµâµâµ¡â´°âµ_â´°âµâµâ´¹âµ¢â´°âµ".split("_"),
        longDateFormat: {
            LT: "HH:mm",
            LTS: "HH:mm:ss",
            L: "DD/MM/YYYY",
            LL: "D MMMM YYYY",
            LLL: "D MMMM YYYY HH:mm",
            LLLL: "dddd D MMMM YYYY HH:mm"
        },
        calendar: {
            sameDay: "[â´°âµâ´·âµ â´´] LT",
            nextDay: "[â´°âµâ´½â´° â´´] LT",
            nextWeek: "dddd [â´´] LT",
            lastDay: "[â´°âµâ´°âµâµ â´´] LT",
            lastWeek: "dddd [â´´] LT",
            sameElse: "L"
        },
        relativeTime: {
            future: "â´·â´°â´·âµ âµ âµ¢â´°âµ %s",
            past: "âµ¢â´°âµ %s",
            s: "âµâµâµâ´½",
            m: "âµâµâµâµâ´º",
            mm: "%d âµâµâµâµâ´º",
            h: "âµâ´°âµâ´°",
            hh: "%d âµâ´°âµâµâ´°âµâµâµ",
            d: "â´°âµâµ",
            dd: "%d oâµâµâ´°âµ",
            M: "â´°âµ¢oâµâµ",
            MM: "%d âµâµ¢âµ¢âµâµâµ",
            y: "â´°âµâ´³â´°âµ",
            yy: "%d âµâµâ´³â´°âµâµ"
        },
        week: {
            dow: 6,
            doy: 12
        }
    });
    function uk__plural(word, num) {
        var forms = word.split("_");
        return num % 10 === 1 && num % 100 !== 11 ? forms[0] : num % 10 >= 2 && num % 10 <= 4 && (num % 100 < 10 || num % 100 >= 20) ? forms[1] : forms[2];
    }
    function uk__relativeTimeWithPlural(number, withoutSuffix, key) {
        var format = {
            mm: "ÑÐ²Ð¸Ð»Ð¸Ð½Ð°_ÑÐ²Ð¸Ð»Ð¸Ð½Ð¸_ÑÐ²Ð¸Ð»Ð¸Ð½",
            hh: "Ð³Ð¾Ð´Ð¸Ð½Ð°_Ð³Ð¾Ð´Ð¸Ð½Ð¸_Ð³Ð¾Ð´Ð¸Ð½",
            dd: "Ð´ÐµÐ½Ñ_Ð´Ð½Ñ_Ð´Ð½ÑÐ²",
            MM: "Ð¼ÑÑÑÑÑ_Ð¼ÑÑÑÑÑ_Ð¼ÑÑÑÑÑÐ²",
            yy: "ÑÑÐº_ÑÐ¾ÐºÐ¸_ÑÐ¾ÐºÑÐ²"
        };
        if (key === "m") {
            return withoutSuffix ? "ÑÐ²Ð¸Ð»Ð¸Ð½Ð°" : "ÑÐ²Ð¸Ð»Ð¸Ð½Ñ";
        } else if (key === "h") {
            return withoutSuffix ? "Ð³Ð¾Ð´Ð¸Ð½Ð°" : "Ð³Ð¾Ð´Ð¸Ð½Ñ";
        } else {
            return number + " " + uk__plural(format[key], +number);
        }
    }
    function uk__monthsCaseReplace(m, format) {
        var months = {
            nominative: "ÑÑÑÐµÐ½Ñ_Ð»ÑÑÐ¸Ð¹_Ð±ÐµÑÐµÐ·ÐµÐ½Ñ_ÐºÐ²ÑÑÐµÐ½Ñ_ÑÑÐ°Ð²ÐµÐ½Ñ_ÑÐµÑÐ²ÐµÐ½Ñ_Ð»Ð¸Ð¿ÐµÐ½Ñ_ÑÐµÑÐ¿ÐµÐ½Ñ_Ð²ÐµÑÐµÑÐµÐ½Ñ_Ð¶Ð¾Ð²ÑÐµÐ½Ñ_Ð»Ð¸ÑÑÐ¾Ð¿Ð°Ð´_Ð³ÑÑÐ´ÐµÐ½Ñ".split("_"),
            accusative: "ÑÑÑÐ½Ñ_Ð»ÑÑÐ¾Ð³Ð¾_Ð±ÐµÑÐµÐ·Ð½Ñ_ÐºÐ²ÑÑÐ½Ñ_ÑÑÐ°Ð²Ð½Ñ_ÑÐµÑÐ²Ð½Ñ_Ð»Ð¸Ð¿Ð½Ñ_ÑÐµÑÐ¿Ð½Ñ_Ð²ÐµÑÐµÑÐ½Ñ_Ð¶Ð¾Ð²ÑÐ½Ñ_Ð»Ð¸ÑÑÐ¾Ð¿Ð°Ð´Ð°_Ð³ÑÑÐ´Ð½Ñ".split("_")
        }, nounCase = /D[oD]? *MMMM?/.test(format) ? "accusative" : "nominative";
        return months[nounCase][m.month()];
    }
    function uk__weekdaysCaseReplace(m, format) {
        var weekdays = {
            nominative: "Ð½ÐµÐ´ÑÐ»Ñ_Ð¿Ð¾Ð½ÐµÐ´ÑÐ»Ð¾Ðº_Ð²ÑÐ²ÑÐ¾ÑÐ¾Ðº_ÑÐµÑÐµÐ´Ð°_ÑÐµÑÐ²ÐµÑ_Ð¿âÑÑÐ½Ð¸ÑÑ_ÑÑÐ±Ð¾ÑÐ°".split("_"),
            accusative: "Ð½ÐµÐ´ÑÐ»Ñ_Ð¿Ð¾Ð½ÐµÐ´ÑÐ»Ð¾Ðº_Ð²ÑÐ²ÑÐ¾ÑÐ¾Ðº_ÑÐµÑÐµÐ´Ñ_ÑÐµÑÐ²ÐµÑ_Ð¿âÑÑÐ½Ð¸ÑÑ_ÑÑÐ±Ð¾ÑÑ".split("_"),
            genitive: "Ð½ÐµÐ´ÑÐ»Ñ_Ð¿Ð¾Ð½ÐµÐ´ÑÐ»ÐºÐ°_Ð²ÑÐ²ÑÐ¾ÑÐºÐ°_ÑÐµÑÐµÐ´Ð¸_ÑÐµÑÐ²ÐµÑÐ³Ð°_Ð¿âÑÑÐ½Ð¸ÑÑ_ÑÑÐ±Ð¾ÑÐ¸".split("_")
        }, nounCase = /(\[[ÐÐ²Ð£Ñ]\]) ?dddd/.test(format) ? "accusative" : /\[?(?:Ð¼Ð¸Ð½ÑÐ»Ð¾Ñ|Ð½Ð°ÑÑÑÐ¿Ð½Ð¾Ñ)? ?\] ?dddd/.test(format) ? "genitive" : "nominative";
        return weekdays[nounCase][m.day()];
    }
    function processHoursFunction(str) {
        return function() {
            return str + "Ð¾" + (this.hours() === 11 ? "Ð±" : "") + "] LT";
        };
    }
    var uk = _moment__default.defineLocale("uk", {
        months: uk__monthsCaseReplace,
        monthsShort: "ÑÑÑ_Ð»ÑÑ_Ð±ÐµÑ_ÐºÐ²ÑÑ_ÑÑÐ°Ð²_ÑÐµÑÐ²_Ð»Ð¸Ð¿_ÑÐµÑÐ¿_Ð²ÐµÑ_Ð¶Ð¾Ð²Ñ_Ð»Ð¸ÑÑ_Ð³ÑÑÐ´".split("_"),
        weekdays: uk__weekdaysCaseReplace,
        weekdaysShort: "Ð½Ð´_Ð¿Ð½_Ð²Ñ_ÑÑ_ÑÑ_Ð¿Ñ_ÑÐ±".split("_"),
        weekdaysMin: "Ð½Ð´_Ð¿Ð½_Ð²Ñ_ÑÑ_ÑÑ_Ð¿Ñ_ÑÐ±".split("_"),
        longDateFormat: {
            LT: "HH:mm",
            LTS: "HH:mm:ss",
            L: "DD.MM.YYYY",
            LL: "D MMMM YYYY Ñ.",
            LLL: "D MMMM YYYY Ñ., HH:mm",
            LLLL: "dddd, D MMMM YYYY Ñ., HH:mm"
        },
        calendar: {
            sameDay: processHoursFunction("[Ð¡ÑÐ¾Ð³Ð¾Ð´Ð½Ñ "),
            nextDay: processHoursFunction("[ÐÐ°Ð²ÑÑÐ° "),
            lastDay: processHoursFunction("[ÐÑÐ¾ÑÐ° "),
            nextWeek: processHoursFunction("[Ð£] dddd ["),
            lastWeek: function() {
                switch (this.day()) {
                  case 0:
                  case 3:
                  case 5:
                  case 6:
                    return processHoursFunction("[ÐÐ¸Ð½ÑÐ»Ð¾Ñ] dddd [").call(this);

                  case 1:
                  case 2:
                  case 4:
                    return processHoursFunction("[ÐÐ¸Ð½ÑÐ»Ð¾Ð³Ð¾] dddd [").call(this);
                }
            },
            sameElse: "L"
        },
        relativeTime: {
            future: "Ð·Ð° %s",
            past: "%s ÑÐ¾Ð¼Ñ",
            s: "Ð´ÐµÐºÑÐ»ÑÐºÐ° ÑÐµÐºÑÐ½Ð´",
            m: uk__relativeTimeWithPlural,
            mm: uk__relativeTimeWithPlural,
            h: "Ð³Ð¾Ð´Ð¸Ð½Ñ",
            hh: uk__relativeTimeWithPlural,
            d: "Ð´ÐµÐ½Ñ",
            dd: uk__relativeTimeWithPlural,
            M: "Ð¼ÑÑÑÑÑ",
            MM: uk__relativeTimeWithPlural,
            y: "ÑÑÐº",
            yy: uk__relativeTimeWithPlural
        },
        meridiemParse: /Ð½Ð¾ÑÑ|ÑÐ°Ð½ÐºÑ|Ð´Ð½Ñ|Ð²ÐµÑÐ¾ÑÐ°/,
        isPM: function(input) {
            return /^(Ð´Ð½Ñ|Ð²ÐµÑÐ¾ÑÐ°)$/.test(input);
        },
        meridiem: function(hour, minute, isLower) {
            if (hour < 4) {
                return "Ð½Ð¾ÑÑ";
            } else if (hour < 12) {
                return "ÑÐ°Ð½ÐºÑ";
            } else if (hour < 17) {
                return "Ð´Ð½Ñ";
            } else {
                return "Ð²ÐµÑÐ¾ÑÐ°";
            }
        },
        ordinalParse: /\d{1,2}-(Ð¹|Ð³Ð¾)/,
        ordinal: function(number, period) {
            switch (period) {
              case "M":
              case "d":
              case "DDD":
              case "w":
              case "W":
                return number + "-Ð¹";

              case "D":
                return number + "-Ð³Ð¾";

              default:
                return number;
            }
        },
        week: {
            dow: 1,
            doy: 7
        }
    });
    var uz = _moment__default.defineLocale("uz", {
        months: "ÑÐ½Ð²Ð°ÑÑ_ÑÐµÐ²ÑÐ°Ð»Ñ_Ð¼Ð°ÑÑ_Ð°Ð¿ÑÐµÐ»Ñ_Ð¼Ð°Ð¹_Ð¸ÑÐ½Ñ_Ð¸ÑÐ»Ñ_Ð°Ð²Ð³ÑÑÑ_ÑÐµÐ½ÑÑÐ±ÑÑ_Ð¾ÐºÑÑÐ±ÑÑ_Ð½Ð¾ÑÐ±ÑÑ_Ð´ÐµÐºÐ°Ð±ÑÑ".split("_"),
        monthsShort: "ÑÐ½Ð²_ÑÐµÐ²_Ð¼Ð°Ñ_Ð°Ð¿Ñ_Ð¼Ð°Ð¹_Ð¸ÑÐ½_Ð¸ÑÐ»_Ð°Ð²Ð³_ÑÐµÐ½_Ð¾ÐºÑ_Ð½Ð¾Ñ_Ð´ÐµÐº".split("_"),
        weekdays: "Ð¯ÐºÑÐ°Ð½Ð±Ð°_ÐÑÑÐ°Ð½Ð±Ð°_Ð¡ÐµÑÐ°Ð½Ð±Ð°_Ð§Ð¾ÑÑÐ°Ð½Ð±Ð°_ÐÐ°Ð¹ÑÐ°Ð½Ð±Ð°_ÐÑÐ¼Ð°_Ð¨Ð°Ð½Ð±Ð°".split("_"),
        weekdaysShort: "Ð¯ÐºÑ_ÐÑÑ_Ð¡ÐµÑ_Ð§Ð¾Ñ_ÐÐ°Ð¹_ÐÑÐ¼_Ð¨Ð°Ð½".split("_"),
        weekdaysMin: "Ð¯Ðº_ÐÑ_Ð¡Ðµ_Ð§Ð¾_ÐÐ°_ÐÑ_Ð¨Ð°".split("_"),
        longDateFormat: {
            LT: "HH:mm",
            LTS: "HH:mm:ss",
            L: "DD/MM/YYYY",
            LL: "D MMMM YYYY",
            LLL: "D MMMM YYYY HH:mm",
            LLLL: "D MMMM YYYY, dddd HH:mm"
        },
        calendar: {
            sameDay: "[ÐÑÐ³ÑÐ½ ÑÐ¾Ð°Ñ] LT [Ð´Ð°]",
            nextDay: "[Ð­ÑÑÐ°Ð³Ð°] LT [Ð´Ð°]",
            nextWeek: "dddd [ÐºÑÐ½Ð¸ ÑÐ¾Ð°Ñ] LT [Ð´Ð°]",
            lastDay: "[ÐÐµÑÐ° ÑÐ¾Ð°Ñ] LT [Ð´Ð°]",
            lastWeek: "[Ð£ÑÐ³Ð°Ð½] dddd [ÐºÑÐ½Ð¸ ÑÐ¾Ð°Ñ] LT [Ð´Ð°]",
            sameElse: "L"
        },
        relativeTime: {
            future: "Ð¯ÐºÐ¸Ð½ %s Ð¸ÑÐ¸Ð´Ð°",
            past: "ÐÐ¸Ñ Ð½ÐµÑÐ° %s Ð¾Ð»Ð´Ð¸Ð½",
            s: "ÑÑÑÑÐ°Ñ",
            m: "Ð±Ð¸Ñ Ð´Ð°ÐºÐ¸ÐºÐ°",
            mm: "%d Ð´Ð°ÐºÐ¸ÐºÐ°",
            h: "Ð±Ð¸Ñ ÑÐ¾Ð°Ñ",
            hh: "%d ÑÐ¾Ð°Ñ",
            d: "Ð±Ð¸Ñ ÐºÑÐ½",
            dd: "%d ÐºÑÐ½",
            M: "Ð±Ð¸Ñ Ð¾Ð¹",
            MM: "%d Ð¾Ð¹",
            y: "Ð±Ð¸Ñ Ð¹Ð¸Ð»",
            yy: "%d Ð¹Ð¸Ð»"
        },
        week: {
            dow: 1,
            doy: 7
        }
    });
    var vi = _moment__default.defineLocale("vi", {
        months: "thÃ¡ng 1_thÃ¡ng 2_thÃ¡ng 3_thÃ¡ng 4_thÃ¡ng 5_thÃ¡ng 6_thÃ¡ng 7_thÃ¡ng 8_thÃ¡ng 9_thÃ¡ng 10_thÃ¡ng 11_thÃ¡ng 12".split("_"),
        monthsShort: "Th01_Th02_Th03_Th04_Th05_Th06_Th07_Th08_Th09_Th10_Th11_Th12".split("_"),
        weekdays: "chá»§ nháº­t_thá»© hai_thá»© ba_thá»© tÆ°_thá»© nÄm_thá»© sÃ¡u_thá»© báº£y".split("_"),
        weekdaysShort: "CN_T2_T3_T4_T5_T6_T7".split("_"),
        weekdaysMin: "CN_T2_T3_T4_T5_T6_T7".split("_"),
        longDateFormat: {
            LT: "HH:mm",
            LTS: "HH:mm:ss",
            L: "DD/MM/YYYY",
            LL: "D MMMM [nÄm] YYYY",
            LLL: "D MMMM [nÄm] YYYY HH:mm",
            LLLL: "dddd, D MMMM [nÄm] YYYY HH:mm",
            l: "DD/M/YYYY",
            ll: "D MMM YYYY",
            lll: "D MMM YYYY HH:mm",
            llll: "ddd, D MMM YYYY HH:mm"
        },
        calendar: {
            sameDay: "[HÃ´m nay lÃºc] LT",
            nextDay: "[NgÃ y mai lÃºc] LT",
            nextWeek: "dddd [tuáº§n tá»i lÃºc] LT",
            lastDay: "[HÃ´m qua lÃºc] LT",
            lastWeek: "dddd [tuáº§n rá»i lÃºc] LT",
            sameElse: "L"
        },
        relativeTime: {
            future: "%s tá»i",
            past: "%s trÆ°á»c",
            s: "vÃ i giÃ¢y",
            m: "má»t phÃºt",
            mm: "%d phÃºt",
            h: "má»t giá»",
            hh: "%d giá»",
            d: "má»t ngÃ y",
            dd: "%d ngÃ y",
            M: "má»t thÃ¡ng",
            MM: "%d thÃ¡ng",
            y: "má»t nÄm",
            yy: "%d nÄm"
        },
        ordinalParse: /\d{1,2}/,
        ordinal: function(number) {
            return number;
        },
        week: {
            dow: 1,
            doy: 4
        }
    });
    var zh_cn = _moment__default.defineLocale("zh-cn", {
        months: "ä¸æ_äºæ_ä¸æ_åæ_äºæ_å­æ_ä¸æ_å«æ_ä¹æ_åæ_åä¸æ_åäºæ".split("_"),
        monthsShort: "1æ_2æ_3æ_4æ_5æ_6æ_7æ_8æ_9æ_10æ_11æ_12æ".split("_"),
        weekdays: "æææ¥_ææä¸_ææäº_ææä¸_ææå_ææäº_ææå­".split("_"),
        weekdaysShort: "å¨æ¥_å¨ä¸_å¨äº_å¨ä¸_å¨å_å¨äº_å¨å­".split("_"),
        weekdaysMin: "æ¥_ä¸_äº_ä¸_å_äº_å­".split("_"),
        longDateFormat: {
            LT: "Ahç¹mmå",
            LTS: "Ahç¹måsç§",
            L: "YYYY-MM-DD",
            LL: "YYYYå¹´MMMDæ¥",
            LLL: "YYYYå¹´MMMDæ¥Ahç¹mmå",
            LLLL: "YYYYå¹´MMMDæ¥ddddAhç¹mmå",
            l: "YYYY-MM-DD",
            ll: "YYYYå¹´MMMDæ¥",
            lll: "YYYYå¹´MMMDæ¥Ahç¹mmå",
            llll: "YYYYå¹´MMMDæ¥ddddAhç¹mmå"
        },
        meridiemParse: /åæ¨|æ©ä¸|ä¸å|ä¸­å|ä¸å|æä¸/,
        meridiemHour: function(hour, meridiem) {
            if (hour === 12) {
                hour = 0;
            }
            if (meridiem === "åæ¨" || meridiem === "æ©ä¸" || meridiem === "ä¸å") {
                return hour;
            } else if (meridiem === "ä¸å" || meridiem === "æä¸") {
                return hour + 12;
            } else {
                return hour >= 11 ? hour : hour + 12;
            }
        },
        meridiem: function(hour, minute, isLower) {
            var hm = hour * 100 + minute;
            if (hm < 600) {
                return "åæ¨";
            } else if (hm < 900) {
                return "æ©ä¸";
            } else if (hm < 1130) {
                return "ä¸å";
            } else if (hm < 1230) {
                return "ä¸­å";
            } else if (hm < 1800) {
                return "ä¸å";
            } else {
                return "æä¸";
            }
        },
        calendar: {
            sameDay: function() {
                return this.minutes() === 0 ? "[ä»å¤©]Ah[ç¹æ´]" : "[ä»å¤©]LT";
            },
            nextDay: function() {
                return this.minutes() === 0 ? "[æå¤©]Ah[ç¹æ´]" : "[æå¤©]LT";
            },
            lastDay: function() {
                return this.minutes() === 0 ? "[æ¨å¤©]Ah[ç¹æ´]" : "[æ¨å¤©]LT";
            },
            nextWeek: function() {
                var startOfWeek, prefix;
                startOfWeek = _moment__default().startOf("week");
                prefix = this.unix() - startOfWeek.unix() >= 7 * 24 * 3600 ? "[ä¸]" : "[æ¬]";
                return this.minutes() === 0 ? prefix + "dddAhç¹æ´" : prefix + "dddAhç¹mm";
            },
            lastWeek: function() {
                var startOfWeek, prefix;
                startOfWeek = _moment__default().startOf("week");
                prefix = this.unix() < startOfWeek.unix() ? "[ä¸]" : "[æ¬]";
                return this.minutes() === 0 ? prefix + "dddAhç¹æ´" : prefix + "dddAhç¹mm";
            },
            sameElse: "LL"
        },
        ordinalParse: /\d{1,2}(æ¥|æ|å¨)/,
        ordinal: function(number, period) {
            switch (period) {
              case "d":
              case "D":
              case "DDD":
                return number + "æ¥";

              case "M":
                return number + "æ";

              case "w":
              case "W":
                return number + "å¨";

              default:
                return number;
            }
        },
        relativeTime: {
            future: "%så",
            past: "%så",
            s: "å ç§",
            m: "1 åé",
            mm: "%d åé",
            h: "1 å°æ¶",
            hh: "%d å°æ¶",
            d: "1 å¤©",
            dd: "%d å¤©",
            M: "1 ä¸ªæ",
            MM: "%d ä¸ªæ",
            y: "1 å¹´",
            yy: "%d å¹´"
        },
        week: {
            dow: 1,
            doy: 4
        }
    });
    var zh_tw = _moment__default.defineLocale("zh-tw", {
        months: "ä¸æ_äºæ_ä¸æ_åæ_äºæ_å­æ_ä¸æ_å«æ_ä¹æ_åæ_åä¸æ_åäºæ".split("_"),
        monthsShort: "1æ_2æ_3æ_4æ_5æ_6æ_7æ_8æ_9æ_10æ_11æ_12æ".split("_"),
        weekdays: "æææ¥_ææä¸_ææäº_ææä¸_ææå_ææäº_ææå­".split("_"),
        weekdaysShort: "é±æ¥_é±ä¸_é±äº_é±ä¸_é±å_é±äº_é±å­".split("_"),
        weekdaysMin: "æ¥_ä¸_äº_ä¸_å_äº_å­".split("_"),
        longDateFormat: {
            LT: "Ahé»mmå",
            LTS: "Ahé»måsç§",
            L: "YYYYå¹´MMMDæ¥",
            LL: "YYYYå¹´MMMDæ¥",
            LLL: "YYYYå¹´MMMDæ¥Ahé»mmå",
            LLLL: "YYYYå¹´MMMDæ¥ddddAhé»mmå",
            l: "YYYYå¹´MMMDæ¥",
            ll: "YYYYå¹´MMMDæ¥",
            lll: "YYYYå¹´MMMDæ¥Ahé»mmå",
            llll: "YYYYå¹´MMMDæ¥ddddAhé»mmå"
        },
        meridiemParse: /æ©ä¸|ä¸å|ä¸­å|ä¸å|æä¸/,
        meridiemHour: function(hour, meridiem) {
            if (hour === 12) {
                hour = 0;
            }
            if (meridiem === "æ©ä¸" || meridiem === "ä¸å") {
                return hour;
            } else if (meridiem === "ä¸­å") {
                return hour >= 11 ? hour : hour + 12;
            } else if (meridiem === "ä¸å" || meridiem === "æä¸") {
                return hour + 12;
            }
        },
        meridiem: function(hour, minute, isLower) {
            var hm = hour * 100 + minute;
            if (hm < 900) {
                return "æ©ä¸";
            } else if (hm < 1130) {
                return "ä¸å";
            } else if (hm < 1230) {
                return "ä¸­å";
            } else if (hm < 1800) {
                return "ä¸å";
            } else {
                return "æä¸";
            }
        },
        calendar: {
            sameDay: "[ä»å¤©]LT",
            nextDay: "[æå¤©]LT",
            nextWeek: "[ä¸]ddddLT",
            lastDay: "[æ¨å¤©]LT",
            lastWeek: "[ä¸]ddddLT",
            sameElse: "L"
        },
        ordinalParse: /\d{1,2}(æ¥|æ|é±)/,
        ordinal: function(number, period) {
            switch (period) {
              case "d":
              case "D":
              case "DDD":
                return number + "æ¥";

              case "M":
                return number + "æ";

              case "w":
              case "W":
                return number + "é±";

              default:
                return number;
            }
        },
        relativeTime: {
            future: "%så§",
            past: "%så",
            s: "å¹¾ç§",
            m: "ä¸åé",
            mm: "%dåé",
            h: "ä¸å°æ",
            hh: "%då°æ",
            d: "ä¸å¤©",
            dd: "%då¤©",
            M: "ä¸åæ",
            MM: "%dåæ",
            y: "ä¸å¹´",
            yy: "%då¹´"
        }
    });
    var moment_with_locales = _moment__default;
    moment_with_locales.locale("en");
    return moment_with_locales;
});

(function(factory) {
    "use strict";
    if (typeof define === "function" && define.amd) {
        define([ "jquery", "moment" ], factory);
    } else if (typeof exports === "object") {
        module.exports = factory(require("jquery"), require("moment"));
    } else {
        if (typeof jQuery === "undefined") {
            throw "bootstrap-datetimepicker requires jQuery to be loaded first";
        }
        if (typeof moment === "undefined") {
            throw "bootstrap-datetimepicker requires Moment.js to be loaded first";
        }
        factory(jQuery, moment);
    }
})(function($, moment) {
    "use strict";
    if (!moment) {
        throw new Error("bootstrap-datetimepicker requires Moment.js to be loaded first");
    }
    var dateTimePicker = function(element, options) {
        var picker = {}, date, viewDate, unset = true, input, component = false, widget = false, use24Hours, minViewModeNumber = 0, actualFormat, parseFormats, currentViewMode, datePickerModes = [ {
            clsName: "days",
            navFnc: "M",
            navStep: 1
        }, {
            clsName: "months",
            navFnc: "y",
            navStep: 1
        }, {
            clsName: "years",
            navFnc: "y",
            navStep: 10
        }, {
            clsName: "decades",
            navFnc: "y",
            navStep: 100
        } ], viewModes = [ "days", "months", "years", "decades" ], verticalModes = [ "top", "bottom", "auto" ], horizontalModes = [ "left", "right", "auto" ], toolbarPlacements = [ "default", "top", "bottom" ], keyMap = {
            up: 38,
            38: "up",
            down: 40,
            40: "down",
            left: 37,
            37: "left",
            right: 39,
            39: "right",
            tab: 9,
            9: "tab",
            escape: 27,
            27: "escape",
            enter: 13,
            13: "enter",
            pageUp: 33,
            33: "pageUp",
            pageDown: 34,
            34: "pageDown",
            shift: 16,
            16: "shift",
            control: 17,
            17: "control",
            space: 32,
            32: "space",
            t: 84,
            84: "t",
            "delete": 46,
            46: "delete"
        }, keyState = {}, hasTimeZone = function() {
            return moment.tz !== undefined && options.timeZone !== undefined && options.timeZone !== null && options.timeZone !== "";
        }, getMoment = function(d) {
            var returnMoment;
            if (d === undefined || d === null) {
                returnMoment = moment();
            } else if (moment.isDate(d) || moment.isMoment(d)) {
                returnMoment = moment(d);
            } else if (hasTimeZone()) {
                returnMoment = moment.tz(d, parseFormats, options.useStrict, options.timeZone);
            } else {
                returnMoment = moment(d, parseFormats, options.useStrict);
            }
            if (hasTimeZone()) {
                returnMoment.tz(options.timeZone);
            }
            return returnMoment;
        }, isEnabled = function(granularity) {
            if (typeof granularity !== "string" || granularity.length > 1) {
                throw new TypeError("isEnabled expects a single character string parameter");
            }
            switch (granularity) {
              case "y":
                return actualFormat.indexOf("Y") !== -1;

              case "M":
                return actualFormat.indexOf("M") !== -1;

              case "d":
                return actualFormat.toLowerCase().indexOf("d") !== -1;

              case "h":
              case "H":
                return actualFormat.toLowerCase().indexOf("h") !== -1;

              case "m":
                return actualFormat.indexOf("m") !== -1;

              case "s":
                return actualFormat.indexOf("s") !== -1;

              default:
                return false;
            }
        }, hasTime = function() {
            return isEnabled("h") || isEnabled("m") || isEnabled("s");
        }, hasDate = function() {
            return isEnabled("y") || isEnabled("M") || isEnabled("d");
        }, getDatePickerTemplate = function() {
            var headTemplate = $("<thead>").append($("<tr>").append($("<th>").addClass("prev").attr("data-action", "previous").append($("<span>").addClass(options.icons.previous))).append($("<th>").addClass("picker-switch").attr("data-action", "pickerSwitch").attr("colspan", options.calendarWeeks ? "6" : "5")).append($("<th>").addClass("next").attr("data-action", "next").append($("<span>").addClass(options.icons.next)))), contTemplate = $("<tbody>").append($("<tr>").append($("<td>").attr("colspan", options.calendarWeeks ? "8" : "7")));
            return [ $("<div>").addClass("datepicker-days").append($("<table>").addClass("table-condensed").append(headTemplate).append($("<tbody>"))), $("<div>").addClass("datepicker-months").append($("<table>").addClass("table-condensed").append(headTemplate.clone()).append(contTemplate.clone())), $("<div>").addClass("datepicker-years").append($("<table>").addClass("table-condensed").append(headTemplate.clone()).append(contTemplate.clone())), $("<div>").addClass("datepicker-decades").append($("<table>").addClass("table-condensed").append(headTemplate.clone()).append(contTemplate.clone())) ];
        }, getTimePickerMainTemplate = function() {
            var topRow = $("<tr>"), middleRow = $("<tr>"), bottomRow = $("<tr>");
            if (isEnabled("h")) {
                topRow.append($("<td>").append($("<a>").attr({
                    href: "#",
                    tabindex: "-1",
                    title: options.tooltips.incrementHour
                }).addClass("btn").attr("data-action", "incrementHours").append($("<span>").addClass(options.icons.up))));
                middleRow.append($("<td>").append($("<span>").addClass("timepicker-hour").attr({
                    "data-time-component": "hours",
                    title: options.tooltips.pickHour
                }).attr("data-action", "showHours")));
                bottomRow.append($("<td>").append($("<a>").attr({
                    href: "#",
                    tabindex: "-1",
                    title: options.tooltips.decrementHour
                }).addClass("btn").attr("data-action", "decrementHours").append($("<span>").addClass(options.icons.down))));
            }
            if (isEnabled("m")) {
                if (isEnabled("h")) {
                    topRow.append($("<td>").addClass("separator"));
                    middleRow.append($("<td>").addClass("separator").html(":"));
                    bottomRow.append($("<td>").addClass("separator"));
                }
                topRow.append($("<td>").append($("<a>").attr({
                    href: "#",
                    tabindex: "-1",
                    title: options.tooltips.incrementMinute
                }).addClass("btn").attr("data-action", "incrementMinutes").append($("<span>").addClass(options.icons.up))));
                middleRow.append($("<td>").append($("<span>").addClass("timepicker-minute").attr({
                    "data-time-component": "minutes",
                    title: options.tooltips.pickMinute
                }).attr("data-action", "showMinutes")));
                bottomRow.append($("<td>").append($("<a>").attr({
                    href: "#",
                    tabindex: "-1",
                    title: options.tooltips.decrementMinute
                }).addClass("btn").attr("data-action", "decrementMinutes").append($("<span>").addClass(options.icons.down))));
            }
            if (isEnabled("s")) {
                if (isEnabled("m")) {
                    topRow.append($("<td>").addClass("separator"));
                    middleRow.append($("<td>").addClass("separator").html(":"));
                    bottomRow.append($("<td>").addClass("separator"));
                }
                topRow.append($("<td>").append($("<a>").attr({
                    href: "#",
                    tabindex: "-1",
                    title: options.tooltips.incrementSecond
                }).addClass("btn").attr("data-action", "incrementSeconds").append($("<span>").addClass(options.icons.up))));
                middleRow.append($("<td>").append($("<span>").addClass("timepicker-second").attr({
                    "data-time-component": "seconds",
                    title: options.tooltips.pickSecond
                }).attr("data-action", "showSeconds")));
                bottomRow.append($("<td>").append($("<a>").attr({
                    href: "#",
                    tabindex: "-1",
                    title: options.tooltips.decrementSecond
                }).addClass("btn").attr("data-action", "decrementSeconds").append($("<span>").addClass(options.icons.down))));
            }
            if (!use24Hours) {
                topRow.append($("<td>").addClass("separator"));
                middleRow.append($("<td>").append($("<button>").addClass("btn btn-primary").attr({
                    "data-action": "togglePeriod",
                    tabindex: "-1",
                    title: options.tooltips.togglePeriod
                })));
                bottomRow.append($("<td>").addClass("separator"));
            }
            return $("<div>").addClass("timepicker-picker").append($("<table>").addClass("table-condensed").append([ topRow, middleRow, bottomRow ]));
        }, getTimePickerTemplate = function() {
            var hoursView = $("<div>").addClass("timepicker-hours").append($("<table>").addClass("table-condensed")), minutesView = $("<div>").addClass("timepicker-minutes").append($("<table>").addClass("table-condensed")), secondsView = $("<div>").addClass("timepicker-seconds").append($("<table>").addClass("table-condensed")), ret = [ getTimePickerMainTemplate() ];
            if (isEnabled("h")) {
                ret.push(hoursView);
            }
            if (isEnabled("m")) {
                ret.push(minutesView);
            }
            if (isEnabled("s")) {
                ret.push(secondsView);
            }
            return ret;
        }, getToolbar = function() {
            var row = [];
            if (options.showTodayButton) {
                row.push($("<td>").append($("<a>").attr({
                    "data-action": "today",
                    title: options.tooltips.today
                }).append($("<span>").addClass(options.icons.today))));
            }
            if (!options.sideBySide && hasDate() && hasTime()) {
                row.push($("<td>").append($("<a>").attr({
                    "data-action": "togglePicker",
                    title: options.tooltips.selectTime
                }).append($("<span>").addClass(options.icons.time))));
            }
            if (options.showClear) {
                row.push($("<td>").append($("<a>").attr({
                    "data-action": "clear",
                    title: options.tooltips.clear
                }).append($("<span>").addClass(options.icons.clear))));
            }
            if (options.showClose) {
                row.push($("<td>").append($("<a>").attr({
                    "data-action": "close",
                    title: options.tooltips.close
                }).append($("<span>").addClass(options.icons.close))));
            }
            return $("<table>").addClass("table-condensed").append($("<tbody>").append($("<tr>").append(row)));
        }, getTemplate = function() {
            var template = $("<div>").addClass("bootstrap-datetimepicker-widget dropdown-menu"), dateView = $("<div>").addClass("datepicker").append(getDatePickerTemplate()), timeView = $("<div>").addClass("timepicker").append(getTimePickerTemplate()), content = $("<ul>").addClass("list-unstyled"), toolbar = $("<li>").addClass("picker-switch" + (options.collapse ? " accordion-toggle" : "")).append(getToolbar());
            if (options.inline) {
                template.removeClass("dropdown-menu");
            }
            if (use24Hours) {
                template.addClass("usetwentyfour");
            }
            if (isEnabled("s") && !use24Hours) {
                template.addClass("wider");
            }
            if (options.sideBySide && hasDate() && hasTime()) {
                template.addClass("timepicker-sbs");
                if (options.toolbarPlacement === "top") {
                    template.append(toolbar);
                }
                template.append($("<div>").addClass("row").append(dateView.addClass("col-md-6")).append(timeView.addClass("col-md-6")));
                if (options.toolbarPlacement === "bottom") {
                    template.append(toolbar);
                }
                return template;
            }
            if (options.toolbarPlacement === "top") {
                content.append(toolbar);
            }
            if (hasDate()) {
                content.append($("<li>").addClass(options.collapse && hasTime() ? "collapse in" : "").append(dateView));
            }
            if (options.toolbarPlacement === "default") {
                content.append(toolbar);
            }
            if (hasTime()) {
                content.append($("<li>").addClass(options.collapse && hasDate() ? "collapse" : "").append(timeView));
            }
            if (options.toolbarPlacement === "bottom") {
                content.append(toolbar);
            }
            return template.append(content);
        }, dataToOptions = function() {
            var eData, dataOptions = {};
            if (element.is("input") || options.inline) {
                eData = element.data();
            } else {
                eData = element.find("input").data();
            }
            if (eData.dateOptions && eData.dateOptions instanceof Object) {
                dataOptions = $.extend(true, dataOptions, eData.dateOptions);
            }
            $.each(options, function(key) {
                var attributeName = "date" + key.charAt(0).toUpperCase() + key.slice(1);
                if (eData[attributeName] !== undefined) {
                    dataOptions[key] = eData[attributeName];
                }
            });
            return dataOptions;
        }, place = function() {
            var position = (component || element).position(), offset = (component || element).offset(), vertical = options.widgetPositioning.vertical, horizontal = options.widgetPositioning.horizontal, parent;
            if (options.widgetParent) {
                parent = options.widgetParent.append(widget);
            } else if (element.is("input")) {
                parent = element.after(widget).parent();
            } else if (options.inline) {
                parent = element.append(widget);
                return;
            } else {
                parent = element;
                element.children().first().after(widget);
            }
            if (vertical === "auto") {
                if (offset.top + widget.height() * 1.5 >= $(window).height() + $(window).scrollTop() && widget.height() + element.outerHeight() < offset.top) {
                    vertical = "top";
                } else {
                    vertical = "bottom";
                }
            }
            if (horizontal === "auto") {
                if (parent.width() < offset.left + widget.outerWidth() / 2 && offset.left + widget.outerWidth() > $(window).width()) {
                    horizontal = "right";
                } else {
                    horizontal = "left";
                }
            }
            if (vertical === "top") {
                widget.addClass("top").removeClass("bottom");
            } else {
                widget.addClass("bottom").removeClass("top");
            }
            if (horizontal === "right") {
                widget.addClass("pull-right");
            } else {
                widget.removeClass("pull-right");
            }
            if (parent.css("position") === "static") {
                parent = parent.parents().filter(function() {
                    return $(this).css("position") !== "static";
                }).first();
            }
            if (parent.length === 0) {
                throw new Error("datetimepicker component should be placed within a non-static positioned container");
            }
            widget.css({
                top: vertical === "top" ? "auto" : position.top + element.outerHeight(),
                bottom: vertical === "top" ? parent.outerHeight() - (parent === element ? 0 : position.top) : "auto",
                left: horizontal === "left" ? parent === element ? 0 : position.left : "auto",
                right: horizontal === "left" ? "auto" : parent.outerWidth() - element.outerWidth() - (parent === element ? 0 : position.left)
            });
        }, notifyEvent = function(e) {
            if (e.type === "dp.change" && (e.date && e.date.isSame(e.oldDate) || !e.date && !e.oldDate)) {
                return;
            }
            element.trigger(e);
        }, viewUpdate = function(e) {
            if (e === "y") {
                e = "YYYY";
            }
            notifyEvent({
                type: "dp.update",
                change: e,
                viewDate: viewDate.clone()
            });
        }, showMode = function(dir) {
            if (!widget) {
                return;
            }
            if (dir) {
                currentViewMode = Math.max(minViewModeNumber, Math.min(3, currentViewMode + dir));
            }
            widget.find(".datepicker > div").hide().filter(".datepicker-" + datePickerModes[currentViewMode].clsName).show();
        }, fillDow = function() {
            var row = $("<tr>"), currentDate = viewDate.clone().startOf("w").startOf("d");
            if (options.calendarWeeks === true) {
                row.append($("<th>").addClass("cw").text("#"));
            }
            while (currentDate.isBefore(viewDate.clone().endOf("w"))) {
                row.append($("<th>").addClass("dow").text(currentDate.format("dd")));
                currentDate.add(1, "d");
            }
            widget.find(".datepicker-days thead").append(row);
        }, isInDisabledDates = function(testDate) {
            return options.disabledDates[testDate.format("YYYY-MM-DD")] === true;
        }, isInEnabledDates = function(testDate) {
            return options.enabledDates[testDate.format("YYYY-MM-DD")] === true;
        }, isInDisabledHours = function(testDate) {
            return options.disabledHours[testDate.format("H")] === true;
        }, isInEnabledHours = function(testDate) {
            return options.enabledHours[testDate.format("H")] === true;
        }, isValid = function(targetMoment, granularity) {
            if (!targetMoment.isValid()) {
                return false;
            }
            if (options.disabledDates && granularity === "d" && isInDisabledDates(targetMoment)) {
                return false;
            }
            if (options.enabledDates && granularity === "d" && !isInEnabledDates(targetMoment)) {
                return false;
            }
            if (options.minDate && targetMoment.isBefore(options.minDate, granularity)) {
                return false;
            }
            if (options.maxDate && targetMoment.isAfter(options.maxDate, granularity)) {
                return false;
            }
            if (options.daysOfWeekDisabled && granularity === "d" && options.daysOfWeekDisabled.indexOf(targetMoment.day()) !== -1) {
                return false;
            }
            if (options.disabledHours && (granularity === "h" || granularity === "m" || granularity === "s") && isInDisabledHours(targetMoment)) {
                return false;
            }
            if (options.enabledHours && (granularity === "h" || granularity === "m" || granularity === "s") && !isInEnabledHours(targetMoment)) {
                return false;
            }
            if (options.disabledTimeIntervals && (granularity === "h" || granularity === "m" || granularity === "s")) {
                var found = false;
                $.each(options.disabledTimeIntervals, function() {
                    if (targetMoment.isBetween(this[0], this[1])) {
                        found = true;
                        return false;
                    }
                });
                if (found) {
                    return false;
                }
            }
            return true;
        }, fillMonths = function() {
            var spans = [], monthsShort = viewDate.clone().startOf("y").startOf("d");
            while (monthsShort.isSame(viewDate, "y")) {
                spans.push($("<span>").attr("data-action", "selectMonth").addClass("month").text(monthsShort.format("MMM")));
                monthsShort.add(1, "M");
            }
            widget.find(".datepicker-months td").empty().append(spans);
        }, updateMonths = function() {
            var monthsView = widget.find(".datepicker-months"), monthsViewHeader = monthsView.find("th"), months = monthsView.find("tbody").find("span");
            monthsViewHeader.eq(0).find("span").attr("title", options.tooltips.prevYear);
            monthsViewHeader.eq(1).attr("title", options.tooltips.selectYear);
            monthsViewHeader.eq(2).find("span").attr("title", options.tooltips.nextYear);
            monthsView.find(".disabled").removeClass("disabled");
            if (!isValid(viewDate.clone().subtract(1, "y"), "y")) {
                monthsViewHeader.eq(0).addClass("disabled");
            }
            monthsViewHeader.eq(1).text(viewDate.year());
            if (!isValid(viewDate.clone().add(1, "y"), "y")) {
                monthsViewHeader.eq(2).addClass("disabled");
            }
            months.removeClass("active");
            if (date.isSame(viewDate, "y") && !unset) {
                months.eq(date.month()).addClass("active");
            }
            months.each(function(index) {
                if (!isValid(viewDate.clone().month(index), "M")) {
                    $(this).addClass("disabled");
                }
            });
        }, updateYears = function() {
            var yearsView = widget.find(".datepicker-years"), yearsViewHeader = yearsView.find("th"), startYear = viewDate.clone().subtract(5, "y"), endYear = viewDate.clone().add(6, "y"), html = "";
            yearsViewHeader.eq(0).find("span").attr("title", options.tooltips.prevDecade);
            yearsViewHeader.eq(1).attr("title", options.tooltips.selectDecade);
            yearsViewHeader.eq(2).find("span").attr("title", options.tooltips.nextDecade);
            yearsView.find(".disabled").removeClass("disabled");
            if (options.minDate && options.minDate.isAfter(startYear, "y")) {
                yearsViewHeader.eq(0).addClass("disabled");
            }
            yearsViewHeader.eq(1).text(startYear.year() + "-" + endYear.year());
            if (options.maxDate && options.maxDate.isBefore(endYear, "y")) {
                yearsViewHeader.eq(2).addClass("disabled");
            }
            while (!startYear.isAfter(endYear, "y")) {
                html += '<span data-action="selectYear" class="year' + (startYear.isSame(date, "y") && !unset ? " active" : "") + (!isValid(startYear, "y") ? " disabled" : "") + '">' + startYear.year() + "</span>";
                startYear.add(1, "y");
            }
            yearsView.find("td").html(html);
        }, updateDecades = function() {
            var decadesView = widget.find(".datepicker-decades"), decadesViewHeader = decadesView.find("th"), startDecade = moment({
                y: viewDate.year() - viewDate.year() % 100 - 1
            }), endDecade = startDecade.clone().add(100, "y"), startedAt = startDecade.clone(), minDateDecade = false, maxDateDecade = false, endDecadeYear, html = "";
            decadesViewHeader.eq(0).find("span").attr("title", options.tooltips.prevCentury);
            decadesViewHeader.eq(2).find("span").attr("title", options.tooltips.nextCentury);
            decadesView.find(".disabled").removeClass("disabled");
            if (startDecade.isSame(moment({
                y: 1900
            })) || options.minDate && options.minDate.isAfter(startDecade, "y")) {
                decadesViewHeader.eq(0).addClass("disabled");
            }
            decadesViewHeader.eq(1).text(startDecade.year() + "-" + endDecade.year());
            if (startDecade.isSame(moment({
                y: 2e3
            })) || options.maxDate && options.maxDate.isBefore(endDecade, "y")) {
                decadesViewHeader.eq(2).addClass("disabled");
            }
            while (!startDecade.isAfter(endDecade, "y")) {
                endDecadeYear = startDecade.year() + 12;
                minDateDecade = options.minDate && options.minDate.isAfter(startDecade, "y") && options.minDate.year() <= endDecadeYear;
                maxDateDecade = options.maxDate && options.maxDate.isAfter(startDecade, "y") && options.maxDate.year() <= endDecadeYear;
                html += '<span data-action="selectDecade" class="decade' + (date.isAfter(startDecade) && date.year() <= endDecadeYear ? " active" : "") + (!isValid(startDecade, "y") && !minDateDecade && !maxDateDecade ? " disabled" : "") + '" data-selection="' + (startDecade.year() + 6) + '">' + (startDecade.year() + 1) + " - " + (startDecade.year() + 12) + "</span>";
                startDecade.add(12, "y");
            }
            html += "<span></span><span></span><span></span>";
            decadesView.find("td").html(html);
            decadesViewHeader.eq(1).text(startedAt.year() + 1 + "-" + startDecade.year());
        }, fillDate = function() {
            var daysView = widget.find(".datepicker-days"), daysViewHeader = daysView.find("th"), currentDate, html = [], row, clsNames = [], i;
            if (!hasDate()) {
                return;
            }
            daysViewHeader.eq(0).find("span").attr("title", options.tooltips.prevMonth);
            daysViewHeader.eq(1).attr("title", options.tooltips.selectMonth);
            daysViewHeader.eq(2).find("span").attr("title", options.tooltips.nextMonth);
            daysView.find(".disabled").removeClass("disabled");
            daysViewHeader.eq(1).text(viewDate.format(options.dayViewHeaderFormat));
            if (!isValid(viewDate.clone().subtract(1, "M"), "M")) {
                daysViewHeader.eq(0).addClass("disabled");
            }
            if (!isValid(viewDate.clone().add(1, "M"), "M")) {
                daysViewHeader.eq(2).addClass("disabled");
            }
            currentDate = viewDate.clone().startOf("M").startOf("w").startOf("d");
            for (i = 0; i < 42; i++) {
                if (currentDate.weekday() === 0) {
                    row = $("<tr>");
                    if (options.calendarWeeks) {
                        row.append('<td class="cw">' + currentDate.week() + "</td>");
                    }
                    html.push(row);
                }
                clsNames = [ "day" ];
                if (currentDate.isBefore(viewDate, "M")) {
                    clsNames.push("old");
                }
                if (currentDate.isAfter(viewDate, "M")) {
                    clsNames.push("new");
                }
                if (currentDate.isSame(date, "d") && !unset) {
                    clsNames.push("active");
                }
                if (!isValid(currentDate, "d")) {
                    clsNames.push("disabled");
                }
                if (currentDate.isSame(getMoment(), "d")) {
                    clsNames.push("today");
                }
                if (currentDate.day() === 0 || currentDate.day() === 6) {
                    clsNames.push("weekend");
                }
                notifyEvent({
                    type: "dp.classify",
                    date: currentDate,
                    classNames: clsNames
                });
                row.append('<td data-action="selectDay" data-day="' + currentDate.format("L") + '" class="' + clsNames.join(" ") + '">' + currentDate.date() + "</td>");
                currentDate.add(1, "d");
            }
            daysView.find("tbody").empty().append(html);
            updateMonths();
            updateYears();
            updateDecades();
        }, fillHours = function() {
            var table = widget.find(".timepicker-hours table"), currentHour = viewDate.clone().startOf("d"), html = [], row = $("<tr>");
            if (viewDate.hour() > 11 && !use24Hours) {
                currentHour.hour(12);
            }
            while (currentHour.isSame(viewDate, "d") && (use24Hours || viewDate.hour() < 12 && currentHour.hour() < 12 || viewDate.hour() > 11)) {
                if (currentHour.hour() % 4 === 0) {
                    row = $("<tr>");
                    html.push(row);
                }
                row.append('<td data-action="selectHour" class="hour' + (!isValid(currentHour, "h") ? " disabled" : "") + '">' + currentHour.format(use24Hours ? "HH" : "hh") + "</td>");
                currentHour.add(1, "h");
            }
            table.empty().append(html);
        }, fillMinutes = function() {
            var table = widget.find(".timepicker-minutes table"), currentMinute = viewDate.clone().startOf("h"), html = [], row = $("<tr>"), step = options.stepping === 1 ? 5 : options.stepping;
            while (viewDate.isSame(currentMinute, "h")) {
                if (currentMinute.minute() % (step * 4) === 0) {
                    row = $("<tr>");
                    html.push(row);
                }
                row.append('<td data-action="selectMinute" class="minute' + (!isValid(currentMinute, "m") ? " disabled" : "") + '">' + currentMinute.format("mm") + "</td>");
                currentMinute.add(step, "m");
            }
            table.empty().append(html);
        }, fillSeconds = function() {
            var table = widget.find(".timepicker-seconds table"), currentSecond = viewDate.clone().startOf("m"), html = [], row = $("<tr>");
            while (viewDate.isSame(currentSecond, "m")) {
                if (currentSecond.second() % 20 === 0) {
                    row = $("<tr>");
                    html.push(row);
                }
                row.append('<td data-action="selectSecond" class="second' + (!isValid(currentSecond, "s") ? " disabled" : "") + '">' + currentSecond.format("ss") + "</td>");
                currentSecond.add(5, "s");
            }
            table.empty().append(html);
        }, fillTime = function() {
            var toggle, newDate, timeComponents = widget.find(".timepicker span[data-time-component]");
            if (!use24Hours) {
                toggle = widget.find(".timepicker [data-action=togglePeriod]");
                newDate = date.clone().add(date.hours() >= 12 ? -12 : 12, "h");
                toggle.text(date.format("A"));
                if (isValid(newDate, "h")) {
                    toggle.removeClass("disabled");
                } else {
                    toggle.addClass("disabled");
                }
            }
            timeComponents.filter("[data-time-component=hours]").text(date.format(use24Hours ? "HH" : "hh"));
            timeComponents.filter("[data-time-component=minutes]").text(date.format("mm"));
            timeComponents.filter("[data-time-component=seconds]").text(date.format("ss"));
            fillHours();
            fillMinutes();
            fillSeconds();
        }, update = function() {
            if (!widget) {
                return;
            }
            fillDate();
            fillTime();
        }, setValue = function(targetMoment) {
            var oldDate = unset ? null : date;
            if (!targetMoment) {
                unset = true;
                input.val("");
                element.data("date", "");
                notifyEvent({
                    type: "dp.change",
                    date: false,
                    oldDate: oldDate
                });
                update();
                return;
            }
            targetMoment = targetMoment.clone().locale(options.locale);
            if (hasTimeZone()) {
                targetMoment.tz(options.timeZone);
            }
            if (options.stepping !== 1) {
                targetMoment.minutes(Math.round(targetMoment.minutes() / options.stepping) * options.stepping).seconds(0);
                while (options.minDate && targetMoment.isBefore(options.minDate)) {
                    targetMoment.add(options.stepping, "minutes");
                }
            }
            if (isValid(targetMoment)) {
                date = targetMoment;
                viewDate = date.clone();
                input.val(date.format(actualFormat));
                element.data("date", date.format(actualFormat));
                unset = false;
                update();
                notifyEvent({
                    type: "dp.change",
                    date: date.clone(),
                    oldDate: oldDate
                });
            } else {
                if (!options.keepInvalid) {
                    input.val(unset ? "" : date.format(actualFormat));
                } else {
                    notifyEvent({
                        type: "dp.change",
                        date: targetMoment,
                        oldDate: oldDate
                    });
                }
                notifyEvent({
                    type: "dp.error",
                    date: targetMoment,
                    oldDate: oldDate
                });
            }
        }, hide = function() {
            var transitioning = false;
            if (!widget) {
                return picker;
            }
            widget.find(".collapse").each(function() {
                var collapseData = $(this).data("collapse");
                if (collapseData && collapseData.transitioning) {
                    transitioning = true;
                    return false;
                }
                return true;
            });
            if (transitioning) {
                return picker;
            }
            if (component && component.hasClass("btn")) {
                component.toggleClass("active");
            }
            widget.hide();
            $(window).off("resize", place);
            widget.off("click", "[data-action]");
            widget.off("mousedown", false);
            widget.remove();
            widget = false;
            notifyEvent({
                type: "dp.hide",
                date: date.clone()
            });
            input.blur();
            currentViewMode = 0;
            viewDate = date.clone();
            return picker;
        }, clear = function() {
            setValue(null);
        }, parseInputDate = function(inputDate) {
            if (options.parseInputDate === undefined) {
                if (!moment.isMoment(inputDate) || inputDate instanceof Date) {
                    inputDate = getMoment(inputDate);
                }
            } else {
                inputDate = options.parseInputDate(inputDate);
            }
            return inputDate;
        }, actions = {
            next: function() {
                var navFnc = datePickerModes[currentViewMode].navFnc;
                viewDate.add(datePickerModes[currentViewMode].navStep, navFnc);
                fillDate();
                viewUpdate(navFnc);
            },
            previous: function() {
                var navFnc = datePickerModes[currentViewMode].navFnc;
                viewDate.subtract(datePickerModes[currentViewMode].navStep, navFnc);
                fillDate();
                viewUpdate(navFnc);
            },
            pickerSwitch: function() {
                showMode(1);
            },
            selectMonth: function(e) {
                var month = $(e.target).closest("tbody").find("span").index($(e.target));
                viewDate.month(month);
                if (currentViewMode === minViewModeNumber) {
                    setValue(date.clone().year(viewDate.year()).month(viewDate.month()));
                    if (!options.inline) {
                        hide();
                    }
                } else {
                    showMode(-1);
                    fillDate();
                }
                viewUpdate("M");
            },
            selectYear: function(e) {
                var year = parseInt($(e.target).text(), 10) || 0;
                viewDate.year(year);
                if (currentViewMode === minViewModeNumber) {
                    setValue(date.clone().year(viewDate.year()));
                    if (!options.inline) {
                        hide();
                    }
                } else {
                    showMode(-1);
                    fillDate();
                }
                viewUpdate("YYYY");
            },
            selectDecade: function(e) {
                var year = parseInt($(e.target).data("selection"), 10) || 0;
                viewDate.year(year);
                if (currentViewMode === minViewModeNumber) {
                    setValue(date.clone().year(viewDate.year()));
                    if (!options.inline) {
                        hide();
                    }
                } else {
                    showMode(-1);
                    fillDate();
                }
                viewUpdate("YYYY");
            },
            selectDay: function(e) {
                var day = viewDate.clone();
                if ($(e.target).is(".old")) {
                    day.subtract(1, "M");
                }
                if ($(e.target).is(".new")) {
                    day.add(1, "M");
                }
                setValue(day.date(parseInt($(e.target).text(), 10)));
                if (!hasTime() && !options.keepOpen && !options.inline) {
                    hide();
                }
            },
            incrementHours: function() {
                var newDate = date.clone().add(1, "h");
                if (isValid(newDate, "h")) {
                    setValue(newDate);
                }
            },
            incrementMinutes: function() {
                var newDate = date.clone().add(options.stepping, "m");
                if (isValid(newDate, "m")) {
                    setValue(newDate);
                }
            },
            incrementSeconds: function() {
                var newDate = date.clone().add(1, "s");
                if (isValid(newDate, "s")) {
                    setValue(newDate);
                }
            },
            decrementHours: function() {
                var newDate = date.clone().subtract(1, "h");
                if (isValid(newDate, "h")) {
                    setValue(newDate);
                }
            },
            decrementMinutes: function() {
                var newDate = date.clone().subtract(options.stepping, "m");
                if (isValid(newDate, "m")) {
                    setValue(newDate);
                }
            },
            decrementSeconds: function() {
                var newDate = date.clone().subtract(1, "s");
                if (isValid(newDate, "s")) {
                    setValue(newDate);
                }
            },
            togglePeriod: function() {
                setValue(date.clone().add(date.hours() >= 12 ? -12 : 12, "h"));
            },
            togglePicker: function(e) {
                var $this = $(e.target), $parent = $this.closest("ul"), expanded = $parent.find(".in"), closed = $parent.find(".collapse:not(.in)"), collapseData;
                if (expanded && expanded.length) {
                    collapseData = expanded.data("collapse");
                    if (collapseData && collapseData.transitioning) {
                        return;
                    }
                    if (expanded.collapse) {
                        expanded.collapse("hide");
                        closed.collapse("show");
                    } else {
                        expanded.removeClass("in");
                        closed.addClass("in");
                    }
                    if ($this.is("span")) {
                        $this.toggleClass(options.icons.time + " " + options.icons.date);
                    } else {
                        $this.find("span").toggleClass(options.icons.time + " " + options.icons.date);
                    }
                }
            },
            showPicker: function() {
                widget.find(".timepicker > div:not(.timepicker-picker)").hide();
                widget.find(".timepicker .timepicker-picker").show();
            },
            showHours: function() {
                widget.find(".timepicker .timepicker-picker").hide();
                widget.find(".timepicker .timepicker-hours").show();
            },
            showMinutes: function() {
                widget.find(".timepicker .timepicker-picker").hide();
                widget.find(".timepicker .timepicker-minutes").show();
            },
            showSeconds: function() {
                widget.find(".timepicker .timepicker-picker").hide();
                widget.find(".timepicker .timepicker-seconds").show();
            },
            selectHour: function(e) {
                var hour = parseInt($(e.target).text(), 10);
                if (!use24Hours) {
                    if (date.hours() >= 12) {
                        if (hour !== 12) {
                            hour += 12;
                        }
                    } else {
                        if (hour === 12) {
                            hour = 0;
                        }
                    }
                }
                setValue(date.clone().hours(hour));
                actions.showPicker.call(picker);
            },
            selectMinute: function(e) {
                setValue(date.clone().minutes(parseInt($(e.target).text(), 10)));
                actions.showPicker.call(picker);
            },
            selectSecond: function(e) {
                setValue(date.clone().seconds(parseInt($(e.target).text(), 10)));
                actions.showPicker.call(picker);
            },
            clear: clear,
            today: function() {
                var todaysDate = getMoment();
                if (isValid(todaysDate, "d")) {
                    setValue(todaysDate);
                }
            },
            close: hide
        }, doAction = function(e) {
            if ($(e.currentTarget).is(".disabled")) {
                return false;
            }
            actions[$(e.currentTarget).data("action")].apply(picker, arguments);
            return false;
        }, show = function() {
            var currentMoment, useCurrentGranularity = {
                year: function(m) {
                    return m.month(0).date(1).hours(0).seconds(0).minutes(0);
                },
                month: function(m) {
                    return m.date(1).hours(0).seconds(0).minutes(0);
                },
                day: function(m) {
                    return m.hours(0).seconds(0).minutes(0);
                },
                hour: function(m) {
                    return m.seconds(0).minutes(0);
                },
                minute: function(m) {
                    return m.seconds(0);
                }
            };
            if (input.prop("disabled") || !options.ignoreReadonly && input.prop("readonly") || widget) {
                return picker;
            }
            if (input.val() !== undefined && input.val().trim().length !== 0) {
                setValue(parseInputDate(input.val().trim()));
            } else if (unset && options.useCurrent && (options.inline || input.is("input") && input.val().trim().length === 0)) {
                currentMoment = getMoment();
                if (typeof options.useCurrent === "string") {
                    currentMoment = useCurrentGranularity[options.useCurrent](currentMoment);
                }
                setValue(currentMoment);
            }
            widget = getTemplate();
            fillDow();
            fillMonths();
            widget.find(".timepicker-hours").hide();
            widget.find(".timepicker-minutes").hide();
            widget.find(".timepicker-seconds").hide();
            update();
            showMode();
            $(window).on("resize", place);
            widget.on("click", "[data-action]", doAction);
            widget.on("mousedown", false);
            if (component && component.hasClass("btn")) {
                component.toggleClass("active");
            }
            place();
            widget.show();
            if (options.focusOnShow && !input.is(":focus")) {
                input.focus();
            }
            notifyEvent({
                type: "dp.show"
            });
            return picker;
        }, toggle = function() {
            return widget ? hide() : show();
        }, keydown = function(e) {
            var handler = null, index, index2, pressedKeys = [], pressedModifiers = {}, currentKey = e.which, keyBindKeys, allModifiersPressed, pressed = "p";
            keyState[currentKey] = pressed;
            for (index in keyState) {
                if (keyState.hasOwnProperty(index) && keyState[index] === pressed) {
                    pressedKeys.push(index);
                    if (parseInt(index, 10) !== currentKey) {
                        pressedModifiers[index] = true;
                    }
                }
            }
            for (index in options.keyBinds) {
                if (options.keyBinds.hasOwnProperty(index) && typeof options.keyBinds[index] === "function") {
                    keyBindKeys = index.split(" ");
                    if (keyBindKeys.length === pressedKeys.length && keyMap[currentKey] === keyBindKeys[keyBindKeys.length - 1]) {
                        allModifiersPressed = true;
                        for (index2 = keyBindKeys.length - 2; index2 >= 0; index2--) {
                            if (!(keyMap[keyBindKeys[index2]] in pressedModifiers)) {
                                allModifiersPressed = false;
                                break;
                            }
                        }
                        if (allModifiersPressed) {
                            handler = options.keyBinds[index];
                            break;
                        }
                    }
                }
            }
            if (handler) {
                handler.call(picker, widget);
                e.stopPropagation();
                e.preventDefault();
            }
        }, keyup = function(e) {
            keyState[e.which] = "r";
            e.stopPropagation();
            e.preventDefault();
        }, change = function(e) {
            var val = $(e.target).val().trim(), parsedDate = val ? parseInputDate(val) : null;
            setValue(parsedDate);
            e.stopImmediatePropagation();
            return false;
        }, attachDatePickerElementEvents = function() {
            input.on({
                change: change,
                blur: options.debug ? "" : hide,
                keydown: keydown,
                keyup: keyup,
                focus: options.allowInputToggle ? show : ""
            });
            if (element.is("input")) {
                input.on({
                    focus: show
                });
            } else if (component) {
                component.on("click", toggle);
                component.on("mousedown", false);
            }
        }, detachDatePickerElementEvents = function() {
            input.off({
                change: change,
                blur: blur,
                keydown: keydown,
                keyup: keyup,
                focus: options.allowInputToggle ? hide : ""
            });
            if (element.is("input")) {
                input.off({
                    focus: show
                });
            } else if (component) {
                component.off("click", toggle);
                component.off("mousedown", false);
            }
        }, indexGivenDates = function(givenDatesArray) {
            var givenDatesIndexed = {};
            $.each(givenDatesArray, function() {
                var dDate = parseInputDate(this);
                if (dDate.isValid()) {
                    givenDatesIndexed[dDate.format("YYYY-MM-DD")] = true;
                }
            });
            return Object.keys(givenDatesIndexed).length ? givenDatesIndexed : false;
        }, indexGivenHours = function(givenHoursArray) {
            var givenHoursIndexed = {};
            $.each(givenHoursArray, function() {
                givenHoursIndexed[this] = true;
            });
            return Object.keys(givenHoursIndexed).length ? givenHoursIndexed : false;
        }, initFormatting = function() {
            var format = options.format || "L LT";
            actualFormat = format.replace(/(\[[^\[]*\])|(\\)?(LTS|LT|LL?L?L?|l{1,4})/g, function(formatInput) {
                var newinput = date.localeData().longDateFormat(formatInput) || formatInput;
                return newinput.replace(/(\[[^\[]*\])|(\\)?(LTS|LT|LL?L?L?|l{1,4})/g, function(formatInput2) {
                    return date.localeData().longDateFormat(formatInput2) || formatInput2;
                });
            });
            parseFormats = options.extraFormats ? options.extraFormats.slice() : [];
            if (parseFormats.indexOf(format) < 0 && parseFormats.indexOf(actualFormat) < 0) {
                parseFormats.push(actualFormat);
            }
            use24Hours = actualFormat.toLowerCase().indexOf("a") < 1 && actualFormat.replace(/\[.*?\]/g, "").indexOf("h") < 1;
            if (isEnabled("y")) {
                minViewModeNumber = 2;
            }
            if (isEnabled("M")) {
                minViewModeNumber = 1;
            }
            if (isEnabled("d")) {
                minViewModeNumber = 0;
            }
            currentViewMode = Math.max(minViewModeNumber, currentViewMode);
            if (!unset) {
                setValue(date);
            }
        };
        picker.destroy = function() {
            hide();
            detachDatePickerElementEvents();
            element.removeData("DateTimePicker");
            element.removeData("date");
        };
        picker.toggle = toggle;
        picker.show = show;
        picker.hide = hide;
        picker.disable = function() {
            hide();
            if (component && component.hasClass("btn")) {
                component.addClass("disabled");
            }
            input.prop("disabled", true);
            return picker;
        };
        picker.enable = function() {
            if (component && component.hasClass("btn")) {
                component.removeClass("disabled");
            }
            input.prop("disabled", false);
            return picker;
        };
        picker.ignoreReadonly = function(ignoreReadonly) {
            if (arguments.length === 0) {
                return options.ignoreReadonly;
            }
            if (typeof ignoreReadonly !== "boolean") {
                throw new TypeError("ignoreReadonly () expects a boolean parameter");
            }
            options.ignoreReadonly = ignoreReadonly;
            return picker;
        };
        picker.options = function(newOptions) {
            if (arguments.length === 0) {
                return $.extend(true, {}, options);
            }
            if (!(newOptions instanceof Object)) {
                throw new TypeError("options() options parameter should be an object");
            }
            $.extend(true, options, newOptions);
            $.each(options, function(key, value) {
                if (picker[key] !== undefined) {
                    picker[key](value);
                } else {
                    throw new TypeError("option " + key + " is not recognized!");
                }
            });
            return picker;
        };
        picker.date = function(newDate) {
            if (arguments.length === 0) {
                if (unset) {
                    return null;
                }
                return date.clone();
            }
            if (newDate !== null && typeof newDate !== "string" && !moment.isMoment(newDate) && !(newDate instanceof Date)) {
                throw new TypeError("date() parameter must be one of [null, string, moment or Date]");
            }
            setValue(newDate === null ? null : parseInputDate(newDate));
            return picker;
        };
        picker.format = function(newFormat) {
            if (arguments.length === 0) {
                return options.format;
            }
            if (typeof newFormat !== "string" && (typeof newFormat !== "boolean" || newFormat !== false)) {
                throw new TypeError("format() expects a string or boolean:false parameter " + newFormat);
            }
            options.format = newFormat;
            if (actualFormat) {
                initFormatting();
            }
            return picker;
        };
        picker.timeZone = function(newZone) {
            if (arguments.length === 0) {
                return options.timeZone;
            }
            if (typeof newZone !== "string") {
                throw new TypeError("newZone() expects a string parameter");
            }
            options.timeZone = newZone;
            return picker;
        };
        picker.dayViewHeaderFormat = function(newFormat) {
            if (arguments.length === 0) {
                return options.dayViewHeaderFormat;
            }
            if (typeof newFormat !== "string") {
                throw new TypeError("dayViewHeaderFormat() expects a string parameter");
            }
            options.dayViewHeaderFormat = newFormat;
            return picker;
        };
        picker.extraFormats = function(formats) {
            if (arguments.length === 0) {
                return options.extraFormats;
            }
            if (formats !== false && !(formats instanceof Array)) {
                throw new TypeError("extraFormats() expects an array or false parameter");
            }
            options.extraFormats = formats;
            if (parseFormats) {
                initFormatting();
            }
            return picker;
        };
        picker.disabledDates = function(dates) {
            if (arguments.length === 0) {
                return options.disabledDates ? $.extend({}, options.disabledDates) : options.disabledDates;
            }
            if (!dates) {
                options.disabledDates = false;
                update();
                return picker;
            }
            if (!(dates instanceof Array)) {
                throw new TypeError("disabledDates() expects an array parameter");
            }
            options.disabledDates = indexGivenDates(dates);
            options.enabledDates = false;
            update();
            return picker;
        };
        picker.enabledDates = function(dates) {
            if (arguments.length === 0) {
                return options.enabledDates ? $.extend({}, options.enabledDates) : options.enabledDates;
            }
            if (!dates) {
                options.enabledDates = false;
                update();
                return picker;
            }
            if (!(dates instanceof Array)) {
                throw new TypeError("enabledDates() expects an array parameter");
            }
            options.enabledDates = indexGivenDates(dates);
            options.disabledDates = false;
            update();
            return picker;
        };
        picker.daysOfWeekDisabled = function(daysOfWeekDisabled) {
            if (arguments.length === 0) {
                return options.daysOfWeekDisabled.splice(0);
            }
            if (typeof daysOfWeekDisabled === "boolean" && !daysOfWeekDisabled) {
                options.daysOfWeekDisabled = false;
                update();
                return picker;
            }
            if (!(daysOfWeekDisabled instanceof Array)) {
                throw new TypeError("daysOfWeekDisabled() expects an array parameter");
            }
            options.daysOfWeekDisabled = daysOfWeekDisabled.reduce(function(previousValue, currentValue) {
                currentValue = parseInt(currentValue, 10);
                if (currentValue > 6 || currentValue < 0 || isNaN(currentValue)) {
                    return previousValue;
                }
                if (previousValue.indexOf(currentValue) === -1) {
                    previousValue.push(currentValue);
                }
                return previousValue;
            }, []).sort();
            if (options.useCurrent && !options.keepInvalid) {
                var tries = 0;
                while (!isValid(date, "d")) {
                    date.add(1, "d");
                    if (tries === 31) {
                        throw "Tried 31 times to find a valid date";
                    }
                    tries++;
                }
                setValue(date);
            }
            update();
            return picker;
        };
        picker.maxDate = function(maxDate) {
            if (arguments.length === 0) {
                return options.maxDate ? options.maxDate.clone() : options.maxDate;
            }
            if (typeof maxDate === "boolean" && maxDate === false) {
                options.maxDate = false;
                update();
                return picker;
            }
            if (typeof maxDate === "string") {
                if (maxDate === "now" || maxDate === "moment") {
                    maxDate = getMoment();
                }
            }
            var parsedDate = parseInputDate(maxDate);
            if (!parsedDate.isValid()) {
                throw new TypeError("maxDate() Could not parse date parameter: " + maxDate);
            }
            if (options.minDate && parsedDate.isBefore(options.minDate)) {
                throw new TypeError("maxDate() date parameter is before options.minDate: " + parsedDate.format(actualFormat));
            }
            options.maxDate = parsedDate;
            if (options.useCurrent && !options.keepInvalid && date.isAfter(maxDate)) {
                setValue(options.maxDate);
            }
            if (viewDate.isAfter(parsedDate)) {
                viewDate = parsedDate.clone().subtract(options.stepping, "m");
            }
            update();
            return picker;
        };
        picker.minDate = function(minDate) {
            if (arguments.length === 0) {
                return options.minDate ? options.minDate.clone() : options.minDate;
            }
            if (typeof minDate === "boolean" && minDate === false) {
                options.minDate = false;
                update();
                return picker;
            }
            if (typeof minDate === "string") {
                if (minDate === "now" || minDate === "moment") {
                    minDate = getMoment();
                }
            }
            var parsedDate = parseInputDate(minDate);
            if (!parsedDate.isValid()) {
                throw new TypeError("minDate() Could not parse date parameter: " + minDate);
            }
            if (options.maxDate && parsedDate.isAfter(options.maxDate)) {
                throw new TypeError("minDate() date parameter is after options.maxDate: " + parsedDate.format(actualFormat));
            }
            options.minDate = parsedDate;
            if (options.useCurrent && !options.keepInvalid && date.isBefore(minDate)) {
                setValue(options.minDate);
            }
            if (viewDate.isBefore(parsedDate)) {
                viewDate = parsedDate.clone().add(options.stepping, "m");
            }
            update();
            return picker;
        };
        picker.defaultDate = function(defaultDate) {
            if (arguments.length === 0) {
                return options.defaultDate ? options.defaultDate.clone() : options.defaultDate;
            }
            if (!defaultDate) {
                options.defaultDate = false;
                return picker;
            }
            if (typeof defaultDate === "string") {
                if (defaultDate === "now" || defaultDate === "moment") {
                    defaultDate = getMoment();
                } else {
                    defaultDate = getMoment(defaultDate);
                }
            }
            var parsedDate = parseInputDate(defaultDate);
            if (!parsedDate.isValid()) {
                throw new TypeError("defaultDate() Could not parse date parameter: " + defaultDate);
            }
            if (!isValid(parsedDate)) {
                throw new TypeError("defaultDate() date passed is invalid according to component setup validations");
            }
            options.defaultDate = parsedDate;
            if (options.defaultDate && options.inline || input.val().trim() === "") {
                setValue(options.defaultDate);
            }
            return picker;
        };
        picker.locale = function(locale) {
            if (arguments.length === 0) {
                return options.locale;
            }
            if (!moment.localeData(locale)) {
                throw new TypeError("locale() locale " + locale + " is not loaded from moment locales!");
            }
            options.locale = locale;
            date.locale(options.locale);
            viewDate.locale(options.locale);
            if (actualFormat) {
                initFormatting();
            }
            if (widget) {
                hide();
                show();
            }
            return picker;
        };
        picker.stepping = function(stepping) {
            if (arguments.length === 0) {
                return options.stepping;
            }
            stepping = parseInt(stepping, 10);
            if (isNaN(stepping) || stepping < 1) {
                stepping = 1;
            }
            options.stepping = stepping;
            return picker;
        };
        picker.useCurrent = function(useCurrent) {
            var useCurrentOptions = [ "year", "month", "day", "hour", "minute" ];
            if (arguments.length === 0) {
                return options.useCurrent;
            }
            if (typeof useCurrent !== "boolean" && typeof useCurrent !== "string") {
                throw new TypeError("useCurrent() expects a boolean or string parameter");
            }
            if (typeof useCurrent === "string" && useCurrentOptions.indexOf(useCurrent.toLowerCase()) === -1) {
                throw new TypeError("useCurrent() expects a string parameter of " + useCurrentOptions.join(", "));
            }
            options.useCurrent = useCurrent;
            return picker;
        };
        picker.collapse = function(collapse) {
            if (arguments.length === 0) {
                return options.collapse;
            }
            if (typeof collapse !== "boolean") {
                throw new TypeError("collapse() expects a boolean parameter");
            }
            if (options.collapse === collapse) {
                return picker;
            }
            options.collapse = collapse;
            if (widget) {
                hide();
                show();
            }
            return picker;
        };
        picker.icons = function(icons) {
            if (arguments.length === 0) {
                return $.extend({}, options.icons);
            }
            if (!(icons instanceof Object)) {
                throw new TypeError("icons() expects parameter to be an Object");
            }
            $.extend(options.icons, icons);
            if (widget) {
                hide();
                show();
            }
            return picker;
        };
        picker.tooltips = function(tooltips) {
            if (arguments.length === 0) {
                return $.extend({}, options.tooltips);
            }
            if (!(tooltips instanceof Object)) {
                throw new TypeError("tooltips() expects parameter to be an Object");
            }
            $.extend(options.tooltips, tooltips);
            if (widget) {
                hide();
                show();
            }
            return picker;
        };
        picker.useStrict = function(useStrict) {
            if (arguments.length === 0) {
                return options.useStrict;
            }
            if (typeof useStrict !== "boolean") {
                throw new TypeError("useStrict() expects a boolean parameter");
            }
            options.useStrict = useStrict;
            return picker;
        };
        picker.sideBySide = function(sideBySide) {
            if (arguments.length === 0) {
                return options.sideBySide;
            }
            if (typeof sideBySide !== "boolean") {
                throw new TypeError("sideBySide() expects a boolean parameter");
            }
            options.sideBySide = sideBySide;
            if (widget) {
                hide();
                show();
            }
            return picker;
        };
        picker.viewMode = function(viewMode) {
            if (arguments.length === 0) {
                return options.viewMode;
            }
            if (typeof viewMode !== "string") {
                throw new TypeError("viewMode() expects a string parameter");
            }
            if (viewModes.indexOf(viewMode) === -1) {
                throw new TypeError("viewMode() parameter must be one of (" + viewModes.join(", ") + ") value");
            }
            options.viewMode = viewMode;
            currentViewMode = Math.max(viewModes.indexOf(viewMode), minViewModeNumber);
            showMode();
            return picker;
        };
        picker.toolbarPlacement = function(toolbarPlacement) {
            if (arguments.length === 0) {
                return options.toolbarPlacement;
            }
            if (typeof toolbarPlacement !== "string") {
                throw new TypeError("toolbarPlacement() expects a string parameter");
            }
            if (toolbarPlacements.indexOf(toolbarPlacement) === -1) {
                throw new TypeError("toolbarPlacement() parameter must be one of (" + toolbarPlacements.join(", ") + ") value");
            }
            options.toolbarPlacement = toolbarPlacement;
            if (widget) {
                hide();
                show();
            }
            return picker;
        };
        picker.widgetPositioning = function(widgetPositioning) {
            if (arguments.length === 0) {
                return $.extend({}, options.widgetPositioning);
            }
            if ({}.toString.call(widgetPositioning) !== "[object Object]") {
                throw new TypeError("widgetPositioning() expects an object variable");
            }
            if (widgetPositioning.horizontal) {
                if (typeof widgetPositioning.horizontal !== "string") {
                    throw new TypeError("widgetPositioning() horizontal variable must be a string");
                }
                widgetPositioning.horizontal = widgetPositioning.horizontal.toLowerCase();
                if (horizontalModes.indexOf(widgetPositioning.horizontal) === -1) {
                    throw new TypeError("widgetPositioning() expects horizontal parameter to be one of (" + horizontalModes.join(", ") + ")");
                }
                options.widgetPositioning.horizontal = widgetPositioning.horizontal;
            }
            if (widgetPositioning.vertical) {
                if (typeof widgetPositioning.vertical !== "string") {
                    throw new TypeError("widgetPositioning() vertical variable must be a string");
                }
                widgetPositioning.vertical = widgetPositioning.vertical.toLowerCase();
                if (verticalModes.indexOf(widgetPositioning.vertical) === -1) {
                    throw new TypeError("widgetPositioning() expects vertical parameter to be one of (" + verticalModes.join(", ") + ")");
                }
                options.widgetPositioning.vertical = widgetPositioning.vertical;
            }
            update();
            return picker;
        };
        picker.calendarWeeks = function(calendarWeeks) {
            if (arguments.length === 0) {
                return options.calendarWeeks;
            }
            if (typeof calendarWeeks !== "boolean") {
                throw new TypeError("calendarWeeks() expects parameter to be a boolean value");
            }
            options.calendarWeeks = calendarWeeks;
            update();
            return picker;
        };
        picker.showTodayButton = function(showTodayButton) {
            if (arguments.length === 0) {
                return options.showTodayButton;
            }
            if (typeof showTodayButton !== "boolean") {
                throw new TypeError("showTodayButton() expects a boolean parameter");
            }
            options.showTodayButton = showTodayButton;
            if (widget) {
                hide();
                show();
            }
            return picker;
        };
        picker.showClear = function(showClear) {
            if (arguments.length === 0) {
                return options.showClear;
            }
            if (typeof showClear !== "boolean") {
                throw new TypeError("showClear() expects a boolean parameter");
            }
            options.showClear = showClear;
            if (widget) {
                hide();
                show();
            }
            return picker;
        };
        picker.widgetParent = function(widgetParent) {
            if (arguments.length === 0) {
                return options.widgetParent;
            }
            if (typeof widgetParent === "string") {
                widgetParent = $(widgetParent);
            }
            if (widgetParent !== null && (typeof widgetParent !== "string" && !(widgetParent instanceof $))) {
                throw new TypeError("widgetParent() expects a string or a jQuery object parameter");
            }
            options.widgetParent = widgetParent;
            if (widget) {
                hide();
                show();
            }
            return picker;
        };
        picker.keepOpen = function(keepOpen) {
            if (arguments.length === 0) {
                return options.keepOpen;
            }
            if (typeof keepOpen !== "boolean") {
                throw new TypeError("keepOpen() expects a boolean parameter");
            }
            options.keepOpen = keepOpen;
            return picker;
        };
        picker.focusOnShow = function(focusOnShow) {
            if (arguments.length === 0) {
                return options.focusOnShow;
            }
            if (typeof focusOnShow !== "boolean") {
                throw new TypeError("focusOnShow() expects a boolean parameter");
            }
            options.focusOnShow = focusOnShow;
            return picker;
        };
        picker.inline = function(inline) {
            if (arguments.length === 0) {
                return options.inline;
            }
            if (typeof inline !== "boolean") {
                throw new TypeError("inline() expects a boolean parameter");
            }
            options.inline = inline;
            return picker;
        };
        picker.clear = function() {
            clear();
            return picker;
        };
        picker.keyBinds = function(keyBinds) {
            if (arguments.length === 0) {
                return options.keyBinds;
            }
            options.keyBinds = keyBinds;
            return picker;
        };
        picker.getMoment = function(d) {
            return getMoment(d);
        };
        picker.debug = function(debug) {
            if (typeof debug !== "boolean") {
                throw new TypeError("debug() expects a boolean parameter");
            }
            options.debug = debug;
            return picker;
        };
        picker.allowInputToggle = function(allowInputToggle) {
            if (arguments.length === 0) {
                return options.allowInputToggle;
            }
            if (typeof allowInputToggle !== "boolean") {
                throw new TypeError("allowInputToggle() expects a boolean parameter");
            }
            options.allowInputToggle = allowInputToggle;
            return picker;
        };
        picker.showClose = function(showClose) {
            if (arguments.length === 0) {
                return options.showClose;
            }
            if (typeof showClose !== "boolean") {
                throw new TypeError("showClose() expects a boolean parameter");
            }
            options.showClose = showClose;
            return picker;
        };
        picker.keepInvalid = function(keepInvalid) {
            if (arguments.length === 0) {
                return options.keepInvalid;
            }
            if (typeof keepInvalid !== "boolean") {
                throw new TypeError("keepInvalid() expects a boolean parameter");
            }
            options.keepInvalid = keepInvalid;
            return picker;
        };
        picker.datepickerInput = function(datepickerInput) {
            if (arguments.length === 0) {
                return options.datepickerInput;
            }
            if (typeof datepickerInput !== "string") {
                throw new TypeError("datepickerInput() expects a string parameter");
            }
            options.datepickerInput = datepickerInput;
            return picker;
        };
        picker.parseInputDate = function(parseInputDate) {
            if (arguments.length === 0) {
                return options.parseInputDate;
            }
            if (typeof parseInputDate !== "function") {
                throw new TypeError("parseInputDate() sholud be as function");
            }
            options.parseInputDate = parseInputDate;
            return picker;
        };
        picker.disabledTimeIntervals = function(disabledTimeIntervals) {
            if (arguments.length === 0) {
                return options.disabledTimeIntervals ? $.extend({}, options.disabledTimeIntervals) : options.disabledTimeIntervals;
            }
            if (!disabledTimeIntervals) {
                options.disabledTimeIntervals = false;
                update();
                return picker;
            }
            if (!(disabledTimeIntervals instanceof Array)) {
                throw new TypeError("disabledTimeIntervals() expects an array parameter");
            }
            options.disabledTimeIntervals = disabledTimeIntervals;
            update();
            return picker;
        };
        picker.disabledHours = function(hours) {
            if (arguments.length === 0) {
                return options.disabledHours ? $.extend({}, options.disabledHours) : options.disabledHours;
            }
            if (!hours) {
                options.disabledHours = false;
                update();
                return picker;
            }
            if (!(hours instanceof Array)) {
                throw new TypeError("disabledHours() expects an array parameter");
            }
            options.disabledHours = indexGivenHours(hours);
            options.enabledHours = false;
            if (options.useCurrent && !options.keepInvalid) {
                var tries = 0;
                while (!isValid(date, "h")) {
                    date.add(1, "h");
                    if (tries === 24) {
                        throw "Tried 24 times to find a valid date";
                    }
                    tries++;
                }
                setValue(date);
            }
            update();
            return picker;
        };
        picker.enabledHours = function(hours) {
            if (arguments.length === 0) {
                return options.enabledHours ? $.extend({}, options.enabledHours) : options.enabledHours;
            }
            if (!hours) {
                options.enabledHours = false;
                update();
                return picker;
            }
            if (!(hours instanceof Array)) {
                throw new TypeError("enabledHours() expects an array parameter");
            }
            options.enabledHours = indexGivenHours(hours);
            options.disabledHours = false;
            if (options.useCurrent && !options.keepInvalid) {
                var tries = 0;
                while (!isValid(date, "h")) {
                    date.add(1, "h");
                    if (tries === 24) {
                        throw "Tried 24 times to find a valid date";
                    }
                    tries++;
                }
                setValue(date);
            }
            update();
            return picker;
        };
        picker.viewDate = function(newDate) {
            if (arguments.length === 0) {
                return viewDate.clone();
            }
            if (!newDate) {
                viewDate = date.clone();
                return picker;
            }
            if (typeof newDate !== "string" && !moment.isMoment(newDate) && !(newDate instanceof Date)) {
                throw new TypeError("viewDate() parameter must be one of [string, moment or Date]");
            }
            viewDate = parseInputDate(newDate);
            viewUpdate();
            return picker;
        };
        if (element.is("input")) {
            input = element;
        } else {
            input = element.find(options.datepickerInput);
            if (input.length === 0) {
                input = element.find("input");
            } else if (!input.is("input")) {
                throw new Error('CSS class "' + options.datepickerInput + '" cannot be applied to non input element');
            }
        }
        if (element.hasClass("input-group")) {
            if (element.find(".datepickerbutton").length === 0) {
                component = element.find(".input-group-addon");
            } else {
                component = element.find(".datepickerbutton");
            }
        }
        if (!options.inline && !input.is("input")) {
            throw new Error("Could not initialize DateTimePicker without an input element");
        }
        date = getMoment();
        viewDate = date.clone();
        $.extend(true, options, dataToOptions());
        picker.options(options);
        initFormatting();
        attachDatePickerElementEvents();
        if (input.prop("disabled")) {
            picker.disable();
        }
        if (input.is("input") && input.val().trim().length !== 0) {
            setValue(parseInputDate(input.val().trim()));
        } else if (options.defaultDate && input.attr("placeholder") === undefined) {
            setValue(options.defaultDate);
        }
        if (options.inline) {
            show();
        }
        return picker;
    };
    $.fn.datetimepicker = function(options) {
        options = options || {};
        var args = Array.prototype.slice.call(arguments, 1), isInstance = true, thisMethods = [ "destroy", "hide", "show", "toggle" ], returnValue;
        if (typeof options === "object") {
            return this.each(function() {
                var $this = $(this), _options;
                if (!$this.data("DateTimePicker")) {
                    _options = $.extend(true, {}, $.fn.datetimepicker.defaults, options);
                    $this.data("DateTimePicker", dateTimePicker($this, _options));
                }
            });
        } else if (typeof options === "string") {
            this.each(function() {
                var $this = $(this), instance = $this.data("DateTimePicker");
                if (!instance) {
                    throw new Error('bootstrap-datetimepicker("' + options + '") method was called on an element that is not using DateTimePicker');
                }
                returnValue = instance[options].apply(instance, args);
                isInstance = returnValue === instance;
            });
            if (isInstance || $.inArray(options, thisMethods) > -1) {
                return this;
            }
            return returnValue;
        }
        throw new TypeError("Invalid arguments for DateTimePicker: " + options);
    };
    $.fn.datetimepicker.defaults = {
        timeZone: "",
        format: false,
        dayViewHeaderFormat: "MMMM YYYY",
        extraFormats: false,
        stepping: 1,
        minDate: false,
        maxDate: false,
        useCurrent: true,
        collapse: true,
        locale: moment.locale(),
        defaultDate: false,
        disabledDates: false,
        enabledDates: false,
        icons: {
            time: "glyphicon glyphicon-time",
            date: "glyphicon glyphicon-calendar",
            up: "glyphicon glyphicon-chevron-up",
            down: "glyphicon glyphicon-chevron-down",
            previous: "glyphicon glyphicon-chevron-left",
            next: "glyphicon glyphicon-chevron-right",
            today: "glyphicon glyphicon-screenshot",
            clear: "glyphicon glyphicon-trash",
            close: "glyphicon glyphicon-remove"
        },
        tooltips: {
            today: "Go to today",
            clear: "Clear selection",
            close: "Close the picker",
            selectMonth: "Select Month",
            prevMonth: "Previous Month",
            nextMonth: "Next Month",
            selectYear: "Select Year",
            prevYear: "Previous Year",
            nextYear: "Next Year",
            selectDecade: "Select Decade",
            prevDecade: "Previous Decade",
            nextDecade: "Next Decade",
            prevCentury: "Previous Century",
            nextCentury: "Next Century",
            pickHour: "Pick Hour",
            incrementHour: "Increment Hour",
            decrementHour: "Decrement Hour",
            pickMinute: "Pick Minute",
            incrementMinute: "Increment Minute",
            decrementMinute: "Decrement Minute",
            pickSecond: "Pick Second",
            incrementSecond: "Increment Second",
            decrementSecond: "Decrement Second",
            togglePeriod: "Toggle Period",
            selectTime: "Select Time"
        },
        useStrict: false,
        sideBySide: false,
        daysOfWeekDisabled: false,
        calendarWeeks: false,
        viewMode: "days",
        toolbarPlacement: "default",
        showTodayButton: false,
        showClear: false,
        showClose: false,
        widgetPositioning: {
            horizontal: "auto",
            vertical: "auto"
        },
        widgetParent: null,
        ignoreReadonly: false,
        keepOpen: false,
        focusOnShow: true,
        inline: false,
        keepInvalid: false,
        datepickerInput: ".datepickerinput",
        keyBinds: {
            up: function(widget) {
                if (!widget) {
                    return;
                }
                var d = this.date() || this.getMoment();
                if (widget.find(".datepicker").is(":visible")) {
                    this.date(d.clone().subtract(7, "d"));
                } else {
                    this.date(d.clone().add(this.stepping(), "m"));
                }
            },
            down: function(widget) {
                if (!widget) {
                    this.show();
                    return;
                }
                var d = this.date() || this.getMoment();
                if (widget.find(".datepicker").is(":visible")) {
                    this.date(d.clone().add(7, "d"));
                } else {
                    this.date(d.clone().subtract(this.stepping(), "m"));
                }
            },
            "control up": function(widget) {
                if (!widget) {
                    return;
                }
                var d = this.date() || this.getMoment();
                if (widget.find(".datepicker").is(":visible")) {
                    this.date(d.clone().subtract(1, "y"));
                } else {
                    this.date(d.clone().add(1, "h"));
                }
            },
            "control down": function(widget) {
                if (!widget) {
                    return;
                }
                var d = this.date() || this.getMoment();
                if (widget.find(".datepicker").is(":visible")) {
                    this.date(d.clone().add(1, "y"));
                } else {
                    this.date(d.clone().subtract(1, "h"));
                }
            },
            left: function(widget) {
                if (!widget) {
                    return;
                }
                var d = this.date() || this.getMoment();
                if (widget.find(".datepicker").is(":visible")) {
                    this.date(d.clone().subtract(1, "d"));
                }
            },
            right: function(widget) {
                if (!widget) {
                    return;
                }
                var d = this.date() || this.getMoment();
                if (widget.find(".datepicker").is(":visible")) {
                    this.date(d.clone().add(1, "d"));
                }
            },
            pageUp: function(widget) {
                if (!widget) {
                    return;
                }
                var d = this.date() || this.getMoment();
                if (widget.find(".datepicker").is(":visible")) {
                    this.date(d.clone().subtract(1, "M"));
                }
            },
            pageDown: function(widget) {
                if (!widget) {
                    return;
                }
                var d = this.date() || this.getMoment();
                if (widget.find(".datepicker").is(":visible")) {
                    this.date(d.clone().add(1, "M"));
                }
            },
            enter: function() {
                this.hide();
            },
            escape: function() {
                this.hide();
            },
            "control space": function(widget) {
                if (!widget) {
                    return;
                }
                if (widget.find(".timepicker").is(":visible")) {
                    widget.find('.btn[data-action="togglePeriod"]').click();
                }
            },
            t: function() {
                this.date(this.getMoment());
            },
            "delete": function() {
                this.clear();
            }
        },
        debug: false,
        allowInputToggle: false,
        disabledTimeIntervals: false,
        disabledHours: false,
        enabledHours: false,
        viewDate: false
    };
    return $.fn.datetimepicker;
});

(function(factory) {
    "use strict";
    if (typeof define === "function" && define.amd) {
        define([ "jquery" ], factory);
    } else if (typeof module !== "undefined" && module.exports) {
        module.exports = factory(require("jquery"));
    } else {
        factory(jQuery);
    }
})(function($) {
    "use strict";
    var $scrollTo = $.scrollTo = function(target, duration, settings) {
        return $(window).scrollTo(target, duration, settings);
    };
    $scrollTo.defaults = {
        axis: "xy",
        duration: 0,
        limit: true
    };
    function isWin(elem) {
        return !elem.nodeName || $.inArray(elem.nodeName.toLowerCase(), [ "iframe", "#document", "html", "body" ]) !== -1;
    }
    $.fn.scrollTo = function(target, duration, settings) {
        if (typeof duration === "object") {
            settings = duration;
            duration = 0;
        }
        if (typeof settings === "function") {
            settings = {
                onAfter: settings
            };
        }
        if (target === "max") {
            target = 9e9;
        }
        settings = $.extend({}, $scrollTo.defaults, settings);
        duration = duration || settings.duration;
        var queue = settings.queue && settings.axis.length > 1;
        if (queue) {
            duration /= 2;
        }
        settings.offset = both(settings.offset);
        settings.over = both(settings.over);
        return this.each(function() {
            if (target === null) return;
            var win = isWin(this), elem = win ? this.contentWindow || window : this, $elem = $(elem), targ = target, attr = {}, toff;
            switch (typeof targ) {
              case "number":
              case "string":
                if (/^([+-]=?)?\d+(\.\d+)?(px|%)?$/.test(targ)) {
                    targ = both(targ);
                    break;
                }
                targ = win ? $(targ) : $(targ, elem);

              case "object":
                if (targ.length === 0) return;
                if (targ.is || targ.style) {
                    toff = (targ = $(targ)).offset();
                }
            }
            var offset = $.isFunction(settings.offset) && settings.offset(elem, targ) || settings.offset;
            $.each(settings.axis.split(""), function(i, axis) {
                var Pos = axis === "x" ? "Left" : "Top", pos = Pos.toLowerCase(), key = "scroll" + Pos, prev = $elem[key](), max = $scrollTo.max(elem, axis);
                if (toff) {
                    attr[key] = toff[pos] + (win ? 0 : prev - $elem.offset()[pos]);
                    if (settings.margin) {
                        attr[key] -= parseInt(targ.css("margin" + Pos), 10) || 0;
                        attr[key] -= parseInt(targ.css("border" + Pos + "Width"), 10) || 0;
                    }
                    attr[key] += offset[pos] || 0;
                    if (settings.over[pos]) {
                        attr[key] += targ[axis === "x" ? "width" : "height"]() * settings.over[pos];
                    }
                } else {
                    var val = targ[pos];
                    attr[key] = val.slice && val.slice(-1) === "%" ? parseFloat(val) / 100 * max : val;
                }
                if (settings.limit && /^\d+$/.test(attr[key])) {
                    attr[key] = attr[key] <= 0 ? 0 : Math.min(attr[key], max);
                }
                if (!i && settings.axis.length > 1) {
                    if (prev === attr[key]) {
                        attr = {};
                    } else if (queue) {
                        animate(settings.onAfterFirst);
                        attr = {};
                    }
                }
            });
            animate(settings.onAfter);
            function animate(callback) {
                var opts = $.extend({}, settings, {
                    queue: true,
                    duration: duration,
                    complete: callback && function() {
                        callback.call(elem, targ, settings);
                    }
                });
                $elem.animate(attr, opts);
            }
        });
    };
    $scrollTo.max = function(elem, axis) {
        var Dim = axis === "x" ? "Width" : "Height", scroll = "scroll" + Dim;
        if (!isWin(elem)) return elem[scroll] - $(elem)[Dim.toLowerCase()]();
        var size = "client" + Dim, doc = elem.ownerDocument || elem.document, html = doc.documentElement, body = doc.body;
        return Math.max(html[scroll], body[scroll]) - Math.min(html[size], body[size]);
    };
    function both(val) {
        return $.isFunction(val) || $.isPlainObject(val) ? val : {
            top: val,
            left: val
        };
    }
    $.Tween.propHooks.scrollLeft = $.Tween.propHooks.scrollTop = {
        get: function(t) {
            return $(t.elem)[t.prop]();
        },
        set: function(t) {
            var curr = this.get(t);
            if (t.options.interrupt && t._last && t._last !== curr) {
                return $(t.elem).stop();
            }
            var next = Math.round(t.now);
            if (curr !== next) {
                $(t.elem)[t.prop](next);
                t._last = this.get(t);
            }
        }
    };
    return $scrollTo;
});

(function(factory) {
    if (typeof define === "function" && define.amd) {
        define([ "jquery" ], factory);
    } else {
        factory(typeof jQuery != "undefined" ? jQuery : window.Zepto);
    }
})(function($) {
    "use strict";
    var feature = {};
    feature.fileapi = $("<input type='file'/>").get(0).files !== undefined;
    feature.formdata = window.FormData !== undefined;
    var hasProp = !!$.fn.prop;
    $.fn.attr2 = function() {
        if (!hasProp) return this.attr.apply(this, arguments);
        var val = this.prop.apply(this, arguments);
        if (val && val.jquery || typeof val === "string") return val;
        return this.attr.apply(this, arguments);
    };
    $.fn.ajaxSubmit = function(options) {
        if (!this.length) {
            log("ajaxSubmit: skipping submit process - no element selected");
            return this;
        }
        var method, action, url, $form = this;
        if (typeof options == "function") {
            options = {
                success: options
            };
        } else if (options === undefined) {
            options = {};
        }
        method = options.type || this.attr2("method");
        action = options.url || this.attr2("action");
        url = typeof action === "string" ? $.trim(action) : "";
        url = url || window.location.href || "";
        if (url) {
            url = (url.match(/^([^#]+)/) || [])[1];
        }
        options = $.extend(true, {
            url: url,
            success: $.ajaxSettings.success,
            type: method || $.ajaxSettings.type,
            iframeSrc: /^https/i.test(window.location.href || "") ? "javascript:false" : "about:blank"
        }, options);
        var veto = {};
        this.trigger("form-pre-serialize", [ this, options, veto ]);
        if (veto.veto) {
            log("ajaxSubmit: submit vetoed via form-pre-serialize trigger");
            return this;
        }
        if (options.beforeSerialize && options.beforeSerialize(this, options) === false) {
            log("ajaxSubmit: submit aborted via beforeSerialize callback");
            return this;
        }
        var traditional = options.traditional;
        if (traditional === undefined) {
            traditional = $.ajaxSettings.traditional;
        }
        var elements = [];
        var qx, a = this.formToArray(options.semantic, elements);
        if (options.data) {
            options.extraData = options.data;
            qx = $.param(options.data, traditional);
        }
        if (options.beforeSubmit && options.beforeSubmit(a, this, options) === false) {
            log("ajaxSubmit: submit aborted via beforeSubmit callback");
            return this;
        }
        this.trigger("form-submit-validate", [ a, this, options, veto ]);
        if (veto.veto) {
            log("ajaxSubmit: submit vetoed via form-submit-validate trigger");
            return this;
        }
        var q = $.param(a, traditional);
        if (qx) {
            q = q ? q + "&" + qx : qx;
        }
        if (options.type.toUpperCase() == "GET") {
            options.url += (options.url.indexOf("?") >= 0 ? "&" : "?") + q;
            options.data = null;
        } else {
            options.data = q;
        }
        var callbacks = [];
        if (options.resetForm) {
            callbacks.push(function() {
                $form.resetForm();
            });
        }
        if (options.clearForm) {
            callbacks.push(function() {
                $form.clearForm(options.includeHidden);
            });
        }
        if (!options.dataType && options.target) {
            var oldSuccess = options.success || function() {};
            callbacks.push(function(data) {
                var fn = options.replaceTarget ? "replaceWith" : "html";
                $(options.target)[fn](data).each(oldSuccess, arguments);
            });
        } else if (options.success) {
            callbacks.push(options.success);
        }
        options.success = function(data, status, xhr) {
            var context = options.context || this;
            for (var i = 0, max = callbacks.length; i < max; i++) {
                callbacks[i].apply(context, [ data, status, xhr || $form, $form ]);
            }
        };
        if (options.error) {
            var oldError = options.error;
            options.error = function(xhr, status, error) {
                var context = options.context || this;
                oldError.apply(context, [ xhr, status, error, $form ]);
            };
        }
        if (options.complete) {
            var oldComplete = options.complete;
            options.complete = function(xhr, status) {
                var context = options.context || this;
                oldComplete.apply(context, [ xhr, status, $form ]);
            };
        }
        var fileInputs = $("input[type=file]:enabled", this).filter(function() {
            return $(this).val() !== "";
        });
        var hasFileInputs = fileInputs.length > 0;
        var mp = "multipart/form-data";
        var multipart = $form.attr("enctype") == mp || $form.attr("encoding") == mp;
        var fileAPI = feature.fileapi && feature.formdata;
        log("fileAPI :" + fileAPI);
        var shouldUseFrame = (hasFileInputs || multipart) && !fileAPI;
        var jqxhr;
        if (options.iframe !== false && (options.iframe || shouldUseFrame)) {
            if (options.closeKeepAlive) {
                $.get(options.closeKeepAlive, function() {
                    jqxhr = fileUploadIframe(a);
                });
            } else {
                jqxhr = fileUploadIframe(a);
            }
        } else if ((hasFileInputs || multipart) && fileAPI) {
            jqxhr = fileUploadXhr(a);
        } else {
            jqxhr = $.ajax(options);
        }
        $form.removeData("jqxhr").data("jqxhr", jqxhr);
        for (var k = 0; k < elements.length; k++) elements[k] = null;
        this.trigger("form-submit-notify", [ this, options ]);
        return this;
        function deepSerialize(extraData) {
            var serialized = $.param(extraData, options.traditional).split("&");
            var len = serialized.length;
            var result = [];
            var i, part;
            for (i = 0; i < len; i++) {
                serialized[i] = serialized[i].replace(/\+/g, " ");
                part = serialized[i].split("=");
                result.push([ decodeURIComponent(part[0]), decodeURIComponent(part[1]) ]);
            }
            return result;
        }
        function fileUploadXhr(a) {
            var formdata = new FormData();
            for (var i = 0; i < a.length; i++) {
                formdata.append(a[i].name, a[i].value);
            }
            if (options.extraData) {
                var serializedData = deepSerialize(options.extraData);
                for (i = 0; i < serializedData.length; i++) if (serializedData[i]) formdata.append(serializedData[i][0], serializedData[i][1]);
            }
            options.data = null;
            var s = $.extend(true, {}, $.ajaxSettings, options, {
                contentType: false,
                processData: false,
                cache: false,
                type: method || "POST"
            });
            if (options.uploadProgress) {
                s.xhr = function() {
                    var xhr = $.ajaxSettings.xhr();
                    if (xhr.upload) {
                        xhr.upload.addEventListener("progress", function(event) {
                            var percent = 0;
                            var position = event.loaded || event.position;
                            var total = event.total;
                            if (event.lengthComputable) {
                                percent = Math.ceil(position / total * 100);
                            }
                            options.uploadProgress(event, position, total, percent);
                        }, false);
                    }
                    return xhr;
                };
            }
            s.data = null;
            var beforeSend = s.beforeSend;
            s.beforeSend = function(xhr, o) {
                if (options.formData) o.data = options.formData; else o.data = formdata;
                if (beforeSend) beforeSend.call(this, xhr, o);
            };
            return $.ajax(s);
        }
        function fileUploadIframe(a) {
            var form = $form[0], el, i, s, g, id, $io, io, xhr, sub, n, timedOut, timeoutHandle;
            var deferred = $.Deferred();
            deferred.abort = function(status) {
                xhr.abort(status);
            };
            if (a) {
                for (i = 0; i < elements.length; i++) {
                    el = $(elements[i]);
                    if (hasProp) el.prop("disabled", false); else el.removeAttr("disabled");
                }
            }
            s = $.extend(true, {}, $.ajaxSettings, options);
            s.context = s.context || s;
            id = "jqFormIO" + new Date().getTime();
            if (s.iframeTarget) {
                $io = $(s.iframeTarget);
                n = $io.attr2("name");
                if (!n) $io.attr2("name", id); else id = n;
            } else {
                $io = $('<iframe name="' + id + '" src="' + s.iframeSrc + '" />');
                $io.css({
                    position: "absolute",
                    top: "-1000px",
                    left: "-1000px"
                });
            }
            io = $io[0];
            xhr = {
                aborted: 0,
                responseText: null,
                responseXML: null,
                status: 0,
                statusText: "n/a",
                getAllResponseHeaders: function() {},
                getResponseHeader: function() {},
                setRequestHeader: function() {},
                abort: function(status) {
                    var e = status === "timeout" ? "timeout" : "aborted";
                    log("aborting upload... " + e);
                    this.aborted = 1;
                    try {
                        if (io.contentWindow.document.execCommand) {
                            io.contentWindow.document.execCommand("Stop");
                        }
                    } catch (ignore) {}
                    $io.attr("src", s.iframeSrc);
                    xhr.error = e;
                    if (s.error) s.error.call(s.context, xhr, e, status);
                    if (g) $.event.trigger("ajaxError", [ xhr, s, e ]);
                    if (s.complete) s.complete.call(s.context, xhr, e);
                }
            };
            g = s.global;
            if (g && 0 === $.active++) {
                $.event.trigger("ajaxStart");
            }
            if (g) {
                $.event.trigger("ajaxSend", [ xhr, s ]);
            }
            if (s.beforeSend && s.beforeSend.call(s.context, xhr, s) === false) {
                if (s.global) {
                    $.active--;
                }
                deferred.reject();
                return deferred;
            }
            if (xhr.aborted) {
                deferred.reject();
                return deferred;
            }
            sub = form.clk;
            if (sub) {
                n = sub.name;
                if (n && !sub.disabled) {
                    s.extraData = s.extraData || {};
                    s.extraData[n] = sub.value;
                    if (sub.type == "image") {
                        s.extraData[n + ".x"] = form.clk_x;
                        s.extraData[n + ".y"] = form.clk_y;
                    }
                }
            }
            var CLIENT_TIMEOUT_ABORT = 1;
            var SERVER_ABORT = 2;
            function getDoc(frame) {
                var doc = null;
                try {
                    if (frame.contentWindow) {
                        doc = frame.contentWindow.document;
                    }
                } catch (err) {
                    log("cannot get iframe.contentWindow document: " + err);
                }
                if (doc) {
                    return doc;
                }
                try {
                    doc = frame.contentDocument ? frame.contentDocument : frame.document;
                } catch (err) {
                    log("cannot get iframe.contentDocument: " + err);
                    doc = frame.document;
                }
                return doc;
            }
            var csrf_token = $("meta[name=csrf-token]").attr("content");
            var csrf_param = $("meta[name=csrf-param]").attr("content");
            if (csrf_param && csrf_token) {
                s.extraData = s.extraData || {};
                s.extraData[csrf_param] = csrf_token;
            }
            function doSubmit() {
                var t = $form.attr2("target"), a = $form.attr2("action");
                form.setAttribute("target", id);
                if (!method || /post/i.test(method)) {
                    form.setAttribute("method", "POST");
                }
                if (a != s.url) {
                    form.setAttribute("action", s.url);
                }
                if (!s.skipEncodingOverride && (!method || /post/i.test(method))) {
                    $form.attr({
                        encoding: "multipart/form-data",
                        enctype: "multipart/form-data"
                    });
                }
                if (s.timeout) {
                    timeoutHandle = setTimeout(function() {
                        timedOut = true;
                        cb(CLIENT_TIMEOUT_ABORT);
                    }, s.timeout);
                }
                function checkState() {
                    try {
                        var state = getDoc(io).readyState;
                        log("state = " + state);
                        if (state && state.toLowerCase() == "uninitialized") setTimeout(checkState, 50);
                    } catch (e) {
                        log("Server abort: ", e, " (", e.name, ")");
                        cb(SERVER_ABORT);
                        if (timeoutHandle) clearTimeout(timeoutHandle);
                        timeoutHandle = undefined;
                    }
                }
                var extraInputs = [];
                try {
                    if (s.extraData) {
                        for (var n in s.extraData) {
                            if (s.extraData.hasOwnProperty(n)) {
                                if ($.isPlainObject(s.extraData[n]) && s.extraData[n].hasOwnProperty("name") && s.extraData[n].hasOwnProperty("value")) {
                                    extraInputs.push($('<input type="hidden" name="' + s.extraData[n].name + '">').val(s.extraData[n].value).appendTo(form)[0]);
                                } else {
                                    extraInputs.push($('<input type="hidden" name="' + n + '">').val(s.extraData[n]).appendTo(form)[0]);
                                }
                            }
                        }
                    }
                    if (!s.iframeTarget) {
                        $io.appendTo("body");
                    }
                    if (io.attachEvent) io.attachEvent("onload", cb); else io.addEventListener("load", cb, false);
                    setTimeout(checkState, 15);
                    try {
                        form.submit();
                    } catch (err) {
                        var submitFn = document.createElement("form").submit;
                        submitFn.apply(form);
                    }
                } finally {
                    form.setAttribute("action", a);
                    if (t) {
                        form.setAttribute("target", t);
                    } else {
                        $form.removeAttr("target");
                    }
                    $(extraInputs).remove();
                }
            }
            if (s.forceSync) {
                doSubmit();
            } else {
                setTimeout(doSubmit, 10);
            }
            var data, doc, domCheckCount = 50, callbackProcessed;
            function cb(e) {
                if (xhr.aborted || callbackProcessed) {
                    return;
                }
                doc = getDoc(io);
                if (!doc) {
                    log("cannot access response document");
                    e = SERVER_ABORT;
                }
                if (e === CLIENT_TIMEOUT_ABORT && xhr) {
                    xhr.abort("timeout");
                    deferred.reject(xhr, "timeout");
                    return;
                } else if (e == SERVER_ABORT && xhr) {
                    xhr.abort("server abort");
                    deferred.reject(xhr, "error", "server abort");
                    return;
                }
                if (!doc || doc.location.href == s.iframeSrc) {
                    if (!timedOut) return;
                }
                if (io.detachEvent) io.detachEvent("onload", cb); else io.removeEventListener("load", cb, false);
                var status = "success", errMsg;
                try {
                    if (timedOut) {
                        throw "timeout";
                    }
                    var isXml = s.dataType == "xml" || doc.XMLDocument || $.isXMLDoc(doc);
                    log("isXml=" + isXml);
                    if (!isXml && window.opera && (doc.body === null || !doc.body.innerHTML)) {
                        if (--domCheckCount) {
                            log("requeing onLoad callback, DOM not available");
                            setTimeout(cb, 250);
                            return;
                        }
                    }
                    var docRoot = doc.body ? doc.body : doc.documentElement;
                    xhr.responseText = docRoot ? docRoot.innerHTML : null;
                    xhr.responseXML = doc.XMLDocument ? doc.XMLDocument : doc;
                    if (isXml) s.dataType = "xml";
                    xhr.getResponseHeader = function(header) {
                        var headers = {
                            "content-type": s.dataType
                        };
                        return headers[header.toLowerCase()];
                    };
                    if (docRoot) {
                        xhr.status = Number(docRoot.getAttribute("status")) || xhr.status;
                        xhr.statusText = docRoot.getAttribute("statusText") || xhr.statusText;
                    }
                    var dt = (s.dataType || "").toLowerCase();
                    var scr = /(json|script|text)/.test(dt);
                    if (scr || s.textarea) {
                        var ta = doc.getElementsByTagName("textarea")[0];
                        if (ta) {
                            xhr.responseText = ta.value;
                            xhr.status = Number(ta.getAttribute("status")) || xhr.status;
                            xhr.statusText = ta.getAttribute("statusText") || xhr.statusText;
                        } else if (scr) {
                            var pre = doc.getElementsByTagName("pre")[0];
                            var b = doc.getElementsByTagName("body")[0];
                            if (pre) {
                                xhr.responseText = pre.textContent ? pre.textContent : pre.innerText;
                            } else if (b) {
                                xhr.responseText = b.textContent ? b.textContent : b.innerText;
                            }
                        }
                    } else if (dt == "xml" && !xhr.responseXML && xhr.responseText) {
                        xhr.responseXML = toXml(xhr.responseText);
                    }
                    try {
                        data = httpData(xhr, dt, s);
                    } catch (err) {
                        status = "parsererror";
                        xhr.error = errMsg = err || status;
                    }
                } catch (err) {
                    log("error caught: ", err);
                    status = "error";
                    xhr.error = errMsg = err || status;
                }
                if (xhr.aborted) {
                    log("upload aborted");
                    status = null;
                }
                if (xhr.status) {
                    status = xhr.status >= 200 && xhr.status < 300 || xhr.status === 304 ? "success" : "error";
                }
                if (status === "success") {
                    if (s.success) s.success.call(s.context, data, "success", xhr);
                    deferred.resolve(xhr.responseText, "success", xhr);
                    if (g) $.event.trigger("ajaxSuccess", [ xhr, s ]);
                } else if (status) {
                    if (errMsg === undefined) errMsg = xhr.statusText;
                    if (s.error) s.error.call(s.context, xhr, status, errMsg);
                    deferred.reject(xhr, "error", errMsg);
                    if (g) $.event.trigger("ajaxError", [ xhr, s, errMsg ]);
                }
                if (g) $.event.trigger("ajaxComplete", [ xhr, s ]);
                if (g && !--$.active) {
                    $.event.trigger("ajaxStop");
                }
                if (s.complete) s.complete.call(s.context, xhr, status);
                callbackProcessed = true;
                if (s.timeout) clearTimeout(timeoutHandle);
                setTimeout(function() {
                    if (!s.iframeTarget) $io.remove(); else $io.attr("src", s.iframeSrc);
                    xhr.responseXML = null;
                }, 100);
            }
            var toXml = $.parseXML || function(s, doc) {
                if (window.ActiveXObject) {
                    doc = new ActiveXObject("Microsoft.XMLDOM");
                    doc.async = "false";
                    doc.loadXML(s);
                } else {
                    doc = new DOMParser().parseFromString(s, "text/xml");
                }
                return doc && doc.documentElement && doc.documentElement.nodeName != "parsererror" ? doc : null;
            };
            var parseJSON = $.parseJSON || function(s) {
                return window["eval"]("(" + s + ")");
            };
            var httpData = function(xhr, type, s) {
                var ct = xhr.getResponseHeader("content-type") || "", xml = type === "xml" || !type && ct.indexOf("xml") >= 0, data = xml ? xhr.responseXML : xhr.responseText;
                if (xml && data.documentElement.nodeName === "parsererror") {
                    if ($.error) $.error("parsererror");
                }
                if (s && s.dataFilter) {
                    data = s.dataFilter(data, type);
                }
                if (typeof data === "string") {
                    if (type === "json" || !type && ct.indexOf("json") >= 0) {
                        data = parseJSON(data);
                    } else if (type === "script" || !type && ct.indexOf("javascript") >= 0) {
                        $.globalEval(data);
                    }
                }
                return data;
            };
            return deferred;
        }
    };
    $.fn.ajaxForm = function(options) {
        options = options || {};
        options.delegation = options.delegation && $.isFunction($.fn.on);
        if (!options.delegation && this.length === 0) {
            var o = {
                s: this.selector,
                c: this.context
            };
            if (!$.isReady && o.s) {
                log("DOM not ready, queuing ajaxForm");
                $(function() {
                    $(o.s, o.c).ajaxForm(options);
                });
                return this;
            }
            log("terminating; zero elements found by selector" + ($.isReady ? "" : " (DOM not ready)"));
            return this;
        }
        if (options.delegation) {
            $(document).off("submit.form-plugin", this.selector, doAjaxSubmit).off("click.form-plugin", this.selector, captureSubmittingElement).on("submit.form-plugin", this.selector, options, doAjaxSubmit).on("click.form-plugin", this.selector, options, captureSubmittingElement);
            return this;
        }
        return this.ajaxFormUnbind().bind("submit.form-plugin", options, doAjaxSubmit).bind("click.form-plugin", options, captureSubmittingElement);
    };
    function doAjaxSubmit(e) {
        var options = e.data;
        if (!e.isDefaultPrevented()) {
            e.preventDefault();
            $(e.target).ajaxSubmit(options);
        }
    }
    function captureSubmittingElement(e) {
        var target = e.target;
        var $el = $(target);
        if (!$el.is("[type=submit],[type=image]")) {
            var t = $el.closest("[type=submit]");
            if (t.length === 0) {
                return;
            }
            target = t[0];
        }
        var form = this;
        form.clk = target;
        if (target.type == "image") {
            if (e.offsetX !== undefined) {
                form.clk_x = e.offsetX;
                form.clk_y = e.offsetY;
            } else if (typeof $.fn.offset == "function") {
                var offset = $el.offset();
                form.clk_x = e.pageX - offset.left;
                form.clk_y = e.pageY - offset.top;
            } else {
                form.clk_x = e.pageX - target.offsetLeft;
                form.clk_y = e.pageY - target.offsetTop;
            }
        }
        setTimeout(function() {
            form.clk = form.clk_x = form.clk_y = null;
        }, 100);
    }
    $.fn.ajaxFormUnbind = function() {
        return this.unbind("submit.form-plugin click.form-plugin");
    };
    $.fn.formToArray = function(semantic, elements) {
        var a = [];
        if (this.length === 0) {
            return a;
        }
        var form = this[0];
        var els = semantic ? form.getElementsByTagName("*") : form.elements;
        if (!els) {
            return a;
        }
        var i, j, n, v, el, max, jmax;
        for (i = 0, max = els.length; i < max; i++) {
            el = els[i];
            n = el.name;
            if (!n || el.disabled) {
                continue;
            }
            if (semantic && form.clk && el.type == "image") {
                if (form.clk == el) {
                    a.push({
                        name: n,
                        value: $(el).val(),
                        type: el.type
                    });
                    a.push({
                        name: n + ".x",
                        value: form.clk_x
                    }, {
                        name: n + ".y",
                        value: form.clk_y
                    });
                }
                continue;
            }
            v = $.fieldValue(el, true);
            if (v && v.constructor == Array) {
                if (elements) elements.push(el);
                for (j = 0, jmax = v.length; j < jmax; j++) {
                    a.push({
                        name: n,
                        value: v[j]
                    });
                }
            } else if (feature.fileapi && el.type == "file") {
                if (elements) elements.push(el);
                var files = el.files;
                if (files.length) {
                    for (j = 0; j < files.length; j++) {
                        a.push({
                            name: n,
                            value: files[j],
                            type: el.type
                        });
                    }
                } else {
                    a.push({
                        name: n,
                        value: "",
                        type: el.type
                    });
                }
            } else if (v !== null && typeof v != "undefined") {
                if (elements) elements.push(el);
                a.push({
                    name: n,
                    value: v,
                    type: el.type,
                    required: el.required
                });
            }
        }
        if (!semantic && form.clk) {
            var $input = $(form.clk), input = $input[0];
            n = input.name;
            if (n && !input.disabled && input.type == "image") {
                a.push({
                    name: n,
                    value: $input.val()
                });
                a.push({
                    name: n + ".x",
                    value: form.clk_x
                }, {
                    name: n + ".y",
                    value: form.clk_y
                });
            }
        }
        return a;
    };
    $.fn.formSerialize = function(semantic) {
        return $.param(this.formToArray(semantic));
    };
    $.fn.fieldSerialize = function(successful) {
        var a = [];
        this.each(function() {
            var n = this.name;
            if (!n) {
                return;
            }
            var v = $.fieldValue(this, successful);
            if (v && v.constructor == Array) {
                for (var i = 0, max = v.length; i < max; i++) {
                    a.push({
                        name: n,
                        value: v[i]
                    });
                }
            } else if (v !== null && typeof v != "undefined") {
                a.push({
                    name: this.name,
                    value: v
                });
            }
        });
        return $.param(a);
    };
    $.fn.fieldValue = function(successful) {
        for (var val = [], i = 0, max = this.length; i < max; i++) {
            var el = this[i];
            var v = $.fieldValue(el, successful);
            if (v === null || typeof v == "undefined" || v.constructor == Array && !v.length) {
                continue;
            }
            if (v.constructor == Array) $.merge(val, v); else val.push(v);
        }
        return val;
    };
    $.fieldValue = function(el, successful) {
        var n = el.name, t = el.type, tag = el.tagName.toLowerCase();
        if (successful === undefined) {
            successful = true;
        }
        if (successful && (!n || el.disabled || t == "reset" || t == "button" || (t == "checkbox" || t == "radio") && !el.checked || (t == "submit" || t == "image") && el.form && el.form.clk != el || tag == "select" && el.selectedIndex == -1)) {
            return null;
        }
        if (tag == "select") {
            var index = el.selectedIndex;
            if (index < 0) {
                return null;
            }
            var a = [], ops = el.options;
            var one = t == "select-one";
            var max = one ? index + 1 : ops.length;
            for (var i = one ? index : 0; i < max; i++) {
                var op = ops[i];
                if (op.selected) {
                    var v = op.value;
                    if (!v) {
                        v = op.attributes && op.attributes["value"] && !op.attributes["value"].specified ? op.text : op.value;
                    }
                    if (one) {
                        return v;
                    }
                    a.push(v);
                }
            }
            return a;
        }
        return $(el).val();
    };
    $.fn.clearForm = function(includeHidden) {
        return this.each(function() {
            $("input,select,textarea", this).clearFields(includeHidden);
        });
    };
    $.fn.clearFields = $.fn.clearInputs = function(includeHidden) {
        var re = /^(?:color|date|datetime|email|month|number|password|range|search|tel|text|time|url|week)$/i;
        return this.each(function() {
            var t = this.type, tag = this.tagName.toLowerCase();
            if (re.test(t) || tag == "textarea") {
                this.value = "";
            } else if (t == "checkbox" || t == "radio") {
                this.checked = false;
            } else if (tag == "select") {
                this.selectedIndex = -1;
            } else if (t == "file") {
                if (/MSIE/.test(navigator.userAgent)) {
                    $(this).replaceWith($(this).clone(true));
                } else {
                    $(this).val("");
                }
            } else if (includeHidden) {
                if (includeHidden === true && /hidden/.test(t) || typeof includeHidden == "string" && $(this).is(includeHidden)) this.value = "";
            }
        });
    };
    $.fn.resetForm = function() {
        return this.each(function() {
            if (typeof this.reset == "function" || typeof this.reset == "object" && !this.reset.nodeType) {
                this.reset();
            }
        });
    };
    $.fn.enable = function(b) {
        if (b === undefined) {
            b = true;
        }
        return this.each(function() {
            this.disabled = !b;
        });
    };
    $.fn.selected = function(select) {
        if (select === undefined) {
            select = true;
        }
        return this.each(function() {
            var t = this.type;
            if (t == "checkbox" || t == "radio") {
                this.checked = select;
            } else if (this.tagName.toLowerCase() == "option") {
                var $sel = $(this).parent("select");
                if (select && $sel[0] && $sel[0].type == "select-one") {
                    $sel.find("option").selected(false);
                }
                this.selected = select;
            }
        });
    };
    $.fn.ajaxSubmit.debug = false;
    function log() {
        if (!$.fn.ajaxSubmit.debug) return;
        var msg = "[jquery.form] " + Array.prototype.join.call(arguments, "");
        if (window.console && window.console.log) {
            window.console.log(msg);
        } else if (window.opera && window.opera.postError) {
            window.opera.postError(msg);
        }
    }
});

(function e(t, n, r) {
    function s(o, u) {
        if (!n[o]) {
            if (!t[o]) {
                var a = typeof require == "function" && require;
                if (!u && a) return a(o, !0);
                if (i) return i(o, !0);
                var f = new Error("Cannot find module '" + o + "'");
                throw f.code = "MODULE_NOT_FOUND", f;
            }
            var l = n[o] = {
                exports: {}
            };
            t[o][0].call(l.exports, function(e) {
                var n = t[o][1][e];
                return s(n ? n : e);
            }, l, l.exports, e, t, n, r);
        }
        return n[o].exports;
    }
    var i = typeof require == "function" && require;
    for (var o = 0; o < r.length; o++) s(r[o]);
    return s;
})({
    1: [ function(require, module, exports) {
        var svgPanZoom = require("./svg-pan-zoom.js");
        (function(window, document) {
            if (typeof define === "function" && define.amd) {
                define("svg-pan-zoom", function() {
                    return svgPanZoom;
                });
            } else if (typeof module !== "undefined" && module.exports) {
                module.exports = svgPanZoom;
                window.svgPanZoom = svgPanZoom;
            }
        })(window, document);
    }, {
        "./svg-pan-zoom.js": 4
    } ],
    2: [ function(require, module, exports) {
        var SvgUtils = require("./svg-utilities");
        module.exports = {
            enable: function(instance) {
                var defs = instance.svg.querySelector("defs");
                if (!defs) {
                    defs = document.createElementNS(SvgUtils.svgNS, "defs");
                    instance.svg.appendChild(defs);
                }
                var styleEl = defs.querySelector("style#svg-pan-zoom-controls-styles");
                if (!styleEl) {
                    var style = document.createElementNS(SvgUtils.svgNS, "style");
                    style.setAttribute("id", "svg-pan-zoom-controls-styles");
                    style.setAttribute("type", "text/css");
                    style.textContent = ".svg-pan-zoom-control { cursor: pointer; fill: black; fill-opacity: 0.333; } .svg-pan-zoom-control:hover { fill-opacity: 0.8; } .svg-pan-zoom-control-background { fill: white; fill-opacity: 0.5; } .svg-pan-zoom-control-background { fill-opacity: 0.8; }";
                    defs.appendChild(style);
                }
                var zoomGroup = document.createElementNS(SvgUtils.svgNS, "g");
                zoomGroup.setAttribute("id", "svg-pan-zoom-controls");
                zoomGroup.setAttribute("transform", "translate(" + (instance.width - 70) + " " + (instance.height - 76) + ") scale(0.75)");
                zoomGroup.setAttribute("class", "svg-pan-zoom-control");
                zoomGroup.appendChild(this._createZoomIn(instance));
                zoomGroup.appendChild(this._createZoomReset(instance));
                zoomGroup.appendChild(this._createZoomOut(instance));
                instance.svg.appendChild(zoomGroup);
                instance.controlIcons = zoomGroup;
            },
            _createZoomIn: function(instance) {
                var zoomIn = document.createElementNS(SvgUtils.svgNS, "g");
                zoomIn.setAttribute("id", "svg-pan-zoom-zoom-in");
                zoomIn.setAttribute("transform", "translate(30.5 5) scale(0.015)");
                zoomIn.setAttribute("class", "svg-pan-zoom-control");
                zoomIn.addEventListener("click", function() {
                    instance.getPublicInstance().zoomIn();
                }, false);
                zoomIn.addEventListener("touchstart", function() {
                    instance.getPublicInstance().zoomIn();
                }, false);
                var zoomInBackground = document.createElementNS(SvgUtils.svgNS, "rect");
                zoomInBackground.setAttribute("x", "0");
                zoomInBackground.setAttribute("y", "0");
                zoomInBackground.setAttribute("width", "1500");
                zoomInBackground.setAttribute("height", "1400");
                zoomInBackground.setAttribute("class", "svg-pan-zoom-control-background");
                zoomIn.appendChild(zoomInBackground);
                var zoomInShape = document.createElementNS(SvgUtils.svgNS, "path");
                zoomInShape.setAttribute("d", "M1280 576v128q0 26 -19 45t-45 19h-320v320q0 26 -19 45t-45 19h-128q-26 0 -45 -19t-19 -45v-320h-320q-26 0 -45 -19t-19 -45v-128q0 -26 19 -45t45 -19h320v-320q0 -26 19 -45t45 -19h128q26 0 45 19t19 45v320h320q26 0 45 19t19 45zM1536 1120v-960 q0 -119 -84.5 -203.5t-203.5 -84.5h-960q-119 0 -203.5 84.5t-84.5 203.5v960q0 119 84.5 203.5t203.5 84.5h960q119 0 203.5 -84.5t84.5 -203.5z");
                zoomInShape.setAttribute("class", "svg-pan-zoom-control-element");
                zoomIn.appendChild(zoomInShape);
                return zoomIn;
            },
            _createZoomReset: function(instance) {
                var resetPanZoomControl = document.createElementNS(SvgUtils.svgNS, "g");
                resetPanZoomControl.setAttribute("id", "svg-pan-zoom-reset-pan-zoom");
                resetPanZoomControl.setAttribute("transform", "translate(5 35) scale(0.4)");
                resetPanZoomControl.setAttribute("class", "svg-pan-zoom-control");
                resetPanZoomControl.addEventListener("click", function() {
                    instance.getPublicInstance().reset();
                }, false);
                resetPanZoomControl.addEventListener("touchstart", function() {
                    instance.getPublicInstance().reset();
                }, false);
                var resetPanZoomControlBackground = document.createElementNS(SvgUtils.svgNS, "rect");
                resetPanZoomControlBackground.setAttribute("x", "2");
                resetPanZoomControlBackground.setAttribute("y", "2");
                resetPanZoomControlBackground.setAttribute("width", "182");
                resetPanZoomControlBackground.setAttribute("height", "58");
                resetPanZoomControlBackground.setAttribute("class", "svg-pan-zoom-control-background");
                resetPanZoomControl.appendChild(resetPanZoomControlBackground);
                var resetPanZoomControlShape1 = document.createElementNS(SvgUtils.svgNS, "path");
                resetPanZoomControlShape1.setAttribute("d", "M33.051,20.632c-0.742-0.406-1.854-0.609-3.338-0.609h-7.969v9.281h7.769c1.543,0,2.701-0.188,3.473-0.562c1.365-0.656,2.048-1.953,2.048-3.891C35.032,22.757,34.372,21.351,33.051,20.632z");
                resetPanZoomControlShape1.setAttribute("class", "svg-pan-zoom-control-element");
                resetPanZoomControl.appendChild(resetPanZoomControlShape1);
                var resetPanZoomControlShape2 = document.createElementNS(SvgUtils.svgNS, "path");
                resetPanZoomControlShape2.setAttribute("d", "M170.231,0.5H15.847C7.102,0.5,0.5,5.708,0.5,11.84v38.861C0.5,56.833,7.102,61.5,15.847,61.5h154.384c8.745,0,15.269-4.667,15.269-10.798V11.84C185.5,5.708,178.976,0.5,170.231,0.5z M42.837,48.569h-7.969c-0.219-0.766-0.375-1.383-0.469-1.852c-0.188-0.969-0.289-1.961-0.305-2.977l-0.047-3.211c-0.03-2.203-0.41-3.672-1.142-4.406c-0.732-0.734-2.103-1.102-4.113-1.102h-7.05v13.547h-7.055V14.022h16.524c2.361,0.047,4.178,0.344,5.45,0.891c1.272,0.547,2.351,1.352,3.234,2.414c0.731,0.875,1.31,1.844,1.737,2.906s0.64,2.273,0.64,3.633c0,1.641-0.414,3.254-1.242,4.84s-2.195,2.707-4.102,3.363c1.594,0.641,2.723,1.551,3.387,2.73s0.996,2.98,0.996,5.402v2.32c0,1.578,0.063,2.648,0.19,3.211c0.19,0.891,0.635,1.547,1.333,1.969V48.569z M75.579,48.569h-26.18V14.022h25.336v6.117H56.454v7.336h16.781v6H56.454v8.883h19.125V48.569z M104.497,46.331c-2.44,2.086-5.887,3.129-10.34,3.129c-4.548,0-8.125-1.027-10.731-3.082s-3.909-4.879-3.909-8.473h6.891c0.224,1.578,0.662,2.758,1.316,3.539c1.196,1.422,3.246,2.133,6.15,2.133c1.739,0,3.151-0.188,4.236-0.562c2.058-0.719,3.087-2.055,3.087-4.008c0-1.141-0.504-2.023-1.512-2.648c-1.008-0.609-2.607-1.148-4.796-1.617l-3.74-0.82c-3.676-0.812-6.201-1.695-7.576-2.648c-2.328-1.594-3.492-4.086-3.492-7.477c0-3.094,1.139-5.664,3.417-7.711s5.623-3.07,10.036-3.07c3.685,0,6.829,0.965,9.431,2.895c2.602,1.93,3.966,4.73,4.093,8.402h-6.938c-0.128-2.078-1.057-3.555-2.787-4.43c-1.154-0.578-2.587-0.867-4.301-0.867c-1.907,0-3.428,0.375-4.565,1.125c-1.138,0.75-1.706,1.797-1.706,3.141c0,1.234,0.561,2.156,1.682,2.766c0.721,0.406,2.25,0.883,4.589,1.43l6.063,1.43c2.657,0.625,4.648,1.461,5.975,2.508c2.059,1.625,3.089,3.977,3.089,7.055C108.157,41.624,106.937,44.245,104.497,46.331z M139.61,48.569h-26.18V14.022h25.336v6.117h-18.281v7.336h16.781v6h-16.781v8.883h19.125V48.569z M170.337,20.14h-10.336v28.43h-7.266V20.14h-10.383v-6.117h27.984V20.14z");
                resetPanZoomControlShape2.setAttribute("class", "svg-pan-zoom-control-element");
                resetPanZoomControl.appendChild(resetPanZoomControlShape2);
                return resetPanZoomControl;
            },
            _createZoomOut: function(instance) {
                var zoomOut = document.createElementNS(SvgUtils.svgNS, "g");
                zoomOut.setAttribute("id", "svg-pan-zoom-zoom-out");
                zoomOut.setAttribute("transform", "translate(30.5 70) scale(0.015)");
                zoomOut.setAttribute("class", "svg-pan-zoom-control");
                zoomOut.addEventListener("click", function() {
                    instance.getPublicInstance().zoomOut();
                }, false);
                zoomOut.addEventListener("touchstart", function() {
                    instance.getPublicInstance().zoomOut();
                }, false);
                var zoomOutBackground = document.createElementNS(SvgUtils.svgNS, "rect");
                zoomOutBackground.setAttribute("x", "0");
                zoomOutBackground.setAttribute("y", "0");
                zoomOutBackground.setAttribute("width", "1500");
                zoomOutBackground.setAttribute("height", "1400");
                zoomOutBackground.setAttribute("class", "svg-pan-zoom-control-background");
                zoomOut.appendChild(zoomOutBackground);
                var zoomOutShape = document.createElementNS(SvgUtils.svgNS, "path");
                zoomOutShape.setAttribute("d", "M1280 576v128q0 26 -19 45t-45 19h-896q-26 0 -45 -19t-19 -45v-128q0 -26 19 -45t45 -19h896q26 0 45 19t19 45zM1536 1120v-960q0 -119 -84.5 -203.5t-203.5 -84.5h-960q-119 0 -203.5 84.5t-84.5 203.5v960q0 119 84.5 203.5t203.5 84.5h960q119 0 203.5 -84.5 t84.5 -203.5z");
                zoomOutShape.setAttribute("class", "svg-pan-zoom-control-element");
                zoomOut.appendChild(zoomOutShape);
                return zoomOut;
            },
            disable: function(instance) {
                if (instance.controlIcons) {
                    instance.controlIcons.parentNode.removeChild(instance.controlIcons);
                    instance.controlIcons = null;
                }
            }
        };
    }, {
        "./svg-utilities": 5
    } ],
    3: [ function(require, module, exports) {
        var SvgUtils = require("./svg-utilities"), Utils = require("./utilities");
        var ShadowViewport = function(viewport, options) {
            this.init(viewport, options);
        };
        ShadowViewport.prototype.init = function(viewport, options) {
            this.viewport = viewport;
            this.options = options;
            this.originalState = {
                zoom: 1,
                x: 0,
                y: 0
            };
            this.activeState = {
                zoom: 1,
                x: 0,
                y: 0
            };
            this.updateCTMCached = Utils.proxy(this.updateCTM, this);
            this.requestAnimationFrame = Utils.createRequestAnimationFrame(this.options.refreshRate);
            this.viewBox = {
                x: 0,
                y: 0,
                width: 0,
                height: 0
            };
            this.cacheViewBox();
            this.processCTM();
            this.updateCTM();
        };
        ShadowViewport.prototype.cacheViewBox = function() {
            var svgViewBox = this.options.svg.getAttribute("viewBox");
            if (svgViewBox) {
                var viewBoxValues = svgViewBox.split(/[\s\,]/).filter(function(v) {
                    return v;
                }).map(parseFloat);
                this.viewBox.x = viewBoxValues[0];
                this.viewBox.y = viewBoxValues[1];
                this.viewBox.width = viewBoxValues[2];
                this.viewBox.height = viewBoxValues[3];
                var zoom = Math.min(this.options.width / this.viewBox.width, this.options.height / this.viewBox.height);
                this.activeState.zoom = zoom;
                this.activeState.x = (this.options.width - this.viewBox.width * zoom) / 2;
                this.activeState.y = (this.options.height - this.viewBox.height * zoom) / 2;
                this.updateCTMOnNextFrame();
                this.options.svg.removeAttribute("viewBox");
            } else {
                var bBox = this.viewport.getBBox();
                this.viewBox.x = bBox.x;
                this.viewBox.y = bBox.y;
                this.viewBox.width = bBox.width;
                this.viewBox.height = bBox.height;
            }
        };
        ShadowViewport.prototype.recacheViewBox = function() {
            var boundingClientRect = this.viewport.getBoundingClientRect(), viewBoxWidth = boundingClientRect.width / this.getZoom(), viewBoxHeight = boundingClientRect.height / this.getZoom();
            this.viewBox.x = 0;
            this.viewBox.y = 0;
            this.viewBox.width = viewBoxWidth;
            this.viewBox.height = viewBoxHeight;
        };
        ShadowViewport.prototype.getViewBox = function() {
            return Utils.extend({}, this.viewBox);
        };
        ShadowViewport.prototype.processCTM = function() {
            var newCTM = this.getCTM();
            if (this.options.fit || this.options.contain) {
                var newScale;
                if (this.options.fit) {
                    newScale = Math.min(this.options.width / this.viewBox.width, this.options.height / this.viewBox.height);
                } else {
                    newScale = Math.max(this.options.width / this.viewBox.width, this.options.height / this.viewBox.height);
                }
                newCTM.a = newScale;
                newCTM.d = newScale;
                newCTM.e = -this.viewBox.x * newScale;
                newCTM.f = -this.viewBox.y * newScale;
            }
            if (this.options.center) {
                var offsetX = (this.options.width - (this.viewBox.width + this.viewBox.x * 2) * newCTM.a) * .5, offsetY = (this.options.height - (this.viewBox.height + this.viewBox.y * 2) * newCTM.a) * .5;
                newCTM.e = offsetX;
                newCTM.f = offsetY;
            }
            this.originalState.zoom = newCTM.a;
            this.originalState.x = newCTM.e;
            this.originalState.y = newCTM.f;
            this.setCTM(newCTM);
        };
        ShadowViewport.prototype.getOriginalState = function() {
            return Utils.extend({}, this.originalState);
        };
        ShadowViewport.prototype.getState = function() {
            return Utils.extend({}, this.activeState);
        };
        ShadowViewport.prototype.getZoom = function() {
            return this.activeState.zoom;
        };
        ShadowViewport.prototype.getRelativeZoom = function() {
            return this.activeState.zoom / this.originalState.zoom;
        };
        ShadowViewport.prototype.computeRelativeZoom = function(scale) {
            return scale / this.originalState.zoom;
        };
        ShadowViewport.prototype.getPan = function() {
            return {
                x: this.activeState.x,
                y: this.activeState.y
            };
        };
        ShadowViewport.prototype.getCTM = function() {
            var safeCTM = this.options.svg.createSVGMatrix();
            safeCTM.a = this.activeState.zoom;
            safeCTM.b = 0;
            safeCTM.c = 0;
            safeCTM.d = this.activeState.zoom;
            safeCTM.e = this.activeState.x;
            safeCTM.f = this.activeState.y;
            return safeCTM;
        };
        ShadowViewport.prototype.setCTM = function(newCTM) {
            var willZoom = this.isZoomDifferent(newCTM), willPan = this.isPanDifferent(newCTM);
            if (willZoom || willPan) {
                if (willZoom) {
                    if (this.options.beforeZoom(this.getRelativeZoom(), this.computeRelativeZoom(newCTM.a)) === false) {
                        newCTM.a = newCTM.d = this.activeState.zoom;
                        willZoom = false;
                    }
                }
                if (willPan) {
                    var preventPan = this.options.beforePan(this.getPan(), {
                        x: newCTM.e,
                        y: newCTM.f
                    }), preventPanX = false, preventPanY = false;
                    if (preventPan === false) {
                        newCTM.e = this.getPan().x;
                        newCTM.f = this.getPan().y;
                        preventPanX = preventPanY = true;
                    } else if (Utils.isObject(preventPan)) {
                        if (preventPan.x === false) {
                            newCTM.e = this.getPan().x;
                            preventPanX = true;
                        } else if (Utils.isNumber(preventPan.x)) {
                            newCTM.e = preventPan.x;
                        }
                        if (preventPan.y === false) {
                            newCTM.f = this.getPan().y;
                            preventPanY = true;
                        } else if (Utils.isNumber(preventPan.y)) {
                            newCTM.f = preventPan.y;
                        }
                    }
                    if (preventPanX && preventPanY) {
                        willPan = false;
                    }
                }
                if (willZoom || willPan) {
                    this.updateCache(newCTM);
                    this.updateCTMOnNextFrame();
                    if (willZoom) {
                        this.options.onZoom(this.getRelativeZoom());
                    }
                    if (willPan) {
                        this.options.onPan(this.getPan());
                    }
                }
            }
        };
        ShadowViewport.prototype.isZoomDifferent = function(newCTM) {
            return this.activeState.zoom !== newCTM.a;
        };
        ShadowViewport.prototype.isPanDifferent = function(newCTM) {
            return this.activeState.x !== newCTM.e || this.activeState.y !== newCTM.f;
        };
        ShadowViewport.prototype.updateCache = function(newCTM) {
            this.activeState.zoom = newCTM.a;
            this.activeState.x = newCTM.e;
            this.activeState.y = newCTM.f;
        };
        ShadowViewport.prototype.pendingUpdate = false;
        ShadowViewport.prototype.updateCTMOnNextFrame = function() {
            if (!this.pendingUpdate) {
                this.pendingUpdate = true;
                this.requestAnimationFrame.call(window, this.updateCTMCached);
            }
        };
        ShadowViewport.prototype.updateCTM = function() {
            SvgUtils.setCTM(this.viewport, this.getCTM(), this.defs);
            this.pendingUpdate = false;
        };
        module.exports = function(viewport, options) {
            return new ShadowViewport(viewport, options);
        };
    }, {
        "./svg-utilities": 5,
        "./utilities": 7
    } ],
    4: [ function(require, module, exports) {
        var Wheel = require("./uniwheel"), ControlIcons = require("./control-icons"), Utils = require("./utilities"), SvgUtils = require("./svg-utilities"), ShadowViewport = require("./shadow-viewport");
        var SvgPanZoom = function(svg, options) {
            this.init(svg, options);
        };
        var optionsDefaults = {
            viewportSelector: ".svg-pan-zoom_viewport",
            panEnabled: true,
            controlIconsEnabled: false,
            zoomEnabled: true,
            dblClickZoomEnabled: true,
            mouseWheelZoomEnabled: true,
            preventMouseEventsDefault: true,
            zoomScaleSensitivity: .1,
            minZoom: .5,
            maxZoom: 10,
            fit: true,
            contain: false,
            center: true,
            refreshRate: "auto",
            beforeZoom: null,
            onZoom: null,
            beforePan: null,
            onPan: null,
            customEventsHandler: null,
            eventsListenerElement: null
        };
        SvgPanZoom.prototype.init = function(svg, options) {
            var that = this;
            this.svg = svg;
            this.defs = svg.querySelector("defs");
            SvgUtils.setupSvgAttributes(this.svg);
            this.options = Utils.extend(Utils.extend({}, optionsDefaults), options);
            this.state = "none";
            var boundingClientRectNormalized = SvgUtils.getBoundingClientRectNormalized(svg);
            this.width = boundingClientRectNormalized.width;
            this.height = boundingClientRectNormalized.height;
            this.viewport = ShadowViewport(SvgUtils.getOrCreateViewport(this.svg, this.options.viewportSelector), {
                svg: this.svg,
                width: this.width,
                height: this.height,
                fit: this.options.fit,
                contain: this.options.contain,
                center: this.options.center,
                refreshRate: this.options.refreshRate,
                beforeZoom: function(oldScale, newScale) {
                    if (that.viewport && that.options.beforeZoom) {
                        return that.options.beforeZoom(oldScale, newScale);
                    }
                },
                onZoom: function(scale) {
                    if (that.viewport && that.options.onZoom) {
                        return that.options.onZoom(scale);
                    }
                },
                beforePan: function(oldPoint, newPoint) {
                    if (that.viewport && that.options.beforePan) {
                        return that.options.beforePan(oldPoint, newPoint);
                    }
                },
                onPan: function(point) {
                    if (that.viewport && that.options.onPan) {
                        return that.options.onPan(point);
                    }
                }
            });
            var publicInstance = this.getPublicInstance();
            publicInstance.setBeforeZoom(this.options.beforeZoom);
            publicInstance.setOnZoom(this.options.onZoom);
            publicInstance.setBeforePan(this.options.beforePan);
            publicInstance.setOnPan(this.options.onPan);
            if (this.options.controlIconsEnabled) {
                ControlIcons.enable(this);
            }
            this.lastMouseWheelEventTime = Date.now();
            this.setupHandlers();
        };
        SvgPanZoom.prototype.setupHandlers = function() {
            var that = this, prevEvt = null;
            this.eventListeners = {
                mousedown: function(evt) {
                    var result = that.handleMouseDown(evt, prevEvt);
                    prevEvt = evt;
                    return result;
                },
                touchstart: function(evt) {
                    var result = that.handleMouseDown(evt, prevEvt);
                    prevEvt = evt;
                    return result;
                },
                mouseup: function(evt) {
                    return that.handleMouseUp(evt);
                },
                touchend: function(evt) {
                    return that.handleMouseUp(evt);
                },
                mousemove: function(evt) {
                    return that.handleMouseMove(evt);
                },
                touchmove: function(evt) {
                    return that.handleMouseMove(evt);
                },
                mouseleave: function(evt) {
                    return that.handleMouseUp(evt);
                },
                touchleave: function(evt) {
                    return that.handleMouseUp(evt);
                },
                touchcancel: function(evt) {
                    return that.handleMouseUp(evt);
                }
            };
            if (this.options.customEventsHandler != null) {
                this.options.customEventsHandler.init({
                    svgElement: this.svg,
                    eventsListenerElement: this.options.eventsListenerElement,
                    instance: this.getPublicInstance()
                });
                var haltEventListeners = this.options.customEventsHandler.haltEventListeners;
                if (haltEventListeners && haltEventListeners.length) {
                    for (var i = haltEventListeners.length - 1; i >= 0; i--) {
                        if (this.eventListeners.hasOwnProperty(haltEventListeners[i])) {
                            delete this.eventListeners[haltEventListeners[i]];
                        }
                    }
                }
            }
            for (var event in this.eventListeners) {
                (this.options.eventsListenerElement || this.svg).addEventListener(event, this.eventListeners[event], false);
            }
            if (this.options.mouseWheelZoomEnabled) {
                this.options.mouseWheelZoomEnabled = false;
                this.enableMouseWheelZoom();
            }
        };
        SvgPanZoom.prototype.enableMouseWheelZoom = function() {
            if (!this.options.mouseWheelZoomEnabled) {
                var that = this;
                this.wheelListener = function(evt) {
                    return that.handleMouseWheel(evt);
                };
                Wheel.on(this.options.eventsListenerElement || this.svg, this.wheelListener, false);
                this.options.mouseWheelZoomEnabled = true;
            }
        };
        SvgPanZoom.prototype.disableMouseWheelZoom = function() {
            if (this.options.mouseWheelZoomEnabled) {
                Wheel.off(this.options.eventsListenerElement || this.svg, this.wheelListener, false);
                this.options.mouseWheelZoomEnabled = false;
            }
        };
        SvgPanZoom.prototype.handleMouseWheel = function(evt) {
            if (!this.options.zoomEnabled || this.state !== "none") {
                return;
            }
            if (this.options.preventMouseEventsDefault) {
                if (evt.preventDefault) {
                    evt.preventDefault();
                } else {
                    evt.returnValue = false;
                }
            }
            var delta = evt.deltaY || 1, timeDelta = Date.now() - this.lastMouseWheelEventTime, divider = 3 + Math.max(0, 30 - timeDelta);
            this.lastMouseWheelEventTime = Date.now();
            if ("deltaMode" in evt && evt.deltaMode === 0 && evt.wheelDelta) {
                delta = evt.deltaY === 0 ? 0 : Math.abs(evt.wheelDelta) / evt.deltaY;
            }
            delta = -.3 < delta && delta < .3 ? delta : (delta > 0 ? 1 : -1) * Math.log(Math.abs(delta) + 10) / divider;
            var inversedScreenCTM = this.svg.getScreenCTM().inverse(), relativeMousePoint = SvgUtils.getEventPoint(evt, this.svg).matrixTransform(inversedScreenCTM), zoom = Math.pow(1 + this.options.zoomScaleSensitivity, -1 * delta);
            this.zoomAtPoint(zoom, relativeMousePoint);
        };
        SvgPanZoom.prototype.zoomAtPoint = function(zoomScale, point, zoomAbsolute) {
            var originalState = this.viewport.getOriginalState();
            if (!zoomAbsolute) {
                if (this.getZoom() * zoomScale < this.options.minZoom * originalState.zoom) {
                    zoomScale = this.options.minZoom * originalState.zoom / this.getZoom();
                } else if (this.getZoom() * zoomScale > this.options.maxZoom * originalState.zoom) {
                    zoomScale = this.options.maxZoom * originalState.zoom / this.getZoom();
                }
            } else {
                zoomScale = Math.max(this.options.minZoom * originalState.zoom, Math.min(this.options.maxZoom * originalState.zoom, zoomScale));
                zoomScale = zoomScale / this.getZoom();
            }
            var oldCTM = this.viewport.getCTM(), relativePoint = point.matrixTransform(oldCTM.inverse()), modifier = this.svg.createSVGMatrix().translate(relativePoint.x, relativePoint.y).scale(zoomScale).translate(-relativePoint.x, -relativePoint.y), newCTM = oldCTM.multiply(modifier);
            if (newCTM.a !== oldCTM.a) {
                this.viewport.setCTM(newCTM);
            }
        };
        SvgPanZoom.prototype.zoom = function(scale, absolute) {
            this.zoomAtPoint(scale, SvgUtils.getSvgCenterPoint(this.svg, this.width, this.height), absolute);
        };
        SvgPanZoom.prototype.publicZoom = function(scale, absolute) {
            if (absolute) {
                scale = this.computeFromRelativeZoom(scale);
            }
            this.zoom(scale, absolute);
        };
        SvgPanZoom.prototype.publicZoomAtPoint = function(scale, point, absolute) {
            if (absolute) {
                scale = this.computeFromRelativeZoom(scale);
            }
            if (Utils.getType(point) !== "SVGPoint") {
                if ("x" in point && "y" in point) {
                    point = SvgUtils.createSVGPoint(this.svg, point.x, point.y);
                } else {
                    throw new Error("Given point is invalid");
                }
            }
            this.zoomAtPoint(scale, point, absolute);
        };
        SvgPanZoom.prototype.getZoom = function() {
            return this.viewport.getZoom();
        };
        SvgPanZoom.prototype.getRelativeZoom = function() {
            return this.viewport.getRelativeZoom();
        };
        SvgPanZoom.prototype.computeFromRelativeZoom = function(zoom) {
            return zoom * this.viewport.getOriginalState().zoom;
        };
        SvgPanZoom.prototype.resetZoom = function() {
            var originalState = this.viewport.getOriginalState();
            this.zoom(originalState.zoom, true);
        };
        SvgPanZoom.prototype.resetPan = function() {
            this.pan(this.viewport.getOriginalState());
        };
        SvgPanZoom.prototype.reset = function() {
            this.resetZoom();
            this.resetPan();
        };
        SvgPanZoom.prototype.handleDblClick = function(evt) {
            if (this.options.preventMouseEventsDefault) {
                if (evt.preventDefault) {
                    evt.preventDefault();
                } else {
                    evt.returnValue = false;
                }
            }
            if (this.options.controlIconsEnabled) {
                var targetClass = evt.target.getAttribute("class") || "";
                if (targetClass.indexOf("svg-pan-zoom-control") > -1) {
                    return false;
                }
            }
            var zoomFactor;
            if (evt.shiftKey) {
                zoomFactor = 1 / ((1 + this.options.zoomScaleSensitivity) * 2);
            } else {
                zoomFactor = (1 + this.options.zoomScaleSensitivity) * 2;
            }
            var point = SvgUtils.getEventPoint(evt, this.svg).matrixTransform(this.svg.getScreenCTM().inverse());
            this.zoomAtPoint(zoomFactor, point);
        };
        SvgPanZoom.prototype.handleMouseDown = function(evt, prevEvt) {
            if (this.options.preventMouseEventsDefault) {
                if (evt.preventDefault) {
                    evt.preventDefault();
                } else {
                    evt.returnValue = false;
                }
            }
            Utils.mouseAndTouchNormalize(evt, this.svg);
            if (this.options.dblClickZoomEnabled && Utils.isDblClick(evt, prevEvt)) {
                this.handleDblClick(evt);
            } else {
                this.state = "pan";
                this.firstEventCTM = this.viewport.getCTM();
                this.stateOrigin = SvgUtils.getEventPoint(evt, this.svg).matrixTransform(this.firstEventCTM.inverse());
            }
        };
        SvgPanZoom.prototype.handleMouseMove = function(evt) {
            if (this.options.preventMouseEventsDefault) {
                if (evt.preventDefault) {
                    evt.preventDefault();
                } else {
                    evt.returnValue = false;
                }
            }
            if (this.state === "pan" && this.options.panEnabled) {
                var point = SvgUtils.getEventPoint(evt, this.svg).matrixTransform(this.firstEventCTM.inverse()), viewportCTM = this.firstEventCTM.translate(point.x - this.stateOrigin.x, point.y - this.stateOrigin.y);
                this.viewport.setCTM(viewportCTM);
            }
        };
        SvgPanZoom.prototype.handleMouseUp = function(evt) {
            if (this.options.preventMouseEventsDefault) {
                if (evt.preventDefault) {
                    evt.preventDefault();
                } else {
                    evt.returnValue = false;
                }
            }
            if (this.state === "pan") {
                this.state = "none";
            }
        };
        SvgPanZoom.prototype.fit = function() {
            var viewBox = this.viewport.getViewBox(), newScale = Math.min(this.width / viewBox.width, this.height / viewBox.height);
            this.zoom(newScale, true);
        };
        SvgPanZoom.prototype.contain = function() {
            var viewBox = this.viewport.getViewBox(), newScale = Math.max(this.width / viewBox.width, this.height / viewBox.height);
            this.zoom(newScale, true);
        };
        SvgPanZoom.prototype.center = function() {
            var viewBox = this.viewport.getViewBox(), offsetX = (this.width - (viewBox.width + viewBox.x * 2) * this.getZoom()) * .5, offsetY = (this.height - (viewBox.height + viewBox.y * 2) * this.getZoom()) * .5;
            this.getPublicInstance().pan({
                x: offsetX,
                y: offsetY
            });
        };
        SvgPanZoom.prototype.updateBBox = function() {
            this.viewport.recacheViewBox();
        };
        SvgPanZoom.prototype.pan = function(point) {
            var viewportCTM = this.viewport.getCTM();
            viewportCTM.e = point.x;
            viewportCTM.f = point.y;
            this.viewport.setCTM(viewportCTM);
        };
        SvgPanZoom.prototype.panBy = function(point) {
            var viewportCTM = this.viewport.getCTM();
            viewportCTM.e += point.x;
            viewportCTM.f += point.y;
            this.viewport.setCTM(viewportCTM);
        };
        SvgPanZoom.prototype.getPan = function() {
            var state = this.viewport.getState();
            return {
                x: state.x,
                y: state.y
            };
        };
        SvgPanZoom.prototype.resize = function() {
            var boundingClientRectNormalized = SvgUtils.getBoundingClientRectNormalized(this.svg);
            this.width = boundingClientRectNormalized.width;
            this.height = boundingClientRectNormalized.height;
            if (this.options.controlIconsEnabled) {
                this.getPublicInstance().disableControlIcons();
                this.getPublicInstance().enableControlIcons();
            }
        };
        SvgPanZoom.prototype.destroy = function() {
            var that = this;
            this.beforeZoom = null;
            this.onZoom = null;
            this.beforePan = null;
            this.onPan = null;
            if (this.options.customEventsHandler != null) {
                this.options.customEventsHandler.destroy({
                    svgElement: this.svg,
                    eventsListenerElement: this.options.eventsListenerElement,
                    instance: this.getPublicInstance()
                });
            }
            for (var event in this.eventListeners) {
                (this.options.eventsListenerElement || this.svg).removeEventListener(event, this.eventListeners[event], false);
            }
            this.disableMouseWheelZoom();
            this.getPublicInstance().disableControlIcons();
            this.reset();
            instancesStore = instancesStore.filter(function(instance) {
                return instance.svg !== that.svg;
            });
            delete this.options;
            delete this.publicInstance;
            delete this.pi;
            this.getPublicInstance = function() {
                return null;
            };
        };
        SvgPanZoom.prototype.getPublicInstance = function() {
            var that = this;
            if (!this.publicInstance) {
                this.publicInstance = this.pi = {
                    enablePan: function() {
                        that.options.panEnabled = true;
                        return that.pi;
                    },
                    disablePan: function() {
                        that.options.panEnabled = false;
                        return that.pi;
                    },
                    isPanEnabled: function() {
                        return !!that.options.panEnabled;
                    },
                    pan: function(point) {
                        that.pan(point);
                        return that.pi;
                    },
                    panBy: function(point) {
                        that.panBy(point);
                        return that.pi;
                    },
                    getPan: function() {
                        return that.getPan();
                    },
                    setBeforePan: function(fn) {
                        that.options.beforePan = fn === null ? null : Utils.proxy(fn, that.publicInstance);
                        return that.pi;
                    },
                    setOnPan: function(fn) {
                        that.options.onPan = fn === null ? null : Utils.proxy(fn, that.publicInstance);
                        return that.pi;
                    },
                    enableZoom: function() {
                        that.options.zoomEnabled = true;
                        return that.pi;
                    },
                    disableZoom: function() {
                        that.options.zoomEnabled = false;
                        return that.pi;
                    },
                    isZoomEnabled: function() {
                        return !!that.options.zoomEnabled;
                    },
                    enableControlIcons: function() {
                        if (!that.options.controlIconsEnabled) {
                            that.options.controlIconsEnabled = true;
                            ControlIcons.enable(that);
                        }
                        return that.pi;
                    },
                    disableControlIcons: function() {
                        if (that.options.controlIconsEnabled) {
                            that.options.controlIconsEnabled = false;
                            ControlIcons.disable(that);
                        }
                        return that.pi;
                    },
                    isControlIconsEnabled: function() {
                        return !!that.options.controlIconsEnabled;
                    },
                    enableDblClickZoom: function() {
                        that.options.dblClickZoomEnabled = true;
                        return that.pi;
                    },
                    disableDblClickZoom: function() {
                        that.options.dblClickZoomEnabled = false;
                        return that.pi;
                    },
                    isDblClickZoomEnabled: function() {
                        return !!that.options.dblClickZoomEnabled;
                    },
                    enableMouseWheelZoom: function() {
                        that.enableMouseWheelZoom();
                        return that.pi;
                    },
                    disableMouseWheelZoom: function() {
                        that.disableMouseWheelZoom();
                        return that.pi;
                    },
                    isMouseWheelZoomEnabled: function() {
                        return !!that.options.mouseWheelZoomEnabled;
                    },
                    setZoomScaleSensitivity: function(scale) {
                        that.options.zoomScaleSensitivity = scale;
                        return that.pi;
                    },
                    setMinZoom: function(zoom) {
                        that.options.minZoom = zoom;
                        return that.pi;
                    },
                    setMaxZoom: function(zoom) {
                        that.options.maxZoom = zoom;
                        return that.pi;
                    },
                    setBeforeZoom: function(fn) {
                        that.options.beforeZoom = fn === null ? null : Utils.proxy(fn, that.publicInstance);
                        return that.pi;
                    },
                    setOnZoom: function(fn) {
                        that.options.onZoom = fn === null ? null : Utils.proxy(fn, that.publicInstance);
                        return that.pi;
                    },
                    zoom: function(scale) {
                        that.publicZoom(scale, true);
                        return that.pi;
                    },
                    zoomBy: function(scale) {
                        that.publicZoom(scale, false);
                        return that.pi;
                    },
                    zoomAtPoint: function(scale, point) {
                        that.publicZoomAtPoint(scale, point, true);
                        return that.pi;
                    },
                    zoomAtPointBy: function(scale, point) {
                        that.publicZoomAtPoint(scale, point, false);
                        return that.pi;
                    },
                    zoomIn: function() {
                        this.zoomBy(1 + that.options.zoomScaleSensitivity);
                        return that.pi;
                    },
                    zoomOut: function() {
                        this.zoomBy(1 / (1 + that.options.zoomScaleSensitivity));
                        return that.pi;
                    },
                    getZoom: function() {
                        return that.getRelativeZoom();
                    },
                    resetZoom: function() {
                        that.resetZoom();
                        return that.pi;
                    },
                    resetPan: function() {
                        that.resetPan();
                        return that.pi;
                    },
                    reset: function() {
                        that.reset();
                        return that.pi;
                    },
                    fit: function() {
                        that.fit();
                        return that.pi;
                    },
                    contain: function() {
                        that.contain();
                        return that.pi;
                    },
                    center: function() {
                        that.center();
                        return that.pi;
                    },
                    updateBBox: function() {
                        that.updateBBox();
                        return that.pi;
                    },
                    resize: function() {
                        that.resize();
                        return that.pi;
                    },
                    getSizes: function() {
                        return {
                            width: that.width,
                            height: that.height,
                            realZoom: that.getZoom(),
                            viewBox: that.viewport.getViewBox()
                        };
                    },
                    destroy: function() {
                        that.destroy();
                        return that.pi;
                    }
                };
            }
            return this.publicInstance;
        };
        var instancesStore = [];
        var svgPanZoom = function(elementOrSelector, options) {
            var svg = Utils.getSvg(elementOrSelector);
            if (svg === null) {
                return null;
            } else {
                for (var i = instancesStore.length - 1; i >= 0; i--) {
                    if (instancesStore[i].svg === svg) {
                        return instancesStore[i].instance.getPublicInstance();
                    }
                }
                instancesStore.push({
                    svg: svg,
                    instance: new SvgPanZoom(svg, options)
                });
                return instancesStore[instancesStore.length - 1].instance.getPublicInstance();
            }
        };
        module.exports = svgPanZoom;
    }, {
        "./control-icons": 2,
        "./shadow-viewport": 3,
        "./svg-utilities": 5,
        "./uniwheel": 6,
        "./utilities": 7
    } ],
    5: [ function(require, module, exports) {
        var Utils = require("./utilities"), _browser = "unknown";
        if (false || !!document.documentMode) {
            _browser = "ie";
        }
        module.exports = {
            svgNS: "http://www.w3.org/2000/svg",
            xmlNS: "http://www.w3.org/XML/1998/namespace",
            xmlnsNS: "http://www.w3.org/2000/xmlns/",
            xlinkNS: "http://www.w3.org/1999/xlink",
            evNS: "http://www.w3.org/2001/xml-events",
            getBoundingClientRectNormalized: function(svg) {
                if (svg.clientWidth && svg.clientHeight) {
                    return {
                        width: svg.clientWidth,
                        height: svg.clientHeight
                    };
                } else if (!!svg.getBoundingClientRect()) {
                    return svg.getBoundingClientRect();
                } else {
                    throw new Error("Cannot get BoundingClientRect for SVG.");
                }
            },
            getOrCreateViewport: function(svg, selector) {
                var viewport = null;
                if (Utils.isElement(selector)) {
                    viewport = selector;
                } else {
                    viewport = svg.querySelector(selector);
                }
                if (!viewport) {
                    var childNodes = Array.prototype.slice.call(svg.childNodes || svg.children).filter(function(el) {
                        return el.nodeName !== "defs" && el.nodeName !== "#text";
                    });
                    if (childNodes.length === 1 && childNodes[0].nodeName === "g" && childNodes[0].getAttribute("transform") === null) {
                        viewport = childNodes[0];
                    }
                }
                if (!viewport) {
                    var viewportId = "viewport-" + new Date().toISOString().replace(/\D/g, "");
                    viewport = document.createElementNS(this.svgNS, "g");
                    viewport.setAttribute("id", viewportId);
                    var svgChildren = svg.childNodes || svg.children;
                    if (!!svgChildren && svgChildren.length > 0) {
                        for (var i = svgChildren.length; i > 0; i--) {
                            if (svgChildren[svgChildren.length - i].nodeName !== "defs") {
                                viewport.appendChild(svgChildren[svgChildren.length - i]);
                            }
                        }
                    }
                    svg.appendChild(viewport);
                }
                var classNames = [];
                if (viewport.getAttribute("class")) {
                    classNames = viewport.getAttribute("class").split(" ");
                }
                if (!~classNames.indexOf("svg-pan-zoom_viewport")) {
                    classNames.push("svg-pan-zoom_viewport");
                    viewport.setAttribute("class", classNames.join(" "));
                }
                return viewport;
            },
            setupSvgAttributes: function(svg) {
                svg.setAttribute("xmlns", this.svgNS);
                svg.setAttributeNS(this.xmlnsNS, "xmlns:xlink", this.xlinkNS);
                svg.setAttributeNS(this.xmlnsNS, "xmlns:ev", this.evNS);
                if (svg.parentNode !== null) {
                    var style = svg.getAttribute("style") || "";
                    if (style.toLowerCase().indexOf("overflow") === -1) {
                        svg.setAttribute("style", "overflow: hidden; " + style);
                    }
                }
            },
            internetExplorerRedisplayInterval: 300,
            refreshDefsGlobal: Utils.throttle(function() {
                var allDefs = document.querySelectorAll("defs");
                var allDefsCount = allDefs.length;
                for (var i = 0; i < allDefsCount; i++) {
                    var thisDefs = allDefs[i];
                    thisDefs.parentNode.insertBefore(thisDefs, thisDefs);
                }
            }, this.internetExplorerRedisplayInterval),
            setCTM: function(element, matrix, defs) {
                var that = this, s = "matrix(" + matrix.a + "," + matrix.b + "," + matrix.c + "," + matrix.d + "," + matrix.e + "," + matrix.f + ")";
                element.setAttributeNS(null, "transform", s);
                if ("transform" in element.style) {
                    element.style.transform = s;
                } else if ("-ms-transform" in element.style) {
                    element.style["-ms-transform"] = s;
                } else if ("-webkit-transform" in element.style) {
                    element.style["-webkit-transform"] = s;
                }
                if (_browser === "ie" && !!defs) {
                    defs.parentNode.insertBefore(defs, defs);
                    window.setTimeout(function() {
                        that.refreshDefsGlobal();
                    }, that.internetExplorerRedisplayInterval);
                }
            },
            getEventPoint: function(evt, svg) {
                var point = svg.createSVGPoint();
                Utils.mouseAndTouchNormalize(evt, svg);
                point.x = evt.clientX;
                point.y = evt.clientY;
                return point;
            },
            getSvgCenterPoint: function(svg, width, height) {
                return this.createSVGPoint(svg, width / 2, height / 2);
            },
            createSVGPoint: function(svg, x, y) {
                var point = svg.createSVGPoint();
                point.x = x;
                point.y = y;
                return point;
            }
        };
    }, {
        "./utilities": 7
    } ],
    6: [ function(require, module, exports) {
        module.exports = function() {
            var prefix = "", _addEventListener, _removeEventListener, onwheel, support, fns = [];
            if (window.addEventListener) {
                _addEventListener = "addEventListener";
                _removeEventListener = "removeEventListener";
            } else {
                _addEventListener = "attachEvent";
                _removeEventListener = "detachEvent";
                prefix = "on";
            }
            support = "onwheel" in document.createElement("div") ? "wheel" : document.onmousewheel !== undefined ? "mousewheel" : "DOMMouseScroll";
            function createCallback(element, callback, capture) {
                var fn = function(originalEvent) {
                    !originalEvent && (originalEvent = window.event);
                    var event = {
                        originalEvent: originalEvent,
                        target: originalEvent.target || originalEvent.srcElement,
                        type: "wheel",
                        deltaMode: originalEvent.type == "MozMousePixelScroll" ? 0 : 1,
                        deltaX: 0,
                        delatZ: 0,
                        preventDefault: function() {
                            originalEvent.preventDefault ? originalEvent.preventDefault() : originalEvent.returnValue = false;
                        }
                    };
                    if (support == "mousewheel") {
                        event.deltaY = -1 / 40 * originalEvent.wheelDelta;
                        originalEvent.wheelDeltaX && (event.deltaX = -1 / 40 * originalEvent.wheelDeltaX);
                    } else {
                        event.deltaY = originalEvent.detail;
                    }
                    return callback(event);
                };
                fns.push({
                    element: element,
                    fn: fn,
                    capture: capture
                });
                return fn;
            }
            function getCallback(element, capture) {
                for (var i = 0; i < fns.length; i++) {
                    if (fns[i].element === element && fns[i].capture === capture) {
                        return fns[i].fn;
                    }
                }
                return function() {};
            }
            function removeCallback(element, capture) {
                for (var i = 0; i < fns.length; i++) {
                    if (fns[i].element === element && fns[i].capture === capture) {
                        return fns.splice(i, 1);
                    }
                }
            }
            function _addWheelListener(elem, eventName, callback, useCapture) {
                var cb;
                if (support === "wheel") {
                    cb = callback;
                } else {
                    cb = createCallback(elem, callback, useCapture);
                }
                elem[_addEventListener](prefix + eventName, cb, useCapture || false);
            }
            function _removeWheelListener(elem, eventName, callback, useCapture) {
                if (support === "wheel") {
                    cb = callback;
                } else {
                    cb = getCallback(elem, useCapture);
                }
                elem[_removeEventListener](prefix + eventName, cb, useCapture || false);
                removeCallback(elem, useCapture);
            }
            function addWheelListener(elem, callback, useCapture) {
                _addWheelListener(elem, support, callback, useCapture);
                if (support == "DOMMouseScroll") {
                    _addWheelListener(elem, "MozMousePixelScroll", callback, useCapture);
                }
            }
            function removeWheelListener(elem, callback, useCapture) {
                _removeWheelListener(elem, support, callback, useCapture);
                if (support == "DOMMouseScroll") {
                    _removeWheelListener(elem, "MozMousePixelScroll", callback, useCapture);
                }
            }
            return {
                on: addWheelListener,
                off: removeWheelListener
            };
        }();
    }, {} ],
    7: [ function(require, module, exports) {
        module.exports = {
            extend: function(target, source) {
                target = target || {};
                for (var prop in source) {
                    if (this.isObject(source[prop])) {
                        target[prop] = this.extend(target[prop], source[prop]);
                    } else {
                        target[prop] = source[prop];
                    }
                }
                return target;
            },
            isElement: function(o) {
                return o instanceof HTMLElement || o instanceof SVGElement || o instanceof SVGSVGElement || o && typeof o === "object" && o !== null && o.nodeType === 1 && typeof o.nodeName === "string";
            },
            isObject: function(o) {
                return Object.prototype.toString.call(o) === "[object Object]";
            },
            isNumber: function(n) {
                return !isNaN(parseFloat(n)) && isFinite(n);
            },
            getSvg: function(elementOrSelector) {
                var element, svg;
                if (!this.isElement(elementOrSelector)) {
                    if (typeof elementOrSelector === "string" || elementOrSelector instanceof String) {
                        element = document.querySelector(elementOrSelector);
                        if (!element) {
                            throw new Error("Provided selector did not find any elements. Selector: " + elementOrSelector);
                            return null;
                        }
                    } else {
                        throw new Error("Provided selector is not an HTML object nor String");
                        return null;
                    }
                } else {
                    element = elementOrSelector;
                }
                if (element.tagName.toLowerCase() === "svg") {
                    svg = element;
                } else {
                    if (element.tagName.toLowerCase() === "object") {
                        svg = element.contentDocument.documentElement;
                    } else {
                        if (element.tagName.toLowerCase() === "embed") {
                            svg = element.getSVGDocument().documentElement;
                        } else {
                            if (element.tagName.toLowerCase() === "img") {
                                throw new Error('Cannot script an SVG in an "img" element. Please use an "object" element or an in-line SVG.');
                            } else {
                                throw new Error("Cannot get SVG.");
                            }
                            return null;
                        }
                    }
                }
                return svg;
            },
            proxy: function(fn, context) {
                return function() {
                    return fn.apply(context, arguments);
                };
            },
            getType: function(o) {
                return Object.prototype.toString.apply(o).replace(/^\[object\s/, "").replace(/\]$/, "");
            },
            mouseAndTouchNormalize: function(evt, svg) {
                if (evt.clientX === void 0 || evt.clientX === null) {
                    evt.clientX = 0;
                    evt.clientY = 0;
                    if (evt.changedTouches !== void 0 && evt.changedTouches.length) {
                        if (evt.changedTouches[0].clientX !== void 0) {
                            evt.clientX = evt.changedTouches[0].clientX;
                            evt.clientY = evt.changedTouches[0].clientY;
                        } else if (evt.changedTouches[0].pageX !== void 0) {
                            var rect = svg.getBoundingClientRect();
                            evt.clientX = evt.changedTouches[0].pageX - rect.left;
                            evt.clientY = evt.changedTouches[0].pageY - rect.top;
                        }
                    } else if (evt.originalEvent !== void 0) {
                        if (evt.originalEvent.clientX !== void 0) {
                            evt.clientX = evt.originalEvent.clientX;
                            evt.clientY = evt.originalEvent.clientY;
                        }
                    }
                }
            },
            isDblClick: function(evt, prevEvt) {
                if (evt.detail === 2) {
                    return true;
                } else if (prevEvt !== void 0 && prevEvt !== null) {
                    var timeStampDiff = evt.timeStamp - prevEvt.timeStamp, touchesDistance = Math.sqrt(Math.pow(evt.clientX - prevEvt.clientX, 2) + Math.pow(evt.clientY - prevEvt.clientY, 2));
                    return timeStampDiff < 250 && touchesDistance < 10;
                }
                return false;
            },
            now: Date.now || function() {
                return new Date().getTime();
            },
            throttle: function(func, wait, options) {
                var that = this;
                var context, args, result;
                var timeout = null;
                var previous = 0;
                if (!options) options = {};
                var later = function() {
                    previous = options.leading === false ? 0 : that.now();
                    timeout = null;
                    result = func.apply(context, args);
                    if (!timeout) context = args = null;
                };
                return function() {
                    var now = that.now();
                    if (!previous && options.leading === false) previous = now;
                    var remaining = wait - (now - previous);
                    context = this;
                    args = arguments;
                    if (remaining <= 0 || remaining > wait) {
                        clearTimeout(timeout);
                        timeout = null;
                        previous = now;
                        result = func.apply(context, args);
                        if (!timeout) context = args = null;
                    } else if (!timeout && options.trailing !== false) {
                        timeout = setTimeout(later, remaining);
                    }
                    return result;
                };
            },
            createRequestAnimationFrame: function(refreshRate) {
                var timeout = null;
                if (refreshRate !== "auto" && refreshRate < 60 && refreshRate > 1) {
                    timeout = Math.floor(1e3 / refreshRate);
                }
                if (timeout === null) {
                    return window.requestAnimationFrame || requestTimeout(33);
                } else {
                    return requestTimeout(timeout);
                }
            }
        };
        function requestTimeout(timeout) {
            return function(callback) {
                window.setTimeout(callback, timeout);
            };
        }
    }, {} ]
}, {}, [ 1 ]);

!function() {
    var d3 = {
        version: "3.5.17"
    };
    var d3_arraySlice = [].slice, d3_array = function(list) {
        return d3_arraySlice.call(list);
    };
    var d3_document = this.document;
    function d3_documentElement(node) {
        return node && (node.ownerDocument || node.document || node).documentElement;
    }
    function d3_window(node) {
        return node && (node.ownerDocument && node.ownerDocument.defaultView || node.document && node || node.defaultView);
    }
    if (d3_document) {
        try {
            d3_array(d3_document.documentElement.childNodes)[0].nodeType;
        } catch (e) {
            d3_array = function(list) {
                var i = list.length, array = new Array(i);
                while (i--) array[i] = list[i];
                return array;
            };
        }
    }
    if (!Date.now) Date.now = function() {
        return +new Date();
    };
    if (d3_document) {
        try {
            d3_document.createElement("DIV").style.setProperty("opacity", 0, "");
        } catch (error) {
            var d3_element_prototype = this.Element.prototype, d3_element_setAttribute = d3_element_prototype.setAttribute, d3_element_setAttributeNS = d3_element_prototype.setAttributeNS, d3_style_prototype = this.CSSStyleDeclaration.prototype, d3_style_setProperty = d3_style_prototype.setProperty;
            d3_element_prototype.setAttribute = function(name, value) {
                d3_element_setAttribute.call(this, name, value + "");
            };
            d3_element_prototype.setAttributeNS = function(space, local, value) {
                d3_element_setAttributeNS.call(this, space, local, value + "");
            };
            d3_style_prototype.setProperty = function(name, value, priority) {
                d3_style_setProperty.call(this, name, value + "", priority);
            };
        }
    }
    d3.ascending = d3_ascending;
    function d3_ascending(a, b) {
        return a < b ? -1 : a > b ? 1 : a >= b ? 0 : NaN;
    }
    d3.descending = function(a, b) {
        return b < a ? -1 : b > a ? 1 : b >= a ? 0 : NaN;
    };
    d3.min = function(array, f) {
        var i = -1, n = array.length, a, b;
        if (arguments.length === 1) {
            while (++i < n) if ((b = array[i]) != null && b >= b) {
                a = b;
                break;
            }
            while (++i < n) if ((b = array[i]) != null && a > b) a = b;
        } else {
            while (++i < n) if ((b = f.call(array, array[i], i)) != null && b >= b) {
                a = b;
                break;
            }
            while (++i < n) if ((b = f.call(array, array[i], i)) != null && a > b) a = b;
        }
        return a;
    };
    d3.max = function(array, f) {
        var i = -1, n = array.length, a, b;
        if (arguments.length === 1) {
            while (++i < n) if ((b = array[i]) != null && b >= b) {
                a = b;
                break;
            }
            while (++i < n) if ((b = array[i]) != null && b > a) a = b;
        } else {
            while (++i < n) if ((b = f.call(array, array[i], i)) != null && b >= b) {
                a = b;
                break;
            }
            while (++i < n) if ((b = f.call(array, array[i], i)) != null && b > a) a = b;
        }
        return a;
    };
    d3.extent = function(array, f) {
        var i = -1, n = array.length, a, b, c;
        if (arguments.length === 1) {
            while (++i < n) if ((b = array[i]) != null && b >= b) {
                a = c = b;
                break;
            }
            while (++i < n) if ((b = array[i]) != null) {
                if (a > b) a = b;
                if (c < b) c = b;
            }
        } else {
            while (++i < n) if ((b = f.call(array, array[i], i)) != null && b >= b) {
                a = c = b;
                break;
            }
            while (++i < n) if ((b = f.call(array, array[i], i)) != null) {
                if (a > b) a = b;
                if (c < b) c = b;
            }
        }
        return [ a, c ];
    };
    function d3_number(x) {
        return x === null ? NaN : +x;
    }
    function d3_numeric(x) {
        return !isNaN(x);
    }
    d3.sum = function(array, f) {
        var s = 0, n = array.length, a, i = -1;
        if (arguments.length === 1) {
            while (++i < n) if (d3_numeric(a = +array[i])) s += a;
        } else {
            while (++i < n) if (d3_numeric(a = +f.call(array, array[i], i))) s += a;
        }
        return s;
    };
    d3.mean = function(array, f) {
        var s = 0, n = array.length, a, i = -1, j = n;
        if (arguments.length === 1) {
            while (++i < n) if (d3_numeric(a = d3_number(array[i]))) s += a; else --j;
        } else {
            while (++i < n) if (d3_numeric(a = d3_number(f.call(array, array[i], i)))) s += a; else --j;
        }
        if (j) return s / j;
    };
    d3.quantile = function(values, p) {
        var H = (values.length - 1) * p + 1, h = Math.floor(H), v = +values[h - 1], e = H - h;
        return e ? v + e * (values[h] - v) : v;
    };
    d3.median = function(array, f) {
        var numbers = [], n = array.length, a, i = -1;
        if (arguments.length === 1) {
            while (++i < n) if (d3_numeric(a = d3_number(array[i]))) numbers.push(a);
        } else {
            while (++i < n) if (d3_numeric(a = d3_number(f.call(array, array[i], i)))) numbers.push(a);
        }
        if (numbers.length) return d3.quantile(numbers.sort(d3_ascending), .5);
    };
    d3.variance = function(array, f) {
        var n = array.length, m = 0, a, d, s = 0, i = -1, j = 0;
        if (arguments.length === 1) {
            while (++i < n) {
                if (d3_numeric(a = d3_number(array[i]))) {
                    d = a - m;
                    m += d / ++j;
                    s += d * (a - m);
                }
            }
        } else {
            while (++i < n) {
                if (d3_numeric(a = d3_number(f.call(array, array[i], i)))) {
                    d = a - m;
                    m += d / ++j;
                    s += d * (a - m);
                }
            }
        }
        if (j > 1) return s / (j - 1);
    };
    d3.deviation = function() {
        var v = d3.variance.apply(this, arguments);
        return v ? Math.sqrt(v) : v;
    };
    function d3_bisector(compare) {
        return {
            left: function(a, x, lo, hi) {
                if (arguments.length < 3) lo = 0;
                if (arguments.length < 4) hi = a.length;
                while (lo < hi) {
                    var mid = lo + hi >>> 1;
                    if (compare(a[mid], x) < 0) lo = mid + 1; else hi = mid;
                }
                return lo;
            },
            right: function(a, x, lo, hi) {
                if (arguments.length < 3) lo = 0;
                if (arguments.length < 4) hi = a.length;
                while (lo < hi) {
                    var mid = lo + hi >>> 1;
                    if (compare(a[mid], x) > 0) hi = mid; else lo = mid + 1;
                }
                return lo;
            }
        };
    }
    var d3_bisect = d3_bisector(d3_ascending);
    d3.bisectLeft = d3_bisect.left;
    d3.bisect = d3.bisectRight = d3_bisect.right;
    d3.bisector = function(f) {
        return d3_bisector(f.length === 1 ? function(d, x) {
            return d3_ascending(f(d), x);
        } : f);
    };
    d3.shuffle = function(array, i0, i1) {
        if ((m = arguments.length) < 3) {
            i1 = array.length;
            if (m < 2) i0 = 0;
        }
        var m = i1 - i0, t, i;
        while (m) {
            i = Math.random() * m-- | 0;
            t = array[m + i0], array[m + i0] = array[i + i0], array[i + i0] = t;
        }
        return array;
    };
    d3.permute = function(array, indexes) {
        var i = indexes.length, permutes = new Array(i);
        while (i--) permutes[i] = array[indexes[i]];
        return permutes;
    };
    d3.pairs = function(array) {
        var i = 0, n = array.length - 1, p0, p1 = array[0], pairs = new Array(n < 0 ? 0 : n);
        while (i < n) pairs[i] = [ p0 = p1, p1 = array[++i] ];
        return pairs;
    };
    d3.transpose = function(matrix) {
        if (!(n = matrix.length)) return [];
        for (var i = -1, m = d3.min(matrix, d3_transposeLength), transpose = new Array(m); ++i < m; ) {
            for (var j = -1, n, row = transpose[i] = new Array(n); ++j < n; ) {
                row[j] = matrix[j][i];
            }
        }
        return transpose;
    };
    function d3_transposeLength(d) {
        return d.length;
    }
    d3.zip = function() {
        return d3.transpose(arguments);
    };
    d3.keys = function(map) {
        var keys = [];
        for (var key in map) keys.push(key);
        return keys;
    };
    d3.values = function(map) {
        var values = [];
        for (var key in map) values.push(map[key]);
        return values;
    };
    d3.entries = function(map) {
        var entries = [];
        for (var key in map) entries.push({
            key: key,
            value: map[key]
        });
        return entries;
    };
    d3.merge = function(arrays) {
        var n = arrays.length, m, i = -1, j = 0, merged, array;
        while (++i < n) j += arrays[i].length;
        merged = new Array(j);
        while (--n >= 0) {
            array = arrays[n];
            m = array.length;
            while (--m >= 0) {
                merged[--j] = array[m];
            }
        }
        return merged;
    };
    var abs = Math.abs;
    d3.range = function(start, stop, step) {
        if (arguments.length < 3) {
            step = 1;
            if (arguments.length < 2) {
                stop = start;
                start = 0;
            }
        }
        if ((stop - start) / step === Infinity) throw new Error("infinite range");
        var range = [], k = d3_range_integerScale(abs(step)), i = -1, j;
        start *= k, stop *= k, step *= k;
        if (step < 0) while ((j = start + step * ++i) > stop) range.push(j / k); else while ((j = start + step * ++i) < stop) range.push(j / k);
        return range;
    };
    function d3_range_integerScale(x) {
        var k = 1;
        while (x * k % 1) k *= 10;
        return k;
    }
    function d3_class(ctor, properties) {
        for (var key in properties) {
            Object.defineProperty(ctor.prototype, key, {
                value: properties[key],
                enumerable: false
            });
        }
    }
    d3.map = function(object, f) {
        var map = new d3_Map();
        if (object instanceof d3_Map) {
            object.forEach(function(key, value) {
                map.set(key, value);
            });
        } else if (Array.isArray(object)) {
            var i = -1, n = object.length, o;
            if (arguments.length === 1) while (++i < n) map.set(i, object[i]); else while (++i < n) map.set(f.call(object, o = object[i], i), o);
        } else {
            for (var key in object) map.set(key, object[key]);
        }
        return map;
    };
    function d3_Map() {
        this._ = Object.create(null);
    }
    var d3_map_proto = "__proto__", d3_map_zero = "\0";
    d3_class(d3_Map, {
        has: d3_map_has,
        get: function(key) {
            return this._[d3_map_escape(key)];
        },
        set: function(key, value) {
            return this._[d3_map_escape(key)] = value;
        },
        remove: d3_map_remove,
        keys: d3_map_keys,
        values: function() {
            var values = [];
            for (var key in this._) values.push(this._[key]);
            return values;
        },
        entries: function() {
            var entries = [];
            for (var key in this._) entries.push({
                key: d3_map_unescape(key),
                value: this._[key]
            });
            return entries;
        },
        size: d3_map_size,
        empty: d3_map_empty,
        forEach: function(f) {
            for (var key in this._) f.call(this, d3_map_unescape(key), this._[key]);
        }
    });
    function d3_map_escape(key) {
        return (key += "") === d3_map_proto || key[0] === d3_map_zero ? d3_map_zero + key : key;
    }
    function d3_map_unescape(key) {
        return (key += "")[0] === d3_map_zero ? key.slice(1) : key;
    }
    function d3_map_has(key) {
        return d3_map_escape(key) in this._;
    }
    function d3_map_remove(key) {
        return (key = d3_map_escape(key)) in this._ && delete this._[key];
    }
    function d3_map_keys() {
        var keys = [];
        for (var key in this._) keys.push(d3_map_unescape(key));
        return keys;
    }
    function d3_map_size() {
        var size = 0;
        for (var key in this._) ++size;
        return size;
    }
    function d3_map_empty() {
        for (var key in this._) return false;
        return true;
    }
    d3.nest = function() {
        var nest = {}, keys = [], sortKeys = [], sortValues, rollup;
        function map(mapType, array, depth) {
            if (depth >= keys.length) return rollup ? rollup.call(nest, array) : sortValues ? array.sort(sortValues) : array;
            var i = -1, n = array.length, key = keys[depth++], keyValue, object, setter, valuesByKey = new d3_Map(), values;
            while (++i < n) {
                if (values = valuesByKey.get(keyValue = key(object = array[i]))) {
                    values.push(object);
                } else {
                    valuesByKey.set(keyValue, [ object ]);
                }
            }
            if (mapType) {
                object = mapType();
                setter = function(keyValue, values) {
                    object.set(keyValue, map(mapType, values, depth));
                };
            } else {
                object = {};
                setter = function(keyValue, values) {
                    object[keyValue] = map(mapType, values, depth);
                };
            }
            valuesByKey.forEach(setter);
            return object;
        }
        function entries(map, depth) {
            if (depth >= keys.length) return map;
            var array = [], sortKey = sortKeys[depth++];
            map.forEach(function(key, keyMap) {
                array.push({
                    key: key,
                    values: entries(keyMap, depth)
                });
            });
            return sortKey ? array.sort(function(a, b) {
                return sortKey(a.key, b.key);
            }) : array;
        }
        nest.map = function(array, mapType) {
            return map(mapType, array, 0);
        };
        nest.entries = function(array) {
            return entries(map(d3.map, array, 0), 0);
        };
        nest.key = function(d) {
            keys.push(d);
            return nest;
        };
        nest.sortKeys = function(order) {
            sortKeys[keys.length - 1] = order;
            return nest;
        };
        nest.sortValues = function(order) {
            sortValues = order;
            return nest;
        };
        nest.rollup = function(f) {
            rollup = f;
            return nest;
        };
        return nest;
    };
    d3.set = function(array) {
        var set = new d3_Set();
        if (array) for (var i = 0, n = array.length; i < n; ++i) set.add(array[i]);
        return set;
    };
    function d3_Set() {
        this._ = Object.create(null);
    }
    d3_class(d3_Set, {
        has: d3_map_has,
        add: function(key) {
            this._[d3_map_escape(key += "")] = true;
            return key;
        },
        remove: d3_map_remove,
        values: d3_map_keys,
        size: d3_map_size,
        empty: d3_map_empty,
        forEach: function(f) {
            for (var key in this._) f.call(this, d3_map_unescape(key));
        }
    });
    d3.behavior = {};
    function d3_identity(d) {
        return d;
    }
    d3.rebind = function(target, source) {
        var i = 1, n = arguments.length, method;
        while (++i < n) target[method = arguments[i]] = d3_rebind(target, source, source[method]);
        return target;
    };
    function d3_rebind(target, source, method) {
        return function() {
            var value = method.apply(source, arguments);
            return value === source ? target : value;
        };
    }
    function d3_vendorSymbol(object, name) {
        if (name in object) return name;
        name = name.charAt(0).toUpperCase() + name.slice(1);
        for (var i = 0, n = d3_vendorPrefixes.length; i < n; ++i) {
            var prefixName = d3_vendorPrefixes[i] + name;
            if (prefixName in object) return prefixName;
        }
    }
    var d3_vendorPrefixes = [ "webkit", "ms", "moz", "Moz", "o", "O" ];
    function d3_noop() {}
    d3.dispatch = function() {
        var dispatch = new d3_dispatch(), i = -1, n = arguments.length;
        while (++i < n) dispatch[arguments[i]] = d3_dispatch_event(dispatch);
        return dispatch;
    };
    function d3_dispatch() {}
    d3_dispatch.prototype.on = function(type, listener) {
        var i = type.indexOf("."), name = "";
        if (i >= 0) {
            name = type.slice(i + 1);
            type = type.slice(0, i);
        }
        if (type) return arguments.length < 2 ? this[type].on(name) : this[type].on(name, listener);
        if (arguments.length === 2) {
            if (listener == null) for (type in this) {
                if (this.hasOwnProperty(type)) this[type].on(name, null);
            }
            return this;
        }
    };
    function d3_dispatch_event(dispatch) {
        var listeners = [], listenerByName = new d3_Map();
        function event() {
            var z = listeners, i = -1, n = z.length, l;
            while (++i < n) if (l = z[i].on) l.apply(this, arguments);
            return dispatch;
        }
        event.on = function(name, listener) {
            var l = listenerByName.get(name), i;
            if (arguments.length < 2) return l && l.on;
            if (l) {
                l.on = null;
                listeners = listeners.slice(0, i = listeners.indexOf(l)).concat(listeners.slice(i + 1));
                listenerByName.remove(name);
            }
            if (listener) listeners.push(listenerByName.set(name, {
                on: listener
            }));
            return dispatch;
        };
        return event;
    }
    d3.event = null;
    function d3_eventPreventDefault() {
        d3.event.preventDefault();
    }
    function d3_eventSource() {
        var e = d3.event, s;
        while (s = e.sourceEvent) e = s;
        return e;
    }
    function d3_eventDispatch(target) {
        var dispatch = new d3_dispatch(), i = 0, n = arguments.length;
        while (++i < n) dispatch[arguments[i]] = d3_dispatch_event(dispatch);
        dispatch.of = function(thiz, argumentz) {
            return function(e1) {
                try {
                    var e0 = e1.sourceEvent = d3.event;
                    e1.target = target;
                    d3.event = e1;
                    dispatch[e1.type].apply(thiz, argumentz);
                } finally {
                    d3.event = e0;
                }
            };
        };
        return dispatch;
    }
    d3.requote = function(s) {
        return s.replace(d3_requote_re, "\\$&");
    };
    var d3_requote_re = /[\\\^\$\*\+\?\|\[\]\(\)\.\{\}]/g;
    var d3_subclass = {}.__proto__ ? function(object, prototype) {
        object.__proto__ = prototype;
    } : function(object, prototype) {
        for (var property in prototype) object[property] = prototype[property];
    };
    function d3_selection(groups) {
        d3_subclass(groups, d3_selectionPrototype);
        return groups;
    }
    var d3_select = function(s, n) {
        return n.querySelector(s);
    }, d3_selectAll = function(s, n) {
        return n.querySelectorAll(s);
    }, d3_selectMatches = function(n, s) {
        var d3_selectMatcher = n.matches || n[d3_vendorSymbol(n, "matchesSelector")];
        d3_selectMatches = function(n, s) {
            return d3_selectMatcher.call(n, s);
        };
        return d3_selectMatches(n, s);
    };
    if (typeof Sizzle === "function") {
        d3_select = function(s, n) {
            return Sizzle(s, n)[0] || null;
        };
        d3_selectAll = Sizzle;
        d3_selectMatches = Sizzle.matchesSelector;
    }
    d3.selection = function() {
        return d3.select(d3_document.documentElement);
    };
    var d3_selectionPrototype = d3.selection.prototype = [];
    d3_selectionPrototype.select = function(selector) {
        var subgroups = [], subgroup, subnode, group, node;
        selector = d3_selection_selector(selector);
        for (var j = -1, m = this.length; ++j < m; ) {
            subgroups.push(subgroup = []);
            subgroup.parentNode = (group = this[j]).parentNode;
            for (var i = -1, n = group.length; ++i < n; ) {
                if (node = group[i]) {
                    subgroup.push(subnode = selector.call(node, node.__data__, i, j));
                    if (subnode && "__data__" in node) subnode.__data__ = node.__data__;
                } else {
                    subgroup.push(null);
                }
            }
        }
        return d3_selection(subgroups);
    };
    function d3_selection_selector(selector) {
        return typeof selector === "function" ? selector : function() {
            return d3_select(selector, this);
        };
    }
    d3_selectionPrototype.selectAll = function(selector) {
        var subgroups = [], subgroup, node;
        selector = d3_selection_selectorAll(selector);
        for (var j = -1, m = this.length; ++j < m; ) {
            for (var group = this[j], i = -1, n = group.length; ++i < n; ) {
                if (node = group[i]) {
                    subgroups.push(subgroup = d3_array(selector.call(node, node.__data__, i, j)));
                    subgroup.parentNode = node;
                }
            }
        }
        return d3_selection(subgroups);
    };
    function d3_selection_selectorAll(selector) {
        return typeof selector === "function" ? selector : function() {
            return d3_selectAll(selector, this);
        };
    }
    var d3_nsXhtml = "http://www.w3.org/1999/xhtml";
    var d3_nsPrefix = {
        svg: "http://www.w3.org/2000/svg",
        xhtml: d3_nsXhtml,
        xlink: "http://www.w3.org/1999/xlink",
        xml: "http://www.w3.org/XML/1998/namespace",
        xmlns: "http://www.w3.org/2000/xmlns/"
    };
    d3.ns = {
        prefix: d3_nsPrefix,
        qualify: function(name) {
            var i = name.indexOf(":"), prefix = name;
            if (i >= 0 && (prefix = name.slice(0, i)) !== "xmlns") name = name.slice(i + 1);
            return d3_nsPrefix.hasOwnProperty(prefix) ? {
                space: d3_nsPrefix[prefix],
                local: name
            } : name;
        }
    };
    d3_selectionPrototype.attr = function(name, value) {
        if (arguments.length < 2) {
            if (typeof name === "string") {
                var node = this.node();
                name = d3.ns.qualify(name);
                return name.local ? node.getAttributeNS(name.space, name.local) : node.getAttribute(name);
            }
            for (value in name) this.each(d3_selection_attr(value, name[value]));
            return this;
        }
        return this.each(d3_selection_attr(name, value));
    };
    function d3_selection_attr(name, value) {
        name = d3.ns.qualify(name);
        function attrNull() {
            this.removeAttribute(name);
        }
        function attrNullNS() {
            this.removeAttributeNS(name.space, name.local);
        }
        function attrConstant() {
            this.setAttribute(name, value);
        }
        function attrConstantNS() {
            this.setAttributeNS(name.space, name.local, value);
        }
        function attrFunction() {
            var x = value.apply(this, arguments);
            if (x == null) this.removeAttribute(name); else this.setAttribute(name, x);
        }
        function attrFunctionNS() {
            var x = value.apply(this, arguments);
            if (x == null) this.removeAttributeNS(name.space, name.local); else this.setAttributeNS(name.space, name.local, x);
        }
        return value == null ? name.local ? attrNullNS : attrNull : typeof value === "function" ? name.local ? attrFunctionNS : attrFunction : name.local ? attrConstantNS : attrConstant;
    }
    function d3_collapse(s) {
        return s.trim().replace(/\s+/g, " ");
    }
    d3_selectionPrototype.classed = function(name, value) {
        if (arguments.length < 2) {
            if (typeof name === "string") {
                var node = this.node(), n = (name = d3_selection_classes(name)).length, i = -1;
                if (value = node.classList) {
                    while (++i < n) if (!value.contains(name[i])) return false;
                } else {
                    value = node.getAttribute("class");
                    while (++i < n) if (!d3_selection_classedRe(name[i]).test(value)) return false;
                }
                return true;
            }
            for (value in name) this.each(d3_selection_classed(value, name[value]));
            return this;
        }
        return this.each(d3_selection_classed(name, value));
    };
    function d3_selection_classedRe(name) {
        return new RegExp("(?:^|\\s+)" + d3.requote(name) + "(?:\\s+|$)", "g");
    }
    function d3_selection_classes(name) {
        return (name + "").trim().split(/^|\s+/);
    }
    function d3_selection_classed(name, value) {
        name = d3_selection_classes(name).map(d3_selection_classedName);
        var n = name.length;
        function classedConstant() {
            var i = -1;
            while (++i < n) name[i](this, value);
        }
        function classedFunction() {
            var i = -1, x = value.apply(this, arguments);
            while (++i < n) name[i](this, x);
        }
        return typeof value === "function" ? classedFunction : classedConstant;
    }
    function d3_selection_classedName(name) {
        var re = d3_selection_classedRe(name);
        return function(node, value) {
            if (c = node.classList) return value ? c.add(name) : c.remove(name);
            var c = node.getAttribute("class") || "";
            if (value) {
                re.lastIndex = 0;
                if (!re.test(c)) node.setAttribute("class", d3_collapse(c + " " + name));
            } else {
                node.setAttribute("class", d3_collapse(c.replace(re, " ")));
            }
        };
    }
    d3_selectionPrototype.style = function(name, value, priority) {
        var n = arguments.length;
        if (n < 3) {
            if (typeof name !== "string") {
                if (n < 2) value = "";
                for (priority in name) this.each(d3_selection_style(priority, name[priority], value));
                return this;
            }
            if (n < 2) {
                var node = this.node();
                return d3_window(node).getComputedStyle(node, null).getPropertyValue(name);
            }
            priority = "";
        }
        return this.each(d3_selection_style(name, value, priority));
    };
    function d3_selection_style(name, value, priority) {
        function styleNull() {
            this.style.removeProperty(name);
        }
        function styleConstant() {
            this.style.setProperty(name, value, priority);
        }
        function styleFunction() {
            var x = value.apply(this, arguments);
            if (x == null) this.style.removeProperty(name); else this.style.setProperty(name, x, priority);
        }
        return value == null ? styleNull : typeof value === "function" ? styleFunction : styleConstant;
    }
    d3_selectionPrototype.property = function(name, value) {
        if (arguments.length < 2) {
            if (typeof name === "string") return this.node()[name];
            for (value in name) this.each(d3_selection_property(value, name[value]));
            return this;
        }
        return this.each(d3_selection_property(name, value));
    };
    function d3_selection_property(name, value) {
        function propertyNull() {
            delete this[name];
        }
        function propertyConstant() {
            this[name] = value;
        }
        function propertyFunction() {
            var x = value.apply(this, arguments);
            if (x == null) delete this[name]; else this[name] = x;
        }
        return value == null ? propertyNull : typeof value === "function" ? propertyFunction : propertyConstant;
    }
    d3_selectionPrototype.text = function(value) {
        return arguments.length ? this.each(typeof value === "function" ? function() {
            var v = value.apply(this, arguments);
            this.textContent = v == null ? "" : v;
        } : value == null ? function() {
            this.textContent = "";
        } : function() {
            this.textContent = value;
        }) : this.node().textContent;
    };
    d3_selectionPrototype.html = function(value) {
        return arguments.length ? this.each(typeof value === "function" ? function() {
            var v = value.apply(this, arguments);
            this.innerHTML = v == null ? "" : v;
        } : value == null ? function() {
            this.innerHTML = "";
        } : function() {
            this.innerHTML = value;
        }) : this.node().innerHTML;
    };
    d3_selectionPrototype.append = function(name) {
        name = d3_selection_creator(name);
        return this.select(function() {
            return this.appendChild(name.apply(this, arguments));
        });
    };
    function d3_selection_creator(name) {
        function create() {
            var document = this.ownerDocument, namespace = this.namespaceURI;
            return namespace === d3_nsXhtml && document.documentElement.namespaceURI === d3_nsXhtml ? document.createElement(name) : document.createElementNS(namespace, name);
        }
        function createNS() {
            return this.ownerDocument.createElementNS(name.space, name.local);
        }
        return typeof name === "function" ? name : (name = d3.ns.qualify(name)).local ? createNS : create;
    }
    d3_selectionPrototype.insert = function(name, before) {
        name = d3_selection_creator(name);
        before = d3_selection_selector(before);
        return this.select(function() {
            return this.insertBefore(name.apply(this, arguments), before.apply(this, arguments) || null);
        });
    };
    d3_selectionPrototype.remove = function() {
        return this.each(d3_selectionRemove);
    };
    function d3_selectionRemove() {
        var parent = this.parentNode;
        if (parent) parent.removeChild(this);
    }
    d3_selectionPrototype.data = function(value, key) {
        var i = -1, n = this.length, group, node;
        if (!arguments.length) {
            value = new Array(n = (group = this[0]).length);
            while (++i < n) {
                if (node = group[i]) {
                    value[i] = node.__data__;
                }
            }
            return value;
        }
        function bind(group, groupData) {
            var i, n = group.length, m = groupData.length, n0 = Math.min(n, m), updateNodes = new Array(m), enterNodes = new Array(m), exitNodes = new Array(n), node, nodeData;
            if (key) {
                var nodeByKeyValue = new d3_Map(), keyValues = new Array(n), keyValue;
                for (i = -1; ++i < n; ) {
                    if (node = group[i]) {
                        if (nodeByKeyValue.has(keyValue = key.call(node, node.__data__, i))) {
                            exitNodes[i] = node;
                        } else {
                            nodeByKeyValue.set(keyValue, node);
                        }
                        keyValues[i] = keyValue;
                    }
                }
                for (i = -1; ++i < m; ) {
                    if (!(node = nodeByKeyValue.get(keyValue = key.call(groupData, nodeData = groupData[i], i)))) {
                        enterNodes[i] = d3_selection_dataNode(nodeData);
                    } else if (node !== true) {
                        updateNodes[i] = node;
                        node.__data__ = nodeData;
                    }
                    nodeByKeyValue.set(keyValue, true);
                }
                for (i = -1; ++i < n; ) {
                    if (i in keyValues && nodeByKeyValue.get(keyValues[i]) !== true) {
                        exitNodes[i] = group[i];
                    }
                }
            } else {
                for (i = -1; ++i < n0; ) {
                    node = group[i];
                    nodeData = groupData[i];
                    if (node) {
                        node.__data__ = nodeData;
                        updateNodes[i] = node;
                    } else {
                        enterNodes[i] = d3_selection_dataNode(nodeData);
                    }
                }
                for (;i < m; ++i) {
                    enterNodes[i] = d3_selection_dataNode(groupData[i]);
                }
                for (;i < n; ++i) {
                    exitNodes[i] = group[i];
                }
            }
            enterNodes.update = updateNodes;
            enterNodes.parentNode = updateNodes.parentNode = exitNodes.parentNode = group.parentNode;
            enter.push(enterNodes);
            update.push(updateNodes);
            exit.push(exitNodes);
        }
        var enter = d3_selection_enter([]), update = d3_selection([]), exit = d3_selection([]);
        if (typeof value === "function") {
            while (++i < n) {
                bind(group = this[i], value.call(group, group.parentNode.__data__, i));
            }
        } else {
            while (++i < n) {
                bind(group = this[i], value);
            }
        }
        update.enter = function() {
            return enter;
        };
        update.exit = function() {
            return exit;
        };
        return update;
    };
    function d3_selection_dataNode(data) {
        return {
            __data__: data
        };
    }
    d3_selectionPrototype.datum = function(value) {
        return arguments.length ? this.property("__data__", value) : this.property("__data__");
    };
    d3_selectionPrototype.filter = function(filter) {
        var subgroups = [], subgroup, group, node;
        if (typeof filter !== "function") filter = d3_selection_filter(filter);
        for (var j = 0, m = this.length; j < m; j++) {
            subgroups.push(subgroup = []);
            subgroup.parentNode = (group = this[j]).parentNode;
            for (var i = 0, n = group.length; i < n; i++) {
                if ((node = group[i]) && filter.call(node, node.__data__, i, j)) {
                    subgroup.push(node);
                }
            }
        }
        return d3_selection(subgroups);
    };
    function d3_selection_filter(selector) {
        return function() {
            return d3_selectMatches(this, selector);
        };
    }
    d3_selectionPrototype.order = function() {
        for (var j = -1, m = this.length; ++j < m; ) {
            for (var group = this[j], i = group.length - 1, next = group[i], node; --i >= 0; ) {
                if (node = group[i]) {
                    if (next && next !== node.nextSibling) next.parentNode.insertBefore(node, next);
                    next = node;
                }
            }
        }
        return this;
    };
    d3_selectionPrototype.sort = function(comparator) {
        comparator = d3_selection_sortComparator.apply(this, arguments);
        for (var j = -1, m = this.length; ++j < m; ) this[j].sort(comparator);
        return this.order();
    };
    function d3_selection_sortComparator(comparator) {
        if (!arguments.length) comparator = d3_ascending;
        return function(a, b) {
            return a && b ? comparator(a.__data__, b.__data__) : !a - !b;
        };
    }
    d3_selectionPrototype.each = function(callback) {
        return d3_selection_each(this, function(node, i, j) {
            callback.call(node, node.__data__, i, j);
        });
    };
    function d3_selection_each(groups, callback) {
        for (var j = 0, m = groups.length; j < m; j++) {
            for (var group = groups[j], i = 0, n = group.length, node; i < n; i++) {
                if (node = group[i]) callback(node, i, j);
            }
        }
        return groups;
    }
    d3_selectionPrototype.call = function(callback) {
        var args = d3_array(arguments);
        callback.apply(args[0] = this, args);
        return this;
    };
    d3_selectionPrototype.empty = function() {
        return !this.node();
    };
    d3_selectionPrototype.node = function() {
        for (var j = 0, m = this.length; j < m; j++) {
            for (var group = this[j], i = 0, n = group.length; i < n; i++) {
                var node = group[i];
                if (node) return node;
            }
        }
        return null;
    };
    d3_selectionPrototype.size = function() {
        var n = 0;
        d3_selection_each(this, function() {
            ++n;
        });
        return n;
    };
    function d3_selection_enter(selection) {
        d3_subclass(selection, d3_selection_enterPrototype);
        return selection;
    }
    var d3_selection_enterPrototype = [];
    d3.selection.enter = d3_selection_enter;
    d3.selection.enter.prototype = d3_selection_enterPrototype;
    d3_selection_enterPrototype.append = d3_selectionPrototype.append;
    d3_selection_enterPrototype.empty = d3_selectionPrototype.empty;
    d3_selection_enterPrototype.node = d3_selectionPrototype.node;
    d3_selection_enterPrototype.call = d3_selectionPrototype.call;
    d3_selection_enterPrototype.size = d3_selectionPrototype.size;
    d3_selection_enterPrototype.select = function(selector) {
        var subgroups = [], subgroup, subnode, upgroup, group, node;
        for (var j = -1, m = this.length; ++j < m; ) {
            upgroup = (group = this[j]).update;
            subgroups.push(subgroup = []);
            subgroup.parentNode = group.parentNode;
            for (var i = -1, n = group.length; ++i < n; ) {
                if (node = group[i]) {
                    subgroup.push(upgroup[i] = subnode = selector.call(group.parentNode, node.__data__, i, j));
                    subnode.__data__ = node.__data__;
                } else {
                    subgroup.push(null);
                }
            }
        }
        return d3_selection(subgroups);
    };
    d3_selection_enterPrototype.insert = function(name, before) {
        if (arguments.length < 2) before = d3_selection_enterInsertBefore(this);
        return d3_selectionPrototype.insert.call(this, name, before);
    };
    function d3_selection_enterInsertBefore(enter) {
        var i0, j0;
        return function(d, i, j) {
            var group = enter[j].update, n = group.length, node;
            if (j != j0) j0 = j, i0 = 0;
            if (i >= i0) i0 = i + 1;
            while (!(node = group[i0]) && ++i0 < n) ;
            return node;
        };
    }
    d3.select = function(node) {
        var group;
        if (typeof node === "string") {
            group = [ d3_select(node, d3_document) ];
            group.parentNode = d3_document.documentElement;
        } else {
            group = [ node ];
            group.parentNode = d3_documentElement(node);
        }
        return d3_selection([ group ]);
    };
    d3.selectAll = function(nodes) {
        var group;
        if (typeof nodes === "string") {
            group = d3_array(d3_selectAll(nodes, d3_document));
            group.parentNode = d3_document.documentElement;
        } else {
            group = d3_array(nodes);
            group.parentNode = null;
        }
        return d3_selection([ group ]);
    };
    d3_selectionPrototype.on = function(type, listener, capture) {
        var n = arguments.length;
        if (n < 3) {
            if (typeof type !== "string") {
                if (n < 2) listener = false;
                for (capture in type) this.each(d3_selection_on(capture, type[capture], listener));
                return this;
            }
            if (n < 2) return (n = this.node()["__on" + type]) && n._;
            capture = false;
        }
        return this.each(d3_selection_on(type, listener, capture));
    };
    function d3_selection_on(type, listener, capture) {
        var name = "__on" + type, i = type.indexOf("."), wrap = d3_selection_onListener;
        if (i > 0) type = type.slice(0, i);
        var filter = d3_selection_onFilters.get(type);
        if (filter) type = filter, wrap = d3_selection_onFilter;
        function onRemove() {
            var l = this[name];
            if (l) {
                this.removeEventListener(type, l, l.$);
                delete this[name];
            }
        }
        function onAdd() {
            var l = wrap(listener, d3_array(arguments));
            onRemove.call(this);
            this.addEventListener(type, this[name] = l, l.$ = capture);
            l._ = listener;
        }
        function removeAll() {
            var re = new RegExp("^__on([^.]+)" + d3.requote(type) + "$"), match;
            for (var name in this) {
                if (match = name.match(re)) {
                    var l = this[name];
                    this.removeEventListener(match[1], l, l.$);
                    delete this[name];
                }
            }
        }
        return i ? listener ? onAdd : onRemove : listener ? d3_noop : removeAll;
    }
    var d3_selection_onFilters = d3.map({
        mouseenter: "mouseover",
        mouseleave: "mouseout"
    });
    if (d3_document) {
        d3_selection_onFilters.forEach(function(k) {
            if ("on" + k in d3_document) d3_selection_onFilters.remove(k);
        });
    }
    function d3_selection_onListener(listener, argumentz) {
        return function(e) {
            var o = d3.event;
            d3.event = e;
            argumentz[0] = this.__data__;
            try {
                listener.apply(this, argumentz);
            } finally {
                d3.event = o;
            }
        };
    }
    function d3_selection_onFilter(listener, argumentz) {
        var l = d3_selection_onListener(listener, argumentz);
        return function(e) {
            var target = this, related = e.relatedTarget;
            if (!related || related !== target && !(related.compareDocumentPosition(target) & 8)) {
                l.call(target, e);
            }
        };
    }
    var d3_event_dragSelect, d3_event_dragId = 0;
    function d3_event_dragSuppress(node) {
        var name = ".dragsuppress-" + ++d3_event_dragId, click = "click" + name, w = d3.select(d3_window(node)).on("touchmove" + name, d3_eventPreventDefault).on("dragstart" + name, d3_eventPreventDefault).on("selectstart" + name, d3_eventPreventDefault);
        if (d3_event_dragSelect == null) {
            d3_event_dragSelect = "onselectstart" in node ? false : d3_vendorSymbol(node.style, "userSelect");
        }
        if (d3_event_dragSelect) {
            var style = d3_documentElement(node).style, select = style[d3_event_dragSelect];
            style[d3_event_dragSelect] = "none";
        }
        return function(suppressClick) {
            w.on(name, null);
            if (d3_event_dragSelect) style[d3_event_dragSelect] = select;
            if (suppressClick) {
                var off = function() {
                    w.on(click, null);
                };
                w.on(click, function() {
                    d3_eventPreventDefault();
                    off();
                }, true);
                setTimeout(off, 0);
            }
        };
    }
    d3.mouse = function(container) {
        return d3_mousePoint(container, d3_eventSource());
    };
    var d3_mouse_bug44083 = this.navigator && /WebKit/.test(this.navigator.userAgent) ? -1 : 0;
    function d3_mousePoint(container, e) {
        if (e.changedTouches) e = e.changedTouches[0];
        var svg = container.ownerSVGElement || container;
        if (svg.createSVGPoint) {
            var point = svg.createSVGPoint();
            if (d3_mouse_bug44083 < 0) {
                var window = d3_window(container);
                if (window.scrollX || window.scrollY) {
                    svg = d3.select("body").append("svg").style({
                        position: "absolute",
                        top: 0,
                        left: 0,
                        margin: 0,
                        padding: 0,
                        border: "none"
                    }, "important");
                    var ctm = svg[0][0].getScreenCTM();
                    d3_mouse_bug44083 = !(ctm.f || ctm.e);
                    svg.remove();
                }
            }
            if (d3_mouse_bug44083) point.x = e.pageX, point.y = e.pageY; else point.x = e.clientX, 
            point.y = e.clientY;
            point = point.matrixTransform(container.getScreenCTM().inverse());
            return [ point.x, point.y ];
        }
        var rect = container.getBoundingClientRect();
        return [ e.clientX - rect.left - container.clientLeft, e.clientY - rect.top - container.clientTop ];
    }
    d3.touch = function(container, touches, identifier) {
        if (arguments.length < 3) identifier = touches, touches = d3_eventSource().changedTouches;
        if (touches) for (var i = 0, n = touches.length, touch; i < n; ++i) {
            if ((touch = touches[i]).identifier === identifier) {
                return d3_mousePoint(container, touch);
            }
        }
    };
    d3.behavior.drag = function() {
        var event = d3_eventDispatch(drag, "drag", "dragstart", "dragend"), origin = null, mousedown = dragstart(d3_noop, d3.mouse, d3_window, "mousemove", "mouseup"), touchstart = dragstart(d3_behavior_dragTouchId, d3.touch, d3_identity, "touchmove", "touchend");
        function drag() {
            this.on("mousedown.drag", mousedown).on("touchstart.drag", touchstart);
        }
        function dragstart(id, position, subject, move, end) {
            return function() {
                var that = this, target = d3.event.target.correspondingElement || d3.event.target, parent = that.parentNode, dispatch = event.of(that, arguments), dragged = 0, dragId = id(), dragName = ".drag" + (dragId == null ? "" : "-" + dragId), dragOffset, dragSubject = d3.select(subject(target)).on(move + dragName, moved).on(end + dragName, ended), dragRestore = d3_event_dragSuppress(target), position0 = position(parent, dragId);
                if (origin) {
                    dragOffset = origin.apply(that, arguments);
                    dragOffset = [ dragOffset.x - position0[0], dragOffset.y - position0[1] ];
                } else {
                    dragOffset = [ 0, 0 ];
                }
                dispatch({
                    type: "dragstart"
                });
                function moved() {
                    var position1 = position(parent, dragId), dx, dy;
                    if (!position1) return;
                    dx = position1[0] - position0[0];
                    dy = position1[1] - position0[1];
                    dragged |= dx | dy;
                    position0 = position1;
                    dispatch({
                        type: "drag",
                        x: position1[0] + dragOffset[0],
                        y: position1[1] + dragOffset[1],
                        dx: dx,
                        dy: dy
                    });
                }
                function ended() {
                    if (!position(parent, dragId)) return;
                    dragSubject.on(move + dragName, null).on(end + dragName, null);
                    dragRestore(dragged);
                    dispatch({
                        type: "dragend"
                    });
                }
            };
        }
        drag.origin = function(x) {
            if (!arguments.length) return origin;
            origin = x;
            return drag;
        };
        return d3.rebind(drag, event, "on");
    };
    function d3_behavior_dragTouchId() {
        return d3.event.changedTouches[0].identifier;
    }
    d3.touches = function(container, touches) {
        if (arguments.length < 2) touches = d3_eventSource().touches;
        return touches ? d3_array(touches).map(function(touch) {
            var point = d3_mousePoint(container, touch);
            point.identifier = touch.identifier;
            return point;
        }) : [];
    };
    var Îµ = 1e-6, Îµ2 = Îµ * Îµ, Ï = Math.PI, Ï = 2 * Ï, ÏÎµ = Ï - Îµ, halfÏ = Ï / 2, d3_radians = Ï / 180, d3_degrees = 180 / Ï;
    function d3_sgn(x) {
        return x > 0 ? 1 : x < 0 ? -1 : 0;
    }
    function d3_cross2d(a, b, c) {
        return (b[0] - a[0]) * (c[1] - a[1]) - (b[1] - a[1]) * (c[0] - a[0]);
    }
    function d3_acos(x) {
        return x > 1 ? 0 : x < -1 ? Ï : Math.acos(x);
    }
    function d3_asin(x) {
        return x > 1 ? halfÏ : x < -1 ? -halfÏ : Math.asin(x);
    }
    function d3_sinh(x) {
        return ((x = Math.exp(x)) - 1 / x) / 2;
    }
    function d3_cosh(x) {
        return ((x = Math.exp(x)) + 1 / x) / 2;
    }
    function d3_tanh(x) {
        return ((x = Math.exp(2 * x)) - 1) / (x + 1);
    }
    function d3_haversin(x) {
        return (x = Math.sin(x / 2)) * x;
    }
    var Ï = Math.SQRT2, Ï2 = 2, Ï4 = 4;
    d3.interpolateZoom = function(p0, p1) {
        var ux0 = p0[0], uy0 = p0[1], w0 = p0[2], ux1 = p1[0], uy1 = p1[1], w1 = p1[2], dx = ux1 - ux0, dy = uy1 - uy0, d2 = dx * dx + dy * dy, i, S;
        if (d2 < Îµ2) {
            S = Math.log(w1 / w0) / Ï;
            i = function(t) {
                return [ ux0 + t * dx, uy0 + t * dy, w0 * Math.exp(Ï * t * S) ];
            };
        } else {
            var d1 = Math.sqrt(d2), b0 = (w1 * w1 - w0 * w0 + Ï4 * d2) / (2 * w0 * Ï2 * d1), b1 = (w1 * w1 - w0 * w0 - Ï4 * d2) / (2 * w1 * Ï2 * d1), r0 = Math.log(Math.sqrt(b0 * b0 + 1) - b0), r1 = Math.log(Math.sqrt(b1 * b1 + 1) - b1);
            S = (r1 - r0) / Ï;
            i = function(t) {
                var s = t * S, coshr0 = d3_cosh(r0), u = w0 / (Ï2 * d1) * (coshr0 * d3_tanh(Ï * s + r0) - d3_sinh(r0));
                return [ ux0 + u * dx, uy0 + u * dy, w0 * coshr0 / d3_cosh(Ï * s + r0) ];
            };
        }
        i.duration = S * 1e3;
        return i;
    };
    d3.behavior.zoom = function() {
        var view = {
            x: 0,
            y: 0,
            k: 1
        }, translate0, center0, center, size = [ 960, 500 ], scaleExtent = d3_behavior_zoomInfinity, duration = 250, zooming = 0, mousedown = "mousedown.zoom", mousemove = "mousemove.zoom", mouseup = "mouseup.zoom", mousewheelTimer, touchstart = "touchstart.zoom", touchtime, event = d3_eventDispatch(zoom, "zoomstart", "zoom", "zoomend"), x0, x1, y0, y1;
        if (!d3_behavior_zoomWheel) {
            d3_behavior_zoomWheel = "onwheel" in d3_document ? (d3_behavior_zoomDelta = function() {
                return -d3.event.deltaY * (d3.event.deltaMode ? 120 : 1);
            }, "wheel") : "onmousewheel" in d3_document ? (d3_behavior_zoomDelta = function() {
                return d3.event.wheelDelta;
            }, "mousewheel") : (d3_behavior_zoomDelta = function() {
                return -d3.event.detail;
            }, "MozMousePixelScroll");
        }
        function zoom(g) {
            g.on(mousedown, mousedowned).on(d3_behavior_zoomWheel + ".zoom", mousewheeled).on("dblclick.zoom", dblclicked).on(touchstart, touchstarted);
        }
        zoom.event = function(g) {
            g.each(function() {
                var dispatch = event.of(this, arguments), view1 = view;
                if (d3_transitionInheritId) {
                    d3.select(this).transition().each("start.zoom", function() {
                        view = this.__chart__ || {
                            x: 0,
                            y: 0,
                            k: 1
                        };
                        zoomstarted(dispatch);
                    }).tween("zoom:zoom", function() {
                        var dx = size[0], dy = size[1], cx = center0 ? center0[0] : dx / 2, cy = center0 ? center0[1] : dy / 2, i = d3.interpolateZoom([ (cx - view.x) / view.k, (cy - view.y) / view.k, dx / view.k ], [ (cx - view1.x) / view1.k, (cy - view1.y) / view1.k, dx / view1.k ]);
                        return function(t) {
                            var l = i(t), k = dx / l[2];
                            this.__chart__ = view = {
                                x: cx - l[0] * k,
                                y: cy - l[1] * k,
                                k: k
                            };
                            zoomed(dispatch);
                        };
                    }).each("interrupt.zoom", function() {
                        zoomended(dispatch);
                    }).each("end.zoom", function() {
                        zoomended(dispatch);
                    });
                } else {
                    this.__chart__ = view;
                    zoomstarted(dispatch);
                    zoomed(dispatch);
                    zoomended(dispatch);
                }
            });
        };
        zoom.translate = function(_) {
            if (!arguments.length) return [ view.x, view.y ];
            view = {
                x: +_[0],
                y: +_[1],
                k: view.k
            };
            rescale();
            return zoom;
        };
        zoom.scale = function(_) {
            if (!arguments.length) return view.k;
            view = {
                x: view.x,
                y: view.y,
                k: null
            };
            scaleTo(+_);
            rescale();
            return zoom;
        };
        zoom.scaleExtent = function(_) {
            if (!arguments.length) return scaleExtent;
            scaleExtent = _ == null ? d3_behavior_zoomInfinity : [ +_[0], +_[1] ];
            return zoom;
        };
        zoom.center = function(_) {
            if (!arguments.length) return center;
            center = _ && [ +_[0], +_[1] ];
            return zoom;
        };
        zoom.size = function(_) {
            if (!arguments.length) return size;
            size = _ && [ +_[0], +_[1] ];
            return zoom;
        };
        zoom.duration = function(_) {
            if (!arguments.length) return duration;
            duration = +_;
            return zoom;
        };
        zoom.x = function(z) {
            if (!arguments.length) return x1;
            x1 = z;
            x0 = z.copy();
            view = {
                x: 0,
                y: 0,
                k: 1
            };
            return zoom;
        };
        zoom.y = function(z) {
            if (!arguments.length) return y1;
            y1 = z;
            y0 = z.copy();
            view = {
                x: 0,
                y: 0,
                k: 1
            };
            return zoom;
        };
        function location(p) {
            return [ (p[0] - view.x) / view.k, (p[1] - view.y) / view.k ];
        }
        function point(l) {
            return [ l[0] * view.k + view.x, l[1] * view.k + view.y ];
        }
        function scaleTo(s) {
            view.k = Math.max(scaleExtent[0], Math.min(scaleExtent[1], s));
        }
        function translateTo(p, l) {
            l = point(l);
            view.x += p[0] - l[0];
            view.y += p[1] - l[1];
        }
        function zoomTo(that, p, l, k) {
            that.__chart__ = {
                x: view.x,
                y: view.y,
                k: view.k
            };
            scaleTo(Math.pow(2, k));
            translateTo(center0 = p, l);
            that = d3.select(that);
            if (duration > 0) that = that.transition().duration(duration);
            that.call(zoom.event);
        }
        function rescale() {
            if (x1) x1.domain(x0.range().map(function(x) {
                return (x - view.x) / view.k;
            }).map(x0.invert));
            if (y1) y1.domain(y0.range().map(function(y) {
                return (y - view.y) / view.k;
            }).map(y0.invert));
        }
        function zoomstarted(dispatch) {
            if (!zooming++) dispatch({
                type: "zoomstart"
            });
        }
        function zoomed(dispatch) {
            rescale();
            dispatch({
                type: "zoom",
                scale: view.k,
                translate: [ view.x, view.y ]
            });
        }
        function zoomended(dispatch) {
            if (!--zooming) dispatch({
                type: "zoomend"
            }), center0 = null;
        }
        function mousedowned() {
            var that = this, dispatch = event.of(that, arguments), dragged = 0, subject = d3.select(d3_window(that)).on(mousemove, moved).on(mouseup, ended), location0 = location(d3.mouse(that)), dragRestore = d3_event_dragSuppress(that);
            d3_selection_interrupt.call(that);
            zoomstarted(dispatch);
            function moved() {
                dragged = 1;
                translateTo(d3.mouse(that), location0);
                zoomed(dispatch);
            }
            function ended() {
                subject.on(mousemove, null).on(mouseup, null);
                dragRestore(dragged);
                zoomended(dispatch);
            }
        }
        function touchstarted() {
            var that = this, dispatch = event.of(that, arguments), locations0 = {}, distance0 = 0, scale0, zoomName = ".zoom-" + d3.event.changedTouches[0].identifier, touchmove = "touchmove" + zoomName, touchend = "touchend" + zoomName, targets = [], subject = d3.select(that), dragRestore = d3_event_dragSuppress(that);
            started();
            zoomstarted(dispatch);
            subject.on(mousedown, null).on(touchstart, started);
            function relocate() {
                var touches = d3.touches(that);
                scale0 = view.k;
                touches.forEach(function(t) {
                    if (t.identifier in locations0) locations0[t.identifier] = location(t);
                });
                return touches;
            }
            function started() {
                var target = d3.event.target;
                d3.select(target).on(touchmove, moved).on(touchend, ended);
                targets.push(target);
                var changed = d3.event.changedTouches;
                for (var i = 0, n = changed.length; i < n; ++i) {
                    locations0[changed[i].identifier] = null;
                }
                var touches = relocate(), now = Date.now();
                if (touches.length === 1) {
                    if (now - touchtime < 500) {
                        var p = touches[0];
                        zoomTo(that, p, locations0[p.identifier], Math.floor(Math.log(view.k) / Math.LN2) + 1);
                        d3_eventPreventDefault();
                    }
                    touchtime = now;
                } else if (touches.length > 1) {
                    var p = touches[0], q = touches[1], dx = p[0] - q[0], dy = p[1] - q[1];
                    distance0 = dx * dx + dy * dy;
                }
            }
            function moved() {
                var touches = d3.touches(that), p0, l0, p1, l1;
                d3_selection_interrupt.call(that);
                for (var i = 0, n = touches.length; i < n; ++i, l1 = null) {
                    p1 = touches[i];
                    if (l1 = locations0[p1.identifier]) {
                        if (l0) break;
                        p0 = p1, l0 = l1;
                    }
                }
                if (l1) {
                    var distance1 = (distance1 = p1[0] - p0[0]) * distance1 + (distance1 = p1[1] - p0[1]) * distance1, scale1 = distance0 && Math.sqrt(distance1 / distance0);
                    p0 = [ (p0[0] + p1[0]) / 2, (p0[1] + p1[1]) / 2 ];
                    l0 = [ (l0[0] + l1[0]) / 2, (l0[1] + l1[1]) / 2 ];
                    scaleTo(scale1 * scale0);
                }
                touchtime = null;
                translateTo(p0, l0);
                zoomed(dispatch);
            }
            function ended() {
                if (d3.event.touches.length) {
                    var changed = d3.event.changedTouches;
                    for (var i = 0, n = changed.length; i < n; ++i) {
                        delete locations0[changed[i].identifier];
                    }
                    for (var identifier in locations0) {
                        return void relocate();
                    }
                }
                d3.selectAll(targets).on(zoomName, null);
                subject.on(mousedown, mousedowned).on(touchstart, touchstarted);
                dragRestore();
                zoomended(dispatch);
            }
        }
        function mousewheeled() {
            var dispatch = event.of(this, arguments);
            if (mousewheelTimer) clearTimeout(mousewheelTimer); else d3_selection_interrupt.call(this), 
            translate0 = location(center0 = center || d3.mouse(this)), zoomstarted(dispatch);
            mousewheelTimer = setTimeout(function() {
                mousewheelTimer = null;
                zoomended(dispatch);
            }, 50);
            d3_eventPreventDefault();
            scaleTo(Math.pow(2, d3_behavior_zoomDelta() * .002) * view.k);
            translateTo(center0, translate0);
            zoomed(dispatch);
        }
        function dblclicked() {
            var p = d3.mouse(this), k = Math.log(view.k) / Math.LN2;
            zoomTo(this, p, location(p), d3.event.shiftKey ? Math.ceil(k) - 1 : Math.floor(k) + 1);
        }
        return d3.rebind(zoom, event, "on");
    };
    var d3_behavior_zoomInfinity = [ 0, Infinity ], d3_behavior_zoomDelta, d3_behavior_zoomWheel;
    d3.color = d3_color;
    function d3_color() {}
    d3_color.prototype.toString = function() {
        return this.rgb() + "";
    };
    d3.hsl = d3_hsl;
    function d3_hsl(h, s, l) {
        return this instanceof d3_hsl ? void (this.h = +h, this.s = +s, this.l = +l) : arguments.length < 2 ? h instanceof d3_hsl ? new d3_hsl(h.h, h.s, h.l) : d3_rgb_parse("" + h, d3_rgb_hsl, d3_hsl) : new d3_hsl(h, s, l);
    }
    var d3_hslPrototype = d3_hsl.prototype = new d3_color();
    d3_hslPrototype.brighter = function(k) {
        k = Math.pow(.7, arguments.length ? k : 1);
        return new d3_hsl(this.h, this.s, this.l / k);
    };
    d3_hslPrototype.darker = function(k) {
        k = Math.pow(.7, arguments.length ? k : 1);
        return new d3_hsl(this.h, this.s, k * this.l);
    };
    d3_hslPrototype.rgb = function() {
        return d3_hsl_rgb(this.h, this.s, this.l);
    };
    function d3_hsl_rgb(h, s, l) {
        var m1, m2;
        h = isNaN(h) ? 0 : (h %= 360) < 0 ? h + 360 : h;
        s = isNaN(s) ? 0 : s < 0 ? 0 : s > 1 ? 1 : s;
        l = l < 0 ? 0 : l > 1 ? 1 : l;
        m2 = l <= .5 ? l * (1 + s) : l + s - l * s;
        m1 = 2 * l - m2;
        function v(h) {
            if (h > 360) h -= 360; else if (h < 0) h += 360;
            if (h < 60) return m1 + (m2 - m1) * h / 60;
            if (h < 180) return m2;
            if (h < 240) return m1 + (m2 - m1) * (240 - h) / 60;
            return m1;
        }
        function vv(h) {
            return Math.round(v(h) * 255);
        }
        return new d3_rgb(vv(h + 120), vv(h), vv(h - 120));
    }
    d3.hcl = d3_hcl;
    function d3_hcl(h, c, l) {
        return this instanceof d3_hcl ? void (this.h = +h, this.c = +c, this.l = +l) : arguments.length < 2 ? h instanceof d3_hcl ? new d3_hcl(h.h, h.c, h.l) : h instanceof d3_lab ? d3_lab_hcl(h.l, h.a, h.b) : d3_lab_hcl((h = d3_rgb_lab((h = d3.rgb(h)).r, h.g, h.b)).l, h.a, h.b) : new d3_hcl(h, c, l);
    }
    var d3_hclPrototype = d3_hcl.prototype = new d3_color();
    d3_hclPrototype.brighter = function(k) {
        return new d3_hcl(this.h, this.c, Math.min(100, this.l + d3_lab_K * (arguments.length ? k : 1)));
    };
    d3_hclPrototype.darker = function(k) {
        return new d3_hcl(this.h, this.c, Math.max(0, this.l - d3_lab_K * (arguments.length ? k : 1)));
    };
    d3_hclPrototype.rgb = function() {
        return d3_hcl_lab(this.h, this.c, this.l).rgb();
    };
    function d3_hcl_lab(h, c, l) {
        if (isNaN(h)) h = 0;
        if (isNaN(c)) c = 0;
        return new d3_lab(l, Math.cos(h *= d3_radians) * c, Math.sin(h) * c);
    }
    d3.lab = d3_lab;
    function d3_lab(l, a, b) {
        return this instanceof d3_lab ? void (this.l = +l, this.a = +a, this.b = +b) : arguments.length < 2 ? l instanceof d3_lab ? new d3_lab(l.l, l.a, l.b) : l instanceof d3_hcl ? d3_hcl_lab(l.h, l.c, l.l) : d3_rgb_lab((l = d3_rgb(l)).r, l.g, l.b) : new d3_lab(l, a, b);
    }
    var d3_lab_K = 18;
    var d3_lab_X = .95047, d3_lab_Y = 1, d3_lab_Z = 1.08883;
    var d3_labPrototype = d3_lab.prototype = new d3_color();
    d3_labPrototype.brighter = function(k) {
        return new d3_lab(Math.min(100, this.l + d3_lab_K * (arguments.length ? k : 1)), this.a, this.b);
    };
    d3_labPrototype.darker = function(k) {
        return new d3_lab(Math.max(0, this.l - d3_lab_K * (arguments.length ? k : 1)), this.a, this.b);
    };
    d3_labPrototype.rgb = function() {
        return d3_lab_rgb(this.l, this.a, this.b);
    };
    function d3_lab_rgb(l, a, b) {
        var y = (l + 16) / 116, x = y + a / 500, z = y - b / 200;
        x = d3_lab_xyz(x) * d3_lab_X;
        y = d3_lab_xyz(y) * d3_lab_Y;
        z = d3_lab_xyz(z) * d3_lab_Z;
        return new d3_rgb(d3_xyz_rgb(3.2404542 * x - 1.5371385 * y - .4985314 * z), d3_xyz_rgb(-.969266 * x + 1.8760108 * y + .041556 * z), d3_xyz_rgb(.0556434 * x - .2040259 * y + 1.0572252 * z));
    }
    function d3_lab_hcl(l, a, b) {
        return l > 0 ? new d3_hcl(Math.atan2(b, a) * d3_degrees, Math.sqrt(a * a + b * b), l) : new d3_hcl(NaN, NaN, l);
    }
    function d3_lab_xyz(x) {
        return x > .206893034 ? x * x * x : (x - 4 / 29) / 7.787037;
    }
    function d3_xyz_lab(x) {
        return x > .008856 ? Math.pow(x, 1 / 3) : 7.787037 * x + 4 / 29;
    }
    function d3_xyz_rgb(r) {
        return Math.round(255 * (r <= .00304 ? 12.92 * r : 1.055 * Math.pow(r, 1 / 2.4) - .055));
    }
    d3.rgb = d3_rgb;
    function d3_rgb(r, g, b) {
        return this instanceof d3_rgb ? void (this.r = ~~r, this.g = ~~g, this.b = ~~b) : arguments.length < 2 ? r instanceof d3_rgb ? new d3_rgb(r.r, r.g, r.b) : d3_rgb_parse("" + r, d3_rgb, d3_hsl_rgb) : new d3_rgb(r, g, b);
    }
    function d3_rgbNumber(value) {
        return new d3_rgb(value >> 16, value >> 8 & 255, value & 255);
    }
    function d3_rgbString(value) {
        return d3_rgbNumber(value) + "";
    }
    var d3_rgbPrototype = d3_rgb.prototype = new d3_color();
    d3_rgbPrototype.brighter = function(k) {
        k = Math.pow(.7, arguments.length ? k : 1);
        var r = this.r, g = this.g, b = this.b, i = 30;
        if (!r && !g && !b) return new d3_rgb(i, i, i);
        if (r && r < i) r = i;
        if (g && g < i) g = i;
        if (b && b < i) b = i;
        return new d3_rgb(Math.min(255, r / k), Math.min(255, g / k), Math.min(255, b / k));
    };
    d3_rgbPrototype.darker = function(k) {
        k = Math.pow(.7, arguments.length ? k : 1);
        return new d3_rgb(k * this.r, k * this.g, k * this.b);
    };
    d3_rgbPrototype.hsl = function() {
        return d3_rgb_hsl(this.r, this.g, this.b);
    };
    d3_rgbPrototype.toString = function() {
        return "#" + d3_rgb_hex(this.r) + d3_rgb_hex(this.g) + d3_rgb_hex(this.b);
    };
    function d3_rgb_hex(v) {
        return v < 16 ? "0" + Math.max(0, v).toString(16) : Math.min(255, v).toString(16);
    }
    function d3_rgb_parse(format, rgb, hsl) {
        var r = 0, g = 0, b = 0, m1, m2, color;
        m1 = /([a-z]+)\((.*)\)/.exec(format = format.toLowerCase());
        if (m1) {
            m2 = m1[2].split(",");
            switch (m1[1]) {
              case "hsl":
                {
                    return hsl(parseFloat(m2[0]), parseFloat(m2[1]) / 100, parseFloat(m2[2]) / 100);
                }

              case "rgb":
                {
                    return rgb(d3_rgb_parseNumber(m2[0]), d3_rgb_parseNumber(m2[1]), d3_rgb_parseNumber(m2[2]));
                }
            }
        }
        if (color = d3_rgb_names.get(format)) {
            return rgb(color.r, color.g, color.b);
        }
        if (format != null && format.charAt(0) === "#" && !isNaN(color = parseInt(format.slice(1), 16))) {
            if (format.length === 4) {
                r = (color & 3840) >> 4;
                r = r >> 4 | r;
                g = color & 240;
                g = g >> 4 | g;
                b = color & 15;
                b = b << 4 | b;
            } else if (format.length === 7) {
                r = (color & 16711680) >> 16;
                g = (color & 65280) >> 8;
                b = color & 255;
            }
        }
        return rgb(r, g, b);
    }
    function d3_rgb_hsl(r, g, b) {
        var min = Math.min(r /= 255, g /= 255, b /= 255), max = Math.max(r, g, b), d = max - min, h, s, l = (max + min) / 2;
        if (d) {
            s = l < .5 ? d / (max + min) : d / (2 - max - min);
            if (r == max) h = (g - b) / d + (g < b ? 6 : 0); else if (g == max) h = (b - r) / d + 2; else h = (r - g) / d + 4;
            h *= 60;
        } else {
            h = NaN;
            s = l > 0 && l < 1 ? 0 : h;
        }
        return new d3_hsl(h, s, l);
    }
    function d3_rgb_lab(r, g, b) {
        r = d3_rgb_xyz(r);
        g = d3_rgb_xyz(g);
        b = d3_rgb_xyz(b);
        var x = d3_xyz_lab((.4124564 * r + .3575761 * g + .1804375 * b) / d3_lab_X), y = d3_xyz_lab((.2126729 * r + .7151522 * g + .072175 * b) / d3_lab_Y), z = d3_xyz_lab((.0193339 * r + .119192 * g + .9503041 * b) / d3_lab_Z);
        return d3_lab(116 * y - 16, 500 * (x - y), 200 * (y - z));
    }
    function d3_rgb_xyz(r) {
        return (r /= 255) <= .04045 ? r / 12.92 : Math.pow((r + .055) / 1.055, 2.4);
    }
    function d3_rgb_parseNumber(c) {
        var f = parseFloat(c);
        return c.charAt(c.length - 1) === "%" ? Math.round(f * 2.55) : f;
    }
    var d3_rgb_names = d3.map({
        aliceblue: 15792383,
        antiquewhite: 16444375,
        aqua: 65535,
        aquamarine: 8388564,
        azure: 15794175,
        beige: 16119260,
        bisque: 16770244,
        black: 0,
        blanchedalmond: 16772045,
        blue: 255,
        blueviolet: 9055202,
        brown: 10824234,
        burlywood: 14596231,
        cadetblue: 6266528,
        chartreuse: 8388352,
        chocolate: 13789470,
        coral: 16744272,
        cornflowerblue: 6591981,
        cornsilk: 16775388,
        crimson: 14423100,
        cyan: 65535,
        darkblue: 139,
        darkcyan: 35723,
        darkgoldenrod: 12092939,
        darkgray: 11119017,
        darkgreen: 25600,
        darkgrey: 11119017,
        darkkhaki: 12433259,
        darkmagenta: 9109643,
        darkolivegreen: 5597999,
        darkorange: 16747520,
        darkorchid: 10040012,
        darkred: 9109504,
        darksalmon: 15308410,
        darkseagreen: 9419919,
        darkslateblue: 4734347,
        darkslategray: 3100495,
        darkslategrey: 3100495,
        darkturquoise: 52945,
        darkviolet: 9699539,
        deeppink: 16716947,
        deepskyblue: 49151,
        dimgray: 6908265,
        dimgrey: 6908265,
        dodgerblue: 2003199,
        firebrick: 11674146,
        floralwhite: 16775920,
        forestgreen: 2263842,
        fuchsia: 16711935,
        gainsboro: 14474460,
        ghostwhite: 16316671,
        gold: 16766720,
        goldenrod: 14329120,
        gray: 8421504,
        green: 32768,
        greenyellow: 11403055,
        grey: 8421504,
        honeydew: 15794160,
        hotpink: 16738740,
        indianred: 13458524,
        indigo: 4915330,
        ivory: 16777200,
        khaki: 15787660,
        lavender: 15132410,
        lavenderblush: 16773365,
        lawngreen: 8190976,
        lemonchiffon: 16775885,
        lightblue: 11393254,
        lightcoral: 15761536,
        lightcyan: 14745599,
        lightgoldenrodyellow: 16448210,
        lightgray: 13882323,
        lightgreen: 9498256,
        lightgrey: 13882323,
        lightpink: 16758465,
        lightsalmon: 16752762,
        lightseagreen: 2142890,
        lightskyblue: 8900346,
        lightslategray: 7833753,
        lightslategrey: 7833753,
        lightsteelblue: 11584734,
        lightyellow: 16777184,
        lime: 65280,
        limegreen: 3329330,
        linen: 16445670,
        magenta: 16711935,
        maroon: 8388608,
        mediumaquamarine: 6737322,
        mediumblue: 205,
        mediumorchid: 12211667,
        mediumpurple: 9662683,
        mediumseagreen: 3978097,
        mediumslateblue: 8087790,
        mediumspringgreen: 64154,
        mediumturquoise: 4772300,
        mediumvioletred: 13047173,
        midnightblue: 1644912,
        mintcream: 16121850,
        mistyrose: 16770273,
        moccasin: 16770229,
        navajowhite: 16768685,
        navy: 128,
        oldlace: 16643558,
        olive: 8421376,
        olivedrab: 7048739,
        orange: 16753920,
        orangered: 16729344,
        orchid: 14315734,
        palegoldenrod: 15657130,
        palegreen: 10025880,
        paleturquoise: 11529966,
        palevioletred: 14381203,
        papayawhip: 16773077,
        peachpuff: 16767673,
        peru: 13468991,
        pink: 16761035,
        plum: 14524637,
        powderblue: 11591910,
        purple: 8388736,
        rebeccapurple: 6697881,
        red: 16711680,
        rosybrown: 12357519,
        royalblue: 4286945,
        saddlebrown: 9127187,
        salmon: 16416882,
        sandybrown: 16032864,
        seagreen: 3050327,
        seashell: 16774638,
        sienna: 10506797,
        silver: 12632256,
        skyblue: 8900331,
        slateblue: 6970061,
        slategray: 7372944,
        slategrey: 7372944,
        snow: 16775930,
        springgreen: 65407,
        steelblue: 4620980,
        tan: 13808780,
        teal: 32896,
        thistle: 14204888,
        tomato: 16737095,
        turquoise: 4251856,
        violet: 15631086,
        wheat: 16113331,
        white: 16777215,
        whitesmoke: 16119285,
        yellow: 16776960,
        yellowgreen: 10145074
    });
    d3_rgb_names.forEach(function(key, value) {
        d3_rgb_names.set(key, d3_rgbNumber(value));
    });
    function d3_functor(v) {
        return typeof v === "function" ? v : function() {
            return v;
        };
    }
    d3.functor = d3_functor;
    d3.xhr = d3_xhrType(d3_identity);
    function d3_xhrType(response) {
        return function(url, mimeType, callback) {
            if (arguments.length === 2 && typeof mimeType === "function") callback = mimeType, 
            mimeType = null;
            return d3_xhr(url, mimeType, response, callback);
        };
    }
    function d3_xhr(url, mimeType, response, callback) {
        var xhr = {}, dispatch = d3.dispatch("beforesend", "progress", "load", "error"), headers = {}, request = new XMLHttpRequest(), responseType = null;
        if (this.XDomainRequest && !("withCredentials" in request) && /^(http(s)?:)?\/\//.test(url)) request = new XDomainRequest();
        "onload" in request ? request.onload = request.onerror = respond : request.onreadystatechange = function() {
            request.readyState > 3 && respond();
        };
        function respond() {
            var status = request.status, result;
            if (!status && d3_xhrHasResponse(request) || status >= 200 && status < 300 || status === 304) {
                try {
                    result = response.call(xhr, request);
                } catch (e) {
                    dispatch.error.call(xhr, e);
                    return;
                }
                dispatch.load.call(xhr, result);
            } else {
                dispatch.error.call(xhr, request);
            }
        }
        request.onprogress = function(event) {
            var o = d3.event;
            d3.event = event;
            try {
                dispatch.progress.call(xhr, request);
            } finally {
                d3.event = o;
            }
        };
        xhr.header = function(name, value) {
            name = (name + "").toLowerCase();
            if (arguments.length < 2) return headers[name];
            if (value == null) delete headers[name]; else headers[name] = value + "";
            return xhr;
        };
        xhr.mimeType = function(value) {
            if (!arguments.length) return mimeType;
            mimeType = value == null ? null : value + "";
            return xhr;
        };
        xhr.responseType = function(value) {
            if (!arguments.length) return responseType;
            responseType = value;
            return xhr;
        };
        xhr.response = function(value) {
            response = value;
            return xhr;
        };
        [ "get", "post" ].forEach(function(method) {
            xhr[method] = function() {
                return xhr.send.apply(xhr, [ method ].concat(d3_array(arguments)));
            };
        });
        xhr.send = function(method, data, callback) {
            if (arguments.length === 2 && typeof data === "function") callback = data, data = null;
            request.open(method, url, true);
            if (mimeType != null && !("accept" in headers)) headers["accept"] = mimeType + ",*/*";
            if (request.setRequestHeader) for (var name in headers) request.setRequestHeader(name, headers[name]);
            if (mimeType != null && request.overrideMimeType) request.overrideMimeType(mimeType);
            if (responseType != null) request.responseType = responseType;
            if (callback != null) xhr.on("error", callback).on("load", function(request) {
                callback(null, request);
            });
            dispatch.beforesend.call(xhr, request);
            request.send(data == null ? null : data);
            return xhr;
        };
        xhr.abort = function() {
            request.abort();
            return xhr;
        };
        d3.rebind(xhr, dispatch, "on");
        return callback == null ? xhr : xhr.get(d3_xhr_fixCallback(callback));
    }
    function d3_xhr_fixCallback(callback) {
        return callback.length === 1 ? function(error, request) {
            callback(error == null ? request : null);
        } : callback;
    }
    function d3_xhrHasResponse(request) {
        var type = request.responseType;
        return type && type !== "text" ? request.response : request.responseText;
    }
    d3.dsv = function(delimiter, mimeType) {
        var reFormat = new RegExp('["' + delimiter + "\n]"), delimiterCode = delimiter.charCodeAt(0);
        function dsv(url, row, callback) {
            if (arguments.length < 3) callback = row, row = null;
            var xhr = d3_xhr(url, mimeType, row == null ? response : typedResponse(row), callback);
            xhr.row = function(_) {
                return arguments.length ? xhr.response((row = _) == null ? response : typedResponse(_)) : row;
            };
            return xhr;
        }
        function response(request) {
            return dsv.parse(request.responseText);
        }
        function typedResponse(f) {
            return function(request) {
                return dsv.parse(request.responseText, f);
            };
        }
        dsv.parse = function(text, f) {
            var o;
            return dsv.parseRows(text, function(row, i) {
                if (o) return o(row, i - 1);
                var a = new Function("d", "return {" + row.map(function(name, i) {
                    return JSON.stringify(name) + ": d[" + i + "]";
                }).join(",") + "}");
                o = f ? function(row, i) {
                    return f(a(row), i);
                } : a;
            });
        };
        dsv.parseRows = function(text, f) {
            var EOL = {}, EOF = {}, rows = [], N = text.length, I = 0, n = 0, t, eol;
            function token() {
                if (I >= N) return EOF;
                if (eol) return eol = false, EOL;
                var j = I;
                if (text.charCodeAt(j) === 34) {
                    var i = j;
                    while (i++ < N) {
                        if (text.charCodeAt(i) === 34) {
                            if (text.charCodeAt(i + 1) !== 34) break;
                            ++i;
                        }
                    }
                    I = i + 2;
                    var c = text.charCodeAt(i + 1);
                    if (c === 13) {
                        eol = true;
                        if (text.charCodeAt(i + 2) === 10) ++I;
                    } else if (c === 10) {
                        eol = true;
                    }
                    return text.slice(j + 1, i).replace(/""/g, '"');
                }
                while (I < N) {
                    var c = text.charCodeAt(I++), k = 1;
                    if (c === 10) eol = true; else if (c === 13) {
                        eol = true;
                        if (text.charCodeAt(I) === 10) ++I, ++k;
                    } else if (c !== delimiterCode) continue;
                    return text.slice(j, I - k);
                }
                return text.slice(j);
            }
            while ((t = token()) !== EOF) {
                var a = [];
                while (t !== EOL && t !== EOF) {
                    a.push(t);
                    t = token();
                }
                if (f && (a = f(a, n++)) == null) continue;
                rows.push(a);
            }
            return rows;
        };
        dsv.format = function(rows) {
            if (Array.isArray(rows[0])) return dsv.formatRows(rows);
            var fieldSet = new d3_Set(), fields = [];
            rows.forEach(function(row) {
                for (var field in row) {
                    if (!fieldSet.has(field)) {
                        fields.push(fieldSet.add(field));
                    }
                }
            });
            return [ fields.map(formatValue).join(delimiter) ].concat(rows.map(function(row) {
                return fields.map(function(field) {
                    return formatValue(row[field]);
                }).join(delimiter);
            })).join("\n");
        };
        dsv.formatRows = function(rows) {
            return rows.map(formatRow).join("\n");
        };
        function formatRow(row) {
            return row.map(formatValue).join(delimiter);
        }
        function formatValue(text) {
            return reFormat.test(text) ? '"' + text.replace(/\"/g, '""') + '"' : text;
        }
        return dsv;
    };
    d3.csv = d3.dsv(",", "text/csv");
    d3.tsv = d3.dsv("\t", "text/tab-separated-values");
    var d3_timer_queueHead, d3_timer_queueTail, d3_timer_interval, d3_timer_timeout, d3_timer_frame = this[d3_vendorSymbol(this, "requestAnimationFrame")] || function(callback) {
        setTimeout(callback, 17);
    };
    d3.timer = function() {
        d3_timer.apply(this, arguments);
    };
    function d3_timer(callback, delay, then) {
        var n = arguments.length;
        if (n < 2) delay = 0;
        if (n < 3) then = Date.now();
        var time = then + delay, timer = {
            c: callback,
            t: time,
            n: null
        };
        if (d3_timer_queueTail) d3_timer_queueTail.n = timer; else d3_timer_queueHead = timer;
        d3_timer_queueTail = timer;
        if (!d3_timer_interval) {
            d3_timer_timeout = clearTimeout(d3_timer_timeout);
            d3_timer_interval = 1;
            d3_timer_frame(d3_timer_step);
        }
        return timer;
    }
    function d3_timer_step() {
        var now = d3_timer_mark(), delay = d3_timer_sweep() - now;
        if (delay > 24) {
            if (isFinite(delay)) {
                clearTimeout(d3_timer_timeout);
                d3_timer_timeout = setTimeout(d3_timer_step, delay);
            }
            d3_timer_interval = 0;
        } else {
            d3_timer_interval = 1;
            d3_timer_frame(d3_timer_step);
        }
    }
    d3.timer.flush = function() {
        d3_timer_mark();
        d3_timer_sweep();
    };
    function d3_timer_mark() {
        var now = Date.now(), timer = d3_timer_queueHead;
        while (timer) {
            if (now >= timer.t && timer.c(now - timer.t)) timer.c = null;
            timer = timer.n;
        }
        return now;
    }
    function d3_timer_sweep() {
        var t0, t1 = d3_timer_queueHead, time = Infinity;
        while (t1) {
            if (t1.c) {
                if (t1.t < time) time = t1.t;
                t1 = (t0 = t1).n;
            } else {
                t1 = t0 ? t0.n = t1.n : d3_timer_queueHead = t1.n;
            }
        }
        d3_timer_queueTail = t0;
        return time;
    }
    function d3_format_precision(x, p) {
        return p - (x ? Math.ceil(Math.log(x) / Math.LN10) : 1);
    }
    d3.round = function(x, n) {
        return n ? Math.round(x * (n = Math.pow(10, n))) / n : Math.round(x);
    };
    var d3_formatPrefixes = [ "y", "z", "a", "f", "p", "n", "Âµ", "m", "", "k", "M", "G", "T", "P", "E", "Z", "Y" ].map(d3_formatPrefix);
    d3.formatPrefix = function(value, precision) {
        var i = 0;
        if (value = +value) {
            if (value < 0) value *= -1;
            if (precision) value = d3.round(value, d3_format_precision(value, precision));
            i = 1 + Math.floor(1e-12 + Math.log(value) / Math.LN10);
            i = Math.max(-24, Math.min(24, Math.floor((i - 1) / 3) * 3));
        }
        return d3_formatPrefixes[8 + i / 3];
    };
    function d3_formatPrefix(d, i) {
        var k = Math.pow(10, abs(8 - i) * 3);
        return {
            scale: i > 8 ? function(d) {
                return d / k;
            } : function(d) {
                return d * k;
            },
            symbol: d
        };
    }
    function d3_locale_numberFormat(locale) {
        var locale_decimal = locale.decimal, locale_thousands = locale.thousands, locale_grouping = locale.grouping, locale_currency = locale.currency, formatGroup = locale_grouping && locale_thousands ? function(value, width) {
            var i = value.length, t = [], j = 0, g = locale_grouping[0], length = 0;
            while (i > 0 && g > 0) {
                if (length + g + 1 > width) g = Math.max(1, width - length);
                t.push(value.substring(i -= g, i + g));
                if ((length += g + 1) > width) break;
                g = locale_grouping[j = (j + 1) % locale_grouping.length];
            }
            return t.reverse().join(locale_thousands);
        } : d3_identity;
        return function(specifier) {
            var match = d3_format_re.exec(specifier), fill = match[1] || " ", align = match[2] || ">", sign = match[3] || "-", symbol = match[4] || "", zfill = match[5], width = +match[6], comma = match[7], precision = match[8], type = match[9], scale = 1, prefix = "", suffix = "", integer = false, exponent = true;
            if (precision) precision = +precision.substring(1);
            if (zfill || fill === "0" && align === "=") {
                zfill = fill = "0";
                align = "=";
            }
            switch (type) {
              case "n":
                comma = true;
                type = "g";
                break;

              case "%":
                scale = 100;
                suffix = "%";
                type = "f";
                break;

              case "p":
                scale = 100;
                suffix = "%";
                type = "r";
                break;

              case "b":
              case "o":
              case "x":
              case "X":
                if (symbol === "#") prefix = "0" + type.toLowerCase();

              case "c":
                exponent = false;

              case "d":
                integer = true;
                precision = 0;
                break;

              case "s":
                scale = -1;
                type = "r";
                break;
            }
            if (symbol === "$") prefix = locale_currency[0], suffix = locale_currency[1];
            if (type == "r" && !precision) type = "g";
            if (precision != null) {
                if (type == "g") precision = Math.max(1, Math.min(21, precision)); else if (type == "e" || type == "f") precision = Math.max(0, Math.min(20, precision));
            }
            type = d3_format_types.get(type) || d3_format_typeDefault;
            var zcomma = zfill && comma;
            return function(value) {
                var fullSuffix = suffix;
                if (integer && value % 1) return "";
                var negative = value < 0 || value === 0 && 1 / value < 0 ? (value = -value, "-") : sign === "-" ? "" : sign;
                if (scale < 0) {
                    var unit = d3.formatPrefix(value, precision);
                    value = unit.scale(value);
                    fullSuffix = unit.symbol + suffix;
                } else {
                    value *= scale;
                }
                value = type(value, precision);
                var i = value.lastIndexOf("."), before, after;
                if (i < 0) {
                    var j = exponent ? value.lastIndexOf("e") : -1;
                    if (j < 0) before = value, after = ""; else before = value.substring(0, j), after = value.substring(j);
                } else {
                    before = value.substring(0, i);
                    after = locale_decimal + value.substring(i + 1);
                }
                if (!zfill && comma) before = formatGroup(before, Infinity);
                var length = prefix.length + before.length + after.length + (zcomma ? 0 : negative.length), padding = length < width ? new Array(length = width - length + 1).join(fill) : "";
                if (zcomma) before = formatGroup(padding + before, padding.length ? width - after.length : Infinity);
                negative += prefix;
                value = before + after;
                return (align === "<" ? negative + value + padding : align === ">" ? padding + negative + value : align === "^" ? padding.substring(0, length >>= 1) + negative + value + padding.substring(length) : negative + (zcomma ? value : padding + value)) + fullSuffix;
            };
        };
    }
    var d3_format_re = /(?:([^{])?([<>=^]))?([+\- ])?([$#])?(0)?(\d+)?(,)?(\.-?\d+)?([a-z%])?/i;
    var d3_format_types = d3.map({
        b: function(x) {
            return x.toString(2);
        },
        c: function(x) {
            return String.fromCharCode(x);
        },
        o: function(x) {
            return x.toString(8);
        },
        x: function(x) {
            return x.toString(16);
        },
        X: function(x) {
            return x.toString(16).toUpperCase();
        },
        g: function(x, p) {
            return x.toPrecision(p);
        },
        e: function(x, p) {
            return x.toExponential(p);
        },
        f: function(x, p) {
            return x.toFixed(p);
        },
        r: function(x, p) {
            return (x = d3.round(x, d3_format_precision(x, p))).toFixed(Math.max(0, Math.min(20, d3_format_precision(x * (1 + 1e-15), p))));
        }
    });
    function d3_format_typeDefault(x) {
        return x + "";
    }
    var d3_time = d3.time = {}, d3_date = Date;
    function d3_date_utc() {
        this._ = new Date(arguments.length > 1 ? Date.UTC.apply(this, arguments) : arguments[0]);
    }
    d3_date_utc.prototype = {
        getDate: function() {
            return this._.getUTCDate();
        },
        getDay: function() {
            return this._.getUTCDay();
        },
        getFullYear: function() {
            return this._.getUTCFullYear();
        },
        getHours: function() {
            return this._.getUTCHours();
        },
        getMilliseconds: function() {
            return this._.getUTCMilliseconds();
        },
        getMinutes: function() {
            return this._.getUTCMinutes();
        },
        getMonth: function() {
            return this._.getUTCMonth();
        },
        getSeconds: function() {
            return this._.getUTCSeconds();
        },
        getTime: function() {
            return this._.getTime();
        },
        getTimezoneOffset: function() {
            return 0;
        },
        valueOf: function() {
            return this._.valueOf();
        },
        setDate: function() {
            d3_time_prototype.setUTCDate.apply(this._, arguments);
        },
        setDay: function() {
            d3_time_prototype.setUTCDay.apply(this._, arguments);
        },
        setFullYear: function() {
            d3_time_prototype.setUTCFullYear.apply(this._, arguments);
        },
        setHours: function() {
            d3_time_prototype.setUTCHours.apply(this._, arguments);
        },
        setMilliseconds: function() {
            d3_time_prototype.setUTCMilliseconds.apply(this._, arguments);
        },
        setMinutes: function() {
            d3_time_prototype.setUTCMinutes.apply(this._, arguments);
        },
        setMonth: function() {
            d3_time_prototype.setUTCMonth.apply(this._, arguments);
        },
        setSeconds: function() {
            d3_time_prototype.setUTCSeconds.apply(this._, arguments);
        },
        setTime: function() {
            d3_time_prototype.setTime.apply(this._, arguments);
        }
    };
    var d3_time_prototype = Date.prototype;
    function d3_time_interval(local, step, number) {
        function round(date) {
            var d0 = local(date), d1 = offset(d0, 1);
            return date - d0 < d1 - date ? d0 : d1;
        }
        function ceil(date) {
            step(date = local(new d3_date(date - 1)), 1);
            return date;
        }
        function offset(date, k) {
            step(date = new d3_date((+date)), k);
            return date;
        }
        function range(t0, t1, dt) {
            var time = ceil(t0), times = [];
            if (dt > 1) {
                while (time < t1) {
                    if (!(number(time) % dt)) times.push(new Date((+time)));
                    step(time, 1);
                }
            } else {
                while (time < t1) times.push(new Date((+time))), step(time, 1);
            }
            return times;
        }
        function range_utc(t0, t1, dt) {
            try {
                d3_date = d3_date_utc;
                var utc = new d3_date_utc();
                utc._ = t0;
                return range(utc, t1, dt);
            } finally {
                d3_date = Date;
            }
        }
        local.floor = local;
        local.round = round;
        local.ceil = ceil;
        local.offset = offset;
        local.range = range;
        var utc = local.utc = d3_time_interval_utc(local);
        utc.floor = utc;
        utc.round = d3_time_interval_utc(round);
        utc.ceil = d3_time_interval_utc(ceil);
        utc.offset = d3_time_interval_utc(offset);
        utc.range = range_utc;
        return local;
    }
    function d3_time_interval_utc(method) {
        return function(date, k) {
            try {
                d3_date = d3_date_utc;
                var utc = new d3_date_utc();
                utc._ = date;
                return method(utc, k)._;
            } finally {
                d3_date = Date;
            }
        };
    }
    d3_time.year = d3_time_interval(function(date) {
        date = d3_time.day(date);
        date.setMonth(0, 1);
        return date;
    }, function(date, offset) {
        date.setFullYear(date.getFullYear() + offset);
    }, function(date) {
        return date.getFullYear();
    });
    d3_time.years = d3_time.year.range;
    d3_time.years.utc = d3_time.year.utc.range;
    d3_time.day = d3_time_interval(function(date) {
        var day = new d3_date(2e3, 0);
        day.setFullYear(date.getFullYear(), date.getMonth(), date.getDate());
        return day;
    }, function(date, offset) {
        date.setDate(date.getDate() + offset);
    }, function(date) {
        return date.getDate() - 1;
    });
    d3_time.days = d3_time.day.range;
    d3_time.days.utc = d3_time.day.utc.range;
    d3_time.dayOfYear = function(date) {
        var year = d3_time.year(date);
        return Math.floor((date - year - (date.getTimezoneOffset() - year.getTimezoneOffset()) * 6e4) / 864e5);
    };
    [ "sunday", "monday", "tuesday", "wednesday", "thursday", "friday", "saturday" ].forEach(function(day, i) {
        i = 7 - i;
        var interval = d3_time[day] = d3_time_interval(function(date) {
            (date = d3_time.day(date)).setDate(date.getDate() - (date.getDay() + i) % 7);
            return date;
        }, function(date, offset) {
            date.setDate(date.getDate() + Math.floor(offset) * 7);
        }, function(date) {
            var day = d3_time.year(date).getDay();
            return Math.floor((d3_time.dayOfYear(date) + (day + i) % 7) / 7) - (day !== i);
        });
        d3_time[day + "s"] = interval.range;
        d3_time[day + "s"].utc = interval.utc.range;
        d3_time[day + "OfYear"] = function(date) {
            var day = d3_time.year(date).getDay();
            return Math.floor((d3_time.dayOfYear(date) + (day + i) % 7) / 7);
        };
    });
    d3_time.week = d3_time.sunday;
    d3_time.weeks = d3_time.sunday.range;
    d3_time.weeks.utc = d3_time.sunday.utc.range;
    d3_time.weekOfYear = d3_time.sundayOfYear;
    function d3_locale_timeFormat(locale) {
        var locale_dateTime = locale.dateTime, locale_date = locale.date, locale_time = locale.time, locale_periods = locale.periods, locale_days = locale.days, locale_shortDays = locale.shortDays, locale_months = locale.months, locale_shortMonths = locale.shortMonths;
        function d3_time_format(template) {
            var n = template.length;
            function format(date) {
                var string = [], i = -1, j = 0, c, p, f;
                while (++i < n) {
                    if (template.charCodeAt(i) === 37) {
                        string.push(template.slice(j, i));
                        if ((p = d3_time_formatPads[c = template.charAt(++i)]) != null) c = template.charAt(++i);
                        if (f = d3_time_formats[c]) c = f(date, p == null ? c === "e" ? " " : "0" : p);
                        string.push(c);
                        j = i + 1;
                    }
                }
                string.push(template.slice(j, i));
                return string.join("");
            }
            format.parse = function(string) {
                var d = {
                    y: 1900,
                    m: 0,
                    d: 1,
                    H: 0,
                    M: 0,
                    S: 0,
                    L: 0,
                    Z: null
                }, i = d3_time_parse(d, template, string, 0);
                if (i != string.length) return null;
                if ("p" in d) d.H = d.H % 12 + d.p * 12;
                var localZ = d.Z != null && d3_date !== d3_date_utc, date = new (localZ ? d3_date_utc : d3_date)();
                if ("j" in d) date.setFullYear(d.y, 0, d.j); else if ("W" in d || "U" in d) {
                    if (!("w" in d)) d.w = "W" in d ? 1 : 0;
                    date.setFullYear(d.y, 0, 1);
                    date.setFullYear(d.y, 0, "W" in d ? (d.w + 6) % 7 + d.W * 7 - (date.getDay() + 5) % 7 : d.w + d.U * 7 - (date.getDay() + 6) % 7);
                } else date.setFullYear(d.y, d.m, d.d);
                date.setHours(d.H + (d.Z / 100 | 0), d.M + d.Z % 100, d.S, d.L);
                return localZ ? date._ : date;
            };
            format.toString = function() {
                return template;
            };
            return format;
        }
        function d3_time_parse(date, template, string, j) {
            var c, p, t, i = 0, n = template.length, m = string.length;
            while (i < n) {
                if (j >= m) return -1;
                c = template.charCodeAt(i++);
                if (c === 37) {
                    t = template.charAt(i++);
                    p = d3_time_parsers[t in d3_time_formatPads ? template.charAt(i++) : t];
                    if (!p || (j = p(date, string, j)) < 0) return -1;
                } else if (c != string.charCodeAt(j++)) {
                    return -1;
                }
            }
            return j;
        }
        d3_time_format.utc = function(template) {
            var local = d3_time_format(template);
            function format(date) {
                try {
                    d3_date = d3_date_utc;
                    var utc = new d3_date();
                    utc._ = date;
                    return local(utc);
                } finally {
                    d3_date = Date;
                }
            }
            format.parse = function(string) {
                try {
                    d3_date = d3_date_utc;
                    var date = local.parse(string);
                    return date && date._;
                } finally {
                    d3_date = Date;
                }
            };
            format.toString = local.toString;
            return format;
        };
        d3_time_format.multi = d3_time_format.utc.multi = d3_time_formatMulti;
        var d3_time_periodLookup = d3.map(), d3_time_dayRe = d3_time_formatRe(locale_days), d3_time_dayLookup = d3_time_formatLookup(locale_days), d3_time_dayAbbrevRe = d3_time_formatRe(locale_shortDays), d3_time_dayAbbrevLookup = d3_time_formatLookup(locale_shortDays), d3_time_monthRe = d3_time_formatRe(locale_months), d3_time_monthLookup = d3_time_formatLookup(locale_months), d3_time_monthAbbrevRe = d3_time_formatRe(locale_shortMonths), d3_time_monthAbbrevLookup = d3_time_formatLookup(locale_shortMonths);
        locale_periods.forEach(function(p, i) {
            d3_time_periodLookup.set(p.toLowerCase(), i);
        });
        var d3_time_formats = {
            a: function(d) {
                return locale_shortDays[d.getDay()];
            },
            A: function(d) {
                return locale_days[d.getDay()];
            },
            b: function(d) {
                return locale_shortMonths[d.getMonth()];
            },
            B: function(d) {
                return locale_months[d.getMonth()];
            },
            c: d3_time_format(locale_dateTime),
            d: function(d, p) {
                return d3_time_formatPad(d.getDate(), p, 2);
            },
            e: function(d, p) {
                return d3_time_formatPad(d.getDate(), p, 2);
            },
            H: function(d, p) {
                return d3_time_formatPad(d.getHours(), p, 2);
            },
            I: function(d, p) {
                return d3_time_formatPad(d.getHours() % 12 || 12, p, 2);
            },
            j: function(d, p) {
                return d3_time_formatPad(1 + d3_time.dayOfYear(d), p, 3);
            },
            L: function(d, p) {
                return d3_time_formatPad(d.getMilliseconds(), p, 3);
            },
            m: function(d, p) {
                return d3_time_formatPad(d.getMonth() + 1, p, 2);
            },
            M: function(d, p) {
                return d3_time_formatPad(d.getMinutes(), p, 2);
            },
            p: function(d) {
                return locale_periods[+(d.getHours() >= 12)];
            },
            S: function(d, p) {
                return d3_time_formatPad(d.getSeconds(), p, 2);
            },
            U: function(d, p) {
                return d3_time_formatPad(d3_time.sundayOfYear(d), p, 2);
            },
            w: function(d) {
                return d.getDay();
            },
            W: function(d, p) {
                return d3_time_formatPad(d3_time.mondayOfYear(d), p, 2);
            },
            x: d3_time_format(locale_date),
            X: d3_time_format(locale_time),
            y: function(d, p) {
                return d3_time_formatPad(d.getFullYear() % 100, p, 2);
            },
            Y: function(d, p) {
                return d3_time_formatPad(d.getFullYear() % 1e4, p, 4);
            },
            Z: d3_time_zone,
            "%": function() {
                return "%";
            }
        };
        var d3_time_parsers = {
            a: d3_time_parseWeekdayAbbrev,
            A: d3_time_parseWeekday,
            b: d3_time_parseMonthAbbrev,
            B: d3_time_parseMonth,
            c: d3_time_parseLocaleFull,
            d: d3_time_parseDay,
            e: d3_time_parseDay,
            H: d3_time_parseHour24,
            I: d3_time_parseHour24,
            j: d3_time_parseDayOfYear,
            L: d3_time_parseMilliseconds,
            m: d3_time_parseMonthNumber,
            M: d3_time_parseMinutes,
            p: d3_time_parseAmPm,
            S: d3_time_parseSeconds,
            U: d3_time_parseWeekNumberSunday,
            w: d3_time_parseWeekdayNumber,
            W: d3_time_parseWeekNumberMonday,
            x: d3_time_parseLocaleDate,
            X: d3_time_parseLocaleTime,
            y: d3_time_parseYear,
            Y: d3_time_parseFullYear,
            Z: d3_time_parseZone,
            "%": d3_time_parseLiteralPercent
        };
        function d3_time_parseWeekdayAbbrev(date, string, i) {
            d3_time_dayAbbrevRe.lastIndex = 0;
            var n = d3_time_dayAbbrevRe.exec(string.slice(i));
            return n ? (date.w = d3_time_dayAbbrevLookup.get(n[0].toLowerCase()), i + n[0].length) : -1;
        }
        function d3_time_parseWeekday(date, string, i) {
            d3_time_dayRe.lastIndex = 0;
            var n = d3_time_dayRe.exec(string.slice(i));
            return n ? (date.w = d3_time_dayLookup.get(n[0].toLowerCase()), i + n[0].length) : -1;
        }
        function d3_time_parseMonthAbbrev(date, string, i) {
            d3_time_monthAbbrevRe.lastIndex = 0;
            var n = d3_time_monthAbbrevRe.exec(string.slice(i));
            return n ? (date.m = d3_time_monthAbbrevLookup.get(n[0].toLowerCase()), i + n[0].length) : -1;
        }
        function d3_time_parseMonth(date, string, i) {
            d3_time_monthRe.lastIndex = 0;
            var n = d3_time_monthRe.exec(string.slice(i));
            return n ? (date.m = d3_time_monthLookup.get(n[0].toLowerCase()), i + n[0].length) : -1;
        }
        function d3_time_parseLocaleFull(date, string, i) {
            return d3_time_parse(date, d3_time_formats.c.toString(), string, i);
        }
        function d3_time_parseLocaleDate(date, string, i) {
            return d3_time_parse(date, d3_time_formats.x.toString(), string, i);
        }
        function d3_time_parseLocaleTime(date, string, i) {
            return d3_time_parse(date, d3_time_formats.X.toString(), string, i);
        }
        function d3_time_parseAmPm(date, string, i) {
            var n = d3_time_periodLookup.get(string.slice(i, i += 2).toLowerCase());
            return n == null ? -1 : (date.p = n, i);
        }
        return d3_time_format;
    }
    var d3_time_formatPads = {
        "-": "",
        _: " ",
        "0": "0"
    }, d3_time_numberRe = /^\s*\d+/, d3_time_percentRe = /^%/;
    function d3_time_formatPad(value, fill, width) {
        var sign = value < 0 ? "-" : "", string = (sign ? -value : value) + "", length = string.length;
        return sign + (length < width ? new Array(width - length + 1).join(fill) + string : string);
    }
    function d3_time_formatRe(names) {
        return new RegExp("^(?:" + names.map(d3.requote).join("|") + ")", "i");
    }
    function d3_time_formatLookup(names) {
        var map = new d3_Map(), i = -1, n = names.length;
        while (++i < n) map.set(names[i].toLowerCase(), i);
        return map;
    }
    function d3_time_parseWeekdayNumber(date, string, i) {
        d3_time_numberRe.lastIndex = 0;
        var n = d3_time_numberRe.exec(string.slice(i, i + 1));
        return n ? (date.w = +n[0], i + n[0].length) : -1;
    }
    function d3_time_parseWeekNumberSunday(date, string, i) {
        d3_time_numberRe.lastIndex = 0;
        var n = d3_time_numberRe.exec(string.slice(i));
        return n ? (date.U = +n[0], i + n[0].length) : -1;
    }
    function d3_time_parseWeekNumberMonday(date, string, i) {
        d3_time_numberRe.lastIndex = 0;
        var n = d3_time_numberRe.exec(string.slice(i));
        return n ? (date.W = +n[0], i + n[0].length) : -1;
    }
    function d3_time_parseFullYear(date, string, i) {
        d3_time_numberRe.lastIndex = 0;
        var n = d3_time_numberRe.exec(string.slice(i, i + 4));
        return n ? (date.y = +n[0], i + n[0].length) : -1;
    }
    function d3_time_parseYear(date, string, i) {
        d3_time_numberRe.lastIndex = 0;
        var n = d3_time_numberRe.exec(string.slice(i, i + 2));
        return n ? (date.y = d3_time_expandYear(+n[0]), i + n[0].length) : -1;
    }
    function d3_time_parseZone(date, string, i) {
        return /^[+-]\d{4}$/.test(string = string.slice(i, i + 5)) ? (date.Z = -string, 
        i + 5) : -1;
    }
    function d3_time_expandYear(d) {
        return d + (d > 68 ? 1900 : 2e3);
    }
    function d3_time_parseMonthNumber(date, string, i) {
        d3_time_numberRe.lastIndex = 0;
        var n = d3_time_numberRe.exec(string.slice(i, i + 2));
        return n ? (date.m = n[0] - 1, i + n[0].length) : -1;
    }
    function d3_time_parseDay(date, string, i) {
        d3_time_numberRe.lastIndex = 0;
        var n = d3_time_numberRe.exec(string.slice(i, i + 2));
        return n ? (date.d = +n[0], i + n[0].length) : -1;
    }
    function d3_time_parseDayOfYear(date, string, i) {
        d3_time_numberRe.lastIndex = 0;
        var n = d3_time_numberRe.exec(string.slice(i, i + 3));
        return n ? (date.j = +n[0], i + n[0].length) : -1;
    }
    function d3_time_parseHour24(date, string, i) {
        d3_time_numberRe.lastIndex = 0;
        var n = d3_time_numberRe.exec(string.slice(i, i + 2));
        return n ? (date.H = +n[0], i + n[0].length) : -1;
    }
    function d3_time_parseMinutes(date, string, i) {
        d3_time_numberRe.lastIndex = 0;
        var n = d3_time_numberRe.exec(string.slice(i, i + 2));
        return n ? (date.M = +n[0], i + n[0].length) : -1;
    }
    function d3_time_parseSeconds(date, string, i) {
        d3_time_numberRe.lastIndex = 0;
        var n = d3_time_numberRe.exec(string.slice(i, i + 2));
        return n ? (date.S = +n[0], i + n[0].length) : -1;
    }
    function d3_time_parseMilliseconds(date, string, i) {
        d3_time_numberRe.lastIndex = 0;
        var n = d3_time_numberRe.exec(string.slice(i, i + 3));
        return n ? (date.L = +n[0], i + n[0].length) : -1;
    }
    function d3_time_zone(d) {
        var z = d.getTimezoneOffset(), zs = z > 0 ? "-" : "+", zh = abs(z) / 60 | 0, zm = abs(z) % 60;
        return zs + d3_time_formatPad(zh, "0", 2) + d3_time_formatPad(zm, "0", 2);
    }
    function d3_time_parseLiteralPercent(date, string, i) {
        d3_time_percentRe.lastIndex = 0;
        var n = d3_time_percentRe.exec(string.slice(i, i + 1));
        return n ? i + n[0].length : -1;
    }
    function d3_time_formatMulti(formats) {
        var n = formats.length, i = -1;
        while (++i < n) formats[i][0] = this(formats[i][0]);
        return function(date) {
            var i = 0, f = formats[i];
            while (!f[1](date)) f = formats[++i];
            return f[0](date);
        };
    }
    d3.locale = function(locale) {
        return {
            numberFormat: d3_locale_numberFormat(locale),
            timeFormat: d3_locale_timeFormat(locale)
        };
    };
    var d3_locale_enUS = d3.locale({
        decimal: ".",
        thousands: ",",
        grouping: [ 3 ],
        currency: [ "$", "" ],
        dateTime: "%a %b %e %X %Y",
        date: "%m/%d/%Y",
        time: "%H:%M:%S",
        periods: [ "AM", "PM" ],
        days: [ "Sunday", "Monday", "Tuesday", "Wednesday", "Thursday", "Friday", "Saturday" ],
        shortDays: [ "Sun", "Mon", "Tue", "Wed", "Thu", "Fri", "Sat" ],
        months: [ "January", "February", "March", "April", "May", "June", "July", "August", "September", "October", "November", "December" ],
        shortMonths: [ "Jan", "Feb", "Mar", "Apr", "May", "Jun", "Jul", "Aug", "Sep", "Oct", "Nov", "Dec" ]
    });
    d3.format = d3_locale_enUS.numberFormat;
    d3.geo = {};
    function d3_adder() {}
    d3_adder.prototype = {
        s: 0,
        t: 0,
        add: function(y) {
            d3_adderSum(y, this.t, d3_adderTemp);
            d3_adderSum(d3_adderTemp.s, this.s, this);
            if (this.s) this.t += d3_adderTemp.t; else this.s = d3_adderTemp.t;
        },
        reset: function() {
            this.s = this.t = 0;
        },
        valueOf: function() {
            return this.s;
        }
    };
    var d3_adderTemp = new d3_adder();
    function d3_adderSum(a, b, o) {
        var x = o.s = a + b, bv = x - a, av = x - bv;
        o.t = a - av + (b - bv);
    }
    d3.geo.stream = function(object, listener) {
        if (object && d3_geo_streamObjectType.hasOwnProperty(object.type)) {
            d3_geo_streamObjectType[object.type](object, listener);
        } else {
            d3_geo_streamGeometry(object, listener);
        }
    };
    function d3_geo_streamGeometry(geometry, listener) {
        if (geometry && d3_geo_streamGeometryType.hasOwnProperty(geometry.type)) {
            d3_geo_streamGeometryType[geometry.type](geometry, listener);
        }
    }
    var d3_geo_streamObjectType = {
        Feature: function(feature, listener) {
            d3_geo_streamGeometry(feature.geometry, listener);
        },
        FeatureCollection: function(object, listener) {
            var features = object.features, i = -1, n = features.length;
            while (++i < n) d3_geo_streamGeometry(features[i].geometry, listener);
        }
    };
    var d3_geo_streamGeometryType = {
        Sphere: function(object, listener) {
            listener.sphere();
        },
        Point: function(object, listener) {
            object = object.coordinates;
            listener.point(object[0], object[1], object[2]);
        },
        MultiPoint: function(object, listener) {
            var coordinates = object.coordinates, i = -1, n = coordinates.length;
            while (++i < n) object = coordinates[i], listener.point(object[0], object[1], object[2]);
        },
        LineString: function(object, listener) {
            d3_geo_streamLine(object.coordinates, listener, 0);
        },
        MultiLineString: function(object, listener) {
            var coordinates = object.coordinates, i = -1, n = coordinates.length;
            while (++i < n) d3_geo_streamLine(coordinates[i], listener, 0);
        },
        Polygon: function(object, listener) {
            d3_geo_streamPolygon(object.coordinates, listener);
        },
        MultiPolygon: function(object, listener) {
            var coordinates = object.coordinates, i = -1, n = coordinates.length;
            while (++i < n) d3_geo_streamPolygon(coordinates[i], listener);
        },
        GeometryCollection: function(object, listener) {
            var geometries = object.geometries, i = -1, n = geometries.length;
            while (++i < n) d3_geo_streamGeometry(geometries[i], listener);
        }
    };
    function d3_geo_streamLine(coordinates, listener, closed) {
        var i = -1, n = coordinates.length - closed, coordinate;
        listener.lineStart();
        while (++i < n) coordinate = coordinates[i], listener.point(coordinate[0], coordinate[1], coordinate[2]);
        listener.lineEnd();
    }
    function d3_geo_streamPolygon(coordinates, listener) {
        var i = -1, n = coordinates.length;
        listener.polygonStart();
        while (++i < n) d3_geo_streamLine(coordinates[i], listener, 1);
        listener.polygonEnd();
    }
    d3.geo.area = function(object) {
        d3_geo_areaSum = 0;
        d3.geo.stream(object, d3_geo_area);
        return d3_geo_areaSum;
    };
    var d3_geo_areaSum, d3_geo_areaRingSum = new d3_adder();
    var d3_geo_area = {
        sphere: function() {
            d3_geo_areaSum += 4 * Ï;
        },
        point: d3_noop,
        lineStart: d3_noop,
        lineEnd: d3_noop,
        polygonStart: function() {
            d3_geo_areaRingSum.reset();
            d3_geo_area.lineStart = d3_geo_areaRingStart;
        },
        polygonEnd: function() {
            var area = 2 * d3_geo_areaRingSum;
            d3_geo_areaSum += area < 0 ? 4 * Ï + area : area;
            d3_geo_area.lineStart = d3_geo_area.lineEnd = d3_geo_area.point = d3_noop;
        }
    };
    function d3_geo_areaRingStart() {
        var Î»00, Ï00, Î»0, cosÏ0, sinÏ0;
        d3_geo_area.point = function(Î», Ï) {
            d3_geo_area.point = nextPoint;
            Î»0 = (Î»00 = Î») * d3_radians, cosÏ0 = Math.cos(Ï = (Ï00 = Ï) * d3_radians / 2 + Ï / 4), 
            sinÏ0 = Math.sin(Ï);
        };
        function nextPoint(Î», Ï) {
            Î» *= d3_radians;
            Ï = Ï * d3_radians / 2 + Ï / 4;
            var dÎ» = Î» - Î»0, sdÎ» = dÎ» >= 0 ? 1 : -1, adÎ» = sdÎ» * dÎ», cosÏ = Math.cos(Ï), sinÏ = Math.sin(Ï), k = sinÏ0 * sinÏ, u = cosÏ0 * cosÏ + k * Math.cos(adÎ»), v = k * sdÎ» * Math.sin(adÎ»);
            d3_geo_areaRingSum.add(Math.atan2(v, u));
            Î»0 = Î», cosÏ0 = cosÏ, sinÏ0 = sinÏ;
        }
        d3_geo_area.lineEnd = function() {
            nextPoint(Î»00, Ï00);
        };
    }
    function d3_geo_cartesian(spherical) {
        var Î» = spherical[0], Ï = spherical[1], cosÏ = Math.cos(Ï);
        return [ cosÏ * Math.cos(Î»), cosÏ * Math.sin(Î»), Math.sin(Ï) ];
    }
    function d3_geo_cartesianDot(a, b) {
        return a[0] * b[0] + a[1] * b[1] + a[2] * b[2];
    }
    function d3_geo_cartesianCross(a, b) {
        return [ a[1] * b[2] - a[2] * b[1], a[2] * b[0] - a[0] * b[2], a[0] * b[1] - a[1] * b[0] ];
    }
    function d3_geo_cartesianAdd(a, b) {
        a[0] += b[0];
        a[1] += b[1];
        a[2] += b[2];
    }
    function d3_geo_cartesianScale(vector, k) {
        return [ vector[0] * k, vector[1] * k, vector[2] * k ];
    }
    function d3_geo_cartesianNormalize(d) {
        var l = Math.sqrt(d[0] * d[0] + d[1] * d[1] + d[2] * d[2]);
        d[0] /= l;
        d[1] /= l;
        d[2] /= l;
    }
    function d3_geo_spherical(cartesian) {
        return [ Math.atan2(cartesian[1], cartesian[0]), d3_asin(cartesian[2]) ];
    }
    function d3_geo_sphericalEqual(a, b) {
        return abs(a[0] - b[0]) < Îµ && abs(a[1] - b[1]) < Îµ;
    }
    d3.geo.bounds = function() {
        var Î»0, Ï0, Î»1, Ï1, Î»_, Î»__, Ï__, p0, dÎ»Sum, ranges, range;
        var bound = {
            point: point,
            lineStart: lineStart,
            lineEnd: lineEnd,
            polygonStart: function() {
                bound.point = ringPoint;
                bound.lineStart = ringStart;
                bound.lineEnd = ringEnd;
                dÎ»Sum = 0;
                d3_geo_area.polygonStart();
            },
            polygonEnd: function() {
                d3_geo_area.polygonEnd();
                bound.point = point;
                bound.lineStart = lineStart;
                bound.lineEnd = lineEnd;
                if (d3_geo_areaRingSum < 0) Î»0 = -(Î»1 = 180), Ï0 = -(Ï1 = 90); else if (dÎ»Sum > Îµ) Ï1 = 90; else if (dÎ»Sum < -Îµ) Ï0 = -90;
                range[0] = Î»0, range[1] = Î»1;
            }
        };
        function point(Î», Ï) {
            ranges.push(range = [ Î»0 = Î», Î»1 = Î» ]);
            if (Ï < Ï0) Ï0 = Ï;
            if (Ï > Ï1) Ï1 = Ï;
        }
        function linePoint(Î», Ï) {
            var p = d3_geo_cartesian([ Î» * d3_radians, Ï * d3_radians ]);
            if (p0) {
                var normal = d3_geo_cartesianCross(p0, p), equatorial = [ normal[1], -normal[0], 0 ], inflection = d3_geo_cartesianCross(equatorial, normal);
                d3_geo_cartesianNormalize(inflection);
                inflection = d3_geo_spherical(inflection);
                var dÎ» = Î» - Î»_, s = dÎ» > 0 ? 1 : -1, Î»i = inflection[0] * d3_degrees * s, antimeridian = abs(dÎ») > 180;
                if (antimeridian ^ (s * Î»_ < Î»i && Î»i < s * Î»)) {
                    var Ïi = inflection[1] * d3_degrees;
                    if (Ïi > Ï1) Ï1 = Ïi;
                } else if (Î»i = (Î»i + 360) % 360 - 180, antimeridian ^ (s * Î»_ < Î»i && Î»i < s * Î»)) {
                    var Ïi = -inflection[1] * d3_degrees;
                    if (Ïi < Ï0) Ï0 = Ïi;
                } else {
                    if (Ï < Ï0) Ï0 = Ï;
                    if (Ï > Ï1) Ï1 = Ï;
                }
                if (antimeridian) {
                    if (Î» < Î»_) {
                        if (angle(Î»0, Î») > angle(Î»0, Î»1)) Î»1 = Î»;
                    } else {
                        if (angle(Î», Î»1) > angle(Î»0, Î»1)) Î»0 = Î»;
                    }
                } else {
                    if (Î»1 >= Î»0) {
                        if (Î» < Î»0) Î»0 = Î»;
                        if (Î» > Î»1) Î»1 = Î»;
                    } else {
                        if (Î» > Î»_) {
                            if (angle(Î»0, Î») > angle(Î»0, Î»1)) Î»1 = Î»;
                        } else {
                            if (angle(Î», Î»1) > angle(Î»0, Î»1)) Î»0 = Î»;
                        }
                    }
                }
            } else {
                point(Î», Ï);
            }
            p0 = p, Î»_ = Î»;
        }
        function lineStart() {
            bound.point = linePoint;
        }
        function lineEnd() {
            range[0] = Î»0, range[1] = Î»1;
            bound.point = point;
            p0 = null;
        }
        function ringPoint(Î», Ï) {
            if (p0) {
                var dÎ» = Î» - Î»_;
                dÎ»Sum += abs(dÎ») > 180 ? dÎ» + (dÎ» > 0 ? 360 : -360) : dÎ»;
            } else Î»__ = Î», Ï__ = Ï;
            d3_geo_area.point(Î», Ï);
            linePoint(Î», Ï);
        }
        function ringStart() {
            d3_geo_area.lineStart();
        }
        function ringEnd() {
            ringPoint(Î»__, Ï__);
            d3_geo_area.lineEnd();
            if (abs(dÎ»Sum) > Îµ) Î»0 = -(Î»1 = 180);
            range[0] = Î»0, range[1] = Î»1;
            p0 = null;
        }
        function angle(Î»0, Î»1) {
            return (Î»1 -= Î»0) < 0 ? Î»1 + 360 : Î»1;
        }
        function compareRanges(a, b) {
            return a[0] - b[0];
        }
        function withinRange(x, range) {
            return range[0] <= range[1] ? range[0] <= x && x <= range[1] : x < range[0] || range[1] < x;
        }
        return function(feature) {
            Ï1 = Î»1 = -(Î»0 = Ï0 = Infinity);
            ranges = [];
            d3.geo.stream(feature, bound);
            var n = ranges.length;
            if (n) {
                ranges.sort(compareRanges);
                for (var i = 1, a = ranges[0], b, merged = [ a ]; i < n; ++i) {
                    b = ranges[i];
                    if (withinRange(b[0], a) || withinRange(b[1], a)) {
                        if (angle(a[0], b[1]) > angle(a[0], a[1])) a[1] = b[1];
                        if (angle(b[0], a[1]) > angle(a[0], a[1])) a[0] = b[0];
                    } else {
                        merged.push(a = b);
                    }
                }
                var best = -Infinity, dÎ»;
                for (var n = merged.length - 1, i = 0, a = merged[n], b; i <= n; a = b, ++i) {
                    b = merged[i];
                    if ((dÎ» = angle(a[1], b[0])) > best) best = dÎ», Î»0 = b[0], Î»1 = a[1];
                }
            }
            ranges = range = null;
            return Î»0 === Infinity || Ï0 === Infinity ? [ [ NaN, NaN ], [ NaN, NaN ] ] : [ [ Î»0, Ï0 ], [ Î»1, Ï1 ] ];
        };
    }();
    d3.geo.centroid = function(object) {
        d3_geo_centroidW0 = d3_geo_centroidW1 = d3_geo_centroidX0 = d3_geo_centroidY0 = d3_geo_centroidZ0 = d3_geo_centroidX1 = d3_geo_centroidY1 = d3_geo_centroidZ1 = d3_geo_centroidX2 = d3_geo_centroidY2 = d3_geo_centroidZ2 = 0;
        d3.geo.stream(object, d3_geo_centroid);
        var x = d3_geo_centroidX2, y = d3_geo_centroidY2, z = d3_geo_centroidZ2, m = x * x + y * y + z * z;
        if (m < Îµ2) {
            x = d3_geo_centroidX1, y = d3_geo_centroidY1, z = d3_geo_centroidZ1;
            if (d3_geo_centroidW1 < Îµ) x = d3_geo_centroidX0, y = d3_geo_centroidY0, z = d3_geo_centroidZ0;
            m = x * x + y * y + z * z;
            if (m < Îµ2) return [ NaN, NaN ];
        }
        return [ Math.atan2(y, x) * d3_degrees, d3_asin(z / Math.sqrt(m)) * d3_degrees ];
    };
    var d3_geo_centroidW0, d3_geo_centroidW1, d3_geo_centroidX0, d3_geo_centroidY0, d3_geo_centroidZ0, d3_geo_centroidX1, d3_geo_centroidY1, d3_geo_centroidZ1, d3_geo_centroidX2, d3_geo_centroidY2, d3_geo_centroidZ2;
    var d3_geo_centroid = {
        sphere: d3_noop,
        point: d3_geo_centroidPoint,
        lineStart: d3_geo_centroidLineStart,
        lineEnd: d3_geo_centroidLineEnd,
        polygonStart: function() {
            d3_geo_centroid.lineStart = d3_geo_centroidRingStart;
        },
        polygonEnd: function() {
            d3_geo_centroid.lineStart = d3_geo_centroidLineStart;
        }
    };
    function d3_geo_centroidPoint(Î», Ï) {
        Î» *= d3_radians;
        var cosÏ = Math.cos(Ï *= d3_radians);
        d3_geo_centroidPointXYZ(cosÏ * Math.cos(Î»), cosÏ * Math.sin(Î»), Math.sin(Ï));
    }
    function d3_geo_centroidPointXYZ(x, y, z) {
        ++d3_geo_centroidW0;
        d3_geo_centroidX0 += (x - d3_geo_centroidX0) / d3_geo_centroidW0;
        d3_geo_centroidY0 += (y - d3_geo_centroidY0) / d3_geo_centroidW0;
        d3_geo_centroidZ0 += (z - d3_geo_centroidZ0) / d3_geo_centroidW0;
    }
    function d3_geo_centroidLineStart() {
        var x0, y0, z0;
        d3_geo_centroid.point = function(Î», Ï) {
            Î» *= d3_radians;
            var cosÏ = Math.cos(Ï *= d3_radians);
            x0 = cosÏ * Math.cos(Î»);
            y0 = cosÏ * Math.sin(Î»);
            z0 = Math.sin(Ï);
            d3_geo_centroid.point = nextPoint;
            d3_geo_centroidPointXYZ(x0, y0, z0);
        };
        function nextPoint(Î», Ï) {
            Î» *= d3_radians;
            var cosÏ = Math.cos(Ï *= d3_radians), x = cosÏ * Math.cos(Î»), y = cosÏ * Math.sin(Î»), z = Math.sin(Ï), w = Math.atan2(Math.sqrt((w = y0 * z - z0 * y) * w + (w = z0 * x - x0 * z) * w + (w = x0 * y - y0 * x) * w), x0 * x + y0 * y + z0 * z);
            d3_geo_centroidW1 += w;
            d3_geo_centroidX1 += w * (x0 + (x0 = x));
            d3_geo_centroidY1 += w * (y0 + (y0 = y));
            d3_geo_centroidZ1 += w * (z0 + (z0 = z));
            d3_geo_centroidPointXYZ(x0, y0, z0);
        }
    }
    function d3_geo_centroidLineEnd() {
        d3_geo_centroid.point = d3_geo_centroidPoint;
    }
    function d3_geo_centroidRingStart() {
        var Î»00, Ï00, x0, y0, z0;
        d3_geo_centroid.point = function(Î», Ï) {
            Î»00 = Î», Ï00 = Ï;
            d3_geo_centroid.point = nextPoint;
            Î» *= d3_radians;
            var cosÏ = Math.cos(Ï *= d3_radians);
            x0 = cosÏ * Math.cos(Î»);
            y0 = cosÏ * Math.sin(Î»);
            z0 = Math.sin(Ï);
            d3_geo_centroidPointXYZ(x0, y0, z0);
        };
        d3_geo_centroid.lineEnd = function() {
            nextPoint(Î»00, Ï00);
            d3_geo_centroid.lineEnd = d3_geo_centroidLineEnd;
            d3_geo_centroid.point = d3_geo_centroidPoint;
        };
        function nextPoint(Î», Ï) {
            Î» *= d3_radians;
            var cosÏ = Math.cos(Ï *= d3_radians), x = cosÏ * Math.cos(Î»), y = cosÏ * Math.sin(Î»), z = Math.sin(Ï), cx = y0 * z - z0 * y, cy = z0 * x - x0 * z, cz = x0 * y - y0 * x, m = Math.sqrt(cx * cx + cy * cy + cz * cz), u = x0 * x + y0 * y + z0 * z, v = m && -d3_acos(u) / m, w = Math.atan2(m, u);
            d3_geo_centroidX2 += v * cx;
            d3_geo_centroidY2 += v * cy;
            d3_geo_centroidZ2 += v * cz;
            d3_geo_centroidW1 += w;
            d3_geo_centroidX1 += w * (x0 + (x0 = x));
            d3_geo_centroidY1 += w * (y0 + (y0 = y));
            d3_geo_centroidZ1 += w * (z0 + (z0 = z));
            d3_geo_centroidPointXYZ(x0, y0, z0);
        }
    }
    function d3_geo_compose(a, b) {
        function compose(x, y) {
            return x = a(x, y), b(x[0], x[1]);
        }
        if (a.invert && b.invert) compose.invert = function(x, y) {
            return x = b.invert(x, y), x && a.invert(x[0], x[1]);
        };
        return compose;
    }
    function d3_true() {
        return true;
    }
    function d3_geo_clipPolygon(segments, compare, clipStartInside, interpolate, listener) {
        var subject = [], clip = [];
        segments.forEach(function(segment) {
            if ((n = segment.length - 1) <= 0) return;
            var n, p0 = segment[0], p1 = segment[n];
            if (d3_geo_sphericalEqual(p0, p1)) {
                listener.lineStart();
                for (var i = 0; i < n; ++i) listener.point((p0 = segment[i])[0], p0[1]);
                listener.lineEnd();
                return;
            }
            var a = new d3_geo_clipPolygonIntersection(p0, segment, null, true), b = new d3_geo_clipPolygonIntersection(p0, null, a, false);
            a.o = b;
            subject.push(a);
            clip.push(b);
            a = new d3_geo_clipPolygonIntersection(p1, segment, null, false);
            b = new d3_geo_clipPolygonIntersection(p1, null, a, true);
            a.o = b;
            subject.push(a);
            clip.push(b);
        });
        clip.sort(compare);
        d3_geo_clipPolygonLinkCircular(subject);
        d3_geo_clipPolygonLinkCircular(clip);
        if (!subject.length) return;
        for (var i = 0, entry = clipStartInside, n = clip.length; i < n; ++i) {
            clip[i].e = entry = !entry;
        }
        var start = subject[0], points, point;
        while (1) {
            var current = start, isSubject = true;
            while (current.v) if ((current = current.n) === start) return;
            points = current.z;
            listener.lineStart();
            do {
                current.v = current.o.v = true;
                if (current.e) {
                    if (isSubject) {
                        for (var i = 0, n = points.length; i < n; ++i) listener.point((point = points[i])[0], point[1]);
                    } else {
                        interpolate(current.x, current.n.x, 1, listener);
                    }
                    current = current.n;
                } else {
                    if (isSubject) {
                        points = current.p.z;
                        for (var i = points.length - 1; i >= 0; --i) listener.point((point = points[i])[0], point[1]);
                    } else {
                        interpolate(current.x, current.p.x, -1, listener);
                    }
                    current = current.p;
                }
                current = current.o;
                points = current.z;
                isSubject = !isSubject;
            } while (!current.v);
            listener.lineEnd();
        }
    }
    function d3_geo_clipPolygonLinkCircular(array) {
        if (!(n = array.length)) return;
        var n, i = 0, a = array[0], b;
        while (++i < n) {
            a.n = b = array[i];
            b.p = a;
            a = b;
        }
        a.n = b = array[0];
        b.p = a;
    }
    function d3_geo_clipPolygonIntersection(point, points, other, entry) {
        this.x = point;
        this.z = points;
        this.o = other;
        this.e = entry;
        this.v = false;
        this.n = this.p = null;
    }
    function d3_geo_clip(pointVisible, clipLine, interpolate, clipStart) {
        return function(rotate, listener) {
            var line = clipLine(listener), rotatedClipStart = rotate.invert(clipStart[0], clipStart[1]);
            var clip = {
                point: point,
                lineStart: lineStart,
                lineEnd: lineEnd,
                polygonStart: function() {
                    clip.point = pointRing;
                    clip.lineStart = ringStart;
                    clip.lineEnd = ringEnd;
                    segments = [];
                    polygon = [];
                },
                polygonEnd: function() {
                    clip.point = point;
                    clip.lineStart = lineStart;
                    clip.lineEnd = lineEnd;
                    segments = d3.merge(segments);
                    var clipStartInside = d3_geo_pointInPolygon(rotatedClipStart, polygon);
                    if (segments.length) {
                        if (!polygonStarted) listener.polygonStart(), polygonStarted = true;
                        d3_geo_clipPolygon(segments, d3_geo_clipSort, clipStartInside, interpolate, listener);
                    } else if (clipStartInside) {
                        if (!polygonStarted) listener.polygonStart(), polygonStarted = true;
                        listener.lineStart();
                        interpolate(null, null, 1, listener);
                        listener.lineEnd();
                    }
                    if (polygonStarted) listener.polygonEnd(), polygonStarted = false;
                    segments = polygon = null;
                },
                sphere: function() {
                    listener.polygonStart();
                    listener.lineStart();
                    interpolate(null, null, 1, listener);
                    listener.lineEnd();
                    listener.polygonEnd();
                }
            };
            function point(Î», Ï) {
                var point = rotate(Î», Ï);
                if (pointVisible(Î» = point[0], Ï = point[1])) listener.point(Î», Ï);
            }
            function pointLine(Î», Ï) {
                var point = rotate(Î», Ï);
                line.point(point[0], point[1]);
            }
            function lineStart() {
                clip.point = pointLine;
                line.lineStart();
            }
            function lineEnd() {
                clip.point = point;
                line.lineEnd();
            }
            var segments;
            var buffer = d3_geo_clipBufferListener(), ringListener = clipLine(buffer), polygonStarted = false, polygon, ring;
            function pointRing(Î», Ï) {
                ring.push([ Î», Ï ]);
                var point = rotate(Î», Ï);
                ringListener.point(point[0], point[1]);
            }
            function ringStart() {
                ringListener.lineStart();
                ring = [];
            }
            function ringEnd() {
                pointRing(ring[0][0], ring[0][1]);
                ringListener.lineEnd();
                var clean = ringListener.clean(), ringSegments = buffer.buffer(), segment, n = ringSegments.length;
                ring.pop();
                polygon.push(ring);
                ring = null;
                if (!n) return;
                if (clean & 1) {
                    segment = ringSegments[0];
                    var n = segment.length - 1, i = -1, point;
                    if (n > 0) {
                        if (!polygonStarted) listener.polygonStart(), polygonStarted = true;
                        listener.lineStart();
                        while (++i < n) listener.point((point = segment[i])[0], point[1]);
                        listener.lineEnd();
                    }
                    return;
                }
                if (n > 1 && clean & 2) ringSegments.push(ringSegments.pop().concat(ringSegments.shift()));
                segments.push(ringSegments.filter(d3_geo_clipSegmentLength1));
            }
            return clip;
        };
    }
    function d3_geo_clipSegmentLength1(segment) {
        return segment.length > 1;
    }
    function d3_geo_clipBufferListener() {
        var lines = [], line;
        return {
            lineStart: function() {
                lines.push(line = []);
            },
            point: function(Î», Ï) {
                line.push([ Î», Ï ]);
            },
            lineEnd: d3_noop,
            buffer: function() {
                var buffer = lines;
                lines = [];
                line = null;
                return buffer;
            },
            rejoin: function() {
                if (lines.length > 1) lines.push(lines.pop().concat(lines.shift()));
            }
        };
    }
    function d3_geo_clipSort(a, b) {
        return ((a = a.x)[0] < 0 ? a[1] - halfÏ - Îµ : halfÏ - a[1]) - ((b = b.x)[0] < 0 ? b[1] - halfÏ - Îµ : halfÏ - b[1]);
    }
    var d3_geo_clipAntimeridian = d3_geo_clip(d3_true, d3_geo_clipAntimeridianLine, d3_geo_clipAntimeridianInterpolate, [ -Ï, -Ï / 2 ]);
    function d3_geo_clipAntimeridianLine(listener) {
        var Î»0 = NaN, Ï0 = NaN, sÎ»0 = NaN, clean;
        return {
            lineStart: function() {
                listener.lineStart();
                clean = 1;
            },
            point: function(Î»1, Ï1) {
                var sÎ»1 = Î»1 > 0 ? Ï : -Ï, dÎ» = abs(Î»1 - Î»0);
                if (abs(dÎ» - Ï) < Îµ) {
                    listener.point(Î»0, Ï0 = (Ï0 + Ï1) / 2 > 0 ? halfÏ : -halfÏ);
                    listener.point(sÎ»0, Ï0);
                    listener.lineEnd();
                    listener.lineStart();
                    listener.point(sÎ»1, Ï0);
                    listener.point(Î»1, Ï0);
                    clean = 0;
                } else if (sÎ»0 !== sÎ»1 && dÎ» >= Ï) {
                    if (abs(Î»0 - sÎ»0) < Îµ) Î»0 -= sÎ»0 * Îµ;
                    if (abs(Î»1 - sÎ»1) < Îµ) Î»1 -= sÎ»1 * Îµ;
                    Ï0 = d3_geo_clipAntimeridianIntersect(Î»0, Ï0, Î»1, Ï1);
                    listener.point(sÎ»0, Ï0);
                    listener.lineEnd();
                    listener.lineStart();
                    listener.point(sÎ»1, Ï0);
                    clean = 0;
                }
                listener.point(Î»0 = Î»1, Ï0 = Ï1);
                sÎ»0 = sÎ»1;
            },
            lineEnd: function() {
                listener.lineEnd();
                Î»0 = Ï0 = NaN;
            },
            clean: function() {
                return 2 - clean;
            }
        };
    }
    function d3_geo_clipAntimeridianIntersect(Î»0, Ï0, Î»1, Ï1) {
        var cosÏ0, cosÏ1, sinÎ»0_Î»1 = Math.sin(Î»0 - Î»1);
        return abs(sinÎ»0_Î»1) > Îµ ? Math.atan((Math.sin(Ï0) * (cosÏ1 = Math.cos(Ï1)) * Math.sin(Î»1) - Math.sin(Ï1) * (cosÏ0 = Math.cos(Ï0)) * Math.sin(Î»0)) / (cosÏ0 * cosÏ1 * sinÎ»0_Î»1)) : (Ï0 + Ï1) / 2;
    }
    function d3_geo_clipAntimeridianInterpolate(from, to, direction, listener) {
        var Ï;
        if (from == null) {
            Ï = direction * halfÏ;
            listener.point(-Ï, Ï);
            listener.point(0, Ï);
            listener.point(Ï, Ï);
            listener.point(Ï, 0);
            listener.point(Ï, -Ï);
            listener.point(0, -Ï);
            listener.point(-Ï, -Ï);
            listener.point(-Ï, 0);
            listener.point(-Ï, Ï);
        } else if (abs(from[0] - to[0]) > Îµ) {
            var s = from[0] < to[0] ? Ï : -Ï;
            Ï = direction * s / 2;
            listener.point(-s, Ï);
            listener.point(0, Ï);
            listener.point(s, Ï);
        } else {
            listener.point(to[0], to[1]);
        }
    }
    function d3_geo_pointInPolygon(point, polygon) {
        var meridian = point[0], parallel = point[1], meridianNormal = [ Math.sin(meridian), -Math.cos(meridian), 0 ], polarAngle = 0, winding = 0;
        d3_geo_areaRingSum.reset();
        for (var i = 0, n = polygon.length; i < n; ++i) {
            var ring = polygon[i], m = ring.length;
            if (!m) continue;
            var point0 = ring[0], Î»0 = point0[0], Ï0 = point0[1] / 2 + Ï / 4, sinÏ0 = Math.sin(Ï0), cosÏ0 = Math.cos(Ï0), j = 1;
            while (true) {
                if (j === m) j = 0;
                point = ring[j];
                var Î» = point[0], Ï = point[1] / 2 + Ï / 4, sinÏ = Math.sin(Ï), cosÏ = Math.cos(Ï), dÎ» = Î» - Î»0, sdÎ» = dÎ» >= 0 ? 1 : -1, adÎ» = sdÎ» * dÎ», antimeridian = adÎ» > Ï, k = sinÏ0 * sinÏ;
                d3_geo_areaRingSum.add(Math.atan2(k * sdÎ» * Math.sin(adÎ»), cosÏ0 * cosÏ + k * Math.cos(adÎ»)));
                polarAngle += antimeridian ? dÎ» + sdÎ» * Ï : dÎ»;
                if (antimeridian ^ Î»0 >= meridian ^ Î» >= meridian) {
                    var arc = d3_geo_cartesianCross(d3_geo_cartesian(point0), d3_geo_cartesian(point));
                    d3_geo_cartesianNormalize(arc);
                    var intersection = d3_geo_cartesianCross(meridianNormal, arc);
                    d3_geo_cartesianNormalize(intersection);
                    var Ïarc = (antimeridian ^ dÎ» >= 0 ? -1 : 1) * d3_asin(intersection[2]);
                    if (parallel > Ïarc || parallel === Ïarc && (arc[0] || arc[1])) {
                        winding += antimeridian ^ dÎ» >= 0 ? 1 : -1;
                    }
                }
                if (!j++) break;
                Î»0 = Î», sinÏ0 = sinÏ, cosÏ0 = cosÏ, point0 = point;
            }
        }
        return (polarAngle < -Îµ || polarAngle < Îµ && d3_geo_areaRingSum < -Îµ) ^ winding & 1;
    }
    function d3_geo_clipCircle(radius) {
        var cr = Math.cos(radius), smallRadius = cr > 0, notHemisphere = abs(cr) > Îµ, interpolate = d3_geo_circleInterpolate(radius, 6 * d3_radians);
        return d3_geo_clip(visible, clipLine, interpolate, smallRadius ? [ 0, -radius ] : [ -Ï, radius - Ï ]);
        function visible(Î», Ï) {
            return Math.cos(Î») * Math.cos(Ï) > cr;
        }
        function clipLine(listener) {
            var point0, c0, v0, v00, clean;
            return {
                lineStart: function() {
                    v00 = v0 = false;
                    clean = 1;
                },
                point: function(Î», Ï) {
                    var point1 = [ Î», Ï ], point2, v = visible(Î», Ï), c = smallRadius ? v ? 0 : code(Î», Ï) : v ? code(Î» + (Î» < 0 ? Ï : -Ï), Ï) : 0;
                    if (!point0 && (v00 = v0 = v)) listener.lineStart();
                    if (v !== v0) {
                        point2 = intersect(point0, point1);
                        if (d3_geo_sphericalEqual(point0, point2) || d3_geo_sphericalEqual(point1, point2)) {
                            point1[0] += Îµ;
                            point1[1] += Îµ;
                            v = visible(point1[0], point1[1]);
                        }
                    }
                    if (v !== v0) {
                        clean = 0;
                        if (v) {
                            listener.lineStart();
                            point2 = intersect(point1, point0);
                            listener.point(point2[0], point2[1]);
                        } else {
                            point2 = intersect(point0, point1);
                            listener.point(point2[0], point2[1]);
                            listener.lineEnd();
                        }
                        point0 = point2;
                    } else if (notHemisphere && point0 && smallRadius ^ v) {
                        var t;
                        if (!(c & c0) && (t = intersect(point1, point0, true))) {
                            clean = 0;
                            if (smallRadius) {
                                listener.lineStart();
                                listener.point(t[0][0], t[0][1]);
                                listener.point(t[1][0], t[1][1]);
                                listener.lineEnd();
                            } else {
                                listener.point(t[1][0], t[1][1]);
                                listener.lineEnd();
                                listener.lineStart();
                                listener.point(t[0][0], t[0][1]);
                            }
                        }
                    }
                    if (v && (!point0 || !d3_geo_sphericalEqual(point0, point1))) {
                        listener.point(point1[0], point1[1]);
                    }
                    point0 = point1, v0 = v, c0 = c;
                },
                lineEnd: function() {
                    if (v0) listener.lineEnd();
                    point0 = null;
                },
                clean: function() {
                    return clean | (v00 && v0) << 1;
                }
            };
        }
        function intersect(a, b, two) {
            var pa = d3_geo_cartesian(a), pb = d3_geo_cartesian(b);
            var n1 = [ 1, 0, 0 ], n2 = d3_geo_cartesianCross(pa, pb), n2n2 = d3_geo_cartesianDot(n2, n2), n1n2 = n2[0], determinant = n2n2 - n1n2 * n1n2;
            if (!determinant) return !two && a;
            var c1 = cr * n2n2 / determinant, c2 = -cr * n1n2 / determinant, n1xn2 = d3_geo_cartesianCross(n1, n2), A = d3_geo_cartesianScale(n1, c1), B = d3_geo_cartesianScale(n2, c2);
            d3_geo_cartesianAdd(A, B);
            var u = n1xn2, w = d3_geo_cartesianDot(A, u), uu = d3_geo_cartesianDot(u, u), t2 = w * w - uu * (d3_geo_cartesianDot(A, A) - 1);
            if (t2 < 0) return;
            var t = Math.sqrt(t2), q = d3_geo_cartesianScale(u, (-w - t) / uu);
            d3_geo_cartesianAdd(q, A);
            q = d3_geo_spherical(q);
            if (!two) return q;
            var Î»0 = a[0], Î»1 = b[0], Ï0 = a[1], Ï1 = b[1], z;
            if (Î»1 < Î»0) z = Î»0, Î»0 = Î»1, Î»1 = z;
            var Î´Î» = Î»1 - Î»0, polar = abs(Î´Î» - Ï) < Îµ, meridian = polar || Î´Î» < Îµ;
            if (!polar && Ï1 < Ï0) z = Ï0, Ï0 = Ï1, Ï1 = z;
            if (meridian ? polar ? Ï0 + Ï1 > 0 ^ q[1] < (abs(q[0] - Î»0) < Îµ ? Ï0 : Ï1) : Ï0 <= q[1] && q[1] <= Ï1 : Î´Î» > Ï ^ (Î»0 <= q[0] && q[0] <= Î»1)) {
                var q1 = d3_geo_cartesianScale(u, (-w + t) / uu);
                d3_geo_cartesianAdd(q1, A);
                return [ q, d3_geo_spherical(q1) ];
            }
        }
        function code(Î», Ï) {
            var r = smallRadius ? radius : Ï - radius, code = 0;
            if (Î» < -r) code |= 1; else if (Î» > r) code |= 2;
            if (Ï < -r) code |= 4; else if (Ï > r) code |= 8;
            return code;
        }
    }
    function d3_geom_clipLine(x0, y0, x1, y1) {
        return function(line) {
            var a = line.a, b = line.b, ax = a.x, ay = a.y, bx = b.x, by = b.y, t0 = 0, t1 = 1, dx = bx - ax, dy = by - ay, r;
            r = x0 - ax;
            if (!dx && r > 0) return;
            r /= dx;
            if (dx < 0) {
                if (r < t0) return;
                if (r < t1) t1 = r;
            } else if (dx > 0) {
                if (r > t1) return;
                if (r > t0) t0 = r;
            }
            r = x1 - ax;
            if (!dx && r < 0) return;
            r /= dx;
            if (dx < 0) {
                if (r > t1) return;
                if (r > t0) t0 = r;
            } else if (dx > 0) {
                if (r < t0) return;
                if (r < t1) t1 = r;
            }
            r = y0 - ay;
            if (!dy && r > 0) return;
            r /= dy;
            if (dy < 0) {
                if (r < t0) return;
                if (r < t1) t1 = r;
            } else if (dy > 0) {
                if (r > t1) return;
                if (r > t0) t0 = r;
            }
            r = y1 - ay;
            if (!dy && r < 0) return;
            r /= dy;
            if (dy < 0) {
                if (r > t1) return;
                if (r > t0) t0 = r;
            } else if (dy > 0) {
                if (r < t0) return;
                if (r < t1) t1 = r;
            }
            if (t0 > 0) line.a = {
                x: ax + t0 * dx,
                y: ay + t0 * dy
            };
            if (t1 < 1) line.b = {
                x: ax + t1 * dx,
                y: ay + t1 * dy
            };
            return line;
        };
    }
    var d3_geo_clipExtentMAX = 1e9;
    d3.geo.clipExtent = function() {
        var x0, y0, x1, y1, stream, clip, clipExtent = {
            stream: function(output) {
                if (stream) stream.valid = false;
                stream = clip(output);
                stream.valid = true;
                return stream;
            },
            extent: function(_) {
                if (!arguments.length) return [ [ x0, y0 ], [ x1, y1 ] ];
                clip = d3_geo_clipExtent(x0 = +_[0][0], y0 = +_[0][1], x1 = +_[1][0], y1 = +_[1][1]);
                if (stream) stream.valid = false, stream = null;
                return clipExtent;
            }
        };
        return clipExtent.extent([ [ 0, 0 ], [ 960, 500 ] ]);
    };
    function d3_geo_clipExtent(x0, y0, x1, y1) {
        return function(listener) {
            var listener_ = listener, bufferListener = d3_geo_clipBufferListener(), clipLine = d3_geom_clipLine(x0, y0, x1, y1), segments, polygon, ring;
            var clip = {
                point: point,
                lineStart: lineStart,
                lineEnd: lineEnd,
                polygonStart: function() {
                    listener = bufferListener;
                    segments = [];
                    polygon = [];
                    clean = true;
                },
                polygonEnd: function() {
                    listener = listener_;
                    segments = d3.merge(segments);
                    var clipStartInside = insidePolygon([ x0, y1 ]), inside = clean && clipStartInside, visible = segments.length;
                    if (inside || visible) {
                        listener.polygonStart();
                        if (inside) {
                            listener.lineStart();
                            interpolate(null, null, 1, listener);
                            listener.lineEnd();
                        }
                        if (visible) {
                            d3_geo_clipPolygon(segments, compare, clipStartInside, interpolate, listener);
                        }
                        listener.polygonEnd();
                    }
                    segments = polygon = ring = null;
                }
            };
            function insidePolygon(p) {
                var wn = 0, n = polygon.length, y = p[1];
                for (var i = 0; i < n; ++i) {
                    for (var j = 1, v = polygon[i], m = v.length, a = v[0], b; j < m; ++j) {
                        b = v[j];
                        if (a[1] <= y) {
                            if (b[1] > y && d3_cross2d(a, b, p) > 0) ++wn;
                        } else {
                            if (b[1] <= y && d3_cross2d(a, b, p) < 0) --wn;
                        }
                        a = b;
                    }
                }
                return wn !== 0;
            }
            function interpolate(from, to, direction, listener) {
                var a = 0, a1 = 0;
                if (from == null || (a = corner(from, direction)) !== (a1 = corner(to, direction)) || comparePoints(from, to) < 0 ^ direction > 0) {
                    do {
                        listener.point(a === 0 || a === 3 ? x0 : x1, a > 1 ? y1 : y0);
                    } while ((a = (a + direction + 4) % 4) !== a1);
                } else {
                    listener.point(to[0], to[1]);
                }
            }
            function pointVisible(x, y) {
                return x0 <= x && x <= x1 && y0 <= y && y <= y1;
            }
            function point(x, y) {
                if (pointVisible(x, y)) listener.point(x, y);
            }
            var x__, y__, v__, x_, y_, v_, first, clean;
            function lineStart() {
                clip.point = linePoint;
                if (polygon) polygon.push(ring = []);
                first = true;
                v_ = false;
                x_ = y_ = NaN;
            }
            function lineEnd() {
                if (segments) {
                    linePoint(x__, y__);
                    if (v__ && v_) bufferListener.rejoin();
                    segments.push(bufferListener.buffer());
                }
                clip.point = point;
                if (v_) listener.lineEnd();
            }
            function linePoint(x, y) {
                x = Math.max(-d3_geo_clipExtentMAX, Math.min(d3_geo_clipExtentMAX, x));
                y = Math.max(-d3_geo_clipExtentMAX, Math.min(d3_geo_clipExtentMAX, y));
                var v = pointVisible(x, y);
                if (polygon) ring.push([ x, y ]);
                if (first) {
                    x__ = x, y__ = y, v__ = v;
                    first = false;
                    if (v) {
                        listener.lineStart();
                        listener.point(x, y);
                    }
                } else {
                    if (v && v_) listener.point(x, y); else {
                        var l = {
                            a: {
                                x: x_,
                                y: y_
                            },
                            b: {
                                x: x,
                                y: y
                            }
                        };
                        if (clipLine(l)) {
                            if (!v_) {
                                listener.lineStart();
                                listener.point(l.a.x, l.a.y);
                            }
                            listener.point(l.b.x, l.b.y);
                            if (!v) listener.lineEnd();
                            clean = false;
                        } else if (v) {
                            listener.lineStart();
                            listener.point(x, y);
                            clean = false;
                        }
                    }
                }
                x_ = x, y_ = y, v_ = v;
            }
            return clip;
        };
        function corner(p, direction) {
            return abs(p[0] - x0) < Îµ ? direction > 0 ? 0 : 3 : abs(p[0] - x1) < Îµ ? direction > 0 ? 2 : 1 : abs(p[1] - y0) < Îµ ? direction > 0 ? 1 : 0 : direction > 0 ? 3 : 2;
        }
        function compare(a, b) {
            return comparePoints(a.x, b.x);
        }
        function comparePoints(a, b) {
            var ca = corner(a, 1), cb = corner(b, 1);
            return ca !== cb ? ca - cb : ca === 0 ? b[1] - a[1] : ca === 1 ? a[0] - b[0] : ca === 2 ? a[1] - b[1] : b[0] - a[0];
        }
    }
    function d3_geo_conic(projectAt) {
        var Ï0 = 0, Ï1 = Ï / 3, m = d3_geo_projectionMutator(projectAt), p = m(Ï0, Ï1);
        p.parallels = function(_) {
            if (!arguments.length) return [ Ï0 / Ï * 180, Ï1 / Ï * 180 ];
            return m(Ï0 = _[0] * Ï / 180, Ï1 = _[1] * Ï / 180);
        };
        return p;
    }
    function d3_geo_conicEqualArea(Ï0, Ï1) {
        var sinÏ0 = Math.sin(Ï0), n = (sinÏ0 + Math.sin(Ï1)) / 2, C = 1 + sinÏ0 * (2 * n - sinÏ0), Ï0 = Math.sqrt(C) / n;
        function forward(Î», Ï) {
            var Ï = Math.sqrt(C - 2 * n * Math.sin(Ï)) / n;
            return [ Ï * Math.sin(Î» *= n), Ï0 - Ï * Math.cos(Î») ];
        }
        forward.invert = function(x, y) {
            var Ï0_y = Ï0 - y;
            return [ Math.atan2(x, Ï0_y) / n, d3_asin((C - (x * x + Ï0_y * Ï0_y) * n * n) / (2 * n)) ];
        };
        return forward;
    }
    (d3.geo.conicEqualArea = function() {
        return d3_geo_conic(d3_geo_conicEqualArea);
    }).raw = d3_geo_conicEqualArea;
    d3.geo.albers = function() {
        return d3.geo.conicEqualArea().rotate([ 96, 0 ]).center([ -.6, 38.7 ]).parallels([ 29.5, 45.5 ]).scale(1070);
    };
    d3.geo.albersUsa = function() {
        var lower48 = d3.geo.albers();
        var alaska = d3.geo.conicEqualArea().rotate([ 154, 0 ]).center([ -2, 58.5 ]).parallels([ 55, 65 ]);
        var hawaii = d3.geo.conicEqualArea().rotate([ 157, 0 ]).center([ -3, 19.9 ]).parallels([ 8, 18 ]);
        var point, pointStream = {
            point: function(x, y) {
                point = [ x, y ];
            }
        }, lower48Point, alaskaPoint, hawaiiPoint;
        function albersUsa(coordinates) {
            var x = coordinates[0], y = coordinates[1];
            point = null;
            (lower48Point(x, y), point) || (alaskaPoint(x, y), point) || hawaiiPoint(x, y);
            return point;
        }
        albersUsa.invert = function(coordinates) {
            var k = lower48.scale(), t = lower48.translate(), x = (coordinates[0] - t[0]) / k, y = (coordinates[1] - t[1]) / k;
            return (y >= .12 && y < .234 && x >= -.425 && x < -.214 ? alaska : y >= .166 && y < .234 && x >= -.214 && x < -.115 ? hawaii : lower48).invert(coordinates);
        };
        albersUsa.stream = function(stream) {
            var lower48Stream = lower48.stream(stream), alaskaStream = alaska.stream(stream), hawaiiStream = hawaii.stream(stream);
            return {
                point: function(x, y) {
                    lower48Stream.point(x, y);
                    alaskaStream.point(x, y);
                    hawaiiStream.point(x, y);
                },
                sphere: function() {
                    lower48Stream.sphere();
                    alaskaStream.sphere();
                    hawaiiStream.sphere();
                },
                lineStart: function() {
                    lower48Stream.lineStart();
                    alaskaStream.lineStart();
                    hawaiiStream.lineStart();
                },
                lineEnd: function() {
                    lower48Stream.lineEnd();
                    alaskaStream.lineEnd();
                    hawaiiStream.lineEnd();
                },
                polygonStart: function() {
                    lower48Stream.polygonStart();
                    alaskaStream.polygonStart();
                    hawaiiStream.polygonStart();
                },
                polygonEnd: function() {
                    lower48Stream.polygonEnd();
                    alaskaStream.polygonEnd();
                    hawaiiStream.polygonEnd();
                }
            };
        };
        albersUsa.precision = function(_) {
            if (!arguments.length) return lower48.precision();
            lower48.precision(_);
            alaska.precision(_);
            hawaii.precision(_);
            return albersUsa;
        };
        albersUsa.scale = function(_) {
            if (!arguments.length) return lower48.scale();
            lower48.scale(_);
            alaska.scale(_ * .35);
            hawaii.scale(_);
            return albersUsa.translate(lower48.translate());
        };
        albersUsa.translate = function(_) {
            if (!arguments.length) return lower48.translate();
            var k = lower48.scale(), x = +_[0], y = +_[1];
            lower48Point = lower48.translate(_).clipExtent([ [ x - .455 * k, y - .238 * k ], [ x + .455 * k, y + .238 * k ] ]).stream(pointStream).point;
            alaskaPoint = alaska.translate([ x - .307 * k, y + .201 * k ]).clipExtent([ [ x - .425 * k + Îµ, y + .12 * k + Îµ ], [ x - .214 * k - Îµ, y + .234 * k - Îµ ] ]).stream(pointStream).point;
            hawaiiPoint = hawaii.translate([ x - .205 * k, y + .212 * k ]).clipExtent([ [ x - .214 * k + Îµ, y + .166 * k + Îµ ], [ x - .115 * k - Îµ, y + .234 * k - Îµ ] ]).stream(pointStream).point;
            return albersUsa;
        };
        return albersUsa.scale(1070);
    };
    var d3_geo_pathAreaSum, d3_geo_pathAreaPolygon, d3_geo_pathArea = {
        point: d3_noop,
        lineStart: d3_noop,
        lineEnd: d3_noop,
        polygonStart: function() {
            d3_geo_pathAreaPolygon = 0;
            d3_geo_pathArea.lineStart = d3_geo_pathAreaRingStart;
        },
        polygonEnd: function() {
            d3_geo_pathArea.lineStart = d3_geo_pathArea.lineEnd = d3_geo_pathArea.point = d3_noop;
            d3_geo_pathAreaSum += abs(d3_geo_pathAreaPolygon / 2);
        }
    };
    function d3_geo_pathAreaRingStart() {
        var x00, y00, x0, y0;
        d3_geo_pathArea.point = function(x, y) {
            d3_geo_pathArea.point = nextPoint;
            x00 = x0 = x, y00 = y0 = y;
        };
        function nextPoint(x, y) {
            d3_geo_pathAreaPolygon += y0 * x - x0 * y;
            x0 = x, y0 = y;
        }
        d3_geo_pathArea.lineEnd = function() {
            nextPoint(x00, y00);
        };
    }
    var d3_geo_pathBoundsX0, d3_geo_pathBoundsY0, d3_geo_pathBoundsX1, d3_geo_pathBoundsY1;
    var d3_geo_pathBounds = {
        point: d3_geo_pathBoundsPoint,
        lineStart: d3_noop,
        lineEnd: d3_noop,
        polygonStart: d3_noop,
        polygonEnd: d3_noop
    };
    function d3_geo_pathBoundsPoint(x, y) {
        if (x < d3_geo_pathBoundsX0) d3_geo_pathBoundsX0 = x;
        if (x > d3_geo_pathBoundsX1) d3_geo_pathBoundsX1 = x;
        if (y < d3_geo_pathBoundsY0) d3_geo_pathBoundsY0 = y;
        if (y > d3_geo_pathBoundsY1) d3_geo_pathBoundsY1 = y;
    }
    function d3_geo_pathBuffer() {
        var pointCircle = d3_geo_pathBufferCircle(4.5), buffer = [];
        var stream = {
            point: point,
            lineStart: function() {
                stream.point = pointLineStart;
            },
            lineEnd: lineEnd,
            polygonStart: function() {
                stream.lineEnd = lineEndPolygon;
            },
            polygonEnd: function() {
                stream.lineEnd = lineEnd;
                stream.point = point;
            },
            pointRadius: function(_) {
                pointCircle = d3_geo_pathBufferCircle(_);
                return stream;
            },
            result: function() {
                if (buffer.length) {
                    var result = buffer.join("");
                    buffer = [];
                    return result;
                }
            }
        };
        function point(x, y) {
            buffer.push("M", x, ",", y, pointCircle);
        }
        function pointLineStart(x, y) {
            buffer.push("M", x, ",", y);
            stream.point = pointLine;
        }
        function pointLine(x, y) {
            buffer.push("L", x, ",", y);
        }
        function lineEnd() {
            stream.point = point;
        }
        function lineEndPolygon() {
            buffer.push("Z");
        }
        return stream;
    }
    function d3_geo_pathBufferCircle(radius) {
        return "m0," + radius + "a" + radius + "," + radius + " 0 1,1 0," + -2 * radius + "a" + radius + "," + radius + " 0 1,1 0," + 2 * radius + "z";
    }
    var d3_geo_pathCentroid = {
        point: d3_geo_pathCentroidPoint,
        lineStart: d3_geo_pathCentroidLineStart,
        lineEnd: d3_geo_pathCentroidLineEnd,
        polygonStart: function() {
            d3_geo_pathCentroid.lineStart = d3_geo_pathCentroidRingStart;
        },
        polygonEnd: function() {
            d3_geo_pathCentroid.point = d3_geo_pathCentroidPoint;
            d3_geo_pathCentroid.lineStart = d3_geo_pathCentroidLineStart;
            d3_geo_pathCentroid.lineEnd = d3_geo_pathCentroidLineEnd;
        }
    };
    function d3_geo_pathCentroidPoint(x, y) {
        d3_geo_centroidX0 += x;
        d3_geo_centroidY0 += y;
        ++d3_geo_centroidZ0;
    }
    function d3_geo_pathCentroidLineStart() {
        var x0, y0;
        d3_geo_pathCentroid.point = function(x, y) {
            d3_geo_pathCentroid.point = nextPoint;
            d3_geo_pathCentroidPoint(x0 = x, y0 = y);
        };
        function nextPoint(x, y) {
            var dx = x - x0, dy = y - y0, z = Math.sqrt(dx * dx + dy * dy);
            d3_geo_centroidX1 += z * (x0 + x) / 2;
            d3_geo_centroidY1 += z * (y0 + y) / 2;
            d3_geo_centroidZ1 += z;
            d3_geo_pathCentroidPoint(x0 = x, y0 = y);
        }
    }
    function d3_geo_pathCentroidLineEnd() {
        d3_geo_pathCentroid.point = d3_geo_pathCentroidPoint;
    }
    function d3_geo_pathCentroidRingStart() {
        var x00, y00, x0, y0;
        d3_geo_pathCentroid.point = function(x, y) {
            d3_geo_pathCentroid.point = nextPoint;
            d3_geo_pathCentroidPoint(x00 = x0 = x, y00 = y0 = y);
        };
        function nextPoint(x, y) {
            var dx = x - x0, dy = y - y0, z = Math.sqrt(dx * dx + dy * dy);
            d3_geo_centroidX1 += z * (x0 + x) / 2;
            d3_geo_centroidY1 += z * (y0 + y) / 2;
            d3_geo_centroidZ1 += z;
            z = y0 * x - x0 * y;
            d3_geo_centroidX2 += z * (x0 + x);
            d3_geo_centroidY2 += z * (y0 + y);
            d3_geo_centroidZ2 += z * 3;
            d3_geo_pathCentroidPoint(x0 = x, y0 = y);
        }
        d3_geo_pathCentroid.lineEnd = function() {
            nextPoint(x00, y00);
        };
    }
    function d3_geo_pathContext(context) {
        var pointRadius = 4.5;
        var stream = {
            point: point,
            lineStart: function() {
                stream.point = pointLineStart;
            },
            lineEnd: lineEnd,
            polygonStart: function() {
                stream.lineEnd = lineEndPolygon;
            },
            polygonEnd: function() {
                stream.lineEnd = lineEnd;
                stream.point = point;
            },
            pointRadius: function(_) {
                pointRadius = _;
                return stream;
            },
            result: d3_noop
        };
        function point(x, y) {
            context.moveTo(x + pointRadius, y);
            context.arc(x, y, pointRadius, 0, Ï);
        }
        function pointLineStart(x, y) {
            context.moveTo(x, y);
            stream.point = pointLine;
        }
        function pointLine(x, y) {
            context.lineTo(x, y);
        }
        function lineEnd() {
            stream.point = point;
        }
        function lineEndPolygon() {
            context.closePath();
        }
        return stream;
    }
    function d3_geo_resample(project) {
        var Î´2 = .5, cosMinDistance = Math.cos(30 * d3_radians), maxDepth = 16;
        function resample(stream) {
            return (maxDepth ? resampleRecursive : resampleNone)(stream);
        }
        function resampleNone(stream) {
            return d3_geo_transformPoint(stream, function(x, y) {
                x = project(x, y);
                stream.point(x[0], x[1]);
            });
        }
        function resampleRecursive(stream) {
            var Î»00, Ï00, x00, y00, a00, b00, c00, Î»0, x0, y0, a0, b0, c0;
            var resample = {
                point: point,
                lineStart: lineStart,
                lineEnd: lineEnd,
                polygonStart: function() {
                    stream.polygonStart();
                    resample.lineStart = ringStart;
                },
                polygonEnd: function() {
                    stream.polygonEnd();
                    resample.lineStart = lineStart;
                }
            };
            function point(x, y) {
                x = project(x, y);
                stream.point(x[0], x[1]);
            }
            function lineStart() {
                x0 = NaN;
                resample.point = linePoint;
                stream.lineStart();
            }
            function linePoint(Î», Ï) {
                var c = d3_geo_cartesian([ Î», Ï ]), p = project(Î», Ï);
                resampleLineTo(x0, y0, Î»0, a0, b0, c0, x0 = p[0], y0 = p[1], Î»0 = Î», a0 = c[0], b0 = c[1], c0 = c[2], maxDepth, stream);
                stream.point(x0, y0);
            }
            function lineEnd() {
                resample.point = point;
                stream.lineEnd();
            }
            function ringStart() {
                lineStart();
                resample.point = ringPoint;
                resample.lineEnd = ringEnd;
            }
            function ringPoint(Î», Ï) {
                linePoint(Î»00 = Î», Ï00 = Ï), x00 = x0, y00 = y0, a00 = a0, b00 = b0, c00 = c0;
                resample.point = linePoint;
            }
            function ringEnd() {
                resampleLineTo(x0, y0, Î»0, a0, b0, c0, x00, y00, Î»00, a00, b00, c00, maxDepth, stream);
                resample.lineEnd = lineEnd;
                lineEnd();
            }
            return resample;
        }
        function resampleLineTo(x0, y0, Î»0, a0, b0, c0, x1, y1, Î»1, a1, b1, c1, depth, stream) {
            var dx = x1 - x0, dy = y1 - y0, d2 = dx * dx + dy * dy;
            if (d2 > 4 * Î´2 && depth--) {
                var a = a0 + a1, b = b0 + b1, c = c0 + c1, m = Math.sqrt(a * a + b * b + c * c), Ï2 = Math.asin(c /= m), Î»2 = abs(abs(c) - 1) < Îµ || abs(Î»0 - Î»1) < Îµ ? (Î»0 + Î»1) / 2 : Math.atan2(b, a), p = project(Î»2, Ï2), x2 = p[0], y2 = p[1], dx2 = x2 - x0, dy2 = y2 - y0, dz = dy * dx2 - dx * dy2;
                if (dz * dz / d2 > Î´2 || abs((dx * dx2 + dy * dy2) / d2 - .5) > .3 || a0 * a1 + b0 * b1 + c0 * c1 < cosMinDistance) {
                    resampleLineTo(x0, y0, Î»0, a0, b0, c0, x2, y2, Î»2, a /= m, b /= m, c, depth, stream);
                    stream.point(x2, y2);
                    resampleLineTo(x2, y2, Î»2, a, b, c, x1, y1, Î»1, a1, b1, c1, depth, stream);
                }
            }
        }
        resample.precision = function(_) {
            if (!arguments.length) return Math.sqrt(Î´2);
            maxDepth = (Î´2 = _ * _) > 0 && 16;
            return resample;
        };
        return resample;
    }
    d3.geo.path = function() {
        var pointRadius = 4.5, projection, context, projectStream, contextStream, cacheStream;
        function path(object) {
            if (object) {
                if (typeof pointRadius === "function") contextStream.pointRadius(+pointRadius.apply(this, arguments));
                if (!cacheStream || !cacheStream.valid) cacheStream = projectStream(contextStream);
                d3.geo.stream(object, cacheStream);
            }
            return contextStream.result();
        }
        path.area = function(object) {
            d3_geo_pathAreaSum = 0;
            d3.geo.stream(object, projectStream(d3_geo_pathArea));
            return d3_geo_pathAreaSum;
        };
        path.centroid = function(object) {
            d3_geo_centroidX0 = d3_geo_centroidY0 = d3_geo_centroidZ0 = d3_geo_centroidX1 = d3_geo_centroidY1 = d3_geo_centroidZ1 = d3_geo_centroidX2 = d3_geo_centroidY2 = d3_geo_centroidZ2 = 0;
            d3.geo.stream(object, projectStream(d3_geo_pathCentroid));
            return d3_geo_centroidZ2 ? [ d3_geo_centroidX2 / d3_geo_centroidZ2, d3_geo_centroidY2 / d3_geo_centroidZ2 ] : d3_geo_centroidZ1 ? [ d3_geo_centroidX1 / d3_geo_centroidZ1, d3_geo_centroidY1 / d3_geo_centroidZ1 ] : d3_geo_centroidZ0 ? [ d3_geo_centroidX0 / d3_geo_centroidZ0, d3_geo_centroidY0 / d3_geo_centroidZ0 ] : [ NaN, NaN ];
        };
        path.bounds = function(object) {
            d3_geo_pathBoundsX1 = d3_geo_pathBoundsY1 = -(d3_geo_pathBoundsX0 = d3_geo_pathBoundsY0 = Infinity);
            d3.geo.stream(object, projectStream(d3_geo_pathBounds));
            return [ [ d3_geo_pathBoundsX0, d3_geo_pathBoundsY0 ], [ d3_geo_pathBoundsX1, d3_geo_pathBoundsY1 ] ];
        };
        path.projection = function(_) {
            if (!arguments.length) return projection;
            projectStream = (projection = _) ? _.stream || d3_geo_pathProjectStream(_) : d3_identity;
            return reset();
        };
        path.context = function(_) {
            if (!arguments.length) return context;
            contextStream = (context = _) == null ? new d3_geo_pathBuffer() : new d3_geo_pathContext(_);
            if (typeof pointRadius !== "function") contextStream.pointRadius(pointRadius);
            return reset();
        };
        path.pointRadius = function(_) {
            if (!arguments.length) return pointRadius;
            pointRadius = typeof _ === "function" ? _ : (contextStream.pointRadius(+_), +_);
            return path;
        };
        function reset() {
            cacheStream = null;
            return path;
        }
        return path.projection(d3.geo.albersUsa()).context(null);
    };
    function d3_geo_pathProjectStream(project) {
        var resample = d3_geo_resample(function(x, y) {
            return project([ x * d3_degrees, y * d3_degrees ]);
        });
        return function(stream) {
            return d3_geo_projectionRadians(resample(stream));
        };
    }
    d3.geo.transform = function(methods) {
        return {
            stream: function(stream) {
                var transform = new d3_geo_transform(stream);
                for (var k in methods) transform[k] = methods[k];
                return transform;
            }
        };
    };
    function d3_geo_transform(stream) {
        this.stream = stream;
    }
    d3_geo_transform.prototype = {
        point: function(x, y) {
            this.stream.point(x, y);
        },
        sphere: function() {
            this.stream.sphere();
        },
        lineStart: function() {
            this.stream.lineStart();
        },
        lineEnd: function() {
            this.stream.lineEnd();
        },
        polygonStart: function() {
            this.stream.polygonStart();
        },
        polygonEnd: function() {
            this.stream.polygonEnd();
        }
    };
    function d3_geo_transformPoint(stream, point) {
        return {
            point: point,
            sphere: function() {
                stream.sphere();
            },
            lineStart: function() {
                stream.lineStart();
            },
            lineEnd: function() {
                stream.lineEnd();
            },
            polygonStart: function() {
                stream.polygonStart();
            },
            polygonEnd: function() {
                stream.polygonEnd();
            }
        };
    }
    d3.geo.projection = d3_geo_projection;
    d3.geo.projectionMutator = d3_geo_projectionMutator;
    function d3_geo_projection(project) {
        return d3_geo_projectionMutator(function() {
            return project;
        })();
    }
    function d3_geo_projectionMutator(projectAt) {
        var project, rotate, projectRotate, projectResample = d3_geo_resample(function(x, y) {
            x = project(x, y);
            return [ x[0] * k + Î´x, Î´y - x[1] * k ];
        }), k = 150, x = 480, y = 250, Î» = 0, Ï = 0, Î´Î» = 0, Î´Ï = 0, Î´Î³ = 0, Î´x, Î´y, preclip = d3_geo_clipAntimeridian, postclip = d3_identity, clipAngle = null, clipExtent = null, stream;
        function projection(point) {
            point = projectRotate(point[0] * d3_radians, point[1] * d3_radians);
            return [ point[0] * k + Î´x, Î´y - point[1] * k ];
        }
        function invert(point) {
            point = projectRotate.invert((point[0] - Î´x) / k, (Î´y - point[1]) / k);
            return point && [ point[0] * d3_degrees, point[1] * d3_degrees ];
        }
        projection.stream = function(output) {
            if (stream) stream.valid = false;
            stream = d3_geo_projectionRadians(preclip(rotate, projectResample(postclip(output))));
            stream.valid = true;
            return stream;
        };
        projection.clipAngle = function(_) {
            if (!arguments.length) return clipAngle;
            preclip = _ == null ? (clipAngle = _, d3_geo_clipAntimeridian) : d3_geo_clipCircle((clipAngle = +_) * d3_radians);
            return invalidate();
        };
        projection.clipExtent = function(_) {
            if (!arguments.length) return clipExtent;
            clipExtent = _;
            postclip = _ ? d3_geo_clipExtent(_[0][0], _[0][1], _[1][0], _[1][1]) : d3_identity;
            return invalidate();
        };
        projection.scale = function(_) {
            if (!arguments.length) return k;
            k = +_;
            return reset();
        };
        projection.translate = function(_) {
            if (!arguments.length) return [ x, y ];
            x = +_[0];
            y = +_[1];
            return reset();
        };
        projection.center = function(_) {
            if (!arguments.length) return [ Î» * d3_degrees, Ï * d3_degrees ];
            Î» = _[0] % 360 * d3_radians;
            Ï = _[1] % 360 * d3_radians;
            return reset();
        };
        projection.rotate = function(_) {
            if (!arguments.length) return [ Î´Î» * d3_degrees, Î´Ï * d3_degrees, Î´Î³ * d3_degrees ];
            Î´Î» = _[0] % 360 * d3_radians;
            Î´Ï = _[1] % 360 * d3_radians;
            Î´Î³ = _.length > 2 ? _[2] % 360 * d3_radians : 0;
            return reset();
        };
        d3.rebind(projection, projectResample, "precision");
        function reset() {
            projectRotate = d3_geo_compose(rotate = d3_geo_rotation(Î´Î», Î´Ï, Î´Î³), project);
            var center = project(Î», Ï);
            Î´x = x - center[0] * k;
            Î´y = y + center[1] * k;
            return invalidate();
        }
        function invalidate() {
            if (stream) stream.valid = false, stream = null;
            return projection;
        }
        return function() {
            project = projectAt.apply(this, arguments);
            projection.invert = project.invert && invert;
            return reset();
        };
    }
    function d3_geo_projectionRadians(stream) {
        return d3_geo_transformPoint(stream, function(x, y) {
            stream.point(x * d3_radians, y * d3_radians);
        });
    }
    function d3_geo_equirectangular(Î», Ï) {
        return [ Î», Ï ];
    }
    (d3.geo.equirectangular = function() {
        return d3_geo_projection(d3_geo_equirectangular);
    }).raw = d3_geo_equirectangular.invert = d3_geo_equirectangular;
    d3.geo.rotation = function(rotate) {
        rotate = d3_geo_rotation(rotate[0] % 360 * d3_radians, rotate[1] * d3_radians, rotate.length > 2 ? rotate[2] * d3_radians : 0);
        function forward(coordinates) {
            coordinates = rotate(coordinates[0] * d3_radians, coordinates[1] * d3_radians);
            return coordinates[0] *= d3_degrees, coordinates[1] *= d3_degrees, coordinates;
        }
        forward.invert = function(coordinates) {
            coordinates = rotate.invert(coordinates[0] * d3_radians, coordinates[1] * d3_radians);
            return coordinates[0] *= d3_degrees, coordinates[1] *= d3_degrees, coordinates;
        };
        return forward;
    };
    function d3_geo_identityRotation(Î», Ï) {
        return [ Î» > Ï ? Î» - Ï : Î» < -Ï ? Î» + Ï : Î», Ï ];
    }
    d3_geo_identityRotation.invert = d3_geo_equirectangular;
    function d3_geo_rotation(Î´Î», Î´Ï, Î´Î³) {
        return Î´Î» ? Î´Ï || Î´Î³ ? d3_geo_compose(d3_geo_rotationÎ»(Î´Î»), d3_geo_rotationÏÎ³(Î´Ï, Î´Î³)) : d3_geo_rotationÎ»(Î´Î») : Î´Ï || Î´Î³ ? d3_geo_rotationÏÎ³(Î´Ï, Î´Î³) : d3_geo_identityRotation;
    }
    function d3_geo_forwardRotationÎ»(Î´Î») {
        return function(Î», Ï) {
            return Î» += Î´Î», [ Î» > Ï ? Î» - Ï : Î» < -Ï ? Î» + Ï : Î», Ï ];
        };
    }
    function d3_geo_rotationÎ»(Î´Î») {
        var rotation = d3_geo_forwardRotationÎ»(Î´Î»);
        rotation.invert = d3_geo_forwardRotationÎ»(-Î´Î»);
        return rotation;
    }
    function d3_geo_rotationÏÎ³(Î´Ï, Î´Î³) {
        var cosÎ´Ï = Math.cos(Î´Ï), sinÎ´Ï = Math.sin(Î´Ï), cosÎ´Î³ = Math.cos(Î´Î³), sinÎ´Î³ = Math.sin(Î´Î³);
        function rotation(Î», Ï) {
            var cosÏ = Math.cos(Ï), x = Math.cos(Î») * cosÏ, y = Math.sin(Î») * cosÏ, z = Math.sin(Ï), k = z * cosÎ´Ï + x * sinÎ´Ï;
            return [ Math.atan2(y * cosÎ´Î³ - k * sinÎ´Î³, x * cosÎ´Ï - z * sinÎ´Ï), d3_asin(k * cosÎ´Î³ + y * sinÎ´Î³) ];
        }
        rotation.invert = function(Î», Ï) {
            var cosÏ = Math.cos(Ï), x = Math.cos(Î») * cosÏ, y = Math.sin(Î») * cosÏ, z = Math.sin(Ï), k = z * cosÎ´Î³ - y * sinÎ´Î³;
            return [ Math.atan2(y * cosÎ´Î³ + z * sinÎ´Î³, x * cosÎ´Ï + k * sinÎ´Ï), d3_asin(k * cosÎ´Ï - x * sinÎ´Ï) ];
        };
        return rotation;
    }
    d3.geo.circle = function() {
        var origin = [ 0, 0 ], angle, precision = 6, interpolate;
        function circle() {
            var center = typeof origin === "function" ? origin.apply(this, arguments) : origin, rotate = d3_geo_rotation(-center[0] * d3_radians, -center[1] * d3_radians, 0).invert, ring = [];
            interpolate(null, null, 1, {
                point: function(x, y) {
                    ring.push(x = rotate(x, y));
                    x[0] *= d3_degrees, x[1] *= d3_degrees;
                }
            });
            return {
                type: "Polygon",
                coordinates: [ ring ]
            };
        }
        circle.origin = function(x) {
            if (!arguments.length) return origin;
            origin = x;
            return circle;
        };
        circle.angle = function(x) {
            if (!arguments.length) return angle;
            interpolate = d3_geo_circleInterpolate((angle = +x) * d3_radians, precision * d3_radians);
            return circle;
        };
        circle.precision = function(_) {
            if (!arguments.length) return precision;
            interpolate = d3_geo_circleInterpolate(angle * d3_radians, (precision = +_) * d3_radians);
            return circle;
        };
        return circle.angle(90);
    };
    function d3_geo_circleInterpolate(radius, precision) {
        var cr = Math.cos(radius), sr = Math.sin(radius);
        return function(from, to, direction, listener) {
            var step = direction * precision;
            if (from != null) {
                from = d3_geo_circleAngle(cr, from);
                to = d3_geo_circleAngle(cr, to);
                if (direction > 0 ? from < to : from > to) from += direction * Ï;
            } else {
                from = radius + direction * Ï;
                to = radius - .5 * step;
            }
            for (var point, t = from; direction > 0 ? t > to : t < to; t -= step) {
                listener.point((point = d3_geo_spherical([ cr, -sr * Math.cos(t), -sr * Math.sin(t) ]))[0], point[1]);
            }
        };
    }
    function d3_geo_circleAngle(cr, point) {
        var a = d3_geo_cartesian(point);
        a[0] -= cr;
        d3_geo_cartesianNormalize(a);
        var angle = d3_acos(-a[1]);
        return ((-a[2] < 0 ? -angle : angle) + 2 * Math.PI - Îµ) % (2 * Math.PI);
    }
    d3.geo.distance = function(a, b) {
        var ÎÎ» = (b[0] - a[0]) * d3_radians, Ï0 = a[1] * d3_radians, Ï1 = b[1] * d3_radians, sinÎÎ» = Math.sin(ÎÎ»), cosÎÎ» = Math.cos(ÎÎ»), sinÏ0 = Math.sin(Ï0), cosÏ0 = Math.cos(Ï0), sinÏ1 = Math.sin(Ï1), cosÏ1 = Math.cos(Ï1), t;
        return Math.atan2(Math.sqrt((t = cosÏ1 * sinÎÎ») * t + (t = cosÏ0 * sinÏ1 - sinÏ0 * cosÏ1 * cosÎÎ») * t), sinÏ0 * sinÏ1 + cosÏ0 * cosÏ1 * cosÎÎ»);
    };
    d3.geo.graticule = function() {
        var x1, x0, X1, X0, y1, y0, Y1, Y0, dx = 10, dy = dx, DX = 90, DY = 360, x, y, X, Y, precision = 2.5;
        function graticule() {
            return {
                type: "MultiLineString",
                coordinates: lines()
            };
        }
        function lines() {
            return d3.range(Math.ceil(X0 / DX) * DX, X1, DX).map(X).concat(d3.range(Math.ceil(Y0 / DY) * DY, Y1, DY).map(Y)).concat(d3.range(Math.ceil(x0 / dx) * dx, x1, dx).filter(function(x) {
                return abs(x % DX) > Îµ;
            }).map(x)).concat(d3.range(Math.ceil(y0 / dy) * dy, y1, dy).filter(function(y) {
                return abs(y % DY) > Îµ;
            }).map(y));
        }
        graticule.lines = function() {
            return lines().map(function(coordinates) {
                return {
                    type: "LineString",
                    coordinates: coordinates
                };
            });
        };
        graticule.outline = function() {
            return {
                type: "Polygon",
                coordinates: [ X(X0).concat(Y(Y1).slice(1), X(X1).reverse().slice(1), Y(Y0).reverse().slice(1)) ]
            };
        };
        graticule.extent = function(_) {
            if (!arguments.length) return graticule.minorExtent();
            return graticule.majorExtent(_).minorExtent(_);
        };
        graticule.majorExtent = function(_) {
            if (!arguments.length) return [ [ X0, Y0 ], [ X1, Y1 ] ];
            X0 = +_[0][0], X1 = +_[1][0];
            Y0 = +_[0][1], Y1 = +_[1][1];
            if (X0 > X1) _ = X0, X0 = X1, X1 = _;
            if (Y0 > Y1) _ = Y0, Y0 = Y1, Y1 = _;
            return graticule.precision(precision);
        };
        graticule.minorExtent = function(_) {
            if (!arguments.length) return [ [ x0, y0 ], [ x1, y1 ] ];
            x0 = +_[0][0], x1 = +_[1][0];
            y0 = +_[0][1], y1 = +_[1][1];
            if (x0 > x1) _ = x0, x0 = x1, x1 = _;
            if (y0 > y1) _ = y0, y0 = y1, y1 = _;
            return graticule.precision(precision);
        };
        graticule.step = function(_) {
            if (!arguments.length) return graticule.minorStep();
            return graticule.majorStep(_).minorStep(_);
        };
        graticule.majorStep = function(_) {
            if (!arguments.length) return [ DX, DY ];
            DX = +_[0], DY = +_[1];
            return graticule;
        };
        graticule.minorStep = function(_) {
            if (!arguments.length) return [ dx, dy ];
            dx = +_[0], dy = +_[1];
            return graticule;
        };
        graticule.precision = function(_) {
            if (!arguments.length) return precision;
            precision = +_;
            x = d3_geo_graticuleX(y0, y1, 90);
            y = d3_geo_graticuleY(x0, x1, precision);
            X = d3_geo_graticuleX(Y0, Y1, 90);
            Y = d3_geo_graticuleY(X0, X1, precision);
            return graticule;
        };
        return graticule.majorExtent([ [ -180, -90 + Îµ ], [ 180, 90 - Îµ ] ]).minorExtent([ [ -180, -80 - Îµ ], [ 180, 80 + Îµ ] ]);
    };
    function d3_geo_graticuleX(y0, y1, dy) {
        var y = d3.range(y0, y1 - Îµ, dy).concat(y1);
        return function(x) {
            return y.map(function(y) {
                return [ x, y ];
            });
        };
    }
    function d3_geo_graticuleY(x0, x1, dx) {
        var x = d3.range(x0, x1 - Îµ, dx).concat(x1);
        return function(y) {
            return x.map(function(x) {
                return [ x, y ];
            });
        };
    }
    function d3_source(d) {
        return d.source;
    }
    function d3_target(d) {
        return d.target;
    }
    d3.geo.greatArc = function() {
        var source = d3_source, source_, target = d3_target, target_;
        function greatArc() {
            return {
                type: "LineString",
                coordinates: [ source_ || source.apply(this, arguments), target_ || target.apply(this, arguments) ]
            };
        }
        greatArc.distance = function() {
            return d3.geo.distance(source_ || source.apply(this, arguments), target_ || target.apply(this, arguments));
        };
        greatArc.source = function(_) {
            if (!arguments.length) return source;
            source = _, source_ = typeof _ === "function" ? null : _;
            return greatArc;
        };
        greatArc.target = function(_) {
            if (!arguments.length) return target;
            target = _, target_ = typeof _ === "function" ? null : _;
            return greatArc;
        };
        greatArc.precision = function() {
            return arguments.length ? greatArc : 0;
        };
        return greatArc;
    };
    d3.geo.interpolate = function(source, target) {
        return d3_geo_interpolate(source[0] * d3_radians, source[1] * d3_radians, target[0] * d3_radians, target[1] * d3_radians);
    };
    function d3_geo_interpolate(x0, y0, x1, y1) {
        var cy0 = Math.cos(y0), sy0 = Math.sin(y0), cy1 = Math.cos(y1), sy1 = Math.sin(y1), kx0 = cy0 * Math.cos(x0), ky0 = cy0 * Math.sin(x0), kx1 = cy1 * Math.cos(x1), ky1 = cy1 * Math.sin(x1), d = 2 * Math.asin(Math.sqrt(d3_haversin(y1 - y0) + cy0 * cy1 * d3_haversin(x1 - x0))), k = 1 / Math.sin(d);
        var interpolate = d ? function(t) {
            var B = Math.sin(t *= d) * k, A = Math.sin(d - t) * k, x = A * kx0 + B * kx1, y = A * ky0 + B * ky1, z = A * sy0 + B * sy1;
            return [ Math.atan2(y, x) * d3_degrees, Math.atan2(z, Math.sqrt(x * x + y * y)) * d3_degrees ];
        } : function() {
            return [ x0 * d3_degrees, y0 * d3_degrees ];
        };
        interpolate.distance = d;
        return interpolate;
    }
    d3.geo.length = function(object) {
        d3_geo_lengthSum = 0;
        d3.geo.stream(object, d3_geo_length);
        return d3_geo_lengthSum;
    };
    var d3_geo_lengthSum;
    var d3_geo_length = {
        sphere: d3_noop,
        point: d3_noop,
        lineStart: d3_geo_lengthLineStart,
        lineEnd: d3_noop,
        polygonStart: d3_noop,
        polygonEnd: d3_noop
    };
    function d3_geo_lengthLineStart() {
        var Î»0, sinÏ0, cosÏ0;
        d3_geo_length.point = function(Î», Ï) {
            Î»0 = Î» * d3_radians, sinÏ0 = Math.sin(Ï *= d3_radians), cosÏ0 = Math.cos(Ï);
            d3_geo_length.point = nextPoint;
        };
        d3_geo_length.lineEnd = function() {
            d3_geo_length.point = d3_geo_length.lineEnd = d3_noop;
        };
        function nextPoint(Î», Ï) {
            var sinÏ = Math.sin(Ï *= d3_radians), cosÏ = Math.cos(Ï), t = abs((Î» *= d3_radians) - Î»0), cosÎÎ» = Math.cos(t);
            d3_geo_lengthSum += Math.atan2(Math.sqrt((t = cosÏ * Math.sin(t)) * t + (t = cosÏ0 * sinÏ - sinÏ0 * cosÏ * cosÎÎ») * t), sinÏ0 * sinÏ + cosÏ0 * cosÏ * cosÎÎ»);
            Î»0 = Î», sinÏ0 = sinÏ, cosÏ0 = cosÏ;
        }
    }
    function d3_geo_azimuthal(scale, angle) {
        function azimuthal(Î», Ï) {
            var cosÎ» = Math.cos(Î»), cosÏ = Math.cos(Ï), k = scale(cosÎ» * cosÏ);
            return [ k * cosÏ * Math.sin(Î»), k * Math.sin(Ï) ];
        }
        azimuthal.invert = function(x, y) {
            var Ï = Math.sqrt(x * x + y * y), c = angle(Ï), sinc = Math.sin(c), cosc = Math.cos(c);
            return [ Math.atan2(x * sinc, Ï * cosc), Math.asin(Ï && y * sinc / Ï) ];
        };
        return azimuthal;
    }
    var d3_geo_azimuthalEqualArea = d3_geo_azimuthal(function(cosÎ»cosÏ) {
        return Math.sqrt(2 / (1 + cosÎ»cosÏ));
    }, function(Ï) {
        return 2 * Math.asin(Ï / 2);
    });
    (d3.geo.azimuthalEqualArea = function() {
        return d3_geo_projection(d3_geo_azimuthalEqualArea);
    }).raw = d3_geo_azimuthalEqualArea;
    var d3_geo_azimuthalEquidistant = d3_geo_azimuthal(function(cosÎ»cosÏ) {
        var c = Math.acos(cosÎ»cosÏ);
        return c && c / Math.sin(c);
    }, d3_identity);
    (d3.geo.azimuthalEquidistant = function() {
        return d3_geo_projection(d3_geo_azimuthalEquidistant);
    }).raw = d3_geo_azimuthalEquidistant;
    function d3_geo_conicConformal(Ï0, Ï1) {
        var cosÏ0 = Math.cos(Ï0), t = function(Ï) {
            return Math.tan(Ï / 4 + Ï / 2);
        }, n = Ï0 === Ï1 ? Math.sin(Ï0) : Math.log(cosÏ0 / Math.cos(Ï1)) / Math.log(t(Ï1) / t(Ï0)), F = cosÏ0 * Math.pow(t(Ï0), n) / n;
        if (!n) return d3_geo_mercator;
        function forward(Î», Ï) {
            if (F > 0) {
                if (Ï < -halfÏ + Îµ) Ï = -halfÏ + Îµ;
            } else {
                if (Ï > halfÏ - Îµ) Ï = halfÏ - Îµ;
            }
            var Ï = F / Math.pow(t(Ï), n);
            return [ Ï * Math.sin(n * Î»), F - Ï * Math.cos(n * Î») ];
        }
        forward.invert = function(x, y) {
            var Ï0_y = F - y, Ï = d3_sgn(n) * Math.sqrt(x * x + Ï0_y * Ï0_y);
            return [ Math.atan2(x, Ï0_y) / n, 2 * Math.atan(Math.pow(F / Ï, 1 / n)) - halfÏ ];
        };
        return forward;
    }
    (d3.geo.conicConformal = function() {
        return d3_geo_conic(d3_geo_conicConformal);
    }).raw = d3_geo_conicConformal;
    function d3_geo_conicEquidistant(Ï0, Ï1) {
        var cosÏ0 = Math.cos(Ï0), n = Ï0 === Ï1 ? Math.sin(Ï0) : (cosÏ0 - Math.cos(Ï1)) / (Ï1 - Ï0), G = cosÏ0 / n + Ï0;
        if (abs(n) < Îµ) return d3_geo_equirectangular;
        function forward(Î», Ï) {
            var Ï = G - Ï;
            return [ Ï * Math.sin(n * Î»), G - Ï * Math.cos(n * Î») ];
        }
        forward.invert = function(x, y) {
            var Ï0_y = G - y;
            return [ Math.atan2(x, Ï0_y) / n, G - d3_sgn(n) * Math.sqrt(x * x + Ï0_y * Ï0_y) ];
        };
        return forward;
    }
    (d3.geo.conicEquidistant = function() {
        return d3_geo_conic(d3_geo_conicEquidistant);
    }).raw = d3_geo_conicEquidistant;
    var d3_geo_gnomonic = d3_geo_azimuthal(function(cosÎ»cosÏ) {
        return 1 / cosÎ»cosÏ;
    }, Math.atan);
    (d3.geo.gnomonic = function() {
        return d3_geo_projection(d3_geo_gnomonic);
    }).raw = d3_geo_gnomonic;
    function d3_geo_mercator(Î», Ï) {
        return [ Î», Math.log(Math.tan(Ï / 4 + Ï / 2)) ];
    }
    d3_geo_mercator.invert = function(x, y) {
        return [ x, 2 * Math.atan(Math.exp(y)) - halfÏ ];
    };
    function d3_geo_mercatorProjection(project) {
        var m = d3_geo_projection(project), scale = m.scale, translate = m.translate, clipExtent = m.clipExtent, clipAuto;
        m.scale = function() {
            var v = scale.apply(m, arguments);
            return v === m ? clipAuto ? m.clipExtent(null) : m : v;
        };
        m.translate = function() {
            var v = translate.apply(m, arguments);
            return v === m ? clipAuto ? m.clipExtent(null) : m : v;
        };
        m.clipExtent = function(_) {
            var v = clipExtent.apply(m, arguments);
            if (v === m) {
                if (clipAuto = _ == null) {
                    var k = Ï * scale(), t = translate();
                    clipExtent([ [ t[0] - k, t[1] - k ], [ t[0] + k, t[1] + k ] ]);
                }
            } else if (clipAuto) {
                v = null;
            }
            return v;
        };
        return m.clipExtent(null);
    }
    (d3.geo.mercator = function() {
        return d3_geo_mercatorProjection(d3_geo_mercator);
    }).raw = d3_geo_mercator;
    var d3_geo_orthographic = d3_geo_azimuthal(function() {
        return 1;
    }, Math.asin);
    (d3.geo.orthographic = function() {
        return d3_geo_projection(d3_geo_orthographic);
    }).raw = d3_geo_orthographic;
    var d3_geo_stereographic = d3_geo_azimuthal(function(cosÎ»cosÏ) {
        return 1 / (1 + cosÎ»cosÏ);
    }, function(Ï) {
        return 2 * Math.atan(Ï);
    });
    (d3.geo.stereographic = function() {
        return d3_geo_projection(d3_geo_stereographic);
    }).raw = d3_geo_stereographic;
    function d3_geo_transverseMercator(Î», Ï) {
        return [ Math.log(Math.tan(Ï / 4 + Ï / 2)), -Î» ];
    }
    d3_geo_transverseMercator.invert = function(x, y) {
        return [ -y, 2 * Math.atan(Math.exp(x)) - halfÏ ];
    };
    (d3.geo.transverseMercator = function() {
        var projection = d3_geo_mercatorProjection(d3_geo_transverseMercator), center = projection.center, rotate = projection.rotate;
        projection.center = function(_) {
            return _ ? center([ -_[1], _[0] ]) : (_ = center(), [ _[1], -_[0] ]);
        };
        projection.rotate = function(_) {
            return _ ? rotate([ _[0], _[1], _.length > 2 ? _[2] + 90 : 90 ]) : (_ = rotate(), 
            [ _[0], _[1], _[2] - 90 ]);
        };
        return rotate([ 0, 0, 90 ]);
    }).raw = d3_geo_transverseMercator;
    d3.geom = {};
    function d3_geom_pointX(d) {
        return d[0];
    }
    function d3_geom_pointY(d) {
        return d[1];
    }
    d3.geom.hull = function(vertices) {
        var x = d3_geom_pointX, y = d3_geom_pointY;
        if (arguments.length) return hull(vertices);
        function hull(data) {
            if (data.length < 3) return [];
            var fx = d3_functor(x), fy = d3_functor(y), i, n = data.length, points = [], flippedPoints = [];
            for (i = 0; i < n; i++) {
                points.push([ +fx.call(this, data[i], i), +fy.call(this, data[i], i), i ]);
            }
            points.sort(d3_geom_hullOrder);
            for (i = 0; i < n; i++) flippedPoints.push([ points[i][0], -points[i][1] ]);
            var upper = d3_geom_hullUpper(points), lower = d3_geom_hullUpper(flippedPoints);
            var skipLeft = lower[0] === upper[0], skipRight = lower[lower.length - 1] === upper[upper.length - 1], polygon = [];
            for (i = upper.length - 1; i >= 0; --i) polygon.push(data[points[upper[i]][2]]);
            for (i = +skipLeft; i < lower.length - skipRight; ++i) polygon.push(data[points[lower[i]][2]]);
            return polygon;
        }
        hull.x = function(_) {
            return arguments.length ? (x = _, hull) : x;
        };
        hull.y = function(_) {
            return arguments.length ? (y = _, hull) : y;
        };
        return hull;
    };
    function d3_geom_hullUpper(points) {
        var n = points.length, hull = [ 0, 1 ], hs = 2;
        for (var i = 2; i < n; i++) {
            while (hs > 1 && d3_cross2d(points[hull[hs - 2]], points[hull[hs - 1]], points[i]) <= 0) --hs;
            hull[hs++] = i;
        }
        return hull.slice(0, hs);
    }
    function d3_geom_hullOrder(a, b) {
        return a[0] - b[0] || a[1] - b[1];
    }
    d3.geom.polygon = function(coordinates) {
        d3_subclass(coordinates, d3_geom_polygonPrototype);
        return coordinates;
    };
    var d3_geom_polygonPrototype = d3.geom.polygon.prototype = [];
    d3_geom_polygonPrototype.area = function() {
        var i = -1, n = this.length, a, b = this[n - 1], area = 0;
        while (++i < n) {
            a = b;
            b = this[i];
            area += a[1] * b[0] - a[0] * b[1];
        }
        return area * .5;
    };
    d3_geom_polygonPrototype.centroid = function(k) {
        var i = -1, n = this.length, x = 0, y = 0, a, b = this[n - 1], c;
        if (!arguments.length) k = -1 / (6 * this.area());
        while (++i < n) {
            a = b;
            b = this[i];
            c = a[0] * b[1] - b[0] * a[1];
            x += (a[0] + b[0]) * c;
            y += (a[1] + b[1]) * c;
        }
        return [ x * k, y * k ];
    };
    d3_geom_polygonPrototype.clip = function(subject) {
        var input, closed = d3_geom_polygonClosed(subject), i = -1, n = this.length - d3_geom_polygonClosed(this), j, m, a = this[n - 1], b, c, d;
        while (++i < n) {
            input = subject.slice();
            subject.length = 0;
            b = this[i];
            c = input[(m = input.length - closed) - 1];
            j = -1;
            while (++j < m) {
                d = input[j];
                if (d3_geom_polygonInside(d, a, b)) {
                    if (!d3_geom_polygonInside(c, a, b)) {
                        subject.push(d3_geom_polygonIntersect(c, d, a, b));
                    }
                    subject.push(d);
                } else if (d3_geom_polygonInside(c, a, b)) {
                    subject.push(d3_geom_polygonIntersect(c, d, a, b));
                }
                c = d;
            }
            if (closed) subject.push(subject[0]);
            a = b;
        }
        return subject;
    };
    function d3_geom_polygonInside(p, a, b) {
        return (b[0] - a[0]) * (p[1] - a[1]) < (b[1] - a[1]) * (p[0] - a[0]);
    }
    function d3_geom_polygonIntersect(c, d, a, b) {
        var x1 = c[0], x3 = a[0], x21 = d[0] - x1, x43 = b[0] - x3, y1 = c[1], y3 = a[1], y21 = d[1] - y1, y43 = b[1] - y3, ua = (x43 * (y1 - y3) - y43 * (x1 - x3)) / (y43 * x21 - x43 * y21);
        return [ x1 + ua * x21, y1 + ua * y21 ];
    }
    function d3_geom_polygonClosed(coordinates) {
        var a = coordinates[0], b = coordinates[coordinates.length - 1];
        return !(a[0] - b[0] || a[1] - b[1]);
    }
    var d3_geom_voronoiEdges, d3_geom_voronoiCells, d3_geom_voronoiBeaches, d3_geom_voronoiBeachPool = [], d3_geom_voronoiFirstCircle, d3_geom_voronoiCircles, d3_geom_voronoiCirclePool = [];
    function d3_geom_voronoiBeach() {
        d3_geom_voronoiRedBlackNode(this);
        this.edge = this.site = this.circle = null;
    }
    function d3_geom_voronoiCreateBeach(site) {
        var beach = d3_geom_voronoiBeachPool.pop() || new d3_geom_voronoiBeach();
        beach.site = site;
        return beach;
    }
    function d3_geom_voronoiDetachBeach(beach) {
        d3_geom_voronoiDetachCircle(beach);
        d3_geom_voronoiBeaches.remove(beach);
        d3_geom_voronoiBeachPool.push(beach);
        d3_geom_voronoiRedBlackNode(beach);
    }
    function d3_geom_voronoiRemoveBeach(beach) {
        var circle = beach.circle, x = circle.x, y = circle.cy, vertex = {
            x: x,
            y: y
        }, previous = beach.P, next = beach.N, disappearing = [ beach ];
        d3_geom_voronoiDetachBeach(beach);
        var lArc = previous;
        while (lArc.circle && abs(x - lArc.circle.x) < Îµ && abs(y - lArc.circle.cy) < Îµ) {
            previous = lArc.P;
            disappearing.unshift(lArc);
            d3_geom_voronoiDetachBeach(lArc);
            lArc = previous;
        }
        disappearing.unshift(lArc);
        d3_geom_voronoiDetachCircle(lArc);
        var rArc = next;
        while (rArc.circle && abs(x - rArc.circle.x) < Îµ && abs(y - rArc.circle.cy) < Îµ) {
            next = rArc.N;
            disappearing.push(rArc);
            d3_geom_voronoiDetachBeach(rArc);
            rArc = next;
        }
        disappearing.push(rArc);
        d3_geom_voronoiDetachCircle(rArc);
        var nArcs = disappearing.length, iArc;
        for (iArc = 1; iArc < nArcs; ++iArc) {
            rArc = disappearing[iArc];
            lArc = disappearing[iArc - 1];
            d3_geom_voronoiSetEdgeEnd(rArc.edge, lArc.site, rArc.site, vertex);
        }
        lArc = disappearing[0];
        rArc = disappearing[nArcs - 1];
        rArc.edge = d3_geom_voronoiCreateEdge(lArc.site, rArc.site, null, vertex);
        d3_geom_voronoiAttachCircle(lArc);
        d3_geom_voronoiAttachCircle(rArc);
    }
    function d3_geom_voronoiAddBeach(site) {
        var x = site.x, directrix = site.y, lArc, rArc, dxl, dxr, node = d3_geom_voronoiBeaches._;
        while (node) {
            dxl = d3_geom_voronoiLeftBreakPoint(node, directrix) - x;
            if (dxl > Îµ) node = node.L; else {
                dxr = x - d3_geom_voronoiRightBreakPoint(node, directrix);
                if (dxr > Îµ) {
                    if (!node.R) {
                        lArc = node;
                        break;
                    }
                    node = node.R;
                } else {
                    if (dxl > -Îµ) {
                        lArc = node.P;
                        rArc = node;
                    } else if (dxr > -Îµ) {
                        lArc = node;
                        rArc = node.N;
                    } else {
                        lArc = rArc = node;
                    }
                    break;
                }
            }
        }
        var newArc = d3_geom_voronoiCreateBeach(site);
        d3_geom_voronoiBeaches.insert(lArc, newArc);
        if (!lArc && !rArc) return;
        if (lArc === rArc) {
            d3_geom_voronoiDetachCircle(lArc);
            rArc = d3_geom_voronoiCreateBeach(lArc.site);
            d3_geom_voronoiBeaches.insert(newArc, rArc);
            newArc.edge = rArc.edge = d3_geom_voronoiCreateEdge(lArc.site, newArc.site);
            d3_geom_voronoiAttachCircle(lArc);
            d3_geom_voronoiAttachCircle(rArc);
            return;
        }
        if (!rArc) {
            newArc.edge = d3_geom_voronoiCreateEdge(lArc.site, newArc.site);
            return;
        }
        d3_geom_voronoiDetachCircle(lArc);
        d3_geom_voronoiDetachCircle(rArc);
        var lSite = lArc.site, ax = lSite.x, ay = lSite.y, bx = site.x - ax, by = site.y - ay, rSite = rArc.site, cx = rSite.x - ax, cy = rSite.y - ay, d = 2 * (bx * cy - by * cx), hb = bx * bx + by * by, hc = cx * cx + cy * cy, vertex = {
            x: (cy * hb - by * hc) / d + ax,
            y: (bx * hc - cx * hb) / d + ay
        };
        d3_geom_voronoiSetEdgeEnd(rArc.edge, lSite, rSite, vertex);
        newArc.edge = d3_geom_voronoiCreateEdge(lSite, site, null, vertex);
        rArc.edge = d3_geom_voronoiCreateEdge(site, rSite, null, vertex);
        d3_geom_voronoiAttachCircle(lArc);
        d3_geom_voronoiAttachCircle(rArc);
    }
    function d3_geom_voronoiLeftBreakPoint(arc, directrix) {
        var site = arc.site, rfocx = site.x, rfocy = site.y, pby2 = rfocy - directrix;
        if (!pby2) return rfocx;
        var lArc = arc.P;
        if (!lArc) return -Infinity;
        site = lArc.site;
        var lfocx = site.x, lfocy = site.y, plby2 = lfocy - directrix;
        if (!plby2) return lfocx;
        var hl = lfocx - rfocx, aby2 = 1 / pby2 - 1 / plby2, b = hl / plby2;
        if (aby2) return (-b + Math.sqrt(b * b - 2 * aby2 * (hl * hl / (-2 * plby2) - lfocy + plby2 / 2 + rfocy - pby2 / 2))) / aby2 + rfocx;
        return (rfocx + lfocx) / 2;
    }
    function d3_geom_voronoiRightBreakPoint(arc, directrix) {
        var rArc = arc.N;
        if (rArc) return d3_geom_voronoiLeftBreakPoint(rArc, directrix);
        var site = arc.site;
        return site.y === directrix ? site.x : Infinity;
    }
    function d3_geom_voronoiCell(site) {
        this.site = site;
        this.edges = [];
    }
    d3_geom_voronoiCell.prototype.prepare = function() {
        var halfEdges = this.edges, iHalfEdge = halfEdges.length, edge;
        while (iHalfEdge--) {
            edge = halfEdges[iHalfEdge].edge;
            if (!edge.b || !edge.a) halfEdges.splice(iHalfEdge, 1);
        }
        halfEdges.sort(d3_geom_voronoiHalfEdgeOrder);
        return halfEdges.length;
    };
    function d3_geom_voronoiCloseCells(extent) {
        var x0 = extent[0][0], x1 = extent[1][0], y0 = extent[0][1], y1 = extent[1][1], x2, y2, x3, y3, cells = d3_geom_voronoiCells, iCell = cells.length, cell, iHalfEdge, halfEdges, nHalfEdges, start, end;
        while (iCell--) {
            cell = cells[iCell];
            if (!cell || !cell.prepare()) continue;
            halfEdges = cell.edges;
            nHalfEdges = halfEdges.length;
            iHalfEdge = 0;
            while (iHalfEdge < nHalfEdges) {
                end = halfEdges[iHalfEdge].end(), x3 = end.x, y3 = end.y;
                start = halfEdges[++iHalfEdge % nHalfEdges].start(), x2 = start.x, y2 = start.y;
                if (abs(x3 - x2) > Îµ || abs(y3 - y2) > Îµ) {
                    halfEdges.splice(iHalfEdge, 0, new d3_geom_voronoiHalfEdge(d3_geom_voronoiCreateBorderEdge(cell.site, end, abs(x3 - x0) < Îµ && y1 - y3 > Îµ ? {
                        x: x0,
                        y: abs(x2 - x0) < Îµ ? y2 : y1
                    } : abs(y3 - y1) < Îµ && x1 - x3 > Îµ ? {
                        x: abs(y2 - y1) < Îµ ? x2 : x1,
                        y: y1
                    } : abs(x3 - x1) < Îµ && y3 - y0 > Îµ ? {
                        x: x1,
                        y: abs(x2 - x1) < Îµ ? y2 : y0
                    } : abs(y3 - y0) < Îµ && x3 - x0 > Îµ ? {
                        x: abs(y2 - y0) < Îµ ? x2 : x0,
                        y: y0
                    } : null), cell.site, null));
                    ++nHalfEdges;
                }
            }
        }
    }
    function d3_geom_voronoiHalfEdgeOrder(a, b) {
        return b.angle - a.angle;
    }
    function d3_geom_voronoiCircle() {
        d3_geom_voronoiRedBlackNode(this);
        this.x = this.y = this.arc = this.site = this.cy = null;
    }
    function d3_geom_voronoiAttachCircle(arc) {
        var lArc = arc.P, rArc = arc.N;
        if (!lArc || !rArc) return;
        var lSite = lArc.site, cSite = arc.site, rSite = rArc.site;
        if (lSite === rSite) return;
        var bx = cSite.x, by = cSite.y, ax = lSite.x - bx, ay = lSite.y - by, cx = rSite.x - bx, cy = rSite.y - by;
        var d = 2 * (ax * cy - ay * cx);
        if (d >= -Îµ2) return;
        var ha = ax * ax + ay * ay, hc = cx * cx + cy * cy, x = (cy * ha - ay * hc) / d, y = (ax * hc - cx * ha) / d, cy = y + by;
        var circle = d3_geom_voronoiCirclePool.pop() || new d3_geom_voronoiCircle();
        circle.arc = arc;
        circle.site = cSite;
        circle.x = x + bx;
        circle.y = cy + Math.sqrt(x * x + y * y);
        circle.cy = cy;
        arc.circle = circle;
        var before = null, node = d3_geom_voronoiCircles._;
        while (node) {
            if (circle.y < node.y || circle.y === node.y && circle.x <= node.x) {
                if (node.L) node = node.L; else {
                    before = node.P;
                    break;
                }
            } else {
                if (node.R) node = node.R; else {
                    before = node;
                    break;
                }
            }
        }
        d3_geom_voronoiCircles.insert(before, circle);
        if (!before) d3_geom_voronoiFirstCircle = circle;
    }
    function d3_geom_voronoiDetachCircle(arc) {
        var circle = arc.circle;
        if (circle) {
            if (!circle.P) d3_geom_voronoiFirstCircle = circle.N;
            d3_geom_voronoiCircles.remove(circle);
            d3_geom_voronoiCirclePool.push(circle);
            d3_geom_voronoiRedBlackNode(circle);
            arc.circle = null;
        }
    }
    function d3_geom_voronoiClipEdges(extent) {
        var edges = d3_geom_voronoiEdges, clip = d3_geom_clipLine(extent[0][0], extent[0][1], extent[1][0], extent[1][1]), i = edges.length, e;
        while (i--) {
            e = edges[i];
            if (!d3_geom_voronoiConnectEdge(e, extent) || !clip(e) || abs(e.a.x - e.b.x) < Îµ && abs(e.a.y - e.b.y) < Îµ) {
                e.a = e.b = null;
                edges.splice(i, 1);
            }
        }
    }
    function d3_geom_voronoiConnectEdge(edge, extent) {
        var vb = edge.b;
        if (vb) return true;
        var va = edge.a, x0 = extent[0][0], x1 = extent[1][0], y0 = extent[0][1], y1 = extent[1][1], lSite = edge.l, rSite = edge.r, lx = lSite.x, ly = lSite.y, rx = rSite.x, ry = rSite.y, fx = (lx + rx) / 2, fy = (ly + ry) / 2, fm, fb;
        if (ry === ly) {
            if (fx < x0 || fx >= x1) return;
            if (lx > rx) {
                if (!va) va = {
                    x: fx,
                    y: y0
                }; else if (va.y >= y1) return;
                vb = {
                    x: fx,
                    y: y1
                };
            } else {
                if (!va) va = {
                    x: fx,
                    y: y1
                }; else if (va.y < y0) return;
                vb = {
                    x: fx,
                    y: y0
                };
            }
        } else {
            fm = (lx - rx) / (ry - ly);
            fb = fy - fm * fx;
            if (fm < -1 || fm > 1) {
                if (lx > rx) {
                    if (!va) va = {
                        x: (y0 - fb) / fm,
                        y: y0
                    }; else if (va.y >= y1) return;
                    vb = {
                        x: (y1 - fb) / fm,
                        y: y1
                    };
                } else {
                    if (!va) va = {
                        x: (y1 - fb) / fm,
                        y: y1
                    }; else if (va.y < y0) return;
                    vb = {
                        x: (y0 - fb) / fm,
                        y: y0
                    };
                }
            } else {
                if (ly < ry) {
                    if (!va) va = {
                        x: x0,
                        y: fm * x0 + fb
                    }; else if (va.x >= x1) return;
                    vb = {
                        x: x1,
                        y: fm * x1 + fb
                    };
                } else {
                    if (!va) va = {
                        x: x1,
                        y: fm * x1 + fb
                    }; else if (va.x < x0) return;
                    vb = {
                        x: x0,
                        y: fm * x0 + fb
                    };
                }
            }
        }
        edge.a = va;
        edge.b = vb;
        return true;
    }
    function d3_geom_voronoiEdge(lSite, rSite) {
        this.l = lSite;
        this.r = rSite;
        this.a = this.b = null;
    }
    function d3_geom_voronoiCreateEdge(lSite, rSite, va, vb) {
        var edge = new d3_geom_voronoiEdge(lSite, rSite);
        d3_geom_voronoiEdges.push(edge);
        if (va) d3_geom_voronoiSetEdgeEnd(edge, lSite, rSite, va);
        if (vb) d3_geom_voronoiSetEdgeEnd(edge, rSite, lSite, vb);
        d3_geom_voronoiCells[lSite.i].edges.push(new d3_geom_voronoiHalfEdge(edge, lSite, rSite));
        d3_geom_voronoiCells[rSite.i].edges.push(new d3_geom_voronoiHalfEdge(edge, rSite, lSite));
        return edge;
    }
    function d3_geom_voronoiCreateBorderEdge(lSite, va, vb) {
        var edge = new d3_geom_voronoiEdge(lSite, null);
        edge.a = va;
        edge.b = vb;
        d3_geom_voronoiEdges.push(edge);
        return edge;
    }
    function d3_geom_voronoiSetEdgeEnd(edge, lSite, rSite, vertex) {
        if (!edge.a && !edge.b) {
            edge.a = vertex;
            edge.l = lSite;
            edge.r = rSite;
        } else if (edge.l === rSite) {
            edge.b = vertex;
        } else {
            edge.a = vertex;
        }
    }
    function d3_geom_voronoiHalfEdge(edge, lSite, rSite) {
        var va = edge.a, vb = edge.b;
        this.edge = edge;
        this.site = lSite;
        this.angle = rSite ? Math.atan2(rSite.y - lSite.y, rSite.x - lSite.x) : edge.l === lSite ? Math.atan2(vb.x - va.x, va.y - vb.y) : Math.atan2(va.x - vb.x, vb.y - va.y);
    }
    d3_geom_voronoiHalfEdge.prototype = {
        start: function() {
            return this.edge.l === this.site ? this.edge.a : this.edge.b;
        },
        end: function() {
            return this.edge.l === this.site ? this.edge.b : this.edge.a;
        }
    };
    function d3_geom_voronoiRedBlackTree() {
        this._ = null;
    }
    function d3_geom_voronoiRedBlackNode(node) {
        node.U = node.C = node.L = node.R = node.P = node.N = null;
    }
    d3_geom_voronoiRedBlackTree.prototype = {
        insert: function(after, node) {
            var parent, grandpa, uncle;
            if (after) {
                node.P = after;
                node.N = after.N;
                if (after.N) after.N.P = node;
                after.N = node;
                if (after.R) {
                    after = after.R;
                    while (after.L) after = after.L;
                    after.L = node;
                } else {
                    after.R = node;
                }
                parent = after;
            } else if (this._) {
                after = d3_geom_voronoiRedBlackFirst(this._);
                node.P = null;
                node.N = after;
                after.P = after.L = node;
                parent = after;
            } else {
                node.P = node.N = null;
                this._ = node;
                parent = null;
            }
            node.L = node.R = null;
            node.U = parent;
            node.C = true;
            after = node;
            while (parent && parent.C) {
                grandpa = parent.U;
                if (parent === grandpa.L) {
                    uncle = grandpa.R;
                    if (uncle && uncle.C) {
                        parent.C = uncle.C = false;
                        grandpa.C = true;
                        after = grandpa;
                    } else {
                        if (after === parent.R) {
                            d3_geom_voronoiRedBlackRotateLeft(this, parent);
                            after = parent;
                            parent = after.U;
                        }
                        parent.C = false;
                        grandpa.C = true;
                        d3_geom_voronoiRedBlackRotateRight(this, grandpa);
                    }
                } else {
                    uncle = grandpa.L;
                    if (uncle && uncle.C) {
                        parent.C = uncle.C = false;
                        grandpa.C = true;
                        after = grandpa;
                    } else {
                        if (after === parent.L) {
                            d3_geom_voronoiRedBlackRotateRight(this, parent);
                            after = parent;
                            parent = after.U;
                        }
                        parent.C = false;
                        grandpa.C = true;
                        d3_geom_voronoiRedBlackRotateLeft(this, grandpa);
                    }
                }
                parent = after.U;
            }
            this._.C = false;
        },
        remove: function(node) {
            if (node.N) node.N.P = node.P;
            if (node.P) node.P.N = node.N;
            node.N = node.P = null;
            var parent = node.U, sibling, left = node.L, right = node.R, next, red;
            if (!left) next = right; else if (!right) next = left; else next = d3_geom_voronoiRedBlackFirst(right);
            if (parent) {
                if (parent.L === node) parent.L = next; else parent.R = next;
            } else {
                this._ = next;
            }
            if (left && right) {
                red = next.C;
                next.C = node.C;
                next.L = left;
                left.U = next;
                if (next !== right) {
                    parent = next.U;
                    next.U = node.U;
                    node = next.R;
                    parent.L = node;
                    next.R = right;
                    right.U = next;
                } else {
                    next.U = parent;
                    parent = next;
                    node = next.R;
                }
            } else {
                red = node.C;
                node = next;
            }
            if (node) node.U = parent;
            if (red) return;
            if (node && node.C) {
                node.C = false;
                return;
            }
            do {
                if (node === this._) break;
                if (node === parent.L) {
                    sibling = parent.R;
                    if (sibling.C) {
                        sibling.C = false;
                        parent.C = true;
                        d3_geom_voronoiRedBlackRotateLeft(this, parent);
                        sibling = parent.R;
                    }
                    if (sibling.L && sibling.L.C || sibling.R && sibling.R.C) {
                        if (!sibling.R || !sibling.R.C) {
                            sibling.L.C = false;
                            sibling.C = true;
                            d3_geom_voronoiRedBlackRotateRight(this, sibling);
                            sibling = parent.R;
                        }
                        sibling.C = parent.C;
                        parent.C = sibling.R.C = false;
                        d3_geom_voronoiRedBlackRotateLeft(this, parent);
                        node = this._;
                        break;
                    }
                } else {
                    sibling = parent.L;
                    if (sibling.C) {
                        sibling.C = false;
                        parent.C = true;
                        d3_geom_voronoiRedBlackRotateRight(this, parent);
                        sibling = parent.L;
                    }
                    if (sibling.L && sibling.L.C || sibling.R && sibling.R.C) {
                        if (!sibling.L || !sibling.L.C) {
                            sibling.R.C = false;
                            sibling.C = true;
                            d3_geom_voronoiRedBlackRotateLeft(this, sibling);
                            sibling = parent.L;
                        }
                        sibling.C = parent.C;
                        parent.C = sibling.L.C = false;
                        d3_geom_voronoiRedBlackRotateRight(this, parent);
                        node = this._;
                        break;
                    }
                }
                sibling.C = true;
                node = parent;
                parent = parent.U;
            } while (!node.C);
            if (node) node.C = false;
        }
    };
    function d3_geom_voronoiRedBlackRotateLeft(tree, node) {
        var p = node, q = node.R, parent = p.U;
        if (parent) {
            if (parent.L === p) parent.L = q; else parent.R = q;
        } else {
            tree._ = q;
        }
        q.U = parent;
        p.U = q;
        p.R = q.L;
        if (p.R) p.R.U = p;
        q.L = p;
    }
    function d3_geom_voronoiRedBlackRotateRight(tree, node) {
        var p = node, q = node.L, parent = p.U;
        if (parent) {
            if (parent.L === p) parent.L = q; else parent.R = q;
        } else {
            tree._ = q;
        }
        q.U = parent;
        p.U = q;
        p.L = q.R;
        if (p.L) p.L.U = p;
        q.R = p;
    }
    function d3_geom_voronoiRedBlackFirst(node) {
        while (node.L) node = node.L;
        return node;
    }
    function d3_geom_voronoi(sites, bbox) {
        var site = sites.sort(d3_geom_voronoiVertexOrder).pop(), x0, y0, circle;
        d3_geom_voronoiEdges = [];
        d3_geom_voronoiCells = new Array(sites.length);
        d3_geom_voronoiBeaches = new d3_geom_voronoiRedBlackTree();
        d3_geom_voronoiCircles = new d3_geom_voronoiRedBlackTree();
        while (true) {
            circle = d3_geom_voronoiFirstCircle;
            if (site && (!circle || site.y < circle.y || site.y === circle.y && site.x < circle.x)) {
                if (site.x !== x0 || site.y !== y0) {
                    d3_geom_voronoiCells[site.i] = new d3_geom_voronoiCell(site);
                    d3_geom_voronoiAddBeach(site);
                    x0 = site.x, y0 = site.y;
                }
                site = sites.pop();
            } else if (circle) {
                d3_geom_voronoiRemoveBeach(circle.arc);
            } else {
                break;
            }
        }
        if (bbox) d3_geom_voronoiClipEdges(bbox), d3_geom_voronoiCloseCells(bbox);
        var diagram = {
            cells: d3_geom_voronoiCells,
            edges: d3_geom_voronoiEdges
        };
        d3_geom_voronoiBeaches = d3_geom_voronoiCircles = d3_geom_voronoiEdges = d3_geom_voronoiCells = null;
        return diagram;
    }
    function d3_geom_voronoiVertexOrder(a, b) {
        return b.y - a.y || b.x - a.x;
    }
    d3.geom.voronoi = function(points) {
        var x = d3_geom_pointX, y = d3_geom_pointY, fx = x, fy = y, clipExtent = d3_geom_voronoiClipExtent;
        if (points) return voronoi(points);
        function voronoi(data) {
            var polygons = new Array(data.length), x0 = clipExtent[0][0], y0 = clipExtent[0][1], x1 = clipExtent[1][0], y1 = clipExtent[1][1];
            d3_geom_voronoi(sites(data), clipExtent).cells.forEach(function(cell, i) {
                var edges = cell.edges, site = cell.site, polygon = polygons[i] = edges.length ? edges.map(function(e) {
                    var s = e.start();
                    return [ s.x, s.y ];
                }) : site.x >= x0 && site.x <= x1 && site.y >= y0 && site.y <= y1 ? [ [ x0, y1 ], [ x1, y1 ], [ x1, y0 ], [ x0, y0 ] ] : [];
                polygon.point = data[i];
            });
            return polygons;
        }
        function sites(data) {
            return data.map(function(d, i) {
                return {
                    x: Math.round(fx(d, i) / Îµ) * Îµ,
                    y: Math.round(fy(d, i) / Îµ) * Îµ,
                    i: i
                };
            });
        }
        voronoi.links = function(data) {
            return d3_geom_voronoi(sites(data)).edges.filter(function(edge) {
                return edge.l && edge.r;
            }).map(function(edge) {
                return {
                    source: data[edge.l.i],
                    target: data[edge.r.i]
                };
            });
        };
        voronoi.triangles = function(data) {
            var triangles = [];
            d3_geom_voronoi(sites(data)).cells.forEach(function(cell, i) {
                var site = cell.site, edges = cell.edges.sort(d3_geom_voronoiHalfEdgeOrder), j = -1, m = edges.length, e0, s0, e1 = edges[m - 1].edge, s1 = e1.l === site ? e1.r : e1.l;
                while (++j < m) {
                    e0 = e1;
                    s0 = s1;
                    e1 = edges[j].edge;
                    s1 = e1.l === site ? e1.r : e1.l;
                    if (i < s0.i && i < s1.i && d3_geom_voronoiTriangleArea(site, s0, s1) < 0) {
                        triangles.push([ data[i], data[s0.i], data[s1.i] ]);
                    }
                }
            });
            return triangles;
        };
        voronoi.x = function(_) {
            return arguments.length ? (fx = d3_functor(x = _), voronoi) : x;
        };
        voronoi.y = function(_) {
            return arguments.length ? (fy = d3_functor(y = _), voronoi) : y;
        };
        voronoi.clipExtent = function(_) {
            if (!arguments.length) return clipExtent === d3_geom_voronoiClipExtent ? null : clipExtent;
            clipExtent = _ == null ? d3_geom_voronoiClipExtent : _;
            return voronoi;
        };
        voronoi.size = function(_) {
            if (!arguments.length) return clipExtent === d3_geom_voronoiClipExtent ? null : clipExtent && clipExtent[1];
            return voronoi.clipExtent(_ && [ [ 0, 0 ], _ ]);
        };
        return voronoi;
    };
    var d3_geom_voronoiClipExtent = [ [ -1e6, -1e6 ], [ 1e6, 1e6 ] ];
    function d3_geom_voronoiTriangleArea(a, b, c) {
        return (a.x - c.x) * (b.y - a.y) - (a.x - b.x) * (c.y - a.y);
    }
    d3.geom.delaunay = function(vertices) {
        return d3.geom.voronoi().triangles(vertices);
    };
    d3.geom.quadtree = function(points, x1, y1, x2, y2) {
        var x = d3_geom_pointX, y = d3_geom_pointY, compat;
        if (compat = arguments.length) {
            x = d3_geom_quadtreeCompatX;
            y = d3_geom_quadtreeCompatY;
            if (compat === 3) {
                y2 = y1;
                x2 = x1;
                y1 = x1 = 0;
            }
            return quadtree(points);
        }
        function quadtree(data) {
            var d, fx = d3_functor(x), fy = d3_functor(y), xs, ys, i, n, x1_, y1_, x2_, y2_;
            if (x1 != null) {
                x1_ = x1, y1_ = y1, x2_ = x2, y2_ = y2;
            } else {
                x2_ = y2_ = -(x1_ = y1_ = Infinity);
                xs = [], ys = [];
                n = data.length;
                if (compat) for (i = 0; i < n; ++i) {
                    d = data[i];
                    if (d.x < x1_) x1_ = d.x;
                    if (d.y < y1_) y1_ = d.y;
                    if (d.x > x2_) x2_ = d.x;
                    if (d.y > y2_) y2_ = d.y;
                    xs.push(d.x);
                    ys.push(d.y);
                } else for (i = 0; i < n; ++i) {
                    var x_ = +fx(d = data[i], i), y_ = +fy(d, i);
                    if (x_ < x1_) x1_ = x_;
                    if (y_ < y1_) y1_ = y_;
                    if (x_ > x2_) x2_ = x_;
                    if (y_ > y2_) y2_ = y_;
                    xs.push(x_);
                    ys.push(y_);
                }
            }
            var dx = x2_ - x1_, dy = y2_ - y1_;
            if (dx > dy) y2_ = y1_ + dx; else x2_ = x1_ + dy;
            function insert(n, d, x, y, x1, y1, x2, y2) {
                if (isNaN(x) || isNaN(y)) return;
                if (n.leaf) {
                    var nx = n.x, ny = n.y;
                    if (nx != null) {
                        if (abs(nx - x) + abs(ny - y) < .01) {
                            insertChild(n, d, x, y, x1, y1, x2, y2);
                        } else {
                            var nPoint = n.point;
                            n.x = n.y = n.point = null;
                            insertChild(n, nPoint, nx, ny, x1, y1, x2, y2);
                            insertChild(n, d, x, y, x1, y1, x2, y2);
                        }
                    } else {
                        n.x = x, n.y = y, n.point = d;
                    }
                } else {
                    insertChild(n, d, x, y, x1, y1, x2, y2);
                }
            }
            function insertChild(n, d, x, y, x1, y1, x2, y2) {
                var xm = (x1 + x2) * .5, ym = (y1 + y2) * .5, right = x >= xm, below = y >= ym, i = below << 1 | right;
                n.leaf = false;
                n = n.nodes[i] || (n.nodes[i] = d3_geom_quadtreeNode());
                if (right) x1 = xm; else x2 = xm;
                if (below) y1 = ym; else y2 = ym;
                insert(n, d, x, y, x1, y1, x2, y2);
            }
            var root = d3_geom_quadtreeNode();
            root.add = function(d) {
                insert(root, d, +fx(d, ++i), +fy(d, i), x1_, y1_, x2_, y2_);
            };
            root.visit = function(f) {
                d3_geom_quadtreeVisit(f, root, x1_, y1_, x2_, y2_);
            };
            root.find = function(point) {
                return d3_geom_quadtreeFind(root, point[0], point[1], x1_, y1_, x2_, y2_);
            };
            i = -1;
            if (x1 == null) {
                while (++i < n) {
                    insert(root, data[i], xs[i], ys[i], x1_, y1_, x2_, y2_);
                }
                --i;
            } else data.forEach(root.add);
            xs = ys = data = d = null;
            return root;
        }
        quadtree.x = function(_) {
            return arguments.length ? (x = _, quadtree) : x;
        };
        quadtree.y = function(_) {
            return arguments.length ? (y = _, quadtree) : y;
        };
        quadtree.extent = function(_) {
            if (!arguments.length) return x1 == null ? null : [ [ x1, y1 ], [ x2, y2 ] ];
            if (_ == null) x1 = y1 = x2 = y2 = null; else x1 = +_[0][0], y1 = +_[0][1], x2 = +_[1][0], 
            y2 = +_[1][1];
            return quadtree;
        };
        quadtree.size = function(_) {
            if (!arguments.length) return x1 == null ? null : [ x2 - x1, y2 - y1 ];
            if (_ == null) x1 = y1 = x2 = y2 = null; else x1 = y1 = 0, x2 = +_[0], y2 = +_[1];
            return quadtree;
        };
        return quadtree;
    };
    function d3_geom_quadtreeCompatX(d) {
        return d.x;
    }
    function d3_geom_quadtreeCompatY(d) {
        return d.y;
    }
    function d3_geom_quadtreeNode() {
        return {
            leaf: true,
            nodes: [],
            point: null,
            x: null,
            y: null
        };
    }
    function d3_geom_quadtreeVisit(f, node, x1, y1, x2, y2) {
        if (!f(node, x1, y1, x2, y2)) {
            var sx = (x1 + x2) * .5, sy = (y1 + y2) * .5, children = node.nodes;
            if (children[0]) d3_geom_quadtreeVisit(f, children[0], x1, y1, sx, sy);
            if (children[1]) d3_geom_quadtreeVisit(f, children[1], sx, y1, x2, sy);
            if (children[2]) d3_geom_quadtreeVisit(f, children[2], x1, sy, sx, y2);
            if (children[3]) d3_geom_quadtreeVisit(f, children[3], sx, sy, x2, y2);
        }
    }
    function d3_geom_quadtreeFind(root, x, y, x0, y0, x3, y3) {
        var minDistance2 = Infinity, closestPoint;
        (function find(node, x1, y1, x2, y2) {
            if (x1 > x3 || y1 > y3 || x2 < x0 || y2 < y0) return;
            if (point = node.point) {
                var point, dx = x - node.x, dy = y - node.y, distance2 = dx * dx + dy * dy;
                if (distance2 < minDistance2) {
                    var distance = Math.sqrt(minDistance2 = distance2);
                    x0 = x - distance, y0 = y - distance;
                    x3 = x + distance, y3 = y + distance;
                    closestPoint = point;
                }
            }
            var children = node.nodes, xm = (x1 + x2) * .5, ym = (y1 + y2) * .5, right = x >= xm, below = y >= ym;
            for (var i = below << 1 | right, j = i + 4; i < j; ++i) {
                if (node = children[i & 3]) switch (i & 3) {
                  case 0:
                    find(node, x1, y1, xm, ym);
                    break;

                  case 1:
                    find(node, xm, y1, x2, ym);
                    break;

                  case 2:
                    find(node, x1, ym, xm, y2);
                    break;

                  case 3:
                    find(node, xm, ym, x2, y2);
                    break;
                }
            }
        })(root, x0, y0, x3, y3);
        return closestPoint;
    }
    d3.interpolateRgb = d3_interpolateRgb;
    function d3_interpolateRgb(a, b) {
        a = d3.rgb(a);
        b = d3.rgb(b);
        var ar = a.r, ag = a.g, ab = a.b, br = b.r - ar, bg = b.g - ag, bb = b.b - ab;
        return function(t) {
            return "#" + d3_rgb_hex(Math.round(ar + br * t)) + d3_rgb_hex(Math.round(ag + bg * t)) + d3_rgb_hex(Math.round(ab + bb * t));
        };
    }
    d3.interpolateObject = d3_interpolateObject;
    function d3_interpolateObject(a, b) {
        var i = {}, c = {}, k;
        for (k in a) {
            if (k in b) {
                i[k] = d3_interpolate(a[k], b[k]);
            } else {
                c[k] = a[k];
            }
        }
        for (k in b) {
            if (!(k in a)) {
                c[k] = b[k];
            }
        }
        return function(t) {
            for (k in i) c[k] = i[k](t);
            return c;
        };
    }
    d3.interpolateNumber = d3_interpolateNumber;
    function d3_interpolateNumber(a, b) {
        a = +a, b = +b;
        return function(t) {
            return a * (1 - t) + b * t;
        };
    }
    d3.interpolateString = d3_interpolateString;
    function d3_interpolateString(a, b) {
        var bi = d3_interpolate_numberA.lastIndex = d3_interpolate_numberB.lastIndex = 0, am, bm, bs, i = -1, s = [], q = [];
        a = a + "", b = b + "";
        while ((am = d3_interpolate_numberA.exec(a)) && (bm = d3_interpolate_numberB.exec(b))) {
            if ((bs = bm.index) > bi) {
                bs = b.slice(bi, bs);
                if (s[i]) s[i] += bs; else s[++i] = bs;
            }
            if ((am = am[0]) === (bm = bm[0])) {
                if (s[i]) s[i] += bm; else s[++i] = bm;
            } else {
                s[++i] = null;
                q.push({
                    i: i,
                    x: d3_interpolateNumber(am, bm)
                });
            }
            bi = d3_interpolate_numberB.lastIndex;
        }
        if (bi < b.length) {
            bs = b.slice(bi);
            if (s[i]) s[i] += bs; else s[++i] = bs;
        }
        return s.length < 2 ? q[0] ? (b = q[0].x, function(t) {
            return b(t) + "";
        }) : function() {
            return b;
        } : (b = q.length, function(t) {
            for (var i = 0, o; i < b; ++i) s[(o = q[i]).i] = o.x(t);
            return s.join("");
        });
    }
    var d3_interpolate_numberA = /[-+]?(?:\d+\.?\d*|\.?\d+)(?:[eE][-+]?\d+)?/g, d3_interpolate_numberB = new RegExp(d3_interpolate_numberA.source, "g");
    d3.interpolate = d3_interpolate;
    function d3_interpolate(a, b) {
        var i = d3.interpolators.length, f;
        while (--i >= 0 && !(f = d3.interpolators[i](a, b))) ;
        return f;
    }
    d3.interpolators = [ function(a, b) {
        var t = typeof b;
        return (t === "string" ? d3_rgb_names.has(b.toLowerCase()) || /^(#|rgb\(|hsl\()/i.test(b) ? d3_interpolateRgb : d3_interpolateString : b instanceof d3_color ? d3_interpolateRgb : Array.isArray(b) ? d3_interpolateArray : t === "object" && isNaN(b) ? d3_interpolateObject : d3_interpolateNumber)(a, b);
    } ];
    d3.interpolateArray = d3_interpolateArray;
    function d3_interpolateArray(a, b) {
        var x = [], c = [], na = a.length, nb = b.length, n0 = Math.min(a.length, b.length), i;
        for (i = 0; i < n0; ++i) x.push(d3_interpolate(a[i], b[i]));
        for (;i < na; ++i) c[i] = a[i];
        for (;i < nb; ++i) c[i] = b[i];
        return function(t) {
            for (i = 0; i < n0; ++i) c[i] = x[i](t);
            return c;
        };
    }
    var d3_ease_default = function() {
        return d3_identity;
    };
    var d3_ease = d3.map({
        linear: d3_ease_default,
        poly: d3_ease_poly,
        quad: function() {
            return d3_ease_quad;
        },
        cubic: function() {
            return d3_ease_cubic;
        },
        sin: function() {
            return d3_ease_sin;
        },
        exp: function() {
            return d3_ease_exp;
        },
        circle: function() {
            return d3_ease_circle;
        },
        elastic: d3_ease_elastic,
        back: d3_ease_back,
        bounce: function() {
            return d3_ease_bounce;
        }
    });
    var d3_ease_mode = d3.map({
        "in": d3_identity,
        out: d3_ease_reverse,
        "in-out": d3_ease_reflect,
        "out-in": function(f) {
            return d3_ease_reflect(d3_ease_reverse(f));
        }
    });
    d3.ease = function(name) {
        var i = name.indexOf("-"), t = i >= 0 ? name.slice(0, i) : name, m = i >= 0 ? name.slice(i + 1) : "in";
        t = d3_ease.get(t) || d3_ease_default;
        m = d3_ease_mode.get(m) || d3_identity;
        return d3_ease_clamp(m(t.apply(null, d3_arraySlice.call(arguments, 1))));
    };
    function d3_ease_clamp(f) {
        return function(t) {
            return t <= 0 ? 0 : t >= 1 ? 1 : f(t);
        };
    }
    function d3_ease_reverse(f) {
        return function(t) {
            return 1 - f(1 - t);
        };
    }
    function d3_ease_reflect(f) {
        return function(t) {
            return .5 * (t < .5 ? f(2 * t) : 2 - f(2 - 2 * t));
        };
    }
    function d3_ease_quad(t) {
        return t * t;
    }
    function d3_ease_cubic(t) {
        return t * t * t;
    }
    function d3_ease_cubicInOut(t) {
        if (t <= 0) return 0;
        if (t >= 1) return 1;
        var t2 = t * t, t3 = t2 * t;
        return 4 * (t < .5 ? t3 : 3 * (t - t2) + t3 - .75);
    }
    function d3_ease_poly(e) {
        return function(t) {
            return Math.pow(t, e);
        };
    }
    function d3_ease_sin(t) {
        return 1 - Math.cos(t * halfÏ);
    }
    function d3_ease_exp(t) {
        return Math.pow(2, 10 * (t - 1));
    }
    function d3_ease_circle(t) {
        return 1 - Math.sqrt(1 - t * t);
    }
    function d3_ease_elastic(a, p) {
        var s;
        if (arguments.length < 2) p = .45;
        if (arguments.length) s = p / Ï * Math.asin(1 / a); else a = 1, s = p / 4;
        return function(t) {
            return 1 + a * Math.pow(2, -10 * t) * Math.sin((t - s) * Ï / p);
        };
    }
    function d3_ease_back(s) {
        if (!s) s = 1.70158;
        return function(t) {
            return t * t * ((s + 1) * t - s);
        };
    }
    function d3_ease_bounce(t) {
        return t < 1 / 2.75 ? 7.5625 * t * t : t < 2 / 2.75 ? 7.5625 * (t -= 1.5 / 2.75) * t + .75 : t < 2.5 / 2.75 ? 7.5625 * (t -= 2.25 / 2.75) * t + .9375 : 7.5625 * (t -= 2.625 / 2.75) * t + .984375;
    }
    d3.interpolateHcl = d3_interpolateHcl;
    function d3_interpolateHcl(a, b) {
        a = d3.hcl(a);
        b = d3.hcl(b);
        var ah = a.h, ac = a.c, al = a.l, bh = b.h - ah, bc = b.c - ac, bl = b.l - al;
        if (isNaN(bc)) bc = 0, ac = isNaN(ac) ? b.c : ac;
        if (isNaN(bh)) bh = 0, ah = isNaN(ah) ? b.h : ah; else if (bh > 180) bh -= 360; else if (bh < -180) bh += 360;
        return function(t) {
            return d3_hcl_lab(ah + bh * t, ac + bc * t, al + bl * t) + "";
        };
    }
    d3.interpolateHsl = d3_interpolateHsl;
    function d3_interpolateHsl(a, b) {
        a = d3.hsl(a);
        b = d3.hsl(b);
        var ah = a.h, as = a.s, al = a.l, bh = b.h - ah, bs = b.s - as, bl = b.l - al;
        if (isNaN(bs)) bs = 0, as = isNaN(as) ? b.s : as;
        if (isNaN(bh)) bh = 0, ah = isNaN(ah) ? b.h : ah; else if (bh > 180) bh -= 360; else if (bh < -180) bh += 360;
        return function(t) {
            return d3_hsl_rgb(ah + bh * t, as + bs * t, al + bl * t) + "";
        };
    }
    d3.interpolateLab = d3_interpolateLab;
    function d3_interpolateLab(a, b) {
        a = d3.lab(a);
        b = d3.lab(b);
        var al = a.l, aa = a.a, ab = a.b, bl = b.l - al, ba = b.a - aa, bb = b.b - ab;
        return function(t) {
            return d3_lab_rgb(al + bl * t, aa + ba * t, ab + bb * t) + "";
        };
    }
    d3.interpolateRound = d3_interpolateRound;
    function d3_interpolateRound(a, b) {
        b -= a;
        return function(t) {
            return Math.round(a + b * t);
        };
    }
    d3.transform = function(string) {
        var g = d3_document.createElementNS(d3.ns.prefix.svg, "g");
        return (d3.transform = function(string) {
            if (string != null) {
                g.setAttribute("transform", string);
                var t = g.transform.baseVal.consolidate();
            }
            return new d3_transform(t ? t.matrix : d3_transformIdentity);
        })(string);
    };
    function d3_transform(m) {
        var r0 = [ m.a, m.b ], r1 = [ m.c, m.d ], kx = d3_transformNormalize(r0), kz = d3_transformDot(r0, r1), ky = d3_transformNormalize(d3_transformCombine(r1, r0, -kz)) || 0;
        if (r0[0] * r1[1] < r1[0] * r0[1]) {
            r0[0] *= -1;
            r0[1] *= -1;
            kx *= -1;
            kz *= -1;
        }
        this.rotate = (kx ? Math.atan2(r0[1], r0[0]) : Math.atan2(-r1[0], r1[1])) * d3_degrees;
        this.translate = [ m.e, m.f ];
        this.scale = [ kx, ky ];
        this.skew = ky ? Math.atan2(kz, ky) * d3_degrees : 0;
    }
    d3_transform.prototype.toString = function() {
        return "translate(" + this.translate + ")rotate(" + this.rotate + ")skewX(" + this.skew + ")scale(" + this.scale + ")";
    };
    function d3_transformDot(a, b) {
        return a[0] * b[0] + a[1] * b[1];
    }
    function d3_transformNormalize(a) {
        var k = Math.sqrt(d3_transformDot(a, a));
        if (k) {
            a[0] /= k;
            a[1] /= k;
        }
        return k;
    }
    function d3_transformCombine(a, b, k) {
        a[0] += k * b[0];
        a[1] += k * b[1];
        return a;
    }
    var d3_transformIdentity = {
        a: 1,
        b: 0,
        c: 0,
        d: 1,
        e: 0,
        f: 0
    };
    d3.interpolateTransform = d3_interpolateTransform;
    function d3_interpolateTransformPop(s) {
        return s.length ? s.pop() + "," : "";
    }
    function d3_interpolateTranslate(ta, tb, s, q) {
        if (ta[0] !== tb[0] || ta[1] !== tb[1]) {
            var i = s.push("translate(", null, ",", null, ")");
            q.push({
                i: i - 4,
                x: d3_interpolateNumber(ta[0], tb[0])
            }, {
                i: i - 2,
                x: d3_interpolateNumber(ta[1], tb[1])
            });
        } else if (tb[0] || tb[1]) {
            s.push("translate(" + tb + ")");
        }
    }
    function d3_interpolateRotate(ra, rb, s, q) {
        if (ra !== rb) {
            if (ra - rb > 180) rb += 360; else if (rb - ra > 180) ra += 360;
            q.push({
                i: s.push(d3_interpolateTransformPop(s) + "rotate(", null, ")") - 2,
                x: d3_interpolateNumber(ra, rb)
            });
        } else if (rb) {
            s.push(d3_interpolateTransformPop(s) + "rotate(" + rb + ")");
        }
    }
    function d3_interpolateSkew(wa, wb, s, q) {
        if (wa !== wb) {
            q.push({
                i: s.push(d3_interpolateTransformPop(s) + "skewX(", null, ")") - 2,
                x: d3_interpolateNumber(wa, wb)
            });
        } else if (wb) {
            s.push(d3_interpolateTransformPop(s) + "skewX(" + wb + ")");
        }
    }
    function d3_interpolateScale(ka, kb, s, q) {
        if (ka[0] !== kb[0] || ka[1] !== kb[1]) {
            var i = s.push(d3_interpolateTransformPop(s) + "scale(", null, ",", null, ")");
            q.push({
                i: i - 4,
                x: d3_interpolateNumber(ka[0], kb[0])
            }, {
                i: i - 2,
                x: d3_interpolateNumber(ka[1], kb[1])
            });
        } else if (kb[0] !== 1 || kb[1] !== 1) {
            s.push(d3_interpolateTransformPop(s) + "scale(" + kb + ")");
        }
    }
    function d3_interpolateTransform(a, b) {
        var s = [], q = [];
        a = d3.transform(a), b = d3.transform(b);
        d3_interpolateTranslate(a.translate, b.translate, s, q);
        d3_interpolateRotate(a.rotate, b.rotate, s, q);
        d3_interpolateSkew(a.skew, b.skew, s, q);
        d3_interpolateScale(a.scale, b.scale, s, q);
        a = b = null;
        return function(t) {
            var i = -1, n = q.length, o;
            while (++i < n) s[(o = q[i]).i] = o.x(t);
            return s.join("");
        };
    }
    function d3_uninterpolateNumber(a, b) {
        b = (b -= a = +a) || 1 / b;
        return function(x) {
            return (x - a) / b;
        };
    }
    function d3_uninterpolateClamp(a, b) {
        b = (b -= a = +a) || 1 / b;
        return function(x) {
            return Math.max(0, Math.min(1, (x - a) / b));
        };
    }
    d3.layout = {};
    d3.layout.bundle = function() {
        return function(links) {
            var paths = [], i = -1, n = links.length;
            while (++i < n) paths.push(d3_layout_bundlePath(links[i]));
            return paths;
        };
    };
    function d3_layout_bundlePath(link) {
        var start = link.source, end = link.target, lca = d3_layout_bundleLeastCommonAncestor(start, end), points = [ start ];
        while (start !== lca) {
            start = start.parent;
            points.push(start);
        }
        var k = points.length;
        while (end !== lca) {
            points.splice(k, 0, end);
            end = end.parent;
        }
        return points;
    }
    function d3_layout_bundleAncestors(node) {
        var ancestors = [], parent = node.parent;
        while (parent != null) {
            ancestors.push(node);
            node = parent;
            parent = parent.parent;
        }
        ancestors.push(node);
        return ancestors;
    }
    function d3_layout_bundleLeastCommonAncestor(a, b) {
        if (a === b) return a;
        var aNodes = d3_layout_bundleAncestors(a), bNodes = d3_layout_bundleAncestors(b), aNode = aNodes.pop(), bNode = bNodes.pop(), sharedNode = null;
        while (aNode === bNode) {
            sharedNode = aNode;
            aNode = aNodes.pop();
            bNode = bNodes.pop();
        }
        return sharedNode;
    }
    d3.layout.chord = function() {
        var chord = {}, chords, groups, matrix, n, padding = 0, sortGroups, sortSubgroups, sortChords;
        function relayout() {
            var subgroups = {}, groupSums = [], groupIndex = d3.range(n), subgroupIndex = [], k, x, x0, i, j;
            chords = [];
            groups = [];
            k = 0, i = -1;
            while (++i < n) {
                x = 0, j = -1;
                while (++j < n) {
                    x += matrix[i][j];
                }
                groupSums.push(x);
                subgroupIndex.push(d3.range(n));
                k += x;
            }
            if (sortGroups) {
                groupIndex.sort(function(a, b) {
                    return sortGroups(groupSums[a], groupSums[b]);
                });
            }
            if (sortSubgroups) {
                subgroupIndex.forEach(function(d, i) {
                    d.sort(function(a, b) {
                        return sortSubgroups(matrix[i][a], matrix[i][b]);
                    });
                });
            }
            k = (Ï - padding * n) / k;
            x = 0, i = -1;
            while (++i < n) {
                x0 = x, j = -1;
                while (++j < n) {
                    var di = groupIndex[i], dj = subgroupIndex[di][j], v = matrix[di][dj], a0 = x, a1 = x += v * k;
                    subgroups[di + "-" + dj] = {
                        index: di,
                        subindex: dj,
                        startAngle: a0,
                        endAngle: a1,
                        value: v
                    };
                }
                groups[di] = {
                    index: di,
                    startAngle: x0,
                    endAngle: x,
                    value: groupSums[di]
                };
                x += padding;
            }
            i = -1;
            while (++i < n) {
                j = i - 1;
                while (++j < n) {
                    var source = subgroups[i + "-" + j], target = subgroups[j + "-" + i];
                    if (source.value || target.value) {
                        chords.push(source.value < target.value ? {
                            source: target,
                            target: source
                        } : {
                            source: source,
                            target: target
                        });
                    }
                }
            }
            if (sortChords) resort();
        }
        function resort() {
            chords.sort(function(a, b) {
                return sortChords((a.source.value + a.target.value) / 2, (b.source.value + b.target.value) / 2);
            });
        }
        chord.matrix = function(x) {
            if (!arguments.length) return matrix;
            n = (matrix = x) && matrix.length;
            chords = groups = null;
            return chord;
        };
        chord.padding = function(x) {
            if (!arguments.length) return padding;
            padding = x;
            chords = groups = null;
            return chord;
        };
        chord.sortGroups = function(x) {
            if (!arguments.length) return sortGroups;
            sortGroups = x;
            chords = groups = null;
            return chord;
        };
        chord.sortSubgroups = function(x) {
            if (!arguments.length) return sortSubgroups;
            sortSubgroups = x;
            chords = null;
            return chord;
        };
        chord.sortChords = function(x) {
            if (!arguments.length) return sortChords;
            sortChords = x;
            if (chords) resort();
            return chord;
        };
        chord.chords = function() {
            if (!chords) relayout();
            return chords;
        };
        chord.groups = function() {
            if (!groups) relayout();
            return groups;
        };
        return chord;
    };
    d3.layout.force = function() {
        var force = {}, event = d3.dispatch("start", "tick", "end"), timer, size = [ 1, 1 ], drag, alpha, friction = .9, linkDistance = d3_layout_forceLinkDistance, linkStrength = d3_layout_forceLinkStrength, charge = -30, chargeDistance2 = d3_layout_forceChargeDistance2, gravity = .1, theta2 = .64, nodes = [], links = [], distances, strengths, charges;
        function repulse(node) {
            return function(quad, x1, _, x2) {
                if (quad.point !== node) {
                    var dx = quad.cx - node.x, dy = quad.cy - node.y, dw = x2 - x1, dn = dx * dx + dy * dy;
                    if (dw * dw / theta2 < dn) {
                        if (dn < chargeDistance2) {
                            var k = quad.charge / dn;
                            node.px -= dx * k;
                            node.py -= dy * k;
                        }
                        return true;
                    }
                    if (quad.point && dn && dn < chargeDistance2) {
                        var k = quad.pointCharge / dn;
                        node.px -= dx * k;
                        node.py -= dy * k;
                    }
                }
                return !quad.charge;
            };
        }
        force.tick = function() {
            if ((alpha *= .99) < .005) {
                timer = null;
                event.end({
                    type: "end",
                    alpha: alpha = 0
                });
                return true;
            }
            var n = nodes.length, m = links.length, q, i, o, s, t, l, k, x, y;
            for (i = 0; i < m; ++i) {
                o = links[i];
                s = o.source;
                t = o.target;
                x = t.x - s.x;
                y = t.y - s.y;
                if (l = x * x + y * y) {
                    l = alpha * strengths[i] * ((l = Math.sqrt(l)) - distances[i]) / l;
                    x *= l;
                    y *= l;
                    t.x -= x * (k = s.weight + t.weight ? s.weight / (s.weight + t.weight) : .5);
                    t.y -= y * k;
                    s.x += x * (k = 1 - k);
                    s.y += y * k;
                }
            }
            if (k = alpha * gravity) {
                x = size[0] / 2;
                y = size[1] / 2;
                i = -1;
                if (k) while (++i < n) {
                    o = nodes[i];
                    o.x += (x - o.x) * k;
                    o.y += (y - o.y) * k;
                }
            }
            if (charge) {
                d3_layout_forceAccumulate(q = d3.geom.quadtree(nodes), alpha, charges);
                i = -1;
                while (++i < n) {
                    if (!(o = nodes[i]).fixed) {
                        q.visit(repulse(o));
                    }
                }
            }
            i = -1;
            while (++i < n) {
                o = nodes[i];
                if (o.fixed) {
                    o.x = o.px;
                    o.y = o.py;
                } else {
                    o.x -= (o.px - (o.px = o.x)) * friction;
                    o.y -= (o.py - (o.py = o.y)) * friction;
                }
            }
            event.tick({
                type: "tick",
                alpha: alpha
            });
        };
        force.nodes = function(x) {
            if (!arguments.length) return nodes;
            nodes = x;
            return force;
        };
        force.links = function(x) {
            if (!arguments.length) return links;
            links = x;
            return force;
        };
        force.size = function(x) {
            if (!arguments.length) return size;
            size = x;
            return force;
        };
        force.linkDistance = function(x) {
            if (!arguments.length) return linkDistance;
            linkDistance = typeof x === "function" ? x : +x;
            return force;
        };
        force.distance = force.linkDistance;
        force.linkStrength = function(x) {
            if (!arguments.length) return linkStrength;
            linkStrength = typeof x === "function" ? x : +x;
            return force;
        };
        force.friction = function(x) {
            if (!arguments.length) return friction;
            friction = +x;
            return force;
        };
        force.charge = function(x) {
            if (!arguments.length) return charge;
            charge = typeof x === "function" ? x : +x;
            return force;
        };
        force.chargeDistance = function(x) {
            if (!arguments.length) return Math.sqrt(chargeDistance2);
            chargeDistance2 = x * x;
            return force;
        };
        force.gravity = function(x) {
            if (!arguments.length) return gravity;
            gravity = +x;
            return force;
        };
        force.theta = function(x) {
            if (!arguments.length) return Math.sqrt(theta2);
            theta2 = x * x;
            return force;
        };
        force.alpha = function(x) {
            if (!arguments.length) return alpha;
            x = +x;
            if (alpha) {
                if (x > 0) {
                    alpha = x;
                } else {
                    timer.c = null, timer.t = NaN, timer = null;
                    event.end({
                        type: "end",
                        alpha: alpha = 0
                    });
                }
            } else if (x > 0) {
                event.start({
                    type: "start",
                    alpha: alpha = x
                });
                timer = d3_timer(force.tick);
            }
            return force;
        };
        force.start = function() {
            var i, n = nodes.length, m = links.length, w = size[0], h = size[1], neighbors, o;
            for (i = 0; i < n; ++i) {
                (o = nodes[i]).index = i;
                o.weight = 0;
            }
            for (i = 0; i < m; ++i) {
                o = links[i];
                if (typeof o.source == "number") o.source = nodes[o.source];
                if (typeof o.target == "number") o.target = nodes[o.target];
                ++o.source.weight;
                ++o.target.weight;
            }
            for (i = 0; i < n; ++i) {
                o = nodes[i];
                if (isNaN(o.x)) o.x = position("x", w);
                if (isNaN(o.y)) o.y = position("y", h);
                if (isNaN(o.px)) o.px = o.x;
                if (isNaN(o.py)) o.py = o.y;
            }
            distances = [];
            if (typeof linkDistance === "function") for (i = 0; i < m; ++i) distances[i] = +linkDistance.call(this, links[i], i); else for (i = 0; i < m; ++i) distances[i] = linkDistance;
            strengths = [];
            if (typeof linkStrength === "function") for (i = 0; i < m; ++i) strengths[i] = +linkStrength.call(this, links[i], i); else for (i = 0; i < m; ++i) strengths[i] = linkStrength;
            charges = [];
            if (typeof charge === "function") for (i = 0; i < n; ++i) charges[i] = +charge.call(this, nodes[i], i); else for (i = 0; i < n; ++i) charges[i] = charge;
            function position(dimension, size) {
                if (!neighbors) {
                    neighbors = new Array(n);
                    for (j = 0; j < n; ++j) {
                        neighbors[j] = [];
                    }
                    for (j = 0; j < m; ++j) {
                        var o = links[j];
                        neighbors[o.source.index].push(o.target);
                        neighbors[o.target.index].push(o.source);
                    }
                }
                var candidates = neighbors[i], j = -1, l = candidates.length, x;
                while (++j < l) if (!isNaN(x = candidates[j][dimension])) return x;
                return Math.random() * size;
            }
            return force.resume();
        };
        force.resume = function() {
            return force.alpha(.1);
        };
        force.stop = function() {
            return force.alpha(0);
        };
        force.drag = function() {
            if (!drag) drag = d3.behavior.drag().origin(d3_identity).on("dragstart.force", d3_layout_forceDragstart).on("drag.force", dragmove).on("dragend.force", d3_layout_forceDragend);
            if (!arguments.length) return drag;
            this.on("mouseover.force", d3_layout_forceMouseover).on("mouseout.force", d3_layout_forceMouseout).call(drag);
        };
        function dragmove(d) {
            d.px = d3.event.x, d.py = d3.event.y;
            force.resume();
        }
        return d3.rebind(force, event, "on");
    };
    function d3_layout_forceDragstart(d) {
        d.fixed |= 2;
    }
    function d3_layout_forceDragend(d) {
        d.fixed &= ~6;
    }
    function d3_layout_forceMouseover(d) {
        d.fixed |= 4;
        d.px = d.x, d.py = d.y;
    }
    function d3_layout_forceMouseout(d) {
        d.fixed &= ~4;
    }
    function d3_layout_forceAccumulate(quad, alpha, charges) {
        var cx = 0, cy = 0;
        quad.charge = 0;
        if (!quad.leaf) {
            var nodes = quad.nodes, n = nodes.length, i = -1, c;
            while (++i < n) {
                c = nodes[i];
                if (c == null) continue;
                d3_layout_forceAccumulate(c, alpha, charges);
                quad.charge += c.charge;
                cx += c.charge * c.cx;
                cy += c.charge * c.cy;
            }
        }
        if (quad.point) {
            if (!quad.leaf) {
                quad.point.x += Math.random() - .5;
                quad.point.y += Math.random() - .5;
            }
            var k = alpha * charges[quad.point.index];
            quad.charge += quad.pointCharge = k;
            cx += k * quad.point.x;
            cy += k * quad.point.y;
        }
        quad.cx = cx / quad.charge;
        quad.cy = cy / quad.charge;
    }
    var d3_layout_forceLinkDistance = 20, d3_layout_forceLinkStrength = 1, d3_layout_forceChargeDistance2 = Infinity;
    d3.layout.hierarchy = function() {
        var sort = d3_layout_hierarchySort, children = d3_layout_hierarchyChildren, value = d3_layout_hierarchyValue;
        function hierarchy(root) {
            var stack = [ root ], nodes = [], node;
            root.depth = 0;
            while ((node = stack.pop()) != null) {
                nodes.push(node);
                if ((childs = children.call(hierarchy, node, node.depth)) && (n = childs.length)) {
                    var n, childs, child;
                    while (--n >= 0) {
                        stack.push(child = childs[n]);
                        child.parent = node;
                        child.depth = node.depth + 1;
                    }
                    if (value) node.value = 0;
                    node.children = childs;
                } else {
                    if (value) node.value = +value.call(hierarchy, node, node.depth) || 0;
                    delete node.children;
                }
            }
            d3_layout_hierarchyVisitAfter(root, function(node) {
                var childs, parent;
                if (sort && (childs = node.children)) childs.sort(sort);
                if (value && (parent = node.parent)) parent.value += node.value;
            });
            return nodes;
        }
        hierarchy.sort = function(x) {
            if (!arguments.length) return sort;
            sort = x;
            return hierarchy;
        };
        hierarchy.children = function(x) {
            if (!arguments.length) return children;
            children = x;
            return hierarchy;
        };
        hierarchy.value = function(x) {
            if (!arguments.length) return value;
            value = x;
            return hierarchy;
        };
        hierarchy.revalue = function(root) {
            if (value) {
                d3_layout_hierarchyVisitBefore(root, function(node) {
                    if (node.children) node.value = 0;
                });
                d3_layout_hierarchyVisitAfter(root, function(node) {
                    var parent;
                    if (!node.children) node.value = +value.call(hierarchy, node, node.depth) || 0;
                    if (parent = node.parent) parent.value += node.value;
                });
            }
            return root;
        };
        return hierarchy;
    };
    function d3_layout_hierarchyRebind(object, hierarchy) {
        d3.rebind(object, hierarchy, "sort", "children", "value");
        object.nodes = object;
        object.links = d3_layout_hierarchyLinks;
        return object;
    }
    function d3_layout_hierarchyVisitBefore(node, callback) {
        var nodes = [ node ];
        while ((node = nodes.pop()) != null) {
            callback(node);
            if ((children = node.children) && (n = children.length)) {
                var n, children;
                while (--n >= 0) nodes.push(children[n]);
            }
        }
    }
    function d3_layout_hierarchyVisitAfter(node, callback) {
        var nodes = [ node ], nodes2 = [];
        while ((node = nodes.pop()) != null) {
            nodes2.push(node);
            if ((children = node.children) && (n = children.length)) {
                var i = -1, n, children;
                while (++i < n) nodes.push(children[i]);
            }
        }
        while ((node = nodes2.pop()) != null) {
            callback(node);
        }
    }
    function d3_layout_hierarchyChildren(d) {
        return d.children;
    }
    function d3_layout_hierarchyValue(d) {
        return d.value;
    }
    function d3_layout_hierarchySort(a, b) {
        return b.value - a.value;
    }
    function d3_layout_hierarchyLinks(nodes) {
        return d3.merge(nodes.map(function(parent) {
            return (parent.children || []).map(function(child) {
                return {
                    source: parent,
                    target: child
                };
            });
        }));
    }
    d3.layout.partition = function() {
        var hierarchy = d3.layout.hierarchy(), size = [ 1, 1 ];
        function position(node, x, dx, dy) {
            var children = node.children;
            node.x = x;
            node.y = node.depth * dy;
            node.dx = dx;
            node.dy = dy;
            if (children && (n = children.length)) {
                var i = -1, n, c, d;
                dx = node.value ? dx / node.value : 0;
                while (++i < n) {
                    position(c = children[i], x, d = c.value * dx, dy);
                    x += d;
                }
            }
        }
        function depth(node) {
            var children = node.children, d = 0;
            if (children && (n = children.length)) {
                var i = -1, n;
                while (++i < n) d = Math.max(d, depth(children[i]));
            }
            return 1 + d;
        }
        function partition(d, i) {
            var nodes = hierarchy.call(this, d, i);
            position(nodes[0], 0, size[0], size[1] / depth(nodes[0]));
            return nodes;
        }
        partition.size = function(x) {
            if (!arguments.length) return size;
            size = x;
            return partition;
        };
        return d3_layout_hierarchyRebind(partition, hierarchy);
    };
    d3.layout.pie = function() {
        var value = Number, sort = d3_layout_pieSortByValue, startAngle = 0, endAngle = Ï, padAngle = 0;
        function pie(data) {
            var n = data.length, values = data.map(function(d, i) {
                return +value.call(pie, d, i);
            }), a = +(typeof startAngle === "function" ? startAngle.apply(this, arguments) : startAngle), da = (typeof endAngle === "function" ? endAngle.apply(this, arguments) : endAngle) - a, p = Math.min(Math.abs(da) / n, +(typeof padAngle === "function" ? padAngle.apply(this, arguments) : padAngle)), pa = p * (da < 0 ? -1 : 1), sum = d3.sum(values), k = sum ? (da - n * pa) / sum : 0, index = d3.range(n), arcs = [], v;
            if (sort != null) index.sort(sort === d3_layout_pieSortByValue ? function(i, j) {
                return values[j] - values[i];
            } : function(i, j) {
                return sort(data[i], data[j]);
            });
            index.forEach(function(i) {
                arcs[i] = {
                    data: data[i],
                    value: v = values[i],
                    startAngle: a,
                    endAngle: a += v * k + pa,
                    padAngle: p
                };
            });
            return arcs;
        }
        pie.value = function(_) {
            if (!arguments.length) return value;
            value = _;
            return pie;
        };
        pie.sort = function(_) {
            if (!arguments.length) return sort;
            sort = _;
            return pie;
        };
        pie.startAngle = function(_) {
            if (!arguments.length) return startAngle;
            startAngle = _;
            return pie;
        };
        pie.endAngle = function(_) {
            if (!arguments.length) return endAngle;
            endAngle = _;
            return pie;
        };
        pie.padAngle = function(_) {
            if (!arguments.length) return padAngle;
            padAngle = _;
            return pie;
        };
        return pie;
    };
    var d3_layout_pieSortByValue = {};
    d3.layout.stack = function() {
        var values = d3_identity, order = d3_layout_stackOrderDefault, offset = d3_layout_stackOffsetZero, out = d3_layout_stackOut, x = d3_layout_stackX, y = d3_layout_stackY;
        function stack(data, index) {
            if (!(n = data.length)) return data;
            var series = data.map(function(d, i) {
                return values.call(stack, d, i);
            });
            var points = series.map(function(d) {
                return d.map(function(v, i) {
                    return [ x.call(stack, v, i), y.call(stack, v, i) ];
                });
            });
            var orders = order.call(stack, points, index);
            series = d3.permute(series, orders);
            points = d3.permute(points, orders);
            var offsets = offset.call(stack, points, index);
            var m = series[0].length, n, i, j, o;
            for (j = 0; j < m; ++j) {
                out.call(stack, series[0][j], o = offsets[j], points[0][j][1]);
                for (i = 1; i < n; ++i) {
                    out.call(stack, series[i][j], o += points[i - 1][j][1], points[i][j][1]);
                }
            }
            return data;
        }
        stack.values = function(x) {
            if (!arguments.length) return values;
            values = x;
            return stack;
        };
        stack.order = function(x) {
            if (!arguments.length) return order;
            order = typeof x === "function" ? x : d3_layout_stackOrders.get(x) || d3_layout_stackOrderDefault;
            return stack;
        };
        stack.offset = function(x) {
            if (!arguments.length) return offset;
            offset = typeof x === "function" ? x : d3_layout_stackOffsets.get(x) || d3_layout_stackOffsetZero;
            return stack;
        };
        stack.x = function(z) {
            if (!arguments.length) return x;
            x = z;
            return stack;
        };
        stack.y = function(z) {
            if (!arguments.length) return y;
            y = z;
            return stack;
        };
        stack.out = function(z) {
            if (!arguments.length) return out;
            out = z;
            return stack;
        };
        return stack;
    };
    function d3_layout_stackX(d) {
        return d.x;
    }
    function d3_layout_stackY(d) {
        return d.y;
    }
    function d3_layout_stackOut(d, y0, y) {
        d.y0 = y0;
        d.y = y;
    }
    var d3_layout_stackOrders = d3.map({
        "inside-out": function(data) {
            var n = data.length, i, j, max = data.map(d3_layout_stackMaxIndex), sums = data.map(d3_layout_stackReduceSum), index = d3.range(n).sort(function(a, b) {
                return max[a] - max[b];
            }), top = 0, bottom = 0, tops = [], bottoms = [];
            for (i = 0; i < n; ++i) {
                j = index[i];
                if (top < bottom) {
                    top += sums[j];
                    tops.push(j);
                } else {
                    bottom += sums[j];
                    bottoms.push(j);
                }
            }
            return bottoms.reverse().concat(tops);
        },
        reverse: function(data) {
            return d3.range(data.length).reverse();
        },
        "default": d3_layout_stackOrderDefault
    });
    var d3_layout_stackOffsets = d3.map({
        silhouette: function(data) {
            var n = data.length, m = data[0].length, sums = [], max = 0, i, j, o, y0 = [];
            for (j = 0; j < m; ++j) {
                for (i = 0, o = 0; i < n; i++) o += data[i][j][1];
                if (o > max) max = o;
                sums.push(o);
            }
            for (j = 0; j < m; ++j) {
                y0[j] = (max - sums[j]) / 2;
            }
            return y0;
        },
        wiggle: function(data) {
            var n = data.length, x = data[0], m = x.length, i, j, k, s1, s2, s3, dx, o, o0, y0 = [];
            y0[0] = o = o0 = 0;
            for (j = 1; j < m; ++j) {
                for (i = 0, s1 = 0; i < n; ++i) s1 += data[i][j][1];
                for (i = 0, s2 = 0, dx = x[j][0] - x[j - 1][0]; i < n; ++i) {
                    for (k = 0, s3 = (data[i][j][1] - data[i][j - 1][1]) / (2 * dx); k < i; ++k) {
                        s3 += (data[k][j][1] - data[k][j - 1][1]) / dx;
                    }
                    s2 += s3 * data[i][j][1];
                }
                y0[j] = o -= s1 ? s2 / s1 * dx : 0;
                if (o < o0) o0 = o;
            }
            for (j = 0; j < m; ++j) y0[j] -= o0;
            return y0;
        },
        expand: function(data) {
            var n = data.length, m = data[0].length, k = 1 / n, i, j, o, y0 = [];
            for (j = 0; j < m; ++j) {
                for (i = 0, o = 0; i < n; i++) o += data[i][j][1];
                if (o) for (i = 0; i < n; i++) data[i][j][1] /= o; else for (i = 0; i < n; i++) data[i][j][1] = k;
            }
            for (j = 0; j < m; ++j) y0[j] = 0;
            return y0;
        },
        zero: d3_layout_stackOffsetZero
    });
    function d3_layout_stackOrderDefault(data) {
        return d3.range(data.length);
    }
    function d3_layout_stackOffsetZero(data) {
        var j = -1, m = data[0].length, y0 = [];
        while (++j < m) y0[j] = 0;
        return y0;
    }
    function d3_layout_stackMaxIndex(array) {
        var i = 1, j = 0, v = array[0][1], k, n = array.length;
        for (;i < n; ++i) {
            if ((k = array[i][1]) > v) {
                j = i;
                v = k;
            }
        }
        return j;
    }
    function d3_layout_stackReduceSum(d) {
        return d.reduce(d3_layout_stackSum, 0);
    }
    function d3_layout_stackSum(p, d) {
        return p + d[1];
    }
    d3.layout.histogram = function() {
        var frequency = true, valuer = Number, ranger = d3_layout_histogramRange, binner = d3_layout_histogramBinSturges;
        function histogram(data, i) {
            var bins = [], values = data.map(valuer, this), range = ranger.call(this, values, i), thresholds = binner.call(this, range, values, i), bin, i = -1, n = values.length, m = thresholds.length - 1, k = frequency ? 1 : 1 / n, x;
            while (++i < m) {
                bin = bins[i] = [];
                bin.dx = thresholds[i + 1] - (bin.x = thresholds[i]);
                bin.y = 0;
            }
            if (m > 0) {
                i = -1;
                while (++i < n) {
                    x = values[i];
                    if (x >= range[0] && x <= range[1]) {
                        bin = bins[d3.bisect(thresholds, x, 1, m) - 1];
                        bin.y += k;
                        bin.push(data[i]);
                    }
                }
            }
            return bins;
        }
        histogram.value = function(x) {
            if (!arguments.length) return valuer;
            valuer = x;
            return histogram;
        };
        histogram.range = function(x) {
            if (!arguments.length) return ranger;
            ranger = d3_functor(x);
            return histogram;
        };
        histogram.bins = function(x) {
            if (!arguments.length) return binner;
            binner = typeof x === "number" ? function(range) {
                return d3_layout_histogramBinFixed(range, x);
            } : d3_functor(x);
            return histogram;
        };
        histogram.frequency = function(x) {
            if (!arguments.length) return frequency;
            frequency = !!x;
            return histogram;
        };
        return histogram;
    };
    function d3_layout_histogramBinSturges(range, values) {
        return d3_layout_histogramBinFixed(range, Math.ceil(Math.log(values.length) / Math.LN2 + 1));
    }
    function d3_layout_histogramBinFixed(range, n) {
        var x = -1, b = +range[0], m = (range[1] - b) / n, f = [];
        while (++x <= n) f[x] = m * x + b;
        return f;
    }
    function d3_layout_histogramRange(values) {
        return [ d3.min(values), d3.max(values) ];
    }
    d3.layout.pack = function() {
        var hierarchy = d3.layout.hierarchy().sort(d3_layout_packSort), padding = 0, size = [ 1, 1 ], radius;
        function pack(d, i) {
            var nodes = hierarchy.call(this, d, i), root = nodes[0], w = size[0], h = size[1], r = radius == null ? Math.sqrt : typeof radius === "function" ? radius : function() {
                return radius;
            };
            root.x = root.y = 0;
            d3_layout_hierarchyVisitAfter(root, function(d) {
                d.r = +r(d.value);
            });
            d3_layout_hierarchyVisitAfter(root, d3_layout_packSiblings);
            if (padding) {
                var dr = padding * (radius ? 1 : Math.max(2 * root.r / w, 2 * root.r / h)) / 2;
                d3_layout_hierarchyVisitAfter(root, function(d) {
                    d.r += dr;
                });
                d3_layout_hierarchyVisitAfter(root, d3_layout_packSiblings);
                d3_layout_hierarchyVisitAfter(root, function(d) {
                    d.r -= dr;
                });
            }
            d3_layout_packTransform(root, w / 2, h / 2, radius ? 1 : 1 / Math.max(2 * root.r / w, 2 * root.r / h));
            return nodes;
        }
        pack.size = function(_) {
            if (!arguments.length) return size;
            size = _;
            return pack;
        };
        pack.radius = function(_) {
            if (!arguments.length) return radius;
            radius = _ == null || typeof _ === "function" ? _ : +_;
            return pack;
        };
        pack.padding = function(_) {
            if (!arguments.length) return padding;
            padding = +_;
            return pack;
        };
        return d3_layout_hierarchyRebind(pack, hierarchy);
    };
    function d3_layout_packSort(a, b) {
        return a.value - b.value;
    }
    function d3_layout_packInsert(a, b) {
        var c = a._pack_next;
        a._pack_next = b;
        b._pack_prev = a;
        b._pack_next = c;
        c._pack_prev = b;
    }
    function d3_layout_packSplice(a, b) {
        a._pack_next = b;
        b._pack_prev = a;
    }
    function d3_layout_packIntersects(a, b) {
        var dx = b.x - a.x, dy = b.y - a.y, dr = a.r + b.r;
        return .999 * dr * dr > dx * dx + dy * dy;
    }
    function d3_layout_packSiblings(node) {
        if (!(nodes = node.children) || !(n = nodes.length)) return;
        var nodes, xMin = Infinity, xMax = -Infinity, yMin = Infinity, yMax = -Infinity, a, b, c, i, j, k, n;
        function bound(node) {
            xMin = Math.min(node.x - node.r, xMin);
            xMax = Math.max(node.x + node.r, xMax);
            yMin = Math.min(node.y - node.r, yMin);
            yMax = Math.max(node.y + node.r, yMax);
        }
        nodes.forEach(d3_layout_packLink);
        a = nodes[0];
        a.x = -a.r;
        a.y = 0;
        bound(a);
        if (n > 1) {
            b = nodes[1];
            b.x = b.r;
            b.y = 0;
            bound(b);
            if (n > 2) {
                c = nodes[2];
                d3_layout_packPlace(a, b, c);
                bound(c);
                d3_layout_packInsert(a, c);
                a._pack_prev = c;
                d3_layout_packInsert(c, b);
                b = a._pack_next;
                for (i = 3; i < n; i++) {
                    d3_layout_packPlace(a, b, c = nodes[i]);
                    var isect = 0, s1 = 1, s2 = 1;
                    for (j = b._pack_next; j !== b; j = j._pack_next, s1++) {
                        if (d3_layout_packIntersects(j, c)) {
                            isect = 1;
                            break;
                        }
                    }
                    if (isect == 1) {
                        for (k = a._pack_prev; k !== j._pack_prev; k = k._pack_prev, s2++) {
                            if (d3_layout_packIntersects(k, c)) {
                                break;
                            }
                        }
                    }
                    if (isect) {
                        if (s1 < s2 || s1 == s2 && b.r < a.r) d3_layout_packSplice(a, b = j); else d3_layout_packSplice(a = k, b);
                        i--;
                    } else {
                        d3_layout_packInsert(a, c);
                        b = c;
                        bound(c);
                    }
                }
            }
        }
        var cx = (xMin + xMax) / 2, cy = (yMin + yMax) / 2, cr = 0;
        for (i = 0; i < n; i++) {
            c = nodes[i];
            c.x -= cx;
            c.y -= cy;
            cr = Math.max(cr, c.r + Math.sqrt(c.x * c.x + c.y * c.y));
        }
        node.r = cr;
        nodes.forEach(d3_layout_packUnlink);
    }
    function d3_layout_packLink(node) {
        node._pack_next = node._pack_prev = node;
    }
    function d3_layout_packUnlink(node) {
        delete node._pack_next;
        delete node._pack_prev;
    }
    function d3_layout_packTransform(node, x, y, k) {
        var children = node.children;
        node.x = x += k * node.x;
        node.y = y += k * node.y;
        node.r *= k;
        if (children) {
            var i = -1, n = children.length;
            while (++i < n) d3_layout_packTransform(children[i], x, y, k);
        }
    }
    function d3_layout_packPlace(a, b, c) {
        var db = a.r + c.r, dx = b.x - a.x, dy = b.y - a.y;
        if (db && (dx || dy)) {
            var da = b.r + c.r, dc = dx * dx + dy * dy;
            da *= da;
            db *= db;
            var x = .5 + (db - da) / (2 * dc), y = Math.sqrt(Math.max(0, 2 * da * (db + dc) - (db -= dc) * db - da * da)) / (2 * dc);
            c.x = a.x + x * dx + y * dy;
            c.y = a.y + x * dy - y * dx;
        } else {
            c.x = a.x + db;
            c.y = a.y;
        }
    }
    d3.layout.tree = function() {
        var hierarchy = d3.layout.hierarchy().sort(null).value(null), separation = d3_layout_treeSeparation, size = [ 1, 1 ], nodeSize = null;
        function tree(d, i) {
            var nodes = hierarchy.call(this, d, i), root0 = nodes[0], root1 = wrapTree(root0);
            d3_layout_hierarchyVisitAfter(root1, firstWalk), root1.parent.m = -root1.z;
            d3_layout_hierarchyVisitBefore(root1, secondWalk);
            if (nodeSize) d3_layout_hierarchyVisitBefore(root0, sizeNode); else {
                var left = root0, right = root0, bottom = root0;
                d3_layout_hierarchyVisitBefore(root0, function(node) {
                    if (node.x < left.x) left = node;
                    if (node.x > right.x) right = node;
                    if (node.depth > bottom.depth) bottom = node;
                });
                var tx = separation(left, right) / 2 - left.x, kx = size[0] / (right.x + separation(right, left) / 2 + tx), ky = size[1] / (bottom.depth || 1);
                d3_layout_hierarchyVisitBefore(root0, function(node) {
                    node.x = (node.x + tx) * kx;
                    node.y = node.depth * ky;
                });
            }
            return nodes;
        }
        function wrapTree(root0) {
            var root1 = {
                A: null,
                children: [ root0 ]
            }, queue = [ root1 ], node1;
            while ((node1 = queue.pop()) != null) {
                for (var children = node1.children, child, i = 0, n = children.length; i < n; ++i) {
                    queue.push((children[i] = child = {
                        _: children[i],
                        parent: node1,
                        children: (child = children[i].children) && child.slice() || [],
                        A: null,
                        a: null,
                        z: 0,
                        m: 0,
                        c: 0,
                        s: 0,
                        t: null,
                        i: i
                    }).a = child);
                }
            }
            return root1.children[0];
        }
        function firstWalk(v) {
            var children = v.children, siblings = v.parent.children, w = v.i ? siblings[v.i - 1] : null;
            if (children.length) {
                d3_layout_treeShift(v);
                var midpoint = (children[0].z + children[children.length - 1].z) / 2;
                if (w) {
                    v.z = w.z + separation(v._, w._);
                    v.m = v.z - midpoint;
                } else {
                    v.z = midpoint;
                }
            } else if (w) {
                v.z = w.z + separation(v._, w._);
            }
            v.parent.A = apportion(v, w, v.parent.A || siblings[0]);
        }
        function secondWalk(v) {
            v._.x = v.z + v.parent.m;
            v.m += v.parent.m;
        }
        function apportion(v, w, ancestor) {
            if (w) {
                var vip = v, vop = v, vim = w, vom = vip.parent.children[0], sip = vip.m, sop = vop.m, sim = vim.m, som = vom.m, shift;
                while (vim = d3_layout_treeRight(vim), vip = d3_layout_treeLeft(vip), vim && vip) {
                    vom = d3_layout_treeLeft(vom);
                    vop = d3_layout_treeRight(vop);
                    vop.a = v;
                    shift = vim.z + sim - vip.z - sip + separation(vim._, vip._);
                    if (shift > 0) {
                        d3_layout_treeMove(d3_layout_treeAncestor(vim, v, ancestor), v, shift);
                        sip += shift;
                        sop += shift;
                    }
                    sim += vim.m;
                    sip += vip.m;
                    som += vom.m;
                    sop += vop.m;
                }
                if (vim && !d3_layout_treeRight(vop)) {
                    vop.t = vim;
                    vop.m += sim - sop;
                }
                if (vip && !d3_layout_treeLeft(vom)) {
                    vom.t = vip;
                    vom.m += sip - som;
                    ancestor = v;
                }
            }
            return ancestor;
        }
        function sizeNode(node) {
            node.x *= size[0];
            node.y = node.depth * size[1];
        }
        tree.separation = function(x) {
            if (!arguments.length) return separation;
            separation = x;
            return tree;
        };
        tree.size = function(x) {
            if (!arguments.length) return nodeSize ? null : size;
            nodeSize = (size = x) == null ? sizeNode : null;
            return tree;
        };
        tree.nodeSize = function(x) {
            if (!arguments.length) return nodeSize ? size : null;
            nodeSize = (size = x) == null ? null : sizeNode;
            return tree;
        };
        return d3_layout_hierarchyRebind(tree, hierarchy);
    };
    function d3_layout_treeSeparation(a, b) {
        return a.parent == b.parent ? 1 : 2;
    }
    function d3_layout_treeLeft(v) {
        var children = v.children;
        return children.length ? children[0] : v.t;
    }
    function d3_layout_treeRight(v) {
        var children = v.children, n;
        return (n = children.length) ? children[n - 1] : v.t;
    }
    function d3_layout_treeMove(wm, wp, shift) {
        var change = shift / (wp.i - wm.i);
        wp.c -= change;
        wp.s += shift;
        wm.c += change;
        wp.z += shift;
        wp.m += shift;
    }
    function d3_layout_treeShift(v) {
        var shift = 0, change = 0, children = v.children, i = children.length, w;
        while (--i >= 0) {
            w = children[i];
            w.z += shift;
            w.m += shift;
            shift += w.s + (change += w.c);
        }
    }
    function d3_layout_treeAncestor(vim, v, ancestor) {
        return vim.a.parent === v.parent ? vim.a : ancestor;
    }
    d3.layout.cluster = function() {
        var hierarchy = d3.layout.hierarchy().sort(null).value(null), separation = d3_layout_treeSeparation, size = [ 1, 1 ], nodeSize = false;
        function cluster(d, i) {
            var nodes = hierarchy.call(this, d, i), root = nodes[0], previousNode, x = 0;
            d3_layout_hierarchyVisitAfter(root, function(node) {
                var children = node.children;
                if (children && children.length) {
                    node.x = d3_layout_clusterX(children);
                    node.y = d3_layout_clusterY(children);
                } else {
                    node.x = previousNode ? x += separation(node, previousNode) : 0;
                    node.y = 0;
                    previousNode = node;
                }
            });
            var left = d3_layout_clusterLeft(root), right = d3_layout_clusterRight(root), x0 = left.x - separation(left, right) / 2, x1 = right.x + separation(right, left) / 2;
            d3_layout_hierarchyVisitAfter(root, nodeSize ? function(node) {
                node.x = (node.x - root.x) * size[0];
                node.y = (root.y - node.y) * size[1];
            } : function(node) {
                node.x = (node.x - x0) / (x1 - x0) * size[0];
                node.y = (1 - (root.y ? node.y / root.y : 1)) * size[1];
            });
            return nodes;
        }
        cluster.separation = function(x) {
            if (!arguments.length) return separation;
            separation = x;
            return cluster;
        };
        cluster.size = function(x) {
            if (!arguments.length) return nodeSize ? null : size;
            nodeSize = (size = x) == null;
            return cluster;
        };
        cluster.nodeSize = function(x) {
            if (!arguments.length) return nodeSize ? size : null;
            nodeSize = (size = x) != null;
            return cluster;
        };
        return d3_layout_hierarchyRebind(cluster, hierarchy);
    };
    function d3_layout_clusterY(children) {
        return 1 + d3.max(children, function(child) {
            return child.y;
        });
    }
    function d3_layout_clusterX(children) {
        return children.reduce(function(x, child) {
            return x + child.x;
        }, 0) / children.length;
    }
    function d3_layout_clusterLeft(node) {
        var children = node.children;
        return children && children.length ? d3_layout_clusterLeft(children[0]) : node;
    }
    function d3_layout_clusterRight(node) {
        var children = node.children, n;
        return children && (n = children.length) ? d3_layout_clusterRight(children[n - 1]) : node;
    }
    d3.layout.treemap = function() {
        var hierarchy = d3.layout.hierarchy(), round = Math.round, size = [ 1, 1 ], padding = null, pad = d3_layout_treemapPadNull, sticky = false, stickies, mode = "squarify", ratio = .5 * (1 + Math.sqrt(5));
        function scale(children, k) {
            var i = -1, n = children.length, child, area;
            while (++i < n) {
                area = (child = children[i]).value * (k < 0 ? 0 : k);
                child.area = isNaN(area) || area <= 0 ? 0 : area;
            }
        }
        function squarify(node) {
            var children = node.children;
            if (children && children.length) {
                var rect = pad(node), row = [], remaining = children.slice(), child, best = Infinity, score, u = mode === "slice" ? rect.dx : mode === "dice" ? rect.dy : mode === "slice-dice" ? node.depth & 1 ? rect.dy : rect.dx : Math.min(rect.dx, rect.dy), n;
                scale(remaining, rect.dx * rect.dy / node.value);
                row.area = 0;
                while ((n = remaining.length) > 0) {
                    row.push(child = remaining[n - 1]);
                    row.area += child.area;
                    if (mode !== "squarify" || (score = worst(row, u)) <= best) {
                        remaining.pop();
                        best = score;
                    } else {
                        row.area -= row.pop().area;
                        position(row, u, rect, false);
                        u = Math.min(rect.dx, rect.dy);
                        row.length = row.area = 0;
                        best = Infinity;
                    }
                }
                if (row.length) {
                    position(row, u, rect, true);
                    row.length = row.area = 0;
                }
                children.forEach(squarify);
            }
        }
        function stickify(node) {
            var children = node.children;
            if (children && children.length) {
                var rect = pad(node), remaining = children.slice(), child, row = [];
                scale(remaining, rect.dx * rect.dy / node.value);
                row.area = 0;
                while (child = remaining.pop()) {
                    row.push(child);
                    row.area += child.area;
                    if (child.z != null) {
                        position(row, child.z ? rect.dx : rect.dy, rect, !remaining.length);
                        row.length = row.area = 0;
                    }
                }
                children.forEach(stickify);
            }
        }
        function worst(row, u) {
            var s = row.area, r, rmax = 0, rmin = Infinity, i = -1, n = row.length;
            while (++i < n) {
                if (!(r = row[i].area)) continue;
                if (r < rmin) rmin = r;
                if (r > rmax) rmax = r;
            }
            s *= s;
            u *= u;
            return s ? Math.max(u * rmax * ratio / s, s / (u * rmin * ratio)) : Infinity;
        }
        function position(row, u, rect, flush) {
            var i = -1, n = row.length, x = rect.x, y = rect.y, v = u ? round(row.area / u) : 0, o;
            if (u == rect.dx) {
                if (flush || v > rect.dy) v = rect.dy;
                while (++i < n) {
                    o = row[i];
                    o.x = x;
                    o.y = y;
                    o.dy = v;
                    x += o.dx = Math.min(rect.x + rect.dx - x, v ? round(o.area / v) : 0);
                }
                o.z = true;
                o.dx += rect.x + rect.dx - x;
                rect.y += v;
                rect.dy -= v;
            } else {
                if (flush || v > rect.dx) v = rect.dx;
                while (++i < n) {
                    o = row[i];
                    o.x = x;
                    o.y = y;
                    o.dx = v;
                    y += o.dy = Math.min(rect.y + rect.dy - y, v ? round(o.area / v) : 0);
                }
                o.z = false;
                o.dy += rect.y + rect.dy - y;
                rect.x += v;
                rect.dx -= v;
            }
        }
        function treemap(d) {
            var nodes = stickies || hierarchy(d), root = nodes[0];
            root.x = root.y = 0;
            if (root.value) root.dx = size[0], root.dy = size[1]; else root.dx = root.dy = 0;
            if (stickies) hierarchy.revalue(root);
            scale([ root ], root.dx * root.dy / root.value);
            (stickies ? stickify : squarify)(root);
            if (sticky) stickies = nodes;
            return nodes;
        }
        treemap.size = function(x) {
            if (!arguments.length) return size;
            size = x;
            return treemap;
        };
        treemap.padding = function(x) {
            if (!arguments.length) return padding;
            function padFunction(node) {
                var p = x.call(treemap, node, node.depth);
                return p == null ? d3_layout_treemapPadNull(node) : d3_layout_treemapPad(node, typeof p === "number" ? [ p, p, p, p ] : p);
            }
            function padConstant(node) {
                return d3_layout_treemapPad(node, x);
            }
            var type;
            pad = (padding = x) == null ? d3_layout_treemapPadNull : (type = typeof x) === "function" ? padFunction : type === "number" ? (x = [ x, x, x, x ], 
            padConstant) : padConstant;
            return treemap;
        };
        treemap.round = function(x) {
            if (!arguments.length) return round != Number;
            round = x ? Math.round : Number;
            return treemap;
        };
        treemap.sticky = function(x) {
            if (!arguments.length) return sticky;
            sticky = x;
            stickies = null;
            return treemap;
        };
        treemap.ratio = function(x) {
            if (!arguments.length) return ratio;
            ratio = x;
            return treemap;
        };
        treemap.mode = function(x) {
            if (!arguments.length) return mode;
            mode = x + "";
            return treemap;
        };
        return d3_layout_hierarchyRebind(treemap, hierarchy);
    };
    function d3_layout_treemapPadNull(node) {
        return {
            x: node.x,
            y: node.y,
            dx: node.dx,
            dy: node.dy
        };
    }
    function d3_layout_treemapPad(node, padding) {
        var x = node.x + padding[3], y = node.y + padding[0], dx = node.dx - padding[1] - padding[3], dy = node.dy - padding[0] - padding[2];
        if (dx < 0) {
            x += dx / 2;
            dx = 0;
        }
        if (dy < 0) {
            y += dy / 2;
            dy = 0;
        }
        return {
            x: x,
            y: y,
            dx: dx,
            dy: dy
        };
    }
    d3.random = {
        normal: function(Âµ, Ï) {
            var n = arguments.length;
            if (n < 2) Ï = 1;
            if (n < 1) Âµ = 0;
            return function() {
                var x, y, r;
                do {
                    x = Math.random() * 2 - 1;
                    y = Math.random() * 2 - 1;
                    r = x * x + y * y;
                } while (!r || r > 1);
                return Âµ + Ï * x * Math.sqrt(-2 * Math.log(r) / r);
            };
        },
        logNormal: function() {
            var random = d3.random.normal.apply(d3, arguments);
            return function() {
                return Math.exp(random());
            };
        },
        bates: function(m) {
            var random = d3.random.irwinHall(m);
            return function() {
                return random() / m;
            };
        },
        irwinHall: function(m) {
            return function() {
                for (var s = 0, j = 0; j < m; j++) s += Math.random();
                return s;
            };
        }
    };
    d3.scale = {};
    function d3_scaleExtent(domain) {
        var start = domain[0], stop = domain[domain.length - 1];
        return start < stop ? [ start, stop ] : [ stop, start ];
    }
    function d3_scaleRange(scale) {
        return scale.rangeExtent ? scale.rangeExtent() : d3_scaleExtent(scale.range());
    }
    function d3_scale_bilinear(domain, range, uninterpolate, interpolate) {
        var u = uninterpolate(domain[0], domain[1]), i = interpolate(range[0], range[1]);
        return function(x) {
            return i(u(x));
        };
    }
    function d3_scale_nice(domain, nice) {
        var i0 = 0, i1 = domain.length - 1, x0 = domain[i0], x1 = domain[i1], dx;
        if (x1 < x0) {
            dx = i0, i0 = i1, i1 = dx;
            dx = x0, x0 = x1, x1 = dx;
        }
        domain[i0] = nice.floor(x0);
        domain[i1] = nice.ceil(x1);
        return domain;
    }
    function d3_scale_niceStep(step) {
        return step ? {
            floor: function(x) {
                return Math.floor(x / step) * step;
            },
            ceil: function(x) {
                return Math.ceil(x / step) * step;
            }
        } : d3_scale_niceIdentity;
    }
    var d3_scale_niceIdentity = {
        floor: d3_identity,
        ceil: d3_identity
    };
    function d3_scale_polylinear(domain, range, uninterpolate, interpolate) {
        var u = [], i = [], j = 0, k = Math.min(domain.length, range.length) - 1;
        if (domain[k] < domain[0]) {
            domain = domain.slice().reverse();
            range = range.slice().reverse();
        }
        while (++j <= k) {
            u.push(uninterpolate(domain[j - 1], domain[j]));
            i.push(interpolate(range[j - 1], range[j]));
        }
        return function(x) {
            var j = d3.bisect(domain, x, 1, k) - 1;
            return i[j](u[j](x));
        };
    }
    d3.scale.linear = function() {
        return d3_scale_linear([ 0, 1 ], [ 0, 1 ], d3_interpolate, false);
    };
    function d3_scale_linear(domain, range, interpolate, clamp) {
        var output, input;
        function rescale() {
            var linear = Math.min(domain.length, range.length) > 2 ? d3_scale_polylinear : d3_scale_bilinear, uninterpolate = clamp ? d3_uninterpolateClamp : d3_uninterpolateNumber;
            output = linear(domain, range, uninterpolate, interpolate);
            input = linear(range, domain, uninterpolate, d3_interpolate);
            return scale;
        }
        function scale(x) {
            return output(x);
        }
        scale.invert = function(y) {
            return input(y);
        };
        scale.domain = function(x) {
            if (!arguments.length) return domain;
            domain = x.map(Number);
            return rescale();
        };
        scale.range = function(x) {
            if (!arguments.length) return range;
            range = x;
            return rescale();
        };
        scale.rangeRound = function(x) {
            return scale.range(x).interpolate(d3_interpolateRound);
        };
        scale.clamp = function(x) {
            if (!arguments.length) return clamp;
            clamp = x;
            return rescale();
        };
        scale.interpolate = function(x) {
            if (!arguments.length) return interpolate;
            interpolate = x;
            return rescale();
        };
        scale.ticks = function(m) {
            return d3_scale_linearTicks(domain, m);
        };
        scale.tickFormat = function(m, format) {
            return d3_scale_linearTickFormat(domain, m, format);
        };
        scale.nice = function(m) {
            d3_scale_linearNice(domain, m);
            return rescale();
        };
        scale.copy = function() {
            return d3_scale_linear(domain, range, interpolate, clamp);
        };
        return rescale();
    }
    function d3_scale_linearRebind(scale, linear) {
        return d3.rebind(scale, linear, "range", "rangeRound", "interpolate", "clamp");
    }
    function d3_scale_linearNice(domain, m) {
        d3_scale_nice(domain, d3_scale_niceStep(d3_scale_linearTickRange(domain, m)[2]));
        d3_scale_nice(domain, d3_scale_niceStep(d3_scale_linearTickRange(domain, m)[2]));
        return domain;
    }
    function d3_scale_linearTickRange(domain, m) {
        if (m == null) m = 10;
        var extent = d3_scaleExtent(domain), span = extent[1] - extent[0], step = Math.pow(10, Math.floor(Math.log(span / m) / Math.LN10)), err = m / span * step;
        if (err <= .15) step *= 10; else if (err <= .35) step *= 5; else if (err <= .75) step *= 2;
        extent[0] = Math.ceil(extent[0] / step) * step;
        extent[1] = Math.floor(extent[1] / step) * step + step * .5;
        extent[2] = step;
        return extent;
    }
    function d3_scale_linearTicks(domain, m) {
        return d3.range.apply(d3, d3_scale_linearTickRange(domain, m));
    }
    function d3_scale_linearTickFormat(domain, m, format) {
        var range = d3_scale_linearTickRange(domain, m);
        if (format) {
            var match = d3_format_re.exec(format);
            match.shift();
            if (match[8] === "s") {
                var prefix = d3.formatPrefix(Math.max(abs(range[0]), abs(range[1])));
                if (!match[7]) match[7] = "." + d3_scale_linearPrecision(prefix.scale(range[2]));
                match[8] = "f";
                format = d3.format(match.join(""));
                return function(d) {
                    return format(prefix.scale(d)) + prefix.symbol;
                };
            }
            if (!match[7]) match[7] = "." + d3_scale_linearFormatPrecision(match[8], range);
            format = match.join("");
        } else {
            format = ",." + d3_scale_linearPrecision(range[2]) + "f";
        }
        return d3.format(format);
    }
    var d3_scale_linearFormatSignificant = {
        s: 1,
        g: 1,
        p: 1,
        r: 1,
        e: 1
    };
    function d3_scale_linearPrecision(value) {
        return -Math.floor(Math.log(value) / Math.LN10 + .01);
    }
    function d3_scale_linearFormatPrecision(type, range) {
        var p = d3_scale_linearPrecision(range[2]);
        return type in d3_scale_linearFormatSignificant ? Math.abs(p - d3_scale_linearPrecision(Math.max(abs(range[0]), abs(range[1])))) + +(type !== "e") : p - (type === "%") * 2;
    }
    d3.scale.log = function() {
        return d3_scale_log(d3.scale.linear().domain([ 0, 1 ]), 10, true, [ 1, 10 ]);
    };
    function d3_scale_log(linear, base, positive, domain) {
        function log(x) {
            return (positive ? Math.log(x < 0 ? 0 : x) : -Math.log(x > 0 ? 0 : -x)) / Math.log(base);
        }
        function pow(x) {
            return positive ? Math.pow(base, x) : -Math.pow(base, -x);
        }
        function scale(x) {
            return linear(log(x));
        }
        scale.invert = function(x) {
            return pow(linear.invert(x));
        };
        scale.domain = function(x) {
            if (!arguments.length) return domain;
            positive = x[0] >= 0;
            linear.domain((domain = x.map(Number)).map(log));
            return scale;
        };
        scale.base = function(_) {
            if (!arguments.length) return base;
            base = +_;
            linear.domain(domain.map(log));
            return scale;
        };
        scale.nice = function() {
            var niced = d3_scale_nice(domain.map(log), positive ? Math : d3_scale_logNiceNegative);
            linear.domain(niced);
            domain = niced.map(pow);
            return scale;
        };
        scale.ticks = function() {
            var extent = d3_scaleExtent(domain), ticks = [], u = extent[0], v = extent[1], i = Math.floor(log(u)), j = Math.ceil(log(v)), n = base % 1 ? 2 : base;
            if (isFinite(j - i)) {
                if (positive) {
                    for (;i < j; i++) for (var k = 1; k < n; k++) ticks.push(pow(i) * k);
                    ticks.push(pow(i));
                } else {
                    ticks.push(pow(i));
                    for (;i++ < j; ) for (var k = n - 1; k > 0; k--) ticks.push(pow(i) * k);
                }
                for (i = 0; ticks[i] < u; i++) {}
                for (j = ticks.length; ticks[j - 1] > v; j--) {}
                ticks = ticks.slice(i, j);
            }
            return ticks;
        };
        scale.tickFormat = function(n, format) {
            if (!arguments.length) return d3_scale_logFormat;
            if (arguments.length < 2) format = d3_scale_logFormat; else if (typeof format !== "function") format = d3.format(format);
            var k = Math.max(1, base * n / scale.ticks().length);
            return function(d) {
                var i = d / pow(Math.round(log(d)));
                if (i * base < base - .5) i *= base;
                return i <= k ? format(d) : "";
            };
        };
        scale.copy = function() {
            return d3_scale_log(linear.copy(), base, positive, domain);
        };
        return d3_scale_linearRebind(scale, linear);
    }
    var d3_scale_logFormat = d3.format(".0e"), d3_scale_logNiceNegative = {
        floor: function(x) {
            return -Math.ceil(-x);
        },
        ceil: function(x) {
            return -Math.floor(-x);
        }
    };
    d3.scale.pow = function() {
        return d3_scale_pow(d3.scale.linear(), 1, [ 0, 1 ]);
    };
    function d3_scale_pow(linear, exponent, domain) {
        var powp = d3_scale_powPow(exponent), powb = d3_scale_powPow(1 / exponent);
        function scale(x) {
            return linear(powp(x));
        }
        scale.invert = function(x) {
            return powb(linear.invert(x));
        };
        scale.domain = function(x) {
            if (!arguments.length) return domain;
            linear.domain((domain = x.map(Number)).map(powp));
            return scale;
        };
        scale.ticks = function(m) {
            return d3_scale_linearTicks(domain, m);
        };
        scale.tickFormat = function(m, format) {
            return d3_scale_linearTickFormat(domain, m, format);
        };
        scale.nice = function(m) {
            return scale.domain(d3_scale_linearNice(domain, m));
        };
        scale.exponent = function(x) {
            if (!arguments.length) return exponent;
            powp = d3_scale_powPow(exponent = x);
            powb = d3_scale_powPow(1 / exponent);
            linear.domain(domain.map(powp));
            return scale;
        };
        scale.copy = function() {
            return d3_scale_pow(linear.copy(), exponent, domain);
        };
        return d3_scale_linearRebind(scale, linear);
    }
    function d3_scale_powPow(e) {
        return function(x) {
            return x < 0 ? -Math.pow(-x, e) : Math.pow(x, e);
        };
    }
    d3.scale.sqrt = function() {
        return d3.scale.pow().exponent(.5);
    };
    d3.scale.ordinal = function() {
        return d3_scale_ordinal([], {
            t: "range",
            a: [ [] ]
        });
    };
    function d3_scale_ordinal(domain, ranger) {
        var index, range, rangeBand;
        function scale(x) {
            return range[((index.get(x) || (ranger.t === "range" ? index.set(x, domain.push(x)) : NaN)) - 1) % range.length];
        }
        function steps(start, step) {
            return d3.range(domain.length).map(function(i) {
                return start + step * i;
            });
        }
        scale.domain = function(x) {
            if (!arguments.length) return domain;
            domain = [];
            index = new d3_Map();
            var i = -1, n = x.length, xi;
            while (++i < n) if (!index.has(xi = x[i])) index.set(xi, domain.push(xi));
            return scale[ranger.t].apply(scale, ranger.a);
        };
        scale.range = function(x) {
            if (!arguments.length) return range;
            range = x;
            rangeBand = 0;
            ranger = {
                t: "range",
                a: arguments
            };
            return scale;
        };
        scale.rangePoints = function(x, padding) {
            if (arguments.length < 2) padding = 0;
            var start = x[0], stop = x[1], step = domain.length < 2 ? (start = (start + stop) / 2, 
            0) : (stop - start) / (domain.length - 1 + padding);
            range = steps(start + step * padding / 2, step);
            rangeBand = 0;
            ranger = {
                t: "rangePoints",
                a: arguments
            };
            return scale;
        };
        scale.rangeRoundPoints = function(x, padding) {
            if (arguments.length < 2) padding = 0;
            var start = x[0], stop = x[1], step = domain.length < 2 ? (start = stop = Math.round((start + stop) / 2), 
            0) : (stop - start) / (domain.length - 1 + padding) | 0;
            range = steps(start + Math.round(step * padding / 2 + (stop - start - (domain.length - 1 + padding) * step) / 2), step);
            rangeBand = 0;
            ranger = {
                t: "rangeRoundPoints",
                a: arguments
            };
            return scale;
        };
        scale.rangeBands = function(x, padding, outerPadding) {
            if (arguments.length < 2) padding = 0;
            if (arguments.length < 3) outerPadding = padding;
            var reverse = x[1] < x[0], start = x[reverse - 0], stop = x[1 - reverse], step = (stop - start) / (domain.length - padding + 2 * outerPadding);
            range = steps(start + step * outerPadding, step);
            if (reverse) range.reverse();
            rangeBand = step * (1 - padding);
            ranger = {
                t: "rangeBands",
                a: arguments
            };
            return scale;
        };
        scale.rangeRoundBands = function(x, padding, outerPadding) {
            if (arguments.length < 2) padding = 0;
            if (arguments.length < 3) outerPadding = padding;
            var reverse = x[1] < x[0], start = x[reverse - 0], stop = x[1 - reverse], step = Math.floor((stop - start) / (domain.length - padding + 2 * outerPadding));
            range = steps(start + Math.round((stop - start - (domain.length - padding) * step) / 2), step);
            if (reverse) range.reverse();
            rangeBand = Math.round(step * (1 - padding));
            ranger = {
                t: "rangeRoundBands",
                a: arguments
            };
            return scale;
        };
        scale.rangeBand = function() {
            return rangeBand;
        };
        scale.rangeExtent = function() {
            return d3_scaleExtent(ranger.a[0]);
        };
        scale.copy = function() {
            return d3_scale_ordinal(domain, ranger);
        };
        return scale.domain(domain);
    }
    d3.scale.category10 = function() {
        return d3.scale.ordinal().range(d3_category10);
    };
    d3.scale.category20 = function() {
        return d3.scale.ordinal().range(d3_category20);
    };
    d3.scale.category20b = function() {
        return d3.scale.ordinal().range(d3_category20b);
    };
    d3.scale.category20c = function() {
        return d3.scale.ordinal().range(d3_category20c);
    };
    var d3_category10 = [ 2062260, 16744206, 2924588, 14034728, 9725885, 9197131, 14907330, 8355711, 12369186, 1556175 ].map(d3_rgbString);
    var d3_category20 = [ 2062260, 11454440, 16744206, 16759672, 2924588, 10018698, 14034728, 16750742, 9725885, 12955861, 9197131, 12885140, 14907330, 16234194, 8355711, 13092807, 12369186, 14408589, 1556175, 10410725 ].map(d3_rgbString);
    var d3_category20b = [ 3750777, 5395619, 7040719, 10264286, 6519097, 9216594, 11915115, 13556636, 9202993, 12426809, 15186514, 15190932, 8666169, 11356490, 14049643, 15177372, 8077683, 10834324, 13528509, 14589654 ].map(d3_rgbString);
    var d3_category20c = [ 3244733, 7057110, 10406625, 13032431, 15095053, 16616764, 16625259, 16634018, 3253076, 7652470, 10607003, 13101504, 7695281, 10394312, 12369372, 14342891, 6513507, 9868950, 12434877, 14277081 ].map(d3_rgbString);
    d3.scale.quantile = function() {
        return d3_scale_quantile([], []);
    };
    function d3_scale_quantile(domain, range) {
        var thresholds;
        function rescale() {
            var k = 0, q = range.length;
            thresholds = [];
            while (++k < q) thresholds[k - 1] = d3.quantile(domain, k / q);
            return scale;
        }
        function scale(x) {
            if (!isNaN(x = +x)) return range[d3.bisect(thresholds, x)];
        }
        scale.domain = function(x) {
            if (!arguments.length) return domain;
            domain = x.map(d3_number).filter(d3_numeric).sort(d3_ascending);
            return rescale();
        };
        scale.range = function(x) {
            if (!arguments.length) return range;
            range = x;
            return rescale();
        };
        scale.quantiles = function() {
            return thresholds;
        };
        scale.invertExtent = function(y) {
            y = range.indexOf(y);
            return y < 0 ? [ NaN, NaN ] : [ y > 0 ? thresholds[y - 1] : domain[0], y < thresholds.length ? thresholds[y] : domain[domain.length - 1] ];
        };
        scale.copy = function() {
            return d3_scale_quantile(domain, range);
        };
        return rescale();
    }
    d3.scale.quantize = function() {
        return d3_scale_quantize(0, 1, [ 0, 1 ]);
    };
    function d3_scale_quantize(x0, x1, range) {
        var kx, i;
        function scale(x) {
            return range[Math.max(0, Math.min(i, Math.floor(kx * (x - x0))))];
        }
        function rescale() {
            kx = range.length / (x1 - x0);
            i = range.length - 1;
            return scale;
        }
        scale.domain = function(x) {
            if (!arguments.length) return [ x0, x1 ];
            x0 = +x[0];
            x1 = +x[x.length - 1];
            return rescale();
        };
        scale.range = function(x) {
            if (!arguments.length) return range;
            range = x;
            return rescale();
        };
        scale.invertExtent = function(y) {
            y = range.indexOf(y);
            y = y < 0 ? NaN : y / kx + x0;
            return [ y, y + 1 / kx ];
        };
        scale.copy = function() {
            return d3_scale_quantize(x0, x1, range);
        };
        return rescale();
    }
    d3.scale.threshold = function() {
        return d3_scale_threshold([ .5 ], [ 0, 1 ]);
    };
    function d3_scale_threshold(domain, range) {
        function scale(x) {
            if (x <= x) return range[d3.bisect(domain, x)];
        }
        scale.domain = function(_) {
            if (!arguments.length) return domain;
            domain = _;
            return scale;
        };
        scale.range = function(_) {
            if (!arguments.length) return range;
            range = _;
            return scale;
        };
        scale.invertExtent = function(y) {
            y = range.indexOf(y);
            return [ domain[y - 1], domain[y] ];
        };
        scale.copy = function() {
            return d3_scale_threshold(domain, range);
        };
        return scale;
    }
    d3.scale.identity = function() {
        return d3_scale_identity([ 0, 1 ]);
    };
    function d3_scale_identity(domain) {
        function identity(x) {
            return +x;
        }
        identity.invert = identity;
        identity.domain = identity.range = function(x) {
            if (!arguments.length) return domain;
            domain = x.map(identity);
            return identity;
        };
        identity.ticks = function(m) {
            return d3_scale_linearTicks(domain, m);
        };
        identity.tickFormat = function(m, format) {
            return d3_scale_linearTickFormat(domain, m, format);
        };
        identity.copy = function() {
            return d3_scale_identity(domain);
        };
        return identity;
    }
    d3.svg = {};
    function d3_zero() {
        return 0;
    }
    d3.svg.arc = function() {
        var innerRadius = d3_svg_arcInnerRadius, outerRadius = d3_svg_arcOuterRadius, cornerRadius = d3_zero, padRadius = d3_svg_arcAuto, startAngle = d3_svg_arcStartAngle, endAngle = d3_svg_arcEndAngle, padAngle = d3_svg_arcPadAngle;
        function arc() {
            var r0 = Math.max(0, +innerRadius.apply(this, arguments)), r1 = Math.max(0, +outerRadius.apply(this, arguments)), a0 = startAngle.apply(this, arguments) - halfÏ, a1 = endAngle.apply(this, arguments) - halfÏ, da = Math.abs(a1 - a0), cw = a0 > a1 ? 0 : 1;
            if (r1 < r0) rc = r1, r1 = r0, r0 = rc;
            if (da >= ÏÎµ) return circleSegment(r1, cw) + (r0 ? circleSegment(r0, 1 - cw) : "") + "Z";
            var rc, cr, rp, ap, p0 = 0, p1 = 0, x0, y0, x1, y1, x2, y2, x3, y3, path = [];
            if (ap = (+padAngle.apply(this, arguments) || 0) / 2) {
                rp = padRadius === d3_svg_arcAuto ? Math.sqrt(r0 * r0 + r1 * r1) : +padRadius.apply(this, arguments);
                if (!cw) p1 *= -1;
                if (r1) p1 = d3_asin(rp / r1 * Math.sin(ap));
                if (r0) p0 = d3_asin(rp / r0 * Math.sin(ap));
            }
            if (r1) {
                x0 = r1 * Math.cos(a0 + p1);
                y0 = r1 * Math.sin(a0 + p1);
                x1 = r1 * Math.cos(a1 - p1);
                y1 = r1 * Math.sin(a1 - p1);
                var l1 = Math.abs(a1 - a0 - 2 * p1) <= Ï ? 0 : 1;
                if (p1 && d3_svg_arcSweep(x0, y0, x1, y1) === cw ^ l1) {
                    var h1 = (a0 + a1) / 2;
                    x0 = r1 * Math.cos(h1);
                    y0 = r1 * Math.sin(h1);
                    x1 = y1 = null;
                }
            } else {
                x0 = y0 = 0;
            }
            if (r0) {
                x2 = r0 * Math.cos(a1 - p0);
                y2 = r0 * Math.sin(a1 - p0);
                x3 = r0 * Math.cos(a0 + p0);
                y3 = r0 * Math.sin(a0 + p0);
                var l0 = Math.abs(a0 - a1 + 2 * p0) <= Ï ? 0 : 1;
                if (p0 && d3_svg_arcSweep(x2, y2, x3, y3) === 1 - cw ^ l0) {
                    var h0 = (a0 + a1) / 2;
                    x2 = r0 * Math.cos(h0);
                    y2 = r0 * Math.sin(h0);
                    x3 = y3 = null;
                }
            } else {
                x2 = y2 = 0;
            }
            if (da > Îµ && (rc = Math.min(Math.abs(r1 - r0) / 2, +cornerRadius.apply(this, arguments))) > .001) {
                cr = r0 < r1 ^ cw ? 0 : 1;
                var rc1 = rc, rc0 = rc;
                if (da < Ï) {
                    var oc = x3 == null ? [ x2, y2 ] : x1 == null ? [ x0, y0 ] : d3_geom_polygonIntersect([ x0, y0 ], [ x3, y3 ], [ x1, y1 ], [ x2, y2 ]), ax = x0 - oc[0], ay = y0 - oc[1], bx = x1 - oc[0], by = y1 - oc[1], kc = 1 / Math.sin(Math.acos((ax * bx + ay * by) / (Math.sqrt(ax * ax + ay * ay) * Math.sqrt(bx * bx + by * by))) / 2), lc = Math.sqrt(oc[0] * oc[0] + oc[1] * oc[1]);
                    rc0 = Math.min(rc, (r0 - lc) / (kc - 1));
                    rc1 = Math.min(rc, (r1 - lc) / (kc + 1));
                }
                if (x1 != null) {
                    var t30 = d3_svg_arcCornerTangents(x3 == null ? [ x2, y2 ] : [ x3, y3 ], [ x0, y0 ], r1, rc1, cw), t12 = d3_svg_arcCornerTangents([ x1, y1 ], [ x2, y2 ], r1, rc1, cw);
                    if (rc === rc1) {
                        path.push("M", t30[0], "A", rc1, ",", rc1, " 0 0,", cr, " ", t30[1], "A", r1, ",", r1, " 0 ", 1 - cw ^ d3_svg_arcSweep(t30[1][0], t30[1][1], t12[1][0], t12[1][1]), ",", cw, " ", t12[1], "A", rc1, ",", rc1, " 0 0,", cr, " ", t12[0]);
                    } else {
                        path.push("M", t30[0], "A", rc1, ",", rc1, " 0 1,", cr, " ", t12[0]);
                    }
                } else {
                    path.push("M", x0, ",", y0);
                }
                if (x3 != null) {
                    var t03 = d3_svg_arcCornerTangents([ x0, y0 ], [ x3, y3 ], r0, -rc0, cw), t21 = d3_svg_arcCornerTangents([ x2, y2 ], x1 == null ? [ x0, y0 ] : [ x1, y1 ], r0, -rc0, cw);
                    if (rc === rc0) {
                        path.push("L", t21[0], "A", rc0, ",", rc0, " 0 0,", cr, " ", t21[1], "A", r0, ",", r0, " 0 ", cw ^ d3_svg_arcSweep(t21[1][0], t21[1][1], t03[1][0], t03[1][1]), ",", 1 - cw, " ", t03[1], "A", rc0, ",", rc0, " 0 0,", cr, " ", t03[0]);
                    } else {
                        path.push("L", t21[0], "A", rc0, ",", rc0, " 0 0,", cr, " ", t03[0]);
                    }
                } else {
                    path.push("L", x2, ",", y2);
                }
            } else {
                path.push("M", x0, ",", y0);
                if (x1 != null) path.push("A", r1, ",", r1, " 0 ", l1, ",", cw, " ", x1, ",", y1);
                path.push("L", x2, ",", y2);
                if (x3 != null) path.push("A", r0, ",", r0, " 0 ", l0, ",", 1 - cw, " ", x3, ",", y3);
            }
            path.push("Z");
            return path.join("");
        }
        function circleSegment(r1, cw) {
            return "M0," + r1 + "A" + r1 + "," + r1 + " 0 1," + cw + " 0," + -r1 + "A" + r1 + "," + r1 + " 0 1," + cw + " 0," + r1;
        }
        arc.innerRadius = function(v) {
            if (!arguments.length) return innerRadius;
            innerRadius = d3_functor(v);
            return arc;
        };
        arc.outerRadius = function(v) {
            if (!arguments.length) return outerRadius;
            outerRadius = d3_functor(v);
            return arc;
        };
        arc.cornerRadius = function(v) {
            if (!arguments.length) return cornerRadius;
            cornerRadius = d3_functor(v);
            return arc;
        };
        arc.padRadius = function(v) {
            if (!arguments.length) return padRadius;
            padRadius = v == d3_svg_arcAuto ? d3_svg_arcAuto : d3_functor(v);
            return arc;
        };
        arc.startAngle = function(v) {
            if (!arguments.length) return startAngle;
            startAngle = d3_functor(v);
            return arc;
        };
        arc.endAngle = function(v) {
            if (!arguments.length) return endAngle;
            endAngle = d3_functor(v);
            return arc;
        };
        arc.padAngle = function(v) {
            if (!arguments.length) return padAngle;
            padAngle = d3_functor(v);
            return arc;
        };
        arc.centroid = function() {
            var r = (+innerRadius.apply(this, arguments) + +outerRadius.apply(this, arguments)) / 2, a = (+startAngle.apply(this, arguments) + +endAngle.apply(this, arguments)) / 2 - halfÏ;
            return [ Math.cos(a) * r, Math.sin(a) * r ];
        };
        return arc;
    };
    var d3_svg_arcAuto = "auto";
    function d3_svg_arcInnerRadius(d) {
        return d.innerRadius;
    }
    function d3_svg_arcOuterRadius(d) {
        return d.outerRadius;
    }
    function d3_svg_arcStartAngle(d) {
        return d.startAngle;
    }
    function d3_svg_arcEndAngle(d) {
        return d.endAngle;
    }
    function d3_svg_arcPadAngle(d) {
        return d && d.padAngle;
    }
    function d3_svg_arcSweep(x0, y0, x1, y1) {
        return (x0 - x1) * y0 - (y0 - y1) * x0 > 0 ? 0 : 1;
    }
    function d3_svg_arcCornerTangents(p0, p1, r1, rc, cw) {
        var x01 = p0[0] - p1[0], y01 = p0[1] - p1[1], lo = (cw ? rc : -rc) / Math.sqrt(x01 * x01 + y01 * y01), ox = lo * y01, oy = -lo * x01, x1 = p0[0] + ox, y1 = p0[1] + oy, x2 = p1[0] + ox, y2 = p1[1] + oy, x3 = (x1 + x2) / 2, y3 = (y1 + y2) / 2, dx = x2 - x1, dy = y2 - y1, d2 = dx * dx + dy * dy, r = r1 - rc, D = x1 * y2 - x2 * y1, d = (dy < 0 ? -1 : 1) * Math.sqrt(Math.max(0, r * r * d2 - D * D)), cx0 = (D * dy - dx * d) / d2, cy0 = (-D * dx - dy * d) / d2, cx1 = (D * dy + dx * d) / d2, cy1 = (-D * dx + dy * d) / d2, dx0 = cx0 - x3, dy0 = cy0 - y3, dx1 = cx1 - x3, dy1 = cy1 - y3;
        if (dx0 * dx0 + dy0 * dy0 > dx1 * dx1 + dy1 * dy1) cx0 = cx1, cy0 = cy1;
        return [ [ cx0 - ox, cy0 - oy ], [ cx0 * r1 / r, cy0 * r1 / r ] ];
    }
    function d3_svg_line(projection) {
        var x = d3_geom_pointX, y = d3_geom_pointY, defined = d3_true, interpolate = d3_svg_lineLinear, interpolateKey = interpolate.key, tension = .7;
        function line(data) {
            var segments = [], points = [], i = -1, n = data.length, d, fx = d3_functor(x), fy = d3_functor(y);
            function segment() {
                segments.push("M", interpolate(projection(points), tension));
            }
            while (++i < n) {
                if (defined.call(this, d = data[i], i)) {
                    points.push([ +fx.call(this, d, i), +fy.call(this, d, i) ]);
                } else if (points.length) {
                    segment();
                    points = [];
                }
            }
            if (points.length) segment();
            return segments.length ? segments.join("") : null;
        }
        line.x = function(_) {
            if (!arguments.length) return x;
            x = _;
            return line;
        };
        line.y = function(_) {
            if (!arguments.length) return y;
            y = _;
            return line;
        };
        line.defined = function(_) {
            if (!arguments.length) return defined;
            defined = _;
            return line;
        };
        line.interpolate = function(_) {
            if (!arguments.length) return interpolateKey;
            if (typeof _ === "function") interpolateKey = interpolate = _; else interpolateKey = (interpolate = d3_svg_lineInterpolators.get(_) || d3_svg_lineLinear).key;
            return line;
        };
        line.tension = function(_) {
            if (!arguments.length) return tension;
            tension = _;
            return line;
        };
        return line;
    }
    d3.svg.line = function() {
        return d3_svg_line(d3_identity);
    };
    var d3_svg_lineInterpolators = d3.map({
        linear: d3_svg_lineLinear,
        "linear-closed": d3_svg_lineLinearClosed,
        step: d3_svg_lineStep,
        "step-before": d3_svg_lineStepBefore,
        "step-after": d3_svg_lineStepAfter,
        basis: d3_svg_lineBasis,
        "basis-open": d3_svg_lineBasisOpen,
        "basis-closed": d3_svg_lineBasisClosed,
        bundle: d3_svg_lineBundle,
        cardinal: d3_svg_lineCardinal,
        "cardinal-open": d3_svg_lineCardinalOpen,
        "cardinal-closed": d3_svg_lineCardinalClosed,
        monotone: d3_svg_lineMonotone
    });
    d3_svg_lineInterpolators.forEach(function(key, value) {
        value.key = key;
        value.closed = /-closed$/.test(key);
    });
    function d3_svg_lineLinear(points) {
        return points.length > 1 ? points.join("L") : points + "Z";
    }
    function d3_svg_lineLinearClosed(points) {
        return points.join("L") + "Z";
    }
    function d3_svg_lineStep(points) {
        var i = 0, n = points.length, p = points[0], path = [ p[0], ",", p[1] ];
        while (++i < n) path.push("H", (p[0] + (p = points[i])[0]) / 2, "V", p[1]);
        if (n > 1) path.push("H", p[0]);
        return path.join("");
    }
    function d3_svg_lineStepBefore(points) {
        var i = 0, n = points.length, p = points[0], path = [ p[0], ",", p[1] ];
        while (++i < n) path.push("V", (p = points[i])[1], "H", p[0]);
        return path.join("");
    }
    function d3_svg_lineStepAfter(points) {
        var i = 0, n = points.length, p = points[0], path = [ p[0], ",", p[1] ];
        while (++i < n) path.push("H", (p = points[i])[0], "V", p[1]);
        return path.join("");
    }
    function d3_svg_lineCardinalOpen(points, tension) {
        return points.length < 4 ? d3_svg_lineLinear(points) : points[1] + d3_svg_lineHermite(points.slice(1, -1), d3_svg_lineCardinalTangents(points, tension));
    }
    function d3_svg_lineCardinalClosed(points, tension) {
        return points.length < 3 ? d3_svg_lineLinearClosed(points) : points[0] + d3_svg_lineHermite((points.push(points[0]), 
        points), d3_svg_lineCardinalTangents([ points[points.length - 2] ].concat(points, [ points[1] ]), tension));
    }
    function d3_svg_lineCardinal(points, tension) {
        return points.length < 3 ? d3_svg_lineLinear(points) : points[0] + d3_svg_lineHermite(points, d3_svg_lineCardinalTangents(points, tension));
    }
    function d3_svg_lineHermite(points, tangents) {
        if (tangents.length < 1 || points.length != tangents.length && points.length != tangents.length + 2) {
            return d3_svg_lineLinear(points);
        }
        var quad = points.length != tangents.length, path = "", p0 = points[0], p = points[1], t0 = tangents[0], t = t0, pi = 1;
        if (quad) {
            path += "Q" + (p[0] - t0[0] * 2 / 3) + "," + (p[1] - t0[1] * 2 / 3) + "," + p[0] + "," + p[1];
            p0 = points[1];
            pi = 2;
        }
        if (tangents.length > 1) {
            t = tangents[1];
            p = points[pi];
            pi++;
            path += "C" + (p0[0] + t0[0]) + "," + (p0[1] + t0[1]) + "," + (p[0] - t[0]) + "," + (p[1] - t[1]) + "," + p[0] + "," + p[1];
            for (var i = 2; i < tangents.length; i++, pi++) {
                p = points[pi];
                t = tangents[i];
                path += "S" + (p[0] - t[0]) + "," + (p[1] - t[1]) + "," + p[0] + "," + p[1];
            }
        }
        if (quad) {
            var lp = points[pi];
            path += "Q" + (p[0] + t[0] * 2 / 3) + "," + (p[1] + t[1] * 2 / 3) + "," + lp[0] + "," + lp[1];
        }
        return path;
    }
    function d3_svg_lineCardinalTangents(points, tension) {
        var tangents = [], a = (1 - tension) / 2, p0, p1 = points[0], p2 = points[1], i = 1, n = points.length;
        while (++i < n) {
            p0 = p1;
            p1 = p2;
            p2 = points[i];
            tangents.push([ a * (p2[0] - p0[0]), a * (p2[1] - p0[1]) ]);
        }
        return tangents;
    }
    function d3_svg_lineBasis(points) {
        if (points.length < 3) return d3_svg_lineLinear(points);
        var i = 1, n = points.length, pi = points[0], x0 = pi[0], y0 = pi[1], px = [ x0, x0, x0, (pi = points[1])[0] ], py = [ y0, y0, y0, pi[1] ], path = [ x0, ",", y0, "L", d3_svg_lineDot4(d3_svg_lineBasisBezier3, px), ",", d3_svg_lineDot4(d3_svg_lineBasisBezier3, py) ];
        points.push(points[n - 1]);
        while (++i <= n) {
            pi = points[i];
            px.shift();
            px.push(pi[0]);
            py.shift();
            py.push(pi[1]);
            d3_svg_lineBasisBezier(path, px, py);
        }
        points.pop();
        path.push("L", pi);
        return path.join("");
    }
    function d3_svg_lineBasisOpen(points) {
        if (points.length < 4) return d3_svg_lineLinear(points);
        var path = [], i = -1, n = points.length, pi, px = [ 0 ], py = [ 0 ];
        while (++i < 3) {
            pi = points[i];
            px.push(pi[0]);
            py.push(pi[1]);
        }
        path.push(d3_svg_lineDot4(d3_svg_lineBasisBezier3, px) + "," + d3_svg_lineDot4(d3_svg_lineBasisBezier3, py));
        --i;
        while (++i < n) {
            pi = points[i];
            px.shift();
            px.push(pi[0]);
            py.shift();
            py.push(pi[1]);
            d3_svg_lineBasisBezier(path, px, py);
        }
        return path.join("");
    }
    function d3_svg_lineBasisClosed(points) {
        var path, i = -1, n = points.length, m = n + 4, pi, px = [], py = [];
        while (++i < 4) {
            pi = points[i % n];
            px.push(pi[0]);
            py.push(pi[1]);
        }
        path = [ d3_svg_lineDot4(d3_svg_lineBasisBezier3, px), ",", d3_svg_lineDot4(d3_svg_lineBasisBezier3, py) ];
        --i;
        while (++i < m) {
            pi = points[i % n];
            px.shift();
            px.push(pi[0]);
            py.shift();
            py.push(pi[1]);
            d3_svg_lineBasisBezier(path, px, py);
        }
        return path.join("");
    }
    function d3_svg_lineBundle(points, tension) {
        var n = points.length - 1;
        if (n) {
            var x0 = points[0][0], y0 = points[0][1], dx = points[n][0] - x0, dy = points[n][1] - y0, i = -1, p, t;
            while (++i <= n) {
                p = points[i];
                t = i / n;
                p[0] = tension * p[0] + (1 - tension) * (x0 + t * dx);
                p[1] = tension * p[1] + (1 - tension) * (y0 + t * dy);
            }
        }
        return d3_svg_lineBasis(points);
    }
    function d3_svg_lineDot4(a, b) {
        return a[0] * b[0] + a[1] * b[1] + a[2] * b[2] + a[3] * b[3];
    }
    var d3_svg_lineBasisBezier1 = [ 0, 2 / 3, 1 / 3, 0 ], d3_svg_lineBasisBezier2 = [ 0, 1 / 3, 2 / 3, 0 ], d3_svg_lineBasisBezier3 = [ 0, 1 / 6, 2 / 3, 1 / 6 ];
    function d3_svg_lineBasisBezier(path, x, y) {
        path.push("C", d3_svg_lineDot4(d3_svg_lineBasisBezier1, x), ",", d3_svg_lineDot4(d3_svg_lineBasisBezier1, y), ",", d3_svg_lineDot4(d3_svg_lineBasisBezier2, x), ",", d3_svg_lineDot4(d3_svg_lineBasisBezier2, y), ",", d3_svg_lineDot4(d3_svg_lineBasisBezier3, x), ",", d3_svg_lineDot4(d3_svg_lineBasisBezier3, y));
    }
    function d3_svg_lineSlope(p0, p1) {
        return (p1[1] - p0[1]) / (p1[0] - p0[0]);
    }
    function d3_svg_lineFiniteDifferences(points) {
        var i = 0, j = points.length - 1, m = [], p0 = points[0], p1 = points[1], d = m[0] = d3_svg_lineSlope(p0, p1);
        while (++i < j) {
            m[i] = (d + (d = d3_svg_lineSlope(p0 = p1, p1 = points[i + 1]))) / 2;
        }
        m[i] = d;
        return m;
    }
    function d3_svg_lineMonotoneTangents(points) {
        var tangents = [], d, a, b, s, m = d3_svg_lineFiniteDifferences(points), i = -1, j = points.length - 1;
        while (++i < j) {
            d = d3_svg_lineSlope(points[i], points[i + 1]);
            if (abs(d) < Îµ) {
                m[i] = m[i + 1] = 0;
            } else {
                a = m[i] / d;
                b = m[i + 1] / d;
                s = a * a + b * b;
                if (s > 9) {
                    s = d * 3 / Math.sqrt(s);
                    m[i] = s * a;
                    m[i + 1] = s * b;
                }
            }
        }
        i = -1;
        while (++i <= j) {
            s = (points[Math.min(j, i + 1)][0] - points[Math.max(0, i - 1)][0]) / (6 * (1 + m[i] * m[i]));
            tangents.push([ s || 0, m[i] * s || 0 ]);
        }
        return tangents;
    }
    function d3_svg_lineMonotone(points) {
        return points.length < 3 ? d3_svg_lineLinear(points) : points[0] + d3_svg_lineHermite(points, d3_svg_lineMonotoneTangents(points));
    }
    d3.svg.line.radial = function() {
        var line = d3_svg_line(d3_svg_lineRadial);
        line.radius = line.x, delete line.x;
        line.angle = line.y, delete line.y;
        return line;
    };
    function d3_svg_lineRadial(points) {
        var point, i = -1, n = points.length, r, a;
        while (++i < n) {
            point = points[i];
            r = point[0];
            a = point[1] - halfÏ;
            point[0] = r * Math.cos(a);
            point[1] = r * Math.sin(a);
        }
        return points;
    }
    function d3_svg_area(projection) {
        var x0 = d3_geom_pointX, x1 = d3_geom_pointX, y0 = 0, y1 = d3_geom_pointY, defined = d3_true, interpolate = d3_svg_lineLinear, interpolateKey = interpolate.key, interpolateReverse = interpolate, L = "L", tension = .7;
        function area(data) {
            var segments = [], points0 = [], points1 = [], i = -1, n = data.length, d, fx0 = d3_functor(x0), fy0 = d3_functor(y0), fx1 = x0 === x1 ? function() {
                return x;
            } : d3_functor(x1), fy1 = y0 === y1 ? function() {
                return y;
            } : d3_functor(y1), x, y;
            function segment() {
                segments.push("M", interpolate(projection(points1), tension), L, interpolateReverse(projection(points0.reverse()), tension), "Z");
            }
            while (++i < n) {
                if (defined.call(this, d = data[i], i)) {
                    points0.push([ x = +fx0.call(this, d, i), y = +fy0.call(this, d, i) ]);
                    points1.push([ +fx1.call(this, d, i), +fy1.call(this, d, i) ]);
                } else if (points0.length) {
                    segment();
                    points0 = [];
                    points1 = [];
                }
            }
            if (points0.length) segment();
            return segments.length ? segments.join("") : null;
        }
        area.x = function(_) {
            if (!arguments.length) return x1;
            x0 = x1 = _;
            return area;
        };
        area.x0 = function(_) {
            if (!arguments.length) return x0;
            x0 = _;
            return area;
        };
        area.x1 = function(_) {
            if (!arguments.length) return x1;
            x1 = _;
            return area;
        };
        area.y = function(_) {
            if (!arguments.length) return y1;
            y0 = y1 = _;
            return area;
        };
        area.y0 = function(_) {
            if (!arguments.length) return y0;
            y0 = _;
            return area;
        };
        area.y1 = function(_) {
            if (!arguments.length) return y1;
            y1 = _;
            return area;
        };
        area.defined = function(_) {
            if (!arguments.length) return defined;
            defined = _;
            return area;
        };
        area.interpolate = function(_) {
            if (!arguments.length) return interpolateKey;
            if (typeof _ === "function") interpolateKey = interpolate = _; else interpolateKey = (interpolate = d3_svg_lineInterpolators.get(_) || d3_svg_lineLinear).key;
            interpolateReverse = interpolate.reverse || interpolate;
            L = interpolate.closed ? "M" : "L";
            return area;
        };
        area.tension = function(_) {
            if (!arguments.length) return tension;
            tension = _;
            return area;
        };
        return area;
    }
    d3_svg_lineStepBefore.reverse = d3_svg_lineStepAfter;
    d3_svg_lineStepAfter.reverse = d3_svg_lineStepBefore;
    d3.svg.area = function() {
        return d3_svg_area(d3_identity);
    };
    d3.svg.area.radial = function() {
        var area = d3_svg_area(d3_svg_lineRadial);
        area.radius = area.x, delete area.x;
        area.innerRadius = area.x0, delete area.x0;
        area.outerRadius = area.x1, delete area.x1;
        area.angle = area.y, delete area.y;
        area.startAngle = area.y0, delete area.y0;
        area.endAngle = area.y1, delete area.y1;
        return area;
    };
    d3.svg.chord = function() {
        var source = d3_source, target = d3_target, radius = d3_svg_chordRadius, startAngle = d3_svg_arcStartAngle, endAngle = d3_svg_arcEndAngle;
        function chord(d, i) {
            var s = subgroup(this, source, d, i), t = subgroup(this, target, d, i);
            return "M" + s.p0 + arc(s.r, s.p1, s.a1 - s.a0) + (equals(s, t) ? curve(s.r, s.p1, s.r, s.p0) : curve(s.r, s.p1, t.r, t.p0) + arc(t.r, t.p1, t.a1 - t.a0) + curve(t.r, t.p1, s.r, s.p0)) + "Z";
        }
        function subgroup(self, f, d, i) {
            var subgroup = f.call(self, d, i), r = radius.call(self, subgroup, i), a0 = startAngle.call(self, subgroup, i) - halfÏ, a1 = endAngle.call(self, subgroup, i) - halfÏ;
            return {
                r: r,
                a0: a0,
                a1: a1,
                p0: [ r * Math.cos(a0), r * Math.sin(a0) ],
                p1: [ r * Math.cos(a1), r * Math.sin(a1) ]
            };
        }
        function equals(a, b) {
            return a.a0 == b.a0 && a.a1 == b.a1;
        }
        function arc(r, p, a) {
            return "A" + r + "," + r + " 0 " + +(a > Ï) + ",1 " + p;
        }
        function curve(r0, p0, r1, p1) {
            return "Q 0,0 " + p1;
        }
        chord.radius = function(v) {
            if (!arguments.length) return radius;
            radius = d3_functor(v);
            return chord;
        };
        chord.source = function(v) {
            if (!arguments.length) return source;
            source = d3_functor(v);
            return chord;
        };
        chord.target = function(v) {
            if (!arguments.length) return target;
            target = d3_functor(v);
            return chord;
        };
        chord.startAngle = function(v) {
            if (!arguments.length) return startAngle;
            startAngle = d3_functor(v);
            return chord;
        };
        chord.endAngle = function(v) {
            if (!arguments.length) return endAngle;
            endAngle = d3_functor(v);
            return chord;
        };
        return chord;
    };
    function d3_svg_chordRadius(d) {
        return d.radius;
    }
    d3.svg.diagonal = function() {
        var source = d3_source, target = d3_target, projection = d3_svg_diagonalProjection;
        function diagonal(d, i) {
            var p0 = source.call(this, d, i), p3 = target.call(this, d, i), m = (p0.y + p3.y) / 2, p = [ p0, {
                x: p0.x,
                y: m
            }, {
                x: p3.x,
                y: m
            }, p3 ];
            p = p.map(projection);
            return "M" + p[0] + "C" + p[1] + " " + p[2] + " " + p[3];
        }
        diagonal.source = function(x) {
            if (!arguments.length) return source;
            source = d3_functor(x);
            return diagonal;
        };
        diagonal.target = function(x) {
            if (!arguments.length) return target;
            target = d3_functor(x);
            return diagonal;
        };
        diagonal.projection = function(x) {
            if (!arguments.length) return projection;
            projection = x;
            return diagonal;
        };
        return diagonal;
    };
    function d3_svg_diagonalProjection(d) {
        return [ d.x, d.y ];
    }
    d3.svg.diagonal.radial = function() {
        var diagonal = d3.svg.diagonal(), projection = d3_svg_diagonalProjection, projection_ = diagonal.projection;
        diagonal.projection = function(x) {
            return arguments.length ? projection_(d3_svg_diagonalRadialProjection(projection = x)) : projection;
        };
        return diagonal;
    };
    function d3_svg_diagonalRadialProjection(projection) {
        return function() {
            var d = projection.apply(this, arguments), r = d[0], a = d[1] - halfÏ;
            return [ r * Math.cos(a), r * Math.sin(a) ];
        };
    }
    d3.svg.symbol = function() {
        var type = d3_svg_symbolType, size = d3_svg_symbolSize;
        function symbol(d, i) {
            return (d3_svg_symbols.get(type.call(this, d, i)) || d3_svg_symbolCircle)(size.call(this, d, i));
        }
        symbol.type = function(x) {
            if (!arguments.length) return type;
            type = d3_functor(x);
            return symbol;
        };
        symbol.size = function(x) {
            if (!arguments.length) return size;
            size = d3_functor(x);
            return symbol;
        };
        return symbol;
    };
    function d3_svg_symbolSize() {
        return 64;
    }
    function d3_svg_symbolType() {
        return "circle";
    }
    function d3_svg_symbolCircle(size) {
        var r = Math.sqrt(size / Ï);
        return "M0," + r + "A" + r + "," + r + " 0 1,1 0," + -r + "A" + r + "," + r + " 0 1,1 0," + r + "Z";
    }
    var d3_svg_symbols = d3.map({
        circle: d3_svg_symbolCircle,
        cross: function(size) {
            var r = Math.sqrt(size / 5) / 2;
            return "M" + -3 * r + "," + -r + "H" + -r + "V" + -3 * r + "H" + r + "V" + -r + "H" + 3 * r + "V" + r + "H" + r + "V" + 3 * r + "H" + -r + "V" + r + "H" + -3 * r + "Z";
        },
        diamond: function(size) {
            var ry = Math.sqrt(size / (2 * d3_svg_symbolTan30)), rx = ry * d3_svg_symbolTan30;
            return "M0," + -ry + "L" + rx + ",0" + " 0," + ry + " " + -rx + ",0" + "Z";
        },
        square: function(size) {
            var r = Math.sqrt(size) / 2;
            return "M" + -r + "," + -r + "L" + r + "," + -r + " " + r + "," + r + " " + -r + "," + r + "Z";
        },
        "triangle-down": function(size) {
            var rx = Math.sqrt(size / d3_svg_symbolSqrt3), ry = rx * d3_svg_symbolSqrt3 / 2;
            return "M0," + ry + "L" + rx + "," + -ry + " " + -rx + "," + -ry + "Z";
        },
        "triangle-up": function(size) {
            var rx = Math.sqrt(size / d3_svg_symbolSqrt3), ry = rx * d3_svg_symbolSqrt3 / 2;
            return "M0," + -ry + "L" + rx + "," + ry + " " + -rx + "," + ry + "Z";
        }
    });
    d3.svg.symbolTypes = d3_svg_symbols.keys();
    var d3_svg_symbolSqrt3 = Math.sqrt(3), d3_svg_symbolTan30 = Math.tan(30 * d3_radians);
    d3_selectionPrototype.transition = function(name) {
        var id = d3_transitionInheritId || ++d3_transitionId, ns = d3_transitionNamespace(name), subgroups = [], subgroup, node, transition = d3_transitionInherit || {
            time: Date.now(),
            ease: d3_ease_cubicInOut,
            delay: 0,
            duration: 250
        };
        for (var j = -1, m = this.length; ++j < m; ) {
            subgroups.push(subgroup = []);
            for (var group = this[j], i = -1, n = group.length; ++i < n; ) {
                if (node = group[i]) d3_transitionNode(node, i, ns, id, transition);
                subgroup.push(node);
            }
        }
        return d3_transition(subgroups, ns, id);
    };
    d3_selectionPrototype.interrupt = function(name) {
        return this.each(name == null ? d3_selection_interrupt : d3_selection_interruptNS(d3_transitionNamespace(name)));
    };
    var d3_selection_interrupt = d3_selection_interruptNS(d3_transitionNamespace());
    function d3_selection_interruptNS(ns) {
        return function() {
            var lock, activeId, active;
            if ((lock = this[ns]) && (active = lock[activeId = lock.active])) {
                active.timer.c = null;
                active.timer.t = NaN;
                if (--lock.count) delete lock[activeId]; else delete this[ns];
                lock.active += .5;
                active.event && active.event.interrupt.call(this, this.__data__, active.index);
            }
        };
    }
    function d3_transition(groups, ns, id) {
        d3_subclass(groups, d3_transitionPrototype);
        groups.namespace = ns;
        groups.id = id;
        return groups;
    }
    var d3_transitionPrototype = [], d3_transitionId = 0, d3_transitionInheritId, d3_transitionInherit;
    d3_transitionPrototype.call = d3_selectionPrototype.call;
    d3_transitionPrototype.empty = d3_selectionPrototype.empty;
    d3_transitionPrototype.node = d3_selectionPrototype.node;
    d3_transitionPrototype.size = d3_selectionPrototype.size;
    d3.transition = function(selection, name) {
        return selection && selection.transition ? d3_transitionInheritId ? selection.transition(name) : selection : d3.selection().transition(selection);
    };
    d3.transition.prototype = d3_transitionPrototype;
    d3_transitionPrototype.select = function(selector) {
        var id = this.id, ns = this.namespace, subgroups = [], subgroup, subnode, node;
        selector = d3_selection_selector(selector);
        for (var j = -1, m = this.length; ++j < m; ) {
            subgroups.push(subgroup = []);
            for (var group = this[j], i = -1, n = group.length; ++i < n; ) {
                if ((node = group[i]) && (subnode = selector.call(node, node.__data__, i, j))) {
                    if ("__data__" in node) subnode.__data__ = node.__data__;
                    d3_transitionNode(subnode, i, ns, id, node[ns][id]);
                    subgroup.push(subnode);
                } else {
                    subgroup.push(null);
                }
            }
        }
        return d3_transition(subgroups, ns, id);
    };
    d3_transitionPrototype.selectAll = function(selector) {
        var id = this.id, ns = this.namespace, subgroups = [], subgroup, subnodes, node, subnode, transition;
        selector = d3_selection_selectorAll(selector);
        for (var j = -1, m = this.length; ++j < m; ) {
            for (var group = this[j], i = -1, n = group.length; ++i < n; ) {
                if (node = group[i]) {
                    transition = node[ns][id];
                    subnodes = selector.call(node, node.__data__, i, j);
                    subgroups.push(subgroup = []);
                    for (var k = -1, o = subnodes.length; ++k < o; ) {
                        if (subnode = subnodes[k]) d3_transitionNode(subnode, k, ns, id, transition);
                        subgroup.push(subnode);
                    }
                }
            }
        }
        return d3_transition(subgroups, ns, id);
    };
    d3_transitionPrototype.filter = function(filter) {
        var subgroups = [], subgroup, group, node;
        if (typeof filter !== "function") filter = d3_selection_filter(filter);
        for (var j = 0, m = this.length; j < m; j++) {
            subgroups.push(subgroup = []);
            for (var group = this[j], i = 0, n = group.length; i < n; i++) {
                if ((node = group[i]) && filter.call(node, node.__data__, i, j)) {
                    subgroup.push(node);
                }
            }
        }
        return d3_transition(subgroups, this.namespace, this.id);
    };
    d3_transitionPrototype.tween = function(name, tween) {
        var id = this.id, ns = this.namespace;
        if (arguments.length < 2) return this.node()[ns][id].tween.get(name);
        return d3_selection_each(this, tween == null ? function(node) {
            node[ns][id].tween.remove(name);
        } : function(node) {
            node[ns][id].tween.set(name, tween);
        });
    };
    function d3_transition_tween(groups, name, value, tween) {
        var id = groups.id, ns = groups.namespace;
        return d3_selection_each(groups, typeof value === "function" ? function(node, i, j) {
            node[ns][id].tween.set(name, tween(value.call(node, node.__data__, i, j)));
        } : (value = tween(value), function(node) {
            node[ns][id].tween.set(name, value);
        }));
    }
    d3_transitionPrototype.attr = function(nameNS, value) {
        if (arguments.length < 2) {
            for (value in nameNS) this.attr(value, nameNS[value]);
            return this;
        }
        var interpolate = nameNS == "transform" ? d3_interpolateTransform : d3_interpolate, name = d3.ns.qualify(nameNS);
        function attrNull() {
            this.removeAttribute(name);
        }
        function attrNullNS() {
            this.removeAttributeNS(name.space, name.local);
        }
        function attrTween(b) {
            return b == null ? attrNull : (b += "", function() {
                var a = this.getAttribute(name), i;
                return a !== b && (i = interpolate(a, b), function(t) {
                    this.setAttribute(name, i(t));
                });
            });
        }
        function attrTweenNS(b) {
            return b == null ? attrNullNS : (b += "", function() {
                var a = this.getAttributeNS(name.space, name.local), i;
                return a !== b && (i = interpolate(a, b), function(t) {
                    this.setAttributeNS(name.space, name.local, i(t));
                });
            });
        }
        return d3_transition_tween(this, "attr." + nameNS, value, name.local ? attrTweenNS : attrTween);
    };
    d3_transitionPrototype.attrTween = function(nameNS, tween) {
        var name = d3.ns.qualify(nameNS);
        function attrTween(d, i) {
            var f = tween.call(this, d, i, this.getAttribute(name));
            return f && function(t) {
                this.setAttribute(name, f(t));
            };
        }
        function attrTweenNS(d, i) {
            var f = tween.call(this, d, i, this.getAttributeNS(name.space, name.local));
            return f && function(t) {
                this.setAttributeNS(name.space, name.local, f(t));
            };
        }
        return this.tween("attr." + nameNS, name.local ? attrTweenNS : attrTween);
    };
    d3_transitionPrototype.style = function(name, value, priority) {
        var n = arguments.length;
        if (n < 3) {
            if (typeof name !== "string") {
                if (n < 2) value = "";
                for (priority in name) this.style(priority, name[priority], value);
                return this;
            }
            priority = "";
        }
        function styleNull() {
            this.style.removeProperty(name);
        }
        function styleString(b) {
            return b == null ? styleNull : (b += "", function() {
                var a = d3_window(this).getComputedStyle(this, null).getPropertyValue(name), i;
                return a !== b && (i = d3_interpolate(a, b), function(t) {
                    this.style.setProperty(name, i(t), priority);
                });
            });
        }
        return d3_transition_tween(this, "style." + name, value, styleString);
    };
    d3_transitionPrototype.styleTween = function(name, tween, priority) {
        if (arguments.length < 3) priority = "";
        function styleTween(d, i) {
            var f = tween.call(this, d, i, d3_window(this).getComputedStyle(this, null).getPropertyValue(name));
            return f && function(t) {
                this.style.setProperty(name, f(t), priority);
            };
        }
        return this.tween("style." + name, styleTween);
    };
    d3_transitionPrototype.text = function(value) {
        return d3_transition_tween(this, "text", value, d3_transition_text);
    };
    function d3_transition_text(b) {
        if (b == null) b = "";
        return function() {
            this.textContent = b;
        };
    }
    d3_transitionPrototype.remove = function() {
        var ns = this.namespace;
        return this.each("end.transition", function() {
            var p;
            if (this[ns].count < 2 && (p = this.parentNode)) p.removeChild(this);
        });
    };
    d3_transitionPrototype.ease = function(value) {
        var id = this.id, ns = this.namespace;
        if (arguments.length < 1) return this.node()[ns][id].ease;
        if (typeof value !== "function") value = d3.ease.apply(d3, arguments);
        return d3_selection_each(this, function(node) {
            node[ns][id].ease = value;
        });
    };
    d3_transitionPrototype.delay = function(value) {
        var id = this.id, ns = this.namespace;
        if (arguments.length < 1) return this.node()[ns][id].delay;
        return d3_selection_each(this, typeof value === "function" ? function(node, i, j) {
            node[ns][id].delay = +value.call(node, node.__data__, i, j);
        } : (value = +value, function(node) {
            node[ns][id].delay = value;
        }));
    };
    d3_transitionPrototype.duration = function(value) {
        var id = this.id, ns = this.namespace;
        if (arguments.length < 1) return this.node()[ns][id].duration;
        return d3_selection_each(this, typeof value === "function" ? function(node, i, j) {
            node[ns][id].duration = Math.max(1, value.call(node, node.__data__, i, j));
        } : (value = Math.max(1, value), function(node) {
            node[ns][id].duration = value;
        }));
    };
    d3_transitionPrototype.each = function(type, listener) {
        var id = this.id, ns = this.namespace;
        if (arguments.length < 2) {
            var inherit = d3_transitionInherit, inheritId = d3_transitionInheritId;
            try {
                d3_transitionInheritId = id;
                d3_selection_each(this, function(node, i, j) {
                    d3_transitionInherit = node[ns][id];
                    type.call(node, node.__data__, i, j);
                });
            } finally {
                d3_transitionInherit = inherit;
                d3_transitionInheritId = inheritId;
            }
        } else {
            d3_selection_each(this, function(node) {
                var transition = node[ns][id];
                (transition.event || (transition.event = d3.dispatch("start", "end", "interrupt"))).on(type, listener);
            });
        }
        return this;
    };
    d3_transitionPrototype.transition = function() {
        var id0 = this.id, id1 = ++d3_transitionId, ns = this.namespace, subgroups = [], subgroup, group, node, transition;
        for (var j = 0, m = this.length; j < m; j++) {
            subgroups.push(subgroup = []);
            for (var group = this[j], i = 0, n = group.length; i < n; i++) {
                if (node = group[i]) {
                    transition = node[ns][id0];
                    d3_transitionNode(node, i, ns, id1, {
                        time: transition.time,
                        ease: transition.ease,
                        delay: transition.delay + transition.duration,
                        duration: transition.duration
                    });
                }
                subgroup.push(node);
            }
        }
        return d3_transition(subgroups, ns, id1);
    };
    function d3_transitionNamespace(name) {
        return name == null ? "__transition__" : "__transition_" + name + "__";
    }
    function d3_transitionNode(node, i, ns, id, inherit) {
        var lock = node[ns] || (node[ns] = {
            active: 0,
            count: 0
        }), transition = lock[id], time, timer, duration, ease, tweens;
        function schedule(elapsed) {
            var delay = transition.delay;
            timer.t = delay + time;
            if (delay <= elapsed) return start(elapsed - delay);
            timer.c = start;
        }
        function start(elapsed) {
            var activeId = lock.active, active = lock[activeId];
            if (active) {
                active.timer.c = null;
                active.timer.t = NaN;
                --lock.count;
                delete lock[activeId];
                active.event && active.event.interrupt.call(node, node.__data__, active.index);
            }
            for (var cancelId in lock) {
                if (+cancelId < id) {
                    var cancel = lock[cancelId];
                    cancel.timer.c = null;
                    cancel.timer.t = NaN;
                    --lock.count;
                    delete lock[cancelId];
                }
            }
            timer.c = tick;
            d3_timer(function() {
                if (timer.c && tick(elapsed || 1)) {
                    timer.c = null;
                    timer.t = NaN;
                }
                return 1;
            }, 0, time);
            lock.active = id;
            transition.event && transition.event.start.call(node, node.__data__, i);
            tweens = [];
            transition.tween.forEach(function(key, value) {
                if (value = value.call(node, node.__data__, i)) {
                    tweens.push(value);
                }
            });
            ease = transition.ease;
            duration = transition.duration;
        }
        function tick(elapsed) {
            var t = elapsed / duration, e = ease(t), n = tweens.length;
            while (n > 0) {
                tweens[--n].call(node, e);
            }
            if (t >= 1) {
                transition.event && transition.event.end.call(node, node.__data__, i);
                if (--lock.count) delete lock[id]; else delete node[ns];
                return 1;
            }
        }
        if (!transition) {
            time = inherit.time;
            timer = d3_timer(schedule, 0, time);
            transition = lock[id] = {
                tween: new d3_Map(),
                time: time,
                timer: timer,
                delay: inherit.delay,
                duration: inherit.duration,
                ease: inherit.ease,
                index: i
            };
            inherit = null;
            ++lock.count;
        }
    }
    d3.svg.axis = function() {
        var scale = d3.scale.linear(), orient = d3_svg_axisDefaultOrient, innerTickSize = 6, outerTickSize = 6, tickPadding = 3, tickArguments_ = [ 10 ], tickValues = null, tickFormat_;
        function axis(g) {
            g.each(function() {
                var g = d3.select(this);
                var scale0 = this.__chart__ || scale, scale1 = this.__chart__ = scale.copy();
                var ticks = tickValues == null ? scale1.ticks ? scale1.ticks.apply(scale1, tickArguments_) : scale1.domain() : tickValues, tickFormat = tickFormat_ == null ? scale1.tickFormat ? scale1.tickFormat.apply(scale1, tickArguments_) : d3_identity : tickFormat_, tick = g.selectAll(".tick").data(ticks, scale1), tickEnter = tick.enter().insert("g", ".domain").attr("class", "tick").style("opacity", Îµ), tickExit = d3.transition(tick.exit()).style("opacity", Îµ).remove(), tickUpdate = d3.transition(tick.order()).style("opacity", 1), tickSpacing = Math.max(innerTickSize, 0) + tickPadding, tickTransform;
                var range = d3_scaleRange(scale1), path = g.selectAll(".domain").data([ 0 ]), pathUpdate = (path.enter().append("path").attr("class", "domain"), 
                d3.transition(path));
                tickEnter.append("line");
                tickEnter.append("text");
                var lineEnter = tickEnter.select("line"), lineUpdate = tickUpdate.select("line"), text = tick.select("text").text(tickFormat), textEnter = tickEnter.select("text"), textUpdate = tickUpdate.select("text"), sign = orient === "top" || orient === "left" ? -1 : 1, x1, x2, y1, y2;
                if (orient === "bottom" || orient === "top") {
                    tickTransform = d3_svg_axisX, x1 = "x", y1 = "y", x2 = "x2", y2 = "y2";
                    text.attr("dy", sign < 0 ? "0em" : ".71em").style("text-anchor", "middle");
                    pathUpdate.attr("d", "M" + range[0] + "," + sign * outerTickSize + "V0H" + range[1] + "V" + sign * outerTickSize);
                } else {
                    tickTransform = d3_svg_axisY, x1 = "y", y1 = "x", x2 = "y2", y2 = "x2";
                    text.attr("dy", ".32em").style("text-anchor", sign < 0 ? "end" : "start");
                    pathUpdate.attr("d", "M" + sign * outerTickSize + "," + range[0] + "H0V" + range[1] + "H" + sign * outerTickSize);
                }
                lineEnter.attr(y2, sign * innerTickSize);
                textEnter.attr(y1, sign * tickSpacing);
                lineUpdate.attr(x2, 0).attr(y2, sign * innerTickSize);
                textUpdate.attr(x1, 0).attr(y1, sign * tickSpacing);
                if (scale1.rangeBand) {
                    var x = scale1, dx = x.rangeBand() / 2;
                    scale0 = scale1 = function(d) {
                        return x(d) + dx;
                    };
                } else if (scale0.rangeBand) {
                    scale0 = scale1;
                } else {
                    tickExit.call(tickTransform, scale1, scale0);
                }
                tickEnter.call(tickTransform, scale0, scale1);
                tickUpdate.call(tickTransform, scale1, scale1);
            });
        }
        axis.scale = function(x) {
            if (!arguments.length) return scale;
            scale = x;
            return axis;
        };
        axis.orient = function(x) {
            if (!arguments.length) return orient;
            orient = x in d3_svg_axisOrients ? x + "" : d3_svg_axisDefaultOrient;
            return axis;
        };
        axis.ticks = function() {
            if (!arguments.length) return tickArguments_;
            tickArguments_ = d3_array(arguments);
            return axis;
        };
        axis.tickValues = function(x) {
            if (!arguments.length) return tickValues;
            tickValues = x;
            return axis;
        };
        axis.tickFormat = function(x) {
            if (!arguments.length) return tickFormat_;
            tickFormat_ = x;
            return axis;
        };
        axis.tickSize = function(x) {
            var n = arguments.length;
            if (!n) return innerTickSize;
            innerTickSize = +x;
            outerTickSize = +arguments[n - 1];
            return axis;
        };
        axis.innerTickSize = function(x) {
            if (!arguments.length) return innerTickSize;
            innerTickSize = +x;
            return axis;
        };
        axis.outerTickSize = function(x) {
            if (!arguments.length) return outerTickSize;
            outerTickSize = +x;
            return axis;
        };
        axis.tickPadding = function(x) {
            if (!arguments.length) return tickPadding;
            tickPadding = +x;
            return axis;
        };
        axis.tickSubdivide = function() {
            return arguments.length && axis;
        };
        return axis;
    };
    var d3_svg_axisDefaultOrient = "bottom", d3_svg_axisOrients = {
        top: 1,
        right: 1,
        bottom: 1,
        left: 1
    };
    function d3_svg_axisX(selection, x0, x1) {
        selection.attr("transform", function(d) {
            var v0 = x0(d);
            return "translate(" + (isFinite(v0) ? v0 : x1(d)) + ",0)";
        });
    }
    function d3_svg_axisY(selection, y0, y1) {
        selection.attr("transform", function(d) {
            var v0 = y0(d);
            return "translate(0," + (isFinite(v0) ? v0 : y1(d)) + ")";
        });
    }
    d3.svg.brush = function() {
        var event = d3_eventDispatch(brush, "brushstart", "brush", "brushend"), x = null, y = null, xExtent = [ 0, 0 ], yExtent = [ 0, 0 ], xExtentDomain, yExtentDomain, xClamp = true, yClamp = true, resizes = d3_svg_brushResizes[0];
        function brush(g) {
            g.each(function() {
                var g = d3.select(this).style("pointer-events", "all").style("-webkit-tap-highlight-color", "rgba(0,0,0,0)").on("mousedown.brush", brushstart).on("touchstart.brush", brushstart);
                var background = g.selectAll(".background").data([ 0 ]);
                background.enter().append("rect").attr("class", "background").style("visibility", "hidden").style("cursor", "crosshair");
                g.selectAll(".extent").data([ 0 ]).enter().append("rect").attr("class", "extent").style("cursor", "move");
                var resize = g.selectAll(".resize").data(resizes, d3_identity);
                resize.exit().remove();
                resize.enter().append("g").attr("class", function(d) {
                    return "resize " + d;
                }).style("cursor", function(d) {
                    return d3_svg_brushCursor[d];
                }).append("rect").attr("x", function(d) {
                    return /[ew]$/.test(d) ? -3 : null;
                }).attr("y", function(d) {
                    return /^[ns]/.test(d) ? -3 : null;
                }).attr("width", 6).attr("height", 6).style("visibility", "hidden");
                resize.style("display", brush.empty() ? "none" : null);
                var gUpdate = d3.transition(g), backgroundUpdate = d3.transition(background), range;
                if (x) {
                    range = d3_scaleRange(x);
                    backgroundUpdate.attr("x", range[0]).attr("width", range[1] - range[0]);
                    redrawX(gUpdate);
                }
                if (y) {
                    range = d3_scaleRange(y);
                    backgroundUpdate.attr("y", range[0]).attr("height", range[1] - range[0]);
                    redrawY(gUpdate);
                }
                redraw(gUpdate);
            });
        }
        brush.event = function(g) {
            g.each(function() {
                var event_ = event.of(this, arguments), extent1 = {
                    x: xExtent,
                    y: yExtent,
                    i: xExtentDomain,
                    j: yExtentDomain
                }, extent0 = this.__chart__ || extent1;
                this.__chart__ = extent1;
                if (d3_transitionInheritId) {
                    d3.select(this).transition().each("start.brush", function() {
                        xExtentDomain = extent0.i;
                        yExtentDomain = extent0.j;
                        xExtent = extent0.x;
                        yExtent = extent0.y;
                        event_({
                            type: "brushstart"
                        });
                    }).tween("brush:brush", function() {
                        var xi = d3_interpolateArray(xExtent, extent1.x), yi = d3_interpolateArray(yExtent, extent1.y);
                        xExtentDomain = yExtentDomain = null;
                        return function(t) {
                            xExtent = extent1.x = xi(t);
                            yExtent = extent1.y = yi(t);
                            event_({
                                type: "brush",
                                mode: "resize"
                            });
                        };
                    }).each("end.brush", function() {
                        xExtentDomain = extent1.i;
                        yExtentDomain = extent1.j;
                        event_({
                            type: "brush",
                            mode: "resize"
                        });
                        event_({
                            type: "brushend"
                        });
                    });
                } else {
                    event_({
                        type: "brushstart"
                    });
                    event_({
                        type: "brush",
                        mode: "resize"
                    });
                    event_({
                        type: "brushend"
                    });
                }
            });
        };
        function redraw(g) {
            g.selectAll(".resize").attr("transform", function(d) {
                return "translate(" + xExtent[+/e$/.test(d)] + "," + yExtent[+/^s/.test(d)] + ")";
            });
        }
        function redrawX(g) {
            g.select(".extent").attr("x", xExtent[0]);
            g.selectAll(".extent,.n>rect,.s>rect").attr("width", xExtent[1] - xExtent[0]);
        }
        function redrawY(g) {
            g.select(".extent").attr("y", yExtent[0]);
            g.selectAll(".extent,.e>rect,.w>rect").attr("height", yExtent[1] - yExtent[0]);
        }
        function brushstart() {
            var target = this, eventTarget = d3.select(d3.event.target), event_ = event.of(target, arguments), g = d3.select(target), resizing = eventTarget.datum(), resizingX = !/^(n|s)$/.test(resizing) && x, resizingY = !/^(e|w)$/.test(resizing) && y, dragging = eventTarget.classed("extent"), dragRestore = d3_event_dragSuppress(target), center, origin = d3.mouse(target), offset;
            var w = d3.select(d3_window(target)).on("keydown.brush", keydown).on("keyup.brush", keyup);
            if (d3.event.changedTouches) {
                w.on("touchmove.brush", brushmove).on("touchend.brush", brushend);
            } else {
                w.on("mousemove.brush", brushmove).on("mouseup.brush", brushend);
            }
            g.interrupt().selectAll("*").interrupt();
            if (dragging) {
                origin[0] = xExtent[0] - origin[0];
                origin[1] = yExtent[0] - origin[1];
            } else if (resizing) {
                var ex = +/w$/.test(resizing), ey = +/^n/.test(resizing);
                offset = [ xExtent[1 - ex] - origin[0], yExtent[1 - ey] - origin[1] ];
                origin[0] = xExtent[ex];
                origin[1] = yExtent[ey];
            } else if (d3.event.altKey) center = origin.slice();
            g.style("pointer-events", "none").selectAll(".resize").style("display", null);
            d3.select("body").style("cursor", eventTarget.style("cursor"));
            event_({
                type: "brushstart"
            });
            brushmove();
            function keydown() {
                if (d3.event.keyCode == 32) {
                    if (!dragging) {
                        center = null;
                        origin[0] -= xExtent[1];
                        origin[1] -= yExtent[1];
                        dragging = 2;
                    }
                    d3_eventPreventDefault();
                }
            }
            function keyup() {
                if (d3.event.keyCode == 32 && dragging == 2) {
                    origin[0] += xExtent[1];
                    origin[1] += yExtent[1];
                    dragging = 0;
                    d3_eventPreventDefault();
                }
            }
            function brushmove() {
                var point = d3.mouse(target), moved = false;
                if (offset) {
                    point[0] += offset[0];
                    point[1] += offset[1];
                }
                if (!dragging) {
                    if (d3.event.altKey) {
                        if (!center) center = [ (xExtent[0] + xExtent[1]) / 2, (yExtent[0] + yExtent[1]) / 2 ];
                        origin[0] = xExtent[+(point[0] < center[0])];
                        origin[1] = yExtent[+(point[1] < center[1])];
                    } else center = null;
                }
                if (resizingX && move1(point, x, 0)) {
                    redrawX(g);
                    moved = true;
                }
                if (resizingY && move1(point, y, 1)) {
                    redrawY(g);
                    moved = true;
                }
                if (moved) {
                    redraw(g);
                    event_({
                        type: "brush",
                        mode: dragging ? "move" : "resize"
                    });
                }
            }
            function move1(point, scale, i) {
                var range = d3_scaleRange(scale), r0 = range[0], r1 = range[1], position = origin[i], extent = i ? yExtent : xExtent, size = extent[1] - extent[0], min, max;
                if (dragging) {
                    r0 -= position;
                    r1 -= size + position;
                }
                min = (i ? yClamp : xClamp) ? Math.max(r0, Math.min(r1, point[i])) : point[i];
                if (dragging) {
                    max = (min += position) + size;
                } else {
                    if (center) position = Math.max(r0, Math.min(r1, 2 * center[i] - min));
                    if (position < min) {
                        max = min;
                        min = position;
                    } else {
                        max = position;
                    }
                }
                if (extent[0] != min || extent[1] != max) {
                    if (i) yExtentDomain = null; else xExtentDomain = null;
                    extent[0] = min;
                    extent[1] = max;
                    return true;
                }
            }
            function brushend() {
                brushmove();
                g.style("pointer-events", "all").selectAll(".resize").style("display", brush.empty() ? "none" : null);
                d3.select("body").style("cursor", null);
                w.on("mousemove.brush", null).on("mouseup.brush", null).on("touchmove.brush", null).on("touchend.brush", null).on("keydown.brush", null).on("keyup.brush", null);
                dragRestore();
                event_({
                    type: "brushend"
                });
            }
        }
        brush.x = function(z) {
            if (!arguments.length) return x;
            x = z;
            resizes = d3_svg_brushResizes[!x << 1 | !y];
            return brush;
        };
        brush.y = function(z) {
            if (!arguments.length) return y;
            y = z;
            resizes = d3_svg_brushResizes[!x << 1 | !y];
            return brush;
        };
        brush.clamp = function(z) {
            if (!arguments.length) return x && y ? [ xClamp, yClamp ] : x ? xClamp : y ? yClamp : null;
            if (x && y) xClamp = !!z[0], yClamp = !!z[1]; else if (x) xClamp = !!z; else if (y) yClamp = !!z;
            return brush;
        };
        brush.extent = function(z) {
            var x0, x1, y0, y1, t;
            if (!arguments.length) {
                if (x) {
                    if (xExtentDomain) {
                        x0 = xExtentDomain[0], x1 = xExtentDomain[1];
                    } else {
                        x0 = xExtent[0], x1 = xExtent[1];
                        if (x.invert) x0 = x.invert(x0), x1 = x.invert(x1);
                        if (x1 < x0) t = x0, x0 = x1, x1 = t;
                    }
                }
                if (y) {
                    if (yExtentDomain) {
                        y0 = yExtentDomain[0], y1 = yExtentDomain[1];
                    } else {
                        y0 = yExtent[0], y1 = yExtent[1];
                        if (y.invert) y0 = y.invert(y0), y1 = y.invert(y1);
                        if (y1 < y0) t = y0, y0 = y1, y1 = t;
                    }
                }
                return x && y ? [ [ x0, y0 ], [ x1, y1 ] ] : x ? [ x0, x1 ] : y && [ y0, y1 ];
            }
            if (x) {
                x0 = z[0], x1 = z[1];
                if (y) x0 = x0[0], x1 = x1[0];
                xExtentDomain = [ x0, x1 ];
                if (x.invert) x0 = x(x0), x1 = x(x1);
                if (x1 < x0) t = x0, x0 = x1, x1 = t;
                if (x0 != xExtent[0] || x1 != xExtent[1]) xExtent = [ x0, x1 ];
            }
            if (y) {
                y0 = z[0], y1 = z[1];
                if (x) y0 = y0[1], y1 = y1[1];
                yExtentDomain = [ y0, y1 ];
                if (y.invert) y0 = y(y0), y1 = y(y1);
                if (y1 < y0) t = y0, y0 = y1, y1 = t;
                if (y0 != yExtent[0] || y1 != yExtent[1]) yExtent = [ y0, y1 ];
            }
            return brush;
        };
        brush.clear = function() {
            if (!brush.empty()) {
                xExtent = [ 0, 0 ], yExtent = [ 0, 0 ];
                xExtentDomain = yExtentDomain = null;
            }
            return brush;
        };
        brush.empty = function() {
            return !!x && xExtent[0] == xExtent[1] || !!y && yExtent[0] == yExtent[1];
        };
        return d3.rebind(brush, event, "on");
    };
    var d3_svg_brushCursor = {
        n: "ns-resize",
        e: "ew-resize",
        s: "ns-resize",
        w: "ew-resize",
        nw: "nwse-resize",
        ne: "nesw-resize",
        se: "nwse-resize",
        sw: "nesw-resize"
    };
    var d3_svg_brushResizes = [ [ "n", "e", "s", "w", "nw", "ne", "se", "sw" ], [ "e", "w" ], [ "n", "s" ], [] ];
    var d3_time_format = d3_time.format = d3_locale_enUS.timeFormat;
    var d3_time_formatUtc = d3_time_format.utc;
    var d3_time_formatIso = d3_time_formatUtc("%Y-%m-%dT%H:%M:%S.%LZ");
    d3_time_format.iso = Date.prototype.toISOString && +new Date("2000-01-01T00:00:00.000Z") ? d3_time_formatIsoNative : d3_time_formatIso;
    function d3_time_formatIsoNative(date) {
        return date.toISOString();
    }
    d3_time_formatIsoNative.parse = function(string) {
        var date = new Date(string);
        return isNaN(date) ? null : date;
    };
    d3_time_formatIsoNative.toString = d3_time_formatIso.toString;
    d3_time.second = d3_time_interval(function(date) {
        return new d3_date(Math.floor(date / 1e3) * 1e3);
    }, function(date, offset) {
        date.setTime(date.getTime() + Math.floor(offset) * 1e3);
    }, function(date) {
        return date.getSeconds();
    });
    d3_time.seconds = d3_time.second.range;
    d3_time.seconds.utc = d3_time.second.utc.range;
    d3_time.minute = d3_time_interval(function(date) {
        return new d3_date(Math.floor(date / 6e4) * 6e4);
    }, function(date, offset) {
        date.setTime(date.getTime() + Math.floor(offset) * 6e4);
    }, function(date) {
        return date.getMinutes();
    });
    d3_time.minutes = d3_time.minute.range;
    d3_time.minutes.utc = d3_time.minute.utc.range;
    d3_time.hour = d3_time_interval(function(date) {
        var timezone = date.getTimezoneOffset() / 60;
        return new d3_date((Math.floor(date / 36e5 - timezone) + timezone) * 36e5);
    }, function(date, offset) {
        date.setTime(date.getTime() + Math.floor(offset) * 36e5);
    }, function(date) {
        return date.getHours();
    });
    d3_time.hours = d3_time.hour.range;
    d3_time.hours.utc = d3_time.hour.utc.range;
    d3_time.month = d3_time_interval(function(date) {
        date = d3_time.day(date);
        date.setDate(1);
        return date;
    }, function(date, offset) {
        date.setMonth(date.getMonth() + offset);
    }, function(date) {
        return date.getMonth();
    });
    d3_time.months = d3_time.month.range;
    d3_time.months.utc = d3_time.month.utc.range;
    function d3_time_scale(linear, methods, format) {
        function scale(x) {
            return linear(x);
        }
        scale.invert = function(x) {
            return d3_time_scaleDate(linear.invert(x));
        };
        scale.domain = function(x) {
            if (!arguments.length) return linear.domain().map(d3_time_scaleDate);
            linear.domain(x);
            return scale;
        };
        function tickMethod(extent, count) {
            var span = extent[1] - extent[0], target = span / count, i = d3.bisect(d3_time_scaleSteps, target);
            return i == d3_time_scaleSteps.length ? [ methods.year, d3_scale_linearTickRange(extent.map(function(d) {
                return d / 31536e6;
            }), count)[2] ] : !i ? [ d3_time_scaleMilliseconds, d3_scale_linearTickRange(extent, count)[2] ] : methods[target / d3_time_scaleSteps[i - 1] < d3_time_scaleSteps[i] / target ? i - 1 : i];
        }
        scale.nice = function(interval, skip) {
            var domain = scale.domain(), extent = d3_scaleExtent(domain), method = interval == null ? tickMethod(extent, 10) : typeof interval === "number" && tickMethod(extent, interval);
            if (method) interval = method[0], skip = method[1];
            function skipped(date) {
                return !isNaN(date) && !interval.range(date, d3_time_scaleDate(+date + 1), skip).length;
            }
            return scale.domain(d3_scale_nice(domain, skip > 1 ? {
                floor: function(date) {
                    while (skipped(date = interval.floor(date))) date = d3_time_scaleDate(date - 1);
                    return date;
                },
                ceil: function(date) {
                    while (skipped(date = interval.ceil(date))) date = d3_time_scaleDate(+date + 1);
                    return date;
                }
            } : interval));
        };
        scale.ticks = function(interval, skip) {
            var extent = d3_scaleExtent(scale.domain()), method = interval == null ? tickMethod(extent, 10) : typeof interval === "number" ? tickMethod(extent, interval) : !interval.range && [ {
                range: interval
            }, skip ];
            if (method) interval = method[0], skip = method[1];
            return interval.range(extent[0], d3_time_scaleDate(+extent[1] + 1), skip < 1 ? 1 : skip);
        };
        scale.tickFormat = function() {
            return format;
        };
        scale.copy = function() {
            return d3_time_scale(linear.copy(), methods, format);
        };
        return d3_scale_linearRebind(scale, linear);
    }
    function d3_time_scaleDate(t) {
        return new Date(t);
    }
    var d3_time_scaleSteps = [ 1e3, 5e3, 15e3, 3e4, 6e4, 3e5, 9e5, 18e5, 36e5, 108e5, 216e5, 432e5, 864e5, 1728e5, 6048e5, 2592e6, 7776e6, 31536e6 ];
    var d3_time_scaleLocalMethods = [ [ d3_time.second, 1 ], [ d3_time.second, 5 ], [ d3_time.second, 15 ], [ d3_time.second, 30 ], [ d3_time.minute, 1 ], [ d3_time.minute, 5 ], [ d3_time.minute, 15 ], [ d3_time.minute, 30 ], [ d3_time.hour, 1 ], [ d3_time.hour, 3 ], [ d3_time.hour, 6 ], [ d3_time.hour, 12 ], [ d3_time.day, 1 ], [ d3_time.day, 2 ], [ d3_time.week, 1 ], [ d3_time.month, 1 ], [ d3_time.month, 3 ], [ d3_time.year, 1 ] ];
    var d3_time_scaleLocalFormat = d3_time_format.multi([ [ ".%L", function(d) {
        return d.getMilliseconds();
    } ], [ ":%S", function(d) {
        return d.getSeconds();
    } ], [ "%I:%M", function(d) {
        return d.getMinutes();
    } ], [ "%I %p", function(d) {
        return d.getHours();
    } ], [ "%a %d", function(d) {
        return d.getDay() && d.getDate() != 1;
    } ], [ "%b %d", function(d) {
        return d.getDate() != 1;
    } ], [ "%B", function(d) {
        return d.getMonth();
    } ], [ "%Y", d3_true ] ]);
    var d3_time_scaleMilliseconds = {
        range: function(start, stop, step) {
            return d3.range(Math.ceil(start / step) * step, +stop, step).map(d3_time_scaleDate);
        },
        floor: d3_identity,
        ceil: d3_identity
    };
    d3_time_scaleLocalMethods.year = d3_time.year;
    d3_time.scale = function() {
        return d3_time_scale(d3.scale.linear(), d3_time_scaleLocalMethods, d3_time_scaleLocalFormat);
    };
    var d3_time_scaleUtcMethods = d3_time_scaleLocalMethods.map(function(m) {
        return [ m[0].utc, m[1] ];
    });
    var d3_time_scaleUtcFormat = d3_time_formatUtc.multi([ [ ".%L", function(d) {
        return d.getUTCMilliseconds();
    } ], [ ":%S", function(d) {
        return d.getUTCSeconds();
    } ], [ "%I:%M", function(d) {
        return d.getUTCMinutes();
    } ], [ "%I %p", function(d) {
        return d.getUTCHours();
    } ], [ "%a %d", function(d) {
        return d.getUTCDay() && d.getUTCDate() != 1;
    } ], [ "%b %d", function(d) {
        return d.getUTCDate() != 1;
    } ], [ "%B", function(d) {
        return d.getUTCMonth();
    } ], [ "%Y", d3_true ] ]);
    d3_time_scaleUtcMethods.year = d3_time.year.utc;
    d3_time.scale.utc = function() {
        return d3_time_scale(d3.scale.linear(), d3_time_scaleUtcMethods, d3_time_scaleUtcFormat);
    };
    d3.text = d3_xhrType(function(request) {
        return request.responseText;
    });
    d3.json = function(url, callback) {
        return d3_xhr(url, "application/json", d3_json, callback);
    };
    function d3_json(request) {
        return JSON.parse(request.responseText);
    }
    d3.html = function(url, callback) {
        return d3_xhr(url, "text/html", d3_html, callback);
    };
    function d3_html(request) {
        var range = d3_document.createRange();
        range.selectNode(d3_document.body);
        return range.createContextualFragment(request.responseText);
    }
    d3.xml = d3_xhrType(function(request) {
        return request.responseXML;
    });
    if (typeof define === "function" && define.amd) this.d3 = d3, define(d3); else if (typeof module === "object" && module.exports) module.exports = d3; else this.d3 = d3;
}();

(function(window) {
    if (window.jQuery) {
        return;
    }
    var $ = function(selector, context) {
        return new $.fn.init(selector, context);
    };
    $.isWindow = function(obj) {
        return obj != null && obj == obj.window;
    };
    $.type = function(obj) {
        if (obj == null) {
            return obj + "";
        }
        return typeof obj === "object" || typeof obj === "function" ? class2type[toString.call(obj)] || "object" : typeof obj;
    };
    $.isArray = Array.isArray || function(obj) {
        return $.type(obj) === "array";
    };
    function isArraylike(obj) {
        var length = obj.length, type = $.type(obj);
        if (type === "function" || $.isWindow(obj)) {
            return false;
        }
        if (obj.nodeType === 1 && length) {
            return true;
        }
        return type === "array" || length === 0 || typeof length === "number" && length > 0 && length - 1 in obj;
    }
    $.isPlainObject = function(obj) {
        var key;
        if (!obj || $.type(obj) !== "object" || obj.nodeType || $.isWindow(obj)) {
            return false;
        }
        try {
            if (obj.constructor && !hasOwn.call(obj, "constructor") && !hasOwn.call(obj.constructor.prototype, "isPrototypeOf")) {
                return false;
            }
        } catch (e) {
            return false;
        }
        for (key in obj) {}
        return key === undefined || hasOwn.call(obj, key);
    };
    $.each = function(obj, callback, args) {
        var value, i = 0, length = obj.length, isArray = isArraylike(obj);
        if (args) {
            if (isArray) {
                for (;i < length; i++) {
                    value = callback.apply(obj[i], args);
                    if (value === false) {
                        break;
                    }
                }
            } else {
                for (i in obj) {
                    value = callback.apply(obj[i], args);
                    if (value === false) {
                        break;
                    }
                }
            }
        } else {
            if (isArray) {
                for (;i < length; i++) {
                    value = callback.call(obj[i], i, obj[i]);
                    if (value === false) {
                        break;
                    }
                }
            } else {
                for (i in obj) {
                    value = callback.call(obj[i], i, obj[i]);
                    if (value === false) {
                        break;
                    }
                }
            }
        }
        return obj;
    };
    $.data = function(node, key, value) {
        if (value === undefined) {
            var id = node[$.expando], store = id && cache[id];
            if (key === undefined) {
                return store;
            } else if (store) {
                if (key in store) {
                    return store[key];
                }
            }
        } else if (key !== undefined) {
            var id = node[$.expando] || (node[$.expando] = ++$.uuid);
            cache[id] = cache[id] || {};
            cache[id][key] = value;
            return value;
        }
    };
    $.removeData = function(node, keys) {
        var id = node[$.expando], store = id && cache[id];
        if (store) {
            $.each(keys, function(_, key) {
                delete store[key];
            });
        }
    };
    $.extend = function() {
        var src, copyIsArray, copy, name, options, clone, target = arguments[0] || {}, i = 1, length = arguments.length, deep = false;
        if (typeof target === "boolean") {
            deep = target;
            target = arguments[i] || {};
            i++;
        }
        if (typeof target !== "object" && $.type(target) !== "function") {
            target = {};
        }
        if (i === length) {
            target = this;
            i--;
        }
        for (;i < length; i++) {
            if ((options = arguments[i]) != null) {
                for (name in options) {
                    src = target[name];
                    copy = options[name];
                    if (target === copy) {
                        continue;
                    }
                    if (deep && copy && ($.isPlainObject(copy) || (copyIsArray = $.isArray(copy)))) {
                        if (copyIsArray) {
                            copyIsArray = false;
                            clone = src && $.isArray(src) ? src : [];
                        } else {
                            clone = src && $.isPlainObject(src) ? src : {};
                        }
                        target[name] = $.extend(deep, clone, copy);
                    } else if (copy !== undefined) {
                        target[name] = copy;
                    }
                }
            }
        }
        return target;
    };
    $.queue = function(elem, type, data) {
        function $makeArray(arr, results) {
            var ret = results || [];
            if (arr != null) {
                if (isArraylike(Object(arr))) {
                    (function(first, second) {
                        var len = +second.length, j = 0, i = first.length;
                        while (j < len) {
                            first[i++] = second[j++];
                        }
                        if (len !== len) {
                            while (second[j] !== undefined) {
                                first[i++] = second[j++];
                            }
                        }
                        first.length = i;
                        return first;
                    })(ret, typeof arr === "string" ? [ arr ] : arr);
                } else {
                    [].push.call(ret, arr);
                }
            }
            return ret;
        }
        if (!elem) {
            return;
        }
        type = (type || "fx") + "queue";
        var q = $.data(elem, type);
        if (!data) {
            return q || [];
        }
        if (!q || $.isArray(data)) {
            q = $.data(elem, type, $makeArray(data));
        } else {
            q.push(data);
        }
        return q;
    };
    $.dequeue = function(elems, type) {
        $.each(elems.nodeType ? [ elems ] : elems, function(i, elem) {
            type = type || "fx";
            var queue = $.queue(elem, type), fn = queue.shift();
            if (fn === "inprogress") {
                fn = queue.shift();
            }
            if (fn) {
                if (type === "fx") {
                    queue.unshift("inprogress");
                }
                fn.call(elem, function() {
                    $.dequeue(elem, type);
                });
            }
        });
    };
    $.fn = $.prototype = {
        init: function(selector) {
            if (selector.nodeType) {
                this[0] = selector;
                return this;
            } else {
                throw new Error("Not a DOM node.");
            }
        },
        offset: function() {
            var box = this[0].getBoundingClientRect ? this[0].getBoundingClientRect() : {
                top: 0,
                left: 0
            };
            return {
                top: box.top + (window.pageYOffset || document.scrollTop || 0) - (document.clientTop || 0),
                left: box.left + (window.pageXOffset || document.scrollLeft || 0) - (document.clientLeft || 0)
            };
        },
        position: function() {
            function offsetParent() {
                var offsetParent = this.offsetParent || document;
                while (offsetParent && (!offsetParent.nodeType.toLowerCase === "html" && offsetParent.style.position === "static")) {
                    offsetParent = offsetParent.offsetParent;
                }
                return offsetParent || document;
            }
            var elem = this[0], offsetParent = offsetParent.apply(elem), offset = this.offset(), parentOffset = /^(?:body|html)$/i.test(offsetParent.nodeName) ? {
                top: 0,
                left: 0
            } : $(offsetParent).offset();
            offset.top -= parseFloat(elem.style.marginTop) || 0;
            offset.left -= parseFloat(elem.style.marginLeft) || 0;
            if (offsetParent.style) {
                parentOffset.top += parseFloat(offsetParent.style.borderTopWidth) || 0;
                parentOffset.left += parseFloat(offsetParent.style.borderLeftWidth) || 0;
            }
            return {
                top: offset.top - parentOffset.top,
                left: offset.left - parentOffset.left
            };
        }
    };
    var cache = {};
    $.expando = "velocity" + new Date().getTime();
    $.uuid = 0;
    var class2type = {}, hasOwn = class2type.hasOwnProperty, toString = class2type.toString;
    var types = "Boolean Number String Function Array Date RegExp Object Error".split(" ");
    for (var i = 0; i < types.length; i++) {
        class2type["[object " + types[i] + "]"] = types[i].toLowerCase();
    }
    $.fn.init.prototype = $.fn;
    window.Velocity = {
        Utilities: $
    };
})(window);

(function(factory) {
    if (typeof module === "object" && typeof module.exports === "object") {
        module.exports = factory();
    } else if (typeof define === "function" && define.amd) {
        define(factory);
    } else {
        factory();
    }
})(function() {
    return function(global, window, document, undefined) {
        var IE = function() {
            if (document.documentMode) {
                return document.documentMode;
            } else {
                for (var i = 7; i > 4; i--) {
                    var div = document.createElement("div");
                    div.innerHTML = "<!--[if IE " + i + "]><span></span><![endif]-->";
                    if (div.getElementsByTagName("span").length) {
                        div = null;
                        return i;
                    }
                }
            }
            return undefined;
        }();
        var rAFShim = function() {
            var timeLast = 0;
            return window.webkitRequestAnimationFrame || window.mozRequestAnimationFrame || function(callback) {
                var timeCurrent = new Date().getTime(), timeDelta;
                timeDelta = Math.max(0, 16 - (timeCurrent - timeLast));
                timeLast = timeCurrent + timeDelta;
                return setTimeout(function() {
                    callback(timeCurrent + timeDelta);
                }, timeDelta);
            };
        }();
        function compactSparseArray(array) {
            var index = -1, length = array ? array.length : 0, result = [];
            while (++index < length) {
                var value = array[index];
                if (value) {
                    result.push(value);
                }
            }
            return result;
        }
        function sanitizeElements(elements) {
            if (Type.isWrapped(elements)) {
                elements = [].slice.call(elements);
            } else if (Type.isNode(elements)) {
                elements = [ elements ];
            }
            return elements;
        }
        var Type = {
            isString: function(variable) {
                return typeof variable === "string";
            },
            isArray: Array.isArray || function(variable) {
                return Object.prototype.toString.call(variable) === "[object Array]";
            },
            isFunction: function(variable) {
                return Object.prototype.toString.call(variable) === "[object Function]";
            },
            isNode: function(variable) {
                return variable && variable.nodeType;
            },
            isNodeList: function(variable) {
                return typeof variable === "object" && /^\[object (HTMLCollection|NodeList|Object)\]$/.test(Object.prototype.toString.call(variable)) && variable.length !== undefined && (variable.length === 0 || typeof variable[0] === "object" && variable[0].nodeType > 0);
            },
            isWrapped: function(variable) {
                return variable && (variable.jquery || window.Zepto && window.Zepto.zepto.isZ(variable));
            },
            isSVG: function(variable) {
                return window.SVGElement && variable instanceof window.SVGElement;
            },
            isEmptyObject: function(variable) {
                for (var name in variable) {
                    return false;
                }
                return true;
            }
        };
        var $, isJQuery = false;
        if (global.fn && global.fn.jquery) {
            $ = global;
            isJQuery = true;
        } else {
            $ = window.Velocity.Utilities;
        }
        if (IE <= 8 && !isJQuery) {
            throw new Error("Velocity: IE8 and below require jQuery to be loaded before Velocity.");
        } else if (IE <= 7) {
            jQuery.fn.velocity = jQuery.fn.animate;
            return;
        }
        var DURATION_DEFAULT = 400, EASING_DEFAULT = "swing";
        var Velocity = {
            State: {
                isMobile: /Android|webOS|iPhone|iPad|iPod|BlackBerry|IEMobile|Opera Mini/i.test(navigator.userAgent),
                isAndroid: /Android/i.test(navigator.userAgent),
                isGingerbread: /Android 2\.3\.[3-7]/i.test(navigator.userAgent),
                isChrome: window.chrome,
                isFirefox: /Firefox/i.test(navigator.userAgent),
                prefixElement: document.createElement("div"),
                prefixMatches: {},
                scrollAnchor: null,
                scrollPropertyLeft: null,
                scrollPropertyTop: null,
                isTicking: false,
                calls: []
            },
            CSS: {},
            Utilities: $,
            Redirects: {},
            Easings: {},
            Promise: window.Promise,
            defaults: {
                queue: "",
                duration: DURATION_DEFAULT,
                easing: EASING_DEFAULT,
                begin: undefined,
                complete: undefined,
                progress: undefined,
                display: undefined,
                visibility: undefined,
                loop: false,
                delay: false,
                mobileHA: true,
                _cacheValues: true
            },
            init: function(element) {
                $.data(element, "velocity", {
                    isSVG: Type.isSVG(element),
                    isAnimating: false,
                    computedStyle: null,
                    tweensContainer: null,
                    rootPropertyValueCache: {},
                    transformCache: {}
                });
            },
            hook: null,
            mock: false,
            version: {
                major: 1,
                minor: 2,
                patch: 2
            },
            debug: false
        };
        if (window.pageYOffset !== undefined) {
            Velocity.State.scrollAnchor = window;
            Velocity.State.scrollPropertyLeft = "pageXOffset";
            Velocity.State.scrollPropertyTop = "pageYOffset";
        } else {
            Velocity.State.scrollAnchor = document.documentElement || document.body.parentNode || document.body;
            Velocity.State.scrollPropertyLeft = "scrollLeft";
            Velocity.State.scrollPropertyTop = "scrollTop";
        }
        function Data(element) {
            var response = $.data(element, "velocity");
            return response === null ? undefined : response;
        }
        function generateStep(steps) {
            return function(p) {
                return Math.round(p * steps) * (1 / steps);
            };
        }
        function generateBezier(mX1, mY1, mX2, mY2) {
            var NEWTON_ITERATIONS = 4, NEWTON_MIN_SLOPE = .001, SUBDIVISION_PRECISION = 1e-7, SUBDIVISION_MAX_ITERATIONS = 10, kSplineTableSize = 11, kSampleStepSize = 1 / (kSplineTableSize - 1), float32ArraySupported = "Float32Array" in window;
            if (arguments.length !== 4) {
                return false;
            }
            for (var i = 0; i < 4; ++i) {
                if (typeof arguments[i] !== "number" || isNaN(arguments[i]) || !isFinite(arguments[i])) {
                    return false;
                }
            }
            mX1 = Math.min(mX1, 1);
            mX2 = Math.min(mX2, 1);
            mX1 = Math.max(mX1, 0);
            mX2 = Math.max(mX2, 0);
            var mSampleValues = float32ArraySupported ? new Float32Array(kSplineTableSize) : new Array(kSplineTableSize);
            function A(aA1, aA2) {
                return 1 - 3 * aA2 + 3 * aA1;
            }
            function B(aA1, aA2) {
                return 3 * aA2 - 6 * aA1;
            }
            function C(aA1) {
                return 3 * aA1;
            }
            function calcBezier(aT, aA1, aA2) {
                return ((A(aA1, aA2) * aT + B(aA1, aA2)) * aT + C(aA1)) * aT;
            }
            function getSlope(aT, aA1, aA2) {
                return 3 * A(aA1, aA2) * aT * aT + 2 * B(aA1, aA2) * aT + C(aA1);
            }
            function newtonRaphsonIterate(aX, aGuessT) {
                for (var i = 0; i < NEWTON_ITERATIONS; ++i) {
                    var currentSlope = getSlope(aGuessT, mX1, mX2);
                    if (currentSlope === 0) return aGuessT;
                    var currentX = calcBezier(aGuessT, mX1, mX2) - aX;
                    aGuessT -= currentX / currentSlope;
                }
                return aGuessT;
            }
            function calcSampleValues() {
                for (var i = 0; i < kSplineTableSize; ++i) {
                    mSampleValues[i] = calcBezier(i * kSampleStepSize, mX1, mX2);
                }
            }
            function binarySubdivide(aX, aA, aB) {
                var currentX, currentT, i = 0;
                do {
                    currentT = aA + (aB - aA) / 2;
                    currentX = calcBezier(currentT, mX1, mX2) - aX;
                    if (currentX > 0) {
                        aB = currentT;
                    } else {
                        aA = currentT;
                    }
                } while (Math.abs(currentX) > SUBDIVISION_PRECISION && ++i < SUBDIVISION_MAX_ITERATIONS);
                return currentT;
            }
            function getTForX(aX) {
                var intervalStart = 0, currentSample = 1, lastSample = kSplineTableSize - 1;
                for (;currentSample != lastSample && mSampleValues[currentSample] <= aX; ++currentSample) {
                    intervalStart += kSampleStepSize;
                }
                --currentSample;
                var dist = (aX - mSampleValues[currentSample]) / (mSampleValues[currentSample + 1] - mSampleValues[currentSample]), guessForT = intervalStart + dist * kSampleStepSize, initialSlope = getSlope(guessForT, mX1, mX2);
                if (initialSlope >= NEWTON_MIN_SLOPE) {
                    return newtonRaphsonIterate(aX, guessForT);
                } else if (initialSlope == 0) {
                    return guessForT;
                } else {
                    return binarySubdivide(aX, intervalStart, intervalStart + kSampleStepSize);
                }
            }
            var _precomputed = false;
            function precompute() {
                _precomputed = true;
                if (mX1 != mY1 || mX2 != mY2) calcSampleValues();
            }
            var f = function(aX) {
                if (!_precomputed) precompute();
                if (mX1 === mY1 && mX2 === mY2) return aX;
                if (aX === 0) return 0;
                if (aX === 1) return 1;
                return calcBezier(getTForX(aX), mY1, mY2);
            };
            f.getControlPoints = function() {
                return [ {
                    x: mX1,
                    y: mY1
                }, {
                    x: mX2,
                    y: mY2
                } ];
            };
            var str = "generateBezier(" + [ mX1, mY1, mX2, mY2 ] + ")";
            f.toString = function() {
                return str;
            };
            return f;
        }
        var generateSpringRK4 = function() {
            function springAccelerationForState(state) {
                return -state.tension * state.x - state.friction * state.v;
            }
            function springEvaluateStateWithDerivative(initialState, dt, derivative) {
                var state = {
                    x: initialState.x + derivative.dx * dt,
                    v: initialState.v + derivative.dv * dt,
                    tension: initialState.tension,
                    friction: initialState.friction
                };
                return {
                    dx: state.v,
                    dv: springAccelerationForState(state)
                };
            }
            function springIntegrateState(state, dt) {
                var a = {
                    dx: state.v,
                    dv: springAccelerationForState(state)
                }, b = springEvaluateStateWithDerivative(state, dt * .5, a), c = springEvaluateStateWithDerivative(state, dt * .5, b), d = springEvaluateStateWithDerivative(state, dt, c), dxdt = 1 / 6 * (a.dx + 2 * (b.dx + c.dx) + d.dx), dvdt = 1 / 6 * (a.dv + 2 * (b.dv + c.dv) + d.dv);
                state.x = state.x + dxdt * dt;
                state.v = state.v + dvdt * dt;
                return state;
            }
            return function springRK4Factory(tension, friction, duration) {
                var initState = {
                    x: -1,
                    v: 0,
                    tension: null,
                    friction: null
                }, path = [ 0 ], time_lapsed = 0, tolerance = 1 / 1e4, DT = 16 / 1e3, have_duration, dt, last_state;
                tension = parseFloat(tension) || 500;
                friction = parseFloat(friction) || 20;
                duration = duration || null;
                initState.tension = tension;
                initState.friction = friction;
                have_duration = duration !== null;
                if (have_duration) {
                    time_lapsed = springRK4Factory(tension, friction);
                    dt = time_lapsed / duration * DT;
                } else {
                    dt = DT;
                }
                while (true) {
                    last_state = springIntegrateState(last_state || initState, dt);
                    path.push(1 + last_state.x);
                    time_lapsed += 16;
                    if (!(Math.abs(last_state.x) > tolerance && Math.abs(last_state.v) > tolerance)) {
                        break;
                    }
                }
                return !have_duration ? time_lapsed : function(percentComplete) {
                    return path[percentComplete * (path.length - 1) | 0];
                };
            };
        }();
        Velocity.Easings = {
            linear: function(p) {
                return p;
            },
            swing: function(p) {
                return .5 - Math.cos(p * Math.PI) / 2;
            },
            spring: function(p) {
                return 1 - Math.cos(p * 4.5 * Math.PI) * Math.exp(-p * 6);
            }
        };
        $.each([ [ "ease", [ .25, .1, .25, 1 ] ], [ "ease-in", [ .42, 0, 1, 1 ] ], [ "ease-out", [ 0, 0, .58, 1 ] ], [ "ease-in-out", [ .42, 0, .58, 1 ] ], [ "easeInSine", [ .47, 0, .745, .715 ] ], [ "easeOutSine", [ .39, .575, .565, 1 ] ], [ "easeInOutSine", [ .445, .05, .55, .95 ] ], [ "easeInQuad", [ .55, .085, .68, .53 ] ], [ "easeOutQuad", [ .25, .46, .45, .94 ] ], [ "easeInOutQuad", [ .455, .03, .515, .955 ] ], [ "easeInCubic", [ .55, .055, .675, .19 ] ], [ "easeOutCubic", [ .215, .61, .355, 1 ] ], [ "easeInOutCubic", [ .645, .045, .355, 1 ] ], [ "easeInQuart", [ .895, .03, .685, .22 ] ], [ "easeOutQuart", [ .165, .84, .44, 1 ] ], [ "easeInOutQuart", [ .77, 0, .175, 1 ] ], [ "easeInQuint", [ .755, .05, .855, .06 ] ], [ "easeOutQuint", [ .23, 1, .32, 1 ] ], [ "easeInOutQuint", [ .86, 0, .07, 1 ] ], [ "easeInExpo", [ .95, .05, .795, .035 ] ], [ "easeOutExpo", [ .19, 1, .22, 1 ] ], [ "easeInOutExpo", [ 1, 0, 0, 1 ] ], [ "easeInCirc", [ .6, .04, .98, .335 ] ], [ "easeOutCirc", [ .075, .82, .165, 1 ] ], [ "easeInOutCirc", [ .785, .135, .15, .86 ] ] ], function(i, easingArray) {
            Velocity.Easings[easingArray[0]] = generateBezier.apply(null, easingArray[1]);
        });
        function getEasing(value, duration) {
            var easing = value;
            if (Type.isString(value)) {
                if (!Velocity.Easings[value]) {
                    easing = false;
                }
            } else if (Type.isArray(value) && value.length === 1) {
                easing = generateStep.apply(null, value);
            } else if (Type.isArray(value) && value.length === 2) {
                easing = generateSpringRK4.apply(null, value.concat([ duration ]));
            } else if (Type.isArray(value) && value.length === 4) {
                easing = generateBezier.apply(null, value);
            } else {
                easing = false;
            }
            if (easing === false) {
                if (Velocity.Easings[Velocity.defaults.easing]) {
                    easing = Velocity.defaults.easing;
                } else {
                    easing = EASING_DEFAULT;
                }
            }
            return easing;
        }
        var CSS = Velocity.CSS = {
            RegEx: {
                isHex: /^#([A-f\d]{3}){1,2}$/i,
                valueUnwrap: /^[A-z]+\((.*)\)$/i,
                wrappedValueAlreadyExtracted: /[0-9.]+ [0-9.]+ [0-9.]+( [0-9.]+)?/,
                valueSplit: /([A-z]+\(.+\))|(([A-z0-9#-.]+?)(?=\s|$))/gi
            },
            Lists: {
                colors: [ "fill", "stroke", "stopColor", "color", "backgroundColor", "borderColor", "borderTopColor", "borderRightColor", "borderBottomColor", "borderLeftColor", "outlineColor" ],
                transformsBase: [ "translateX", "translateY", "scale", "scaleX", "scaleY", "skewX", "skewY", "rotateZ" ],
                transforms3D: [ "transformPerspective", "translateZ", "scaleZ", "rotateX", "rotateY" ]
            },
            Hooks: {
                templates: {
                    textShadow: [ "Color X Y Blur", "black 0px 0px 0px" ],
                    boxShadow: [ "Color X Y Blur Spread", "black 0px 0px 0px 0px" ],
                    clip: [ "Top Right Bottom Left", "0px 0px 0px 0px" ],
                    backgroundPosition: [ "X Y", "0% 0%" ],
                    transformOrigin: [ "X Y Z", "50% 50% 0px" ],
                    perspectiveOrigin: [ "X Y", "50% 50%" ]
                },
                registered: {},
                register: function() {
                    for (var i = 0; i < CSS.Lists.colors.length; i++) {
                        var rgbComponents = CSS.Lists.colors[i] === "color" ? "0 0 0 1" : "255 255 255 1";
                        CSS.Hooks.templates[CSS.Lists.colors[i]] = [ "Red Green Blue Alpha", rgbComponents ];
                    }
                    var rootProperty, hookTemplate, hookNames;
                    if (IE) {
                        for (rootProperty in CSS.Hooks.templates) {
                            hookTemplate = CSS.Hooks.templates[rootProperty];
                            hookNames = hookTemplate[0].split(" ");
                            var defaultValues = hookTemplate[1].match(CSS.RegEx.valueSplit);
                            if (hookNames[0] === "Color") {
                                hookNames.push(hookNames.shift());
                                defaultValues.push(defaultValues.shift());
                                CSS.Hooks.templates[rootProperty] = [ hookNames.join(" "), defaultValues.join(" ") ];
                            }
                        }
                    }
                    for (rootProperty in CSS.Hooks.templates) {
                        hookTemplate = CSS.Hooks.templates[rootProperty];
                        hookNames = hookTemplate[0].split(" ");
                        for (var i in hookNames) {
                            var fullHookName = rootProperty + hookNames[i], hookPosition = i;
                            CSS.Hooks.registered[fullHookName] = [ rootProperty, hookPosition ];
                        }
                    }
                },
                getRoot: function(property) {
                    var hookData = CSS.Hooks.registered[property];
                    if (hookData) {
                        return hookData[0];
                    } else {
                        return property;
                    }
                },
                cleanRootPropertyValue: function(rootProperty, rootPropertyValue) {
                    if (CSS.RegEx.valueUnwrap.test(rootPropertyValue)) {
                        rootPropertyValue = rootPropertyValue.match(CSS.RegEx.valueUnwrap)[1];
                    }
                    if (CSS.Values.isCSSNullValue(rootPropertyValue)) {
                        rootPropertyValue = CSS.Hooks.templates[rootProperty][1];
                    }
                    return rootPropertyValue;
                },
                extractValue: function(fullHookName, rootPropertyValue) {
                    var hookData = CSS.Hooks.registered[fullHookName];
                    if (hookData) {
                        var hookRoot = hookData[0], hookPosition = hookData[1];
                        rootPropertyValue = CSS.Hooks.cleanRootPropertyValue(hookRoot, rootPropertyValue);
                        return rootPropertyValue.toString().match(CSS.RegEx.valueSplit)[hookPosition];
                    } else {
                        return rootPropertyValue;
                    }
                },
                injectValue: function(fullHookName, hookValue, rootPropertyValue) {
                    var hookData = CSS.Hooks.registered[fullHookName];
                    if (hookData) {
                        var hookRoot = hookData[0], hookPosition = hookData[1], rootPropertyValueParts, rootPropertyValueUpdated;
                        rootPropertyValue = CSS.Hooks.cleanRootPropertyValue(hookRoot, rootPropertyValue);
                        rootPropertyValueParts = rootPropertyValue.toString().match(CSS.RegEx.valueSplit);
                        rootPropertyValueParts[hookPosition] = hookValue;
                        rootPropertyValueUpdated = rootPropertyValueParts.join(" ");
                        return rootPropertyValueUpdated;
                    } else {
                        return rootPropertyValue;
                    }
                }
            },
            Normalizations: {
                registered: {
                    clip: function(type, element, propertyValue) {
                        switch (type) {
                          case "name":
                            return "clip";

                          case "extract":
                            var extracted;
                            if (CSS.RegEx.wrappedValueAlreadyExtracted.test(propertyValue)) {
                                extracted = propertyValue;
                            } else {
                                extracted = propertyValue.toString().match(CSS.RegEx.valueUnwrap);
                                extracted = extracted ? extracted[1].replace(/,(\s+)?/g, " ") : propertyValue;
                            }
                            return extracted;

                          case "inject":
                            return "rect(" + propertyValue + ")";
                        }
                    },
                    blur: function(type, element, propertyValue) {
                        switch (type) {
                          case "name":
                            return Velocity.State.isFirefox ? "filter" : "-webkit-filter";

                          case "extract":
                            var extracted = parseFloat(propertyValue);
                            if (!(extracted || extracted === 0)) {
                                var blurComponent = propertyValue.toString().match(/blur\(([0-9]+[A-z]+)\)/i);
                                if (blurComponent) {
                                    extracted = blurComponent[1];
                                } else {
                                    extracted = 0;
                                }
                            }
                            return extracted;

                          case "inject":
                            if (!parseFloat(propertyValue)) {
                                return "none";
                            } else {
                                return "blur(" + propertyValue + ")";
                            }
                        }
                    },
                    opacity: function(type, element, propertyValue) {
                        if (IE <= 8) {
                            switch (type) {
                              case "name":
                                return "filter";

                              case "extract":
                                var extracted = propertyValue.toString().match(/alpha\(opacity=(.*)\)/i);
                                if (extracted) {
                                    propertyValue = extracted[1] / 100;
                                } else {
                                    propertyValue = 1;
                                }
                                return propertyValue;

                              case "inject":
                                element.style.zoom = 1;
                                if (parseFloat(propertyValue) >= 1) {
                                    return "";
                                } else {
                                    return "alpha(opacity=" + parseInt(parseFloat(propertyValue) * 100, 10) + ")";
                                }
                            }
                        } else {
                            switch (type) {
                              case "name":
                                return "opacity";

                              case "extract":
                                return propertyValue;

                              case "inject":
                                return propertyValue;
                            }
                        }
                    }
                },
                register: function() {
                    if (!(IE <= 9) && !Velocity.State.isGingerbread) {
                        CSS.Lists.transformsBase = CSS.Lists.transformsBase.concat(CSS.Lists.transforms3D);
                    }
                    for (var i = 0; i < CSS.Lists.transformsBase.length; i++) {
                        (function() {
                            var transformName = CSS.Lists.transformsBase[i];
                            CSS.Normalizations.registered[transformName] = function(type, element, propertyValue) {
                                switch (type) {
                                  case "name":
                                    return "transform";

                                  case "extract":
                                    if (Data(element) === undefined || Data(element).transformCache[transformName] === undefined) {
                                        return /^scale/i.test(transformName) ? 1 : 0;
                                    } else {
                                        return Data(element).transformCache[transformName].replace(/[()]/g, "");
                                    }

                                  case "inject":
                                    var invalid = false;
                                    switch (transformName.substr(0, transformName.length - 1)) {
                                      case "translate":
                                        invalid = !/(%|px|em|rem|vw|vh|\d)$/i.test(propertyValue);
                                        break;

                                      case "scal":
                                      case "scale":
                                        if (Velocity.State.isAndroid && Data(element).transformCache[transformName] === undefined && propertyValue < 1) {
                                            propertyValue = 1;
                                        }
                                        invalid = !/(\d)$/i.test(propertyValue);
                                        break;

                                      case "skew":
                                        invalid = !/(deg|\d)$/i.test(propertyValue);
                                        break;

                                      case "rotate":
                                        invalid = !/(deg|\d)$/i.test(propertyValue);
                                        break;
                                    }
                                    if (!invalid) {
                                        Data(element).transformCache[transformName] = "(" + propertyValue + ")";
                                    }
                                    return Data(element).transformCache[transformName];
                                }
                            };
                        })();
                    }
                    for (var i = 0; i < CSS.Lists.colors.length; i++) {
                        (function() {
                            var colorName = CSS.Lists.colors[i];
                            CSS.Normalizations.registered[colorName] = function(type, element, propertyValue) {
                                switch (type) {
                                  case "name":
                                    return colorName;

                                  case "extract":
                                    var extracted;
                                    if (CSS.RegEx.wrappedValueAlreadyExtracted.test(propertyValue)) {
                                        extracted = propertyValue;
                                    } else {
                                        var converted, colorNames = {
                                            black: "rgb(0, 0, 0)",
                                            blue: "rgb(0, 0, 255)",
                                            gray: "rgb(128, 128, 128)",
                                            green: "rgb(0, 128, 0)",
                                            red: "rgb(255, 0, 0)",
                                            white: "rgb(255, 255, 255)"
                                        };
                                        if (/^[A-z]+$/i.test(propertyValue)) {
                                            if (colorNames[propertyValue] !== undefined) {
                                                converted = colorNames[propertyValue];
                                            } else {
                                                converted = colorNames.black;
                                            }
                                        } else if (CSS.RegEx.isHex.test(propertyValue)) {
                                            converted = "rgb(" + CSS.Values.hexToRgb(propertyValue).join(" ") + ")";
                                        } else if (!/^rgba?\(/i.test(propertyValue)) {
                                            converted = colorNames.black;
                                        }
                                        extracted = (converted || propertyValue).toString().match(CSS.RegEx.valueUnwrap)[1].replace(/,(\s+)?/g, " ");
                                    }
                                    if (!(IE <= 8) && extracted.split(" ").length === 3) {
                                        extracted += " 1";
                                    }
                                    return extracted;

                                  case "inject":
                                    if (IE <= 8) {
                                        if (propertyValue.split(" ").length === 4) {
                                            propertyValue = propertyValue.split(/\s+/).slice(0, 3).join(" ");
                                        }
                                    } else if (propertyValue.split(" ").length === 3) {
                                        propertyValue += " 1";
                                    }
                                    return (IE <= 8 ? "rgb" : "rgba") + "(" + propertyValue.replace(/\s+/g, ",").replace(/\.(\d)+(?=,)/g, "") + ")";
                                }
                            };
                        })();
                    }
                }
            },
            Names: {
                camelCase: function(property) {
                    return property.replace(/-(\w)/g, function(match, subMatch) {
                        return subMatch.toUpperCase();
                    });
                },
                SVGAttribute: function(property) {
                    var SVGAttributes = "width|height|x|y|cx|cy|r|rx|ry|x1|x2|y1|y2";
                    if (IE || Velocity.State.isAndroid && !Velocity.State.isChrome) {
                        SVGAttributes += "|transform";
                    }
                    return new RegExp("^(" + SVGAttributes + ")$", "i").test(property);
                },
                prefixCheck: function(property) {
                    if (Velocity.State.prefixMatches[property]) {
                        return [ Velocity.State.prefixMatches[property], true ];
                    } else {
                        var vendors = [ "", "Webkit", "Moz", "ms", "O" ];
                        for (var i = 0, vendorsLength = vendors.length; i < vendorsLength; i++) {
                            var propertyPrefixed;
                            if (i === 0) {
                                propertyPrefixed = property;
                            } else {
                                propertyPrefixed = vendors[i] + property.replace(/^\w/, function(match) {
                                    return match.toUpperCase();
                                });
                            }
                            if (Type.isString(Velocity.State.prefixElement.style[propertyPrefixed])) {
                                Velocity.State.prefixMatches[property] = propertyPrefixed;
                                return [ propertyPrefixed, true ];
                            }
                        }
                        return [ property, false ];
                    }
                }
            },
            Values: {
                hexToRgb: function(hex) {
                    var shortformRegex = /^#?([a-f\d])([a-f\d])([a-f\d])$/i, longformRegex = /^#?([a-f\d]{2})([a-f\d]{2})([a-f\d]{2})$/i, rgbParts;
                    hex = hex.replace(shortformRegex, function(m, r, g, b) {
                        return r + r + g + g + b + b;
                    });
                    rgbParts = longformRegex.exec(hex);
                    return rgbParts ? [ parseInt(rgbParts[1], 16), parseInt(rgbParts[2], 16), parseInt(rgbParts[3], 16) ] : [ 0, 0, 0 ];
                },
                isCSSNullValue: function(value) {
                    return value == 0 || /^(none|auto|transparent|(rgba\(0, ?0, ?0, ?0\)))$/i.test(value);
                },
                getUnitType: function(property) {
                    if (/^(rotate|skew)/i.test(property)) {
                        return "deg";
                    } else if (/(^(scale|scaleX|scaleY|scaleZ|alpha|flexGrow|flexHeight|zIndex|fontWeight)$)|((opacity|red|green|blue|alpha)$)/i.test(property)) {
                        return "";
                    } else {
                        return "px";
                    }
                },
                getDisplayType: function(element) {
                    var tagName = element && element.tagName.toString().toLowerCase();
                    if (/^(b|big|i|small|tt|abbr|acronym|cite|code|dfn|em|kbd|strong|samp|var|a|bdo|br|img|map|object|q|script|span|sub|sup|button|input|label|select|textarea)$/i.test(tagName)) {
                        return "inline";
                    } else if (/^(li)$/i.test(tagName)) {
                        return "list-item";
                    } else if (/^(tr)$/i.test(tagName)) {
                        return "table-row";
                    } else if (/^(table)$/i.test(tagName)) {
                        return "table";
                    } else if (/^(tbody)$/i.test(tagName)) {
                        return "table-row-group";
                    } else {
                        return "block";
                    }
                },
                addClass: function(element, className) {
                    if (element.classList) {
                        element.classList.add(className);
                    } else {
                        element.className += (element.className.length ? " " : "") + className;
                    }
                },
                removeClass: function(element, className) {
                    if (element.classList) {
                        element.classList.remove(className);
                    } else {
                        element.className = element.className.toString().replace(new RegExp("(^|\\s)" + className.split(" ").join("|") + "(\\s|$)", "gi"), " ");
                    }
                }
            },
            getPropertyValue: function(element, property, rootPropertyValue, forceStyleLookup) {
                function computePropertyValue(element, property) {
                    var computedValue = 0;
                    if (IE <= 8) {
                        computedValue = $.css(element, property);
                    } else {
                        var toggleDisplay = false;
                        if (/^(width|height)$/.test(property) && CSS.getPropertyValue(element, "display") === 0) {
                            toggleDisplay = true;
                            CSS.setPropertyValue(element, "display", CSS.Values.getDisplayType(element));
                        }
                        function revertDisplay() {
                            if (toggleDisplay) {
                                CSS.setPropertyValue(element, "display", "none");
                            }
                        }
                        if (!forceStyleLookup) {
                            if (property === "height" && CSS.getPropertyValue(element, "boxSizing").toString().toLowerCase() !== "border-box") {
                                var contentBoxHeight = element.offsetHeight - (parseFloat(CSS.getPropertyValue(element, "borderTopWidth")) || 0) - (parseFloat(CSS.getPropertyValue(element, "borderBottomWidth")) || 0) - (parseFloat(CSS.getPropertyValue(element, "paddingTop")) || 0) - (parseFloat(CSS.getPropertyValue(element, "paddingBottom")) || 0);
                                revertDisplay();
                                return contentBoxHeight;
                            } else if (property === "width" && CSS.getPropertyValue(element, "boxSizing").toString().toLowerCase() !== "border-box") {
                                var contentBoxWidth = element.offsetWidth - (parseFloat(CSS.getPropertyValue(element, "borderLeftWidth")) || 0) - (parseFloat(CSS.getPropertyValue(element, "borderRightWidth")) || 0) - (parseFloat(CSS.getPropertyValue(element, "paddingLeft")) || 0) - (parseFloat(CSS.getPropertyValue(element, "paddingRight")) || 0);
                                revertDisplay();
                                return contentBoxWidth;
                            }
                        }
                        var computedStyle;
                        if (Data(element) === undefined) {
                            computedStyle = window.getComputedStyle(element, null);
                        } else if (!Data(element).computedStyle) {
                            computedStyle = Data(element).computedStyle = window.getComputedStyle(element, null);
                        } else {
                            computedStyle = Data(element).computedStyle;
                        }
                        if (property === "borderColor") {
                            property = "borderTopColor";
                        }
                        if (IE === 9 && property === "filter") {
                            computedValue = computedStyle.getPropertyValue(property);
                        } else {
                            computedValue = computedStyle[property];
                        }
                        if (computedValue === "" || computedValue === null) {
                            computedValue = element.style[property];
                        }
                        revertDisplay();
                    }
                    if (computedValue === "auto" && /^(top|right|bottom|left)$/i.test(property)) {
                        var position = computePropertyValue(element, "position");
                        if (position === "fixed" || position === "absolute" && /top|left/i.test(property)) {
                            computedValue = $(element).position()[property] + "px";
                        }
                    }
                    return computedValue;
                }
                var propertyValue;
                if (CSS.Hooks.registered[property]) {
                    var hook = property, hookRoot = CSS.Hooks.getRoot(hook);
                    if (rootPropertyValue === undefined) {
                        rootPropertyValue = CSS.getPropertyValue(element, CSS.Names.prefixCheck(hookRoot)[0]);
                    }
                    if (CSS.Normalizations.registered[hookRoot]) {
                        rootPropertyValue = CSS.Normalizations.registered[hookRoot]("extract", element, rootPropertyValue);
                    }
                    propertyValue = CSS.Hooks.extractValue(hook, rootPropertyValue);
                } else if (CSS.Normalizations.registered[property]) {
                    var normalizedPropertyName, normalizedPropertyValue;
                    normalizedPropertyName = CSS.Normalizations.registered[property]("name", element);
                    if (normalizedPropertyName !== "transform") {
                        normalizedPropertyValue = computePropertyValue(element, CSS.Names.prefixCheck(normalizedPropertyName)[0]);
                        if (CSS.Values.isCSSNullValue(normalizedPropertyValue) && CSS.Hooks.templates[property]) {
                            normalizedPropertyValue = CSS.Hooks.templates[property][1];
                        }
                    }
                    propertyValue = CSS.Normalizations.registered[property]("extract", element, normalizedPropertyValue);
                }
                if (!/^[\d-]/.test(propertyValue)) {
                    if (Data(element) && Data(element).isSVG && CSS.Names.SVGAttribute(property)) {
                        if (/^(height|width)$/i.test(property)) {
                            try {
                                propertyValue = element.getBBox()[property];
                            } catch (error) {
                                propertyValue = 0;
                            }
                        } else {
                            propertyValue = element.getAttribute(property);
                        }
                    } else {
                        propertyValue = computePropertyValue(element, CSS.Names.prefixCheck(property)[0]);
                    }
                }
                if (CSS.Values.isCSSNullValue(propertyValue)) {
                    propertyValue = 0;
                }
                if (Velocity.debug >= 2) console.log("Get " + property + ": " + propertyValue);
                return propertyValue;
            },
            setPropertyValue: function(element, property, propertyValue, rootPropertyValue, scrollData) {
                var propertyName = property;
                if (property === "scroll") {
                    if (scrollData.container) {
                        scrollData.container["scroll" + scrollData.direction] = propertyValue;
                    } else {
                        if (scrollData.direction === "Left") {
                            window.scrollTo(propertyValue, scrollData.alternateValue);
                        } else {
                            window.scrollTo(scrollData.alternateValue, propertyValue);
                        }
                    }
                } else {
                    if (CSS.Normalizations.registered[property] && CSS.Normalizations.registered[property]("name", element) === "transform") {
                        CSS.Normalizations.registered[property]("inject", element, propertyValue);
                        propertyName = "transform";
                        propertyValue = Data(element).transformCache[property];
                    } else {
                        if (CSS.Hooks.registered[property]) {
                            var hookName = property, hookRoot = CSS.Hooks.getRoot(property);
                            rootPropertyValue = rootPropertyValue || CSS.getPropertyValue(element, hookRoot);
                            propertyValue = CSS.Hooks.injectValue(hookName, propertyValue, rootPropertyValue);
                            property = hookRoot;
                        }
                        if (CSS.Normalizations.registered[property]) {
                            propertyValue = CSS.Normalizations.registered[property]("inject", element, propertyValue);
                            property = CSS.Normalizations.registered[property]("name", element);
                        }
                        propertyName = CSS.Names.prefixCheck(property)[0];
                        if (IE <= 8) {
                            try {
                                element.style[propertyName] = propertyValue;
                            } catch (error) {
                                if (Velocity.debug) console.log("Browser does not support [" + propertyValue + "] for [" + propertyName + "]");
                            }
                        } else if (Data(element) && Data(element).isSVG && CSS.Names.SVGAttribute(property)) {
                            element.setAttribute(property, propertyValue);
                        } else {
                            element.style[propertyName] = propertyValue;
                        }
                        if (Velocity.debug >= 2) console.log("Set " + property + " (" + propertyName + "): " + propertyValue);
                    }
                }
                return [ propertyName, propertyValue ];
            },
            flushTransformCache: function(element) {
                var transformString = "";
                if ((IE || Velocity.State.isAndroid && !Velocity.State.isChrome) && Data(element).isSVG) {
                    function getTransformFloat(transformProperty) {
                        return parseFloat(CSS.getPropertyValue(element, transformProperty));
                    }
                    var SVGTransforms = {
                        translate: [ getTransformFloat("translateX"), getTransformFloat("translateY") ],
                        skewX: [ getTransformFloat("skewX") ],
                        skewY: [ getTransformFloat("skewY") ],
                        scale: getTransformFloat("scale") !== 1 ? [ getTransformFloat("scale"), getTransformFloat("scale") ] : [ getTransformFloat("scaleX"), getTransformFloat("scaleY") ],
                        rotate: [ getTransformFloat("rotateZ"), 0, 0 ]
                    };
                    $.each(Data(element).transformCache, function(transformName) {
                        if (/^translate/i.test(transformName)) {
                            transformName = "translate";
                        } else if (/^scale/i.test(transformName)) {
                            transformName = "scale";
                        } else if (/^rotate/i.test(transformName)) {
                            transformName = "rotate";
                        }
                        if (SVGTransforms[transformName]) {
                            transformString += transformName + "(" + SVGTransforms[transformName].join(" ") + ")" + " ";
                            delete SVGTransforms[transformName];
                        }
                    });
                } else {
                    var transformValue, perspective;
                    $.each(Data(element).transformCache, function(transformName) {
                        transformValue = Data(element).transformCache[transformName];
                        if (transformName === "transformPerspective") {
                            perspective = transformValue;
                            return true;
                        }
                        if (IE === 9 && transformName === "rotateZ") {
                            transformName = "rotate";
                        }
                        transformString += transformName + transformValue + " ";
                    });
                    if (perspective) {
                        transformString = "perspective" + perspective + " " + transformString;
                    }
                }
                CSS.setPropertyValue(element, "transform", transformString);
            }
        };
        CSS.Hooks.register();
        CSS.Normalizations.register();
        Velocity.hook = function(elements, arg2, arg3) {
            var value = undefined;
            elements = sanitizeElements(elements);
            $.each(elements, function(i, element) {
                if (Data(element) === undefined) {
                    Velocity.init(element);
                }
                if (arg3 === undefined) {
                    if (value === undefined) {
                        value = Velocity.CSS.getPropertyValue(element, arg2);
                    }
                } else {
                    var adjustedSet = Velocity.CSS.setPropertyValue(element, arg2, arg3);
                    if (adjustedSet[0] === "transform") {
                        Velocity.CSS.flushTransformCache(element);
                    }
                    value = adjustedSet;
                }
            });
            return value;
        };
        var animate = function() {
            function getChain() {
                if (isUtility) {
                    return promiseData.promise || null;
                } else {
                    return elementsWrapped;
                }
            }
            var syntacticSugar = arguments[0] && (arguments[0].p || ($.isPlainObject(arguments[0].properties) && !arguments[0].properties.names || Type.isString(arguments[0].properties))), isUtility, elementsWrapped, argumentIndex;
            var elements, propertiesMap, options;
            if (Type.isWrapped(this)) {
                isUtility = false;
                argumentIndex = 0;
                elements = this;
                elementsWrapped = this;
            } else {
                isUtility = true;
                argumentIndex = 1;
                elements = syntacticSugar ? arguments[0].elements || arguments[0].e : arguments[0];
            }
            elements = sanitizeElements(elements);
            if (!elements) {
                return;
            }
            if (syntacticSugar) {
                propertiesMap = arguments[0].properties || arguments[0].p;
                options = arguments[0].options || arguments[0].o;
            } else {
                propertiesMap = arguments[argumentIndex];
                options = arguments[argumentIndex + 1];
            }
            var elementsLength = elements.length, elementsIndex = 0;
            if (!/^(stop|finish|finishAll)$/i.test(propertiesMap) && !$.isPlainObject(options)) {
                var startingArgumentPosition = argumentIndex + 1;
                options = {};
                for (var i = startingArgumentPosition; i < arguments.length; i++) {
                    if (!Type.isArray(arguments[i]) && (/^(fast|normal|slow)$/i.test(arguments[i]) || /^\d/.test(arguments[i]))) {
                        options.duration = arguments[i];
                    } else if (Type.isString(arguments[i]) || Type.isArray(arguments[i])) {
                        options.easing = arguments[i];
                    } else if (Type.isFunction(arguments[i])) {
                        options.complete = arguments[i];
                    }
                }
            }
            var promiseData = {
                promise: null,
                resolver: null,
                rejecter: null
            };
            if (isUtility && Velocity.Promise) {
                promiseData.promise = new Velocity.Promise(function(resolve, reject) {
                    promiseData.resolver = resolve;
                    promiseData.rejecter = reject;
                });
            }
            var action;
            switch (propertiesMap) {
              case "scroll":
                action = "scroll";
                break;

              case "reverse":
                action = "reverse";
                break;

              case "finish":
              case "finishAll":
              case "stop":
                $.each(elements, function(i, element) {
                    if (Data(element) && Data(element).delayTimer) {
                        clearTimeout(Data(element).delayTimer.setTimeout);
                        if (Data(element).delayTimer.next) {
                            Data(element).delayTimer.next();
                        }
                        delete Data(element).delayTimer;
                    }
                    if (propertiesMap === "finishAll" && (options === true || Type.isString(options))) {
                        $.each($.queue(element, Type.isString(options) ? options : ""), function(_, item) {
                            if (Type.isFunction(item)) {
                                item();
                            }
                        });
                        $.queue(element, Type.isString(options) ? options : "", []);
                    }
                });
                var callsToStop = [];
                $.each(Velocity.State.calls, function(i, activeCall) {
                    if (activeCall) {
                        $.each(activeCall[1], function(k, activeElement) {
                            var queueName = options === undefined ? "" : options;
                            if (queueName !== true && activeCall[2].queue !== queueName && !(options === undefined && activeCall[2].queue === false)) {
                                return true;
                            }
                            $.each(elements, function(l, element) {
                                if (element === activeElement) {
                                    if (options === true || Type.isString(options)) {
                                        $.each($.queue(element, Type.isString(options) ? options : ""), function(_, item) {
                                            if (Type.isFunction(item)) {
                                                item(null, true);
                                            }
                                        });
                                        $.queue(element, Type.isString(options) ? options : "", []);
                                    }
                                    if (propertiesMap === "stop") {
                                        if (Data(element) && Data(element).tweensContainer && queueName !== false) {
                                            $.each(Data(element).tweensContainer, function(m, activeTween) {
                                                activeTween.endValue = activeTween.currentValue;
                                            });
                                        }
                                        callsToStop.push(i);
                                    } else if (propertiesMap === "finish" || propertiesMap === "finishAll") {
                                        activeCall[2].duration = 1;
                                    }
                                }
                            });
                        });
                    }
                });
                if (propertiesMap === "stop") {
                    $.each(callsToStop, function(i, j) {
                        completeCall(j, true);
                    });
                    if (promiseData.promise) {
                        promiseData.resolver(elements);
                    }
                }
                return getChain();

              default:
                if ($.isPlainObject(propertiesMap) && !Type.isEmptyObject(propertiesMap)) {
                    action = "start";
                } else if (Type.isString(propertiesMap) && Velocity.Redirects[propertiesMap]) {
                    var opts = $.extend({}, options), durationOriginal = opts.duration, delayOriginal = opts.delay || 0;
                    if (opts.backwards === true) {
                        elements = $.extend(true, [], elements).reverse();
                    }
                    $.each(elements, function(elementIndex, element) {
                        if (parseFloat(opts.stagger)) {
                            opts.delay = delayOriginal + parseFloat(opts.stagger) * elementIndex;
                        } else if (Type.isFunction(opts.stagger)) {
                            opts.delay = delayOriginal + opts.stagger.call(element, elementIndex, elementsLength);
                        }
                        if (opts.drag) {
                            opts.duration = parseFloat(durationOriginal) || (/^(callout|transition)/.test(propertiesMap) ? 1e3 : DURATION_DEFAULT);
                            opts.duration = Math.max(opts.duration * (opts.backwards ? 1 - elementIndex / elementsLength : (elementIndex + 1) / elementsLength), opts.duration * .75, 200);
                        }
                        Velocity.Redirects[propertiesMap].call(element, element, opts || {}, elementIndex, elementsLength, elements, promiseData.promise ? promiseData : undefined);
                    });
                    return getChain();
                } else {
                    var abortError = "Velocity: First argument (" + propertiesMap + ") was not a property map, a known action, or a registered redirect. Aborting.";
                    if (promiseData.promise) {
                        promiseData.rejecter(new Error(abortError));
                    } else {
                        console.log(abortError);
                    }
                    return getChain();
                }
            }
            var callUnitConversionData = {
                lastParent: null,
                lastPosition: null,
                lastFontSize: null,
                lastPercentToPxWidth: null,
                lastPercentToPxHeight: null,
                lastEmToPx: null,
                remToPx: null,
                vwToPx: null,
                vhToPx: null
            };
            var call = [];
            function processElement() {
                var element = this, opts = $.extend({}, Velocity.defaults, options), tweensContainer = {}, elementUnitConversionData;
                if (Data(element) === undefined) {
                    Velocity.init(element);
                }
                if (parseFloat(opts.delay) && opts.queue !== false) {
                    $.queue(element, opts.queue, function(next) {
                        Velocity.velocityQueueEntryFlag = true;
                        Data(element).delayTimer = {
                            setTimeout: setTimeout(next, parseFloat(opts.delay)),
                            next: next
                        };
                    });
                }
                switch (opts.duration.toString().toLowerCase()) {
                  case "fast":
                    opts.duration = 200;
                    break;

                  case "normal":
                    opts.duration = DURATION_DEFAULT;
                    break;

                  case "slow":
                    opts.duration = 600;
                    break;

                  default:
                    opts.duration = parseFloat(opts.duration) || 1;
                }
                if (Velocity.mock !== false) {
                    if (Velocity.mock === true) {
                        opts.duration = opts.delay = 1;
                    } else {
                        opts.duration *= parseFloat(Velocity.mock) || 1;
                        opts.delay *= parseFloat(Velocity.mock) || 1;
                    }
                }
                opts.easing = getEasing(opts.easing, opts.duration);
                if (opts.begin && !Type.isFunction(opts.begin)) {
                    opts.begin = null;
                }
                if (opts.progress && !Type.isFunction(opts.progress)) {
                    opts.progress = null;
                }
                if (opts.complete && !Type.isFunction(opts.complete)) {
                    opts.complete = null;
                }
                if (opts.display !== undefined && opts.display !== null) {
                    opts.display = opts.display.toString().toLowerCase();
                    if (opts.display === "auto") {
                        opts.display = Velocity.CSS.Values.getDisplayType(element);
                    }
                }
                if (opts.visibility !== undefined && opts.visibility !== null) {
                    opts.visibility = opts.visibility.toString().toLowerCase();
                }
                opts.mobileHA = opts.mobileHA && Velocity.State.isMobile && !Velocity.State.isGingerbread;
                function buildQueue(next) {
                    if (opts.begin && elementsIndex === 0) {
                        try {
                            opts.begin.call(elements, elements);
                        } catch (error) {
                            setTimeout(function() {
                                throw error;
                            }, 1);
                        }
                    }
                    if (action === "scroll") {
                        var scrollDirection = /^x$/i.test(opts.axis) ? "Left" : "Top", scrollOffset = parseFloat(opts.offset) || 0, scrollPositionCurrent, scrollPositionCurrentAlternate, scrollPositionEnd;
                        if (opts.container) {
                            if (Type.isWrapped(opts.container) || Type.isNode(opts.container)) {
                                opts.container = opts.container[0] || opts.container;
                                scrollPositionCurrent = opts.container["scroll" + scrollDirection];
                                scrollPositionEnd = scrollPositionCurrent + $(element).position()[scrollDirection.toLowerCase()] + scrollOffset;
                            } else {
                                opts.container = null;
                            }
                        } else {
                            scrollPositionCurrent = Velocity.State.scrollAnchor[Velocity.State["scrollProperty" + scrollDirection]];
                            scrollPositionCurrentAlternate = Velocity.State.scrollAnchor[Velocity.State["scrollProperty" + (scrollDirection === "Left" ? "Top" : "Left")]];
                            scrollPositionEnd = $(element).offset()[scrollDirection.toLowerCase()] + scrollOffset;
                        }
                        tweensContainer = {
                            scroll: {
                                rootPropertyValue: false,
                                startValue: scrollPositionCurrent,
                                currentValue: scrollPositionCurrent,
                                endValue: scrollPositionEnd,
                                unitType: "",
                                easing: opts.easing,
                                scrollData: {
                                    container: opts.container,
                                    direction: scrollDirection,
                                    alternateValue: scrollPositionCurrentAlternate
                                }
                            },
                            element: element
                        };
                        if (Velocity.debug) console.log("tweensContainer (scroll): ", tweensContainer.scroll, element);
                    } else if (action === "reverse") {
                        if (!Data(element).tweensContainer) {
                            $.dequeue(element, opts.queue);
                            return;
                        } else {
                            if (Data(element).opts.display === "none") {
                                Data(element).opts.display = "auto";
                            }
                            if (Data(element).opts.visibility === "hidden") {
                                Data(element).opts.visibility = "visible";
                            }
                            Data(element).opts.loop = false;
                            Data(element).opts.begin = null;
                            Data(element).opts.complete = null;
                            if (!options.easing) {
                                delete opts.easing;
                            }
                            if (!options.duration) {
                                delete opts.duration;
                            }
                            opts = $.extend({}, Data(element).opts, opts);
                            var lastTweensContainer = $.extend(true, {}, Data(element).tweensContainer);
                            for (var lastTween in lastTweensContainer) {
                                if (lastTween !== "element") {
                                    var lastStartValue = lastTweensContainer[lastTween].startValue;
                                    lastTweensContainer[lastTween].startValue = lastTweensContainer[lastTween].currentValue = lastTweensContainer[lastTween].endValue;
                                    lastTweensContainer[lastTween].endValue = lastStartValue;
                                    if (!Type.isEmptyObject(options)) {
                                        lastTweensContainer[lastTween].easing = opts.easing;
                                    }
                                    if (Velocity.debug) console.log("reverse tweensContainer (" + lastTween + "): " + JSON.stringify(lastTweensContainer[lastTween]), element);
                                }
                            }
                            tweensContainer = lastTweensContainer;
                        }
                    } else if (action === "start") {
                        var lastTweensContainer;
                        if (Data(element).tweensContainer && Data(element).isAnimating === true) {
                            lastTweensContainer = Data(element).tweensContainer;
                        }
                        function parsePropertyValue(valueData, skipResolvingEasing) {
                            var endValue = undefined, easing = undefined, startValue = undefined;
                            if (Type.isArray(valueData)) {
                                endValue = valueData[0];
                                if (!Type.isArray(valueData[1]) && /^[\d-]/.test(valueData[1]) || Type.isFunction(valueData[1]) || CSS.RegEx.isHex.test(valueData[1])) {
                                    startValue = valueData[1];
                                } else if (Type.isString(valueData[1]) && !CSS.RegEx.isHex.test(valueData[1]) || Type.isArray(valueData[1])) {
                                    easing = skipResolvingEasing ? valueData[1] : getEasing(valueData[1], opts.duration);
                                    if (valueData[2] !== undefined) {
                                        startValue = valueData[2];
                                    }
                                }
                            } else {
                                endValue = valueData;
                            }
                            if (!skipResolvingEasing) {
                                easing = easing || opts.easing;
                            }
                            if (Type.isFunction(endValue)) {
                                endValue = endValue.call(element, elementsIndex, elementsLength);
                            }
                            if (Type.isFunction(startValue)) {
                                startValue = startValue.call(element, elementsIndex, elementsLength);
                            }
                            return [ endValue || 0, easing, startValue ];
                        }
                        $.each(propertiesMap, function(property, value) {
                            if (RegExp("^" + CSS.Lists.colors.join("$|^") + "$").test(property)) {
                                var valueData = parsePropertyValue(value, true), endValue = valueData[0], easing = valueData[1], startValue = valueData[2];
                                if (CSS.RegEx.isHex.test(endValue)) {
                                    var colorComponents = [ "Red", "Green", "Blue" ], endValueRGB = CSS.Values.hexToRgb(endValue), startValueRGB = startValue ? CSS.Values.hexToRgb(startValue) : undefined;
                                    for (var i = 0; i < colorComponents.length; i++) {
                                        var dataArray = [ endValueRGB[i] ];
                                        if (easing) {
                                            dataArray.push(easing);
                                        }
                                        if (startValueRGB !== undefined) {
                                            dataArray.push(startValueRGB[i]);
                                        }
                                        propertiesMap[property + colorComponents[i]] = dataArray;
                                    }
                                    delete propertiesMap[property];
                                }
                            }
                        });
                        for (var property in propertiesMap) {
                            var valueData = parsePropertyValue(propertiesMap[property]), endValue = valueData[0], easing = valueData[1], startValue = valueData[2];
                            property = CSS.Names.camelCase(property);
                            var rootProperty = CSS.Hooks.getRoot(property), rootPropertyValue = false;
                            if (!Data(element).isSVG && rootProperty !== "tween" && CSS.Names.prefixCheck(rootProperty)[1] === false && CSS.Normalizations.registered[rootProperty] === undefined) {
                                if (Velocity.debug) console.log("Skipping [" + rootProperty + "] due to a lack of browser support.");
                                continue;
                            }
                            if ((opts.display !== undefined && opts.display !== null && opts.display !== "none" || opts.visibility !== undefined && opts.visibility !== "hidden") && /opacity|filter/.test(property) && !startValue && endValue !== 0) {
                                startValue = 0;
                            }
                            if (opts._cacheValues && lastTweensContainer && lastTweensContainer[property]) {
                                if (startValue === undefined) {
                                    startValue = lastTweensContainer[property].endValue + lastTweensContainer[property].unitType;
                                }
                                rootPropertyValue = Data(element).rootPropertyValueCache[rootProperty];
                            } else {
                                if (CSS.Hooks.registered[property]) {
                                    if (startValue === undefined) {
                                        rootPropertyValue = CSS.getPropertyValue(element, rootProperty);
                                        startValue = CSS.getPropertyValue(element, property, rootPropertyValue);
                                    } else {
                                        rootPropertyValue = CSS.Hooks.templates[rootProperty][1];
                                    }
                                } else if (startValue === undefined) {
                                    startValue = CSS.getPropertyValue(element, property);
                                }
                            }
                            var separatedValue, endValueUnitType, startValueUnitType, operator = false;
                            function separateValue(property, value) {
                                var unitType, numericValue;
                                numericValue = (value || "0").toString().toLowerCase().replace(/[%A-z]+$/, function(match) {
                                    unitType = match;
                                    return "";
                                });
                                if (!unitType) {
                                    unitType = CSS.Values.getUnitType(property);
                                }
                                return [ numericValue, unitType ];
                            }
                            separatedValue = separateValue(property, startValue);
                            startValue = separatedValue[0];
                            startValueUnitType = separatedValue[1];
                            separatedValue = separateValue(property, endValue);
                            endValue = separatedValue[0].replace(/^([+-\/*])=/, function(match, subMatch) {
                                operator = subMatch;
                                return "";
                            });
                            endValueUnitType = separatedValue[1];
                            startValue = parseFloat(startValue) || 0;
                            endValue = parseFloat(endValue) || 0;
                            if (endValueUnitType === "%") {
                                if (/^(fontSize|lineHeight)$/.test(property)) {
                                    endValue = endValue / 100;
                                    endValueUnitType = "em";
                                } else if (/^scale/.test(property)) {
                                    endValue = endValue / 100;
                                    endValueUnitType = "";
                                } else if (/(Red|Green|Blue)$/i.test(property)) {
                                    endValue = endValue / 100 * 255;
                                    endValueUnitType = "";
                                }
                            }
                            function calculateUnitRatios() {
                                var sameRatioIndicators = {
                                    myParent: element.parentNode || document.body,
                                    position: CSS.getPropertyValue(element, "position"),
                                    fontSize: CSS.getPropertyValue(element, "fontSize")
                                }, samePercentRatio = sameRatioIndicators.position === callUnitConversionData.lastPosition && sameRatioIndicators.myParent === callUnitConversionData.lastParent, sameEmRatio = sameRatioIndicators.fontSize === callUnitConversionData.lastFontSize;
                                callUnitConversionData.lastParent = sameRatioIndicators.myParent;
                                callUnitConversionData.lastPosition = sameRatioIndicators.position;
                                callUnitConversionData.lastFontSize = sameRatioIndicators.fontSize;
                                var measurement = 100, unitRatios = {};
                                if (!sameEmRatio || !samePercentRatio) {
                                    var dummy = Data(element).isSVG ? document.createElementNS("http://www.w3.org/2000/svg", "rect") : document.createElement("div");
                                    Velocity.init(dummy);
                                    sameRatioIndicators.myParent.appendChild(dummy);
                                    $.each([ "overflow", "overflowX", "overflowY" ], function(i, property) {
                                        Velocity.CSS.setPropertyValue(dummy, property, "hidden");
                                    });
                                    Velocity.CSS.setPropertyValue(dummy, "position", sameRatioIndicators.position);
                                    Velocity.CSS.setPropertyValue(dummy, "fontSize", sameRatioIndicators.fontSize);
                                    Velocity.CSS.setPropertyValue(dummy, "boxSizing", "content-box");
                                    $.each([ "minWidth", "maxWidth", "width", "minHeight", "maxHeight", "height" ], function(i, property) {
                                        Velocity.CSS.setPropertyValue(dummy, property, measurement + "%");
                                    });
                                    Velocity.CSS.setPropertyValue(dummy, "paddingLeft", measurement + "em");
                                    unitRatios.percentToPxWidth = callUnitConversionData.lastPercentToPxWidth = (parseFloat(CSS.getPropertyValue(dummy, "width", null, true)) || 1) / measurement;
                                    unitRatios.percentToPxHeight = callUnitConversionData.lastPercentToPxHeight = (parseFloat(CSS.getPropertyValue(dummy, "height", null, true)) || 1) / measurement;
                                    unitRatios.emToPx = callUnitConversionData.lastEmToPx = (parseFloat(CSS.getPropertyValue(dummy, "paddingLeft")) || 1) / measurement;
                                    sameRatioIndicators.myParent.removeChild(dummy);
                                } else {
                                    unitRatios.emToPx = callUnitConversionData.lastEmToPx;
                                    unitRatios.percentToPxWidth = callUnitConversionData.lastPercentToPxWidth;
                                    unitRatios.percentToPxHeight = callUnitConversionData.lastPercentToPxHeight;
                                }
                                if (callUnitConversionData.remToPx === null) {
                                    callUnitConversionData.remToPx = parseFloat(CSS.getPropertyValue(document.body, "fontSize")) || 16;
                                }
                                if (callUnitConversionData.vwToPx === null) {
                                    callUnitConversionData.vwToPx = parseFloat(window.innerWidth) / 100;
                                    callUnitConversionData.vhToPx = parseFloat(window.innerHeight) / 100;
                                }
                                unitRatios.remToPx = callUnitConversionData.remToPx;
                                unitRatios.vwToPx = callUnitConversionData.vwToPx;
                                unitRatios.vhToPx = callUnitConversionData.vhToPx;
                                if (Velocity.debug >= 1) console.log("Unit ratios: " + JSON.stringify(unitRatios), element);
                                return unitRatios;
                            }
                            if (/[\/*]/.test(operator)) {
                                endValueUnitType = startValueUnitType;
                            } else if (startValueUnitType !== endValueUnitType && startValue !== 0) {
                                if (endValue === 0) {
                                    endValueUnitType = startValueUnitType;
                                } else {
                                    elementUnitConversionData = elementUnitConversionData || calculateUnitRatios();
                                    var axis = /margin|padding|left|right|width|text|word|letter/i.test(property) || /X$/.test(property) || property === "x" ? "x" : "y";
                                    switch (startValueUnitType) {
                                      case "%":
                                        startValue *= axis === "x" ? elementUnitConversionData.percentToPxWidth : elementUnitConversionData.percentToPxHeight;
                                        break;

                                      case "px":
                                        break;

                                      default:
                                        startValue *= elementUnitConversionData[startValueUnitType + "ToPx"];
                                    }
                                    switch (endValueUnitType) {
                                      case "%":
                                        startValue *= 1 / (axis === "x" ? elementUnitConversionData.percentToPxWidth : elementUnitConversionData.percentToPxHeight);
                                        break;

                                      case "px":
                                        break;

                                      default:
                                        startValue *= 1 / elementUnitConversionData[endValueUnitType + "ToPx"];
                                    }
                                }
                            }
                            switch (operator) {
                              case "+":
                                endValue = startValue + endValue;
                                break;

                              case "-":
                                endValue = startValue - endValue;
                                break;

                              case "*":
                                endValue = startValue * endValue;
                                break;

                              case "/":
                                endValue = startValue / endValue;
                                break;
                            }
                            tweensContainer[property] = {
                                rootPropertyValue: rootPropertyValue,
                                startValue: startValue,
                                currentValue: startValue,
                                endValue: endValue,
                                unitType: endValueUnitType,
                                easing: easing
                            };
                            if (Velocity.debug) console.log("tweensContainer (" + property + "): " + JSON.stringify(tweensContainer[property]), element);
                        }
                        tweensContainer.element = element;
                    }
                    if (tweensContainer.element) {
                        CSS.Values.addClass(element, "velocity-animating");
                        call.push(tweensContainer);
                        if (opts.queue === "") {
                            Data(element).tweensContainer = tweensContainer;
                            Data(element).opts = opts;
                        }
                        Data(element).isAnimating = true;
                        if (elementsIndex === elementsLength - 1) {
                            Velocity.State.calls.push([ call, elements, opts, null, promiseData.resolver ]);
                            if (Velocity.State.isTicking === false) {
                                Velocity.State.isTicking = true;
                                tick();
                            }
                        } else {
                            elementsIndex++;
                        }
                    }
                }
                if (opts.queue === false) {
                    if (opts.delay) {
                        setTimeout(buildQueue, opts.delay);
                    } else {
                        buildQueue();
                    }
                } else {
                    $.queue(element, opts.queue, function(next, clearQueue) {
                        if (clearQueue === true) {
                            if (promiseData.promise) {
                                promiseData.resolver(elements);
                            }
                            return true;
                        }
                        Velocity.velocityQueueEntryFlag = true;
                        buildQueue(next);
                    });
                }
                if ((opts.queue === "" || opts.queue === "fx") && $.queue(element)[0] !== "inprogress") {
                    $.dequeue(element);
                }
            }
            $.each(elements, function(i, element) {
                if (Type.isNode(element)) {
                    processElement.call(element);
                }
            });
            var opts = $.extend({}, Velocity.defaults, options), reverseCallsCount;
            opts.loop = parseInt(opts.loop);
            reverseCallsCount = opts.loop * 2 - 1;
            if (opts.loop) {
                for (var x = 0; x < reverseCallsCount; x++) {
                    var reverseOptions = {
                        delay: opts.delay,
                        progress: opts.progress
                    };
                    if (x === reverseCallsCount - 1) {
                        reverseOptions.display = opts.display;
                        reverseOptions.visibility = opts.visibility;
                        reverseOptions.complete = opts.complete;
                    }
                    animate(elements, "reverse", reverseOptions);
                }
            }
            return getChain();
        };
        Velocity = $.extend(animate, Velocity);
        Velocity.animate = animate;
        var ticker = window.requestAnimationFrame || rAFShim;
        if (!Velocity.State.isMobile && document.hidden !== undefined) {
            document.addEventListener("visibilitychange", function() {
                if (document.hidden) {
                    ticker = function(callback) {
                        return setTimeout(function() {
                            callback(true);
                        }, 16);
                    };
                    tick();
                } else {
                    ticker = window.requestAnimationFrame || rAFShim;
                }
            });
        }
        function tick(timestamp) {
            if (timestamp) {
                var timeCurrent = new Date().getTime();
                var callsLength = Velocity.State.calls.length;
                if (callsLength > 1e4) {
                    Velocity.State.calls = compactSparseArray(Velocity.State.calls);
                }
                for (var i = 0; i < callsLength; i++) {
                    if (!Velocity.State.calls[i]) {
                        continue;
                    }
                    var callContainer = Velocity.State.calls[i], call = callContainer[0], opts = callContainer[2], timeStart = callContainer[3], firstTick = !!timeStart, tweenDummyValue = null;
                    if (!timeStart) {
                        timeStart = Velocity.State.calls[i][3] = timeCurrent - 16;
                    }
                    var percentComplete = Math.min((timeCurrent - timeStart) / opts.duration, 1);
                    for (var j = 0, callLength = call.length; j < callLength; j++) {
                        var tweensContainer = call[j], element = tweensContainer.element;
                        if (!Data(element)) {
                            continue;
                        }
                        var transformPropertyExists = false;
                        if (opts.display !== undefined && opts.display !== null && opts.display !== "none") {
                            if (opts.display === "flex") {
                                var flexValues = [ "-webkit-box", "-moz-box", "-ms-flexbox", "-webkit-flex" ];
                                $.each(flexValues, function(i, flexValue) {
                                    CSS.setPropertyValue(element, "display", flexValue);
                                });
                            }
                            CSS.setPropertyValue(element, "display", opts.display);
                        }
                        if (opts.visibility !== undefined && opts.visibility !== "hidden") {
                            CSS.setPropertyValue(element, "visibility", opts.visibility);
                        }
                        for (var property in tweensContainer) {
                            if (property !== "element") {
                                var tween = tweensContainer[property], currentValue, easing = Type.isString(tween.easing) ? Velocity.Easings[tween.easing] : tween.easing;
                                if (percentComplete === 1) {
                                    currentValue = tween.endValue;
                                } else {
                                    var tweenDelta = tween.endValue - tween.startValue;
                                    currentValue = tween.startValue + tweenDelta * easing(percentComplete, opts, tweenDelta);
                                    if (!firstTick && currentValue === tween.currentValue) {
                                        continue;
                                    }
                                }
                                tween.currentValue = currentValue;
                                if (property === "tween") {
                                    tweenDummyValue = currentValue;
                                } else {
                                    if (CSS.Hooks.registered[property]) {
                                        var hookRoot = CSS.Hooks.getRoot(property), rootPropertyValueCache = Data(element).rootPropertyValueCache[hookRoot];
                                        if (rootPropertyValueCache) {
                                            tween.rootPropertyValue = rootPropertyValueCache;
                                        }
                                    }
                                    var adjustedSetData = CSS.setPropertyValue(element, property, tween.currentValue + (parseFloat(currentValue) === 0 ? "" : tween.unitType), tween.rootPropertyValue, tween.scrollData);
                                    if (CSS.Hooks.registered[property]) {
                                        if (CSS.Normalizations.registered[hookRoot]) {
                                            Data(element).rootPropertyValueCache[hookRoot] = CSS.Normalizations.registered[hookRoot]("extract", null, adjustedSetData[1]);
                                        } else {
                                            Data(element).rootPropertyValueCache[hookRoot] = adjustedSetData[1];
                                        }
                                    }
                                    if (adjustedSetData[0] === "transform") {
                                        transformPropertyExists = true;
                                    }
                                }
                            }
                        }
                        if (opts.mobileHA) {
                            if (Data(element).transformCache.translate3d === undefined) {
                                Data(element).transformCache.translate3d = "(0px, 0px, 0px)";
                                transformPropertyExists = true;
                            }
                        }
                        if (transformPropertyExists) {
                            CSS.flushTransformCache(element);
                        }
                    }
                    if (opts.display !== undefined && opts.display !== "none") {
                        Velocity.State.calls[i][2].display = false;
                    }
                    if (opts.visibility !== undefined && opts.visibility !== "hidden") {
                        Velocity.State.calls[i][2].visibility = false;
                    }
                    if (opts.progress) {
                        opts.progress.call(callContainer[1], callContainer[1], percentComplete, Math.max(0, timeStart + opts.duration - timeCurrent), timeStart, tweenDummyValue);
                    }
                    if (percentComplete === 1) {
                        completeCall(i);
                    }
                }
            }
            if (Velocity.State.isTicking) {
                ticker(tick);
            }
        }
        function completeCall(callIndex, isStopped) {
            if (!Velocity.State.calls[callIndex]) {
                return false;
            }
            var call = Velocity.State.calls[callIndex][0], elements = Velocity.State.calls[callIndex][1], opts = Velocity.State.calls[callIndex][2], resolver = Velocity.State.calls[callIndex][4];
            var remainingCallsExist = false;
            for (var i = 0, callLength = call.length; i < callLength; i++) {
                var element = call[i].element;
                if (!isStopped && !opts.loop) {
                    if (opts.display === "none") {
                        CSS.setPropertyValue(element, "display", opts.display);
                    }
                    if (opts.visibility === "hidden") {
                        CSS.setPropertyValue(element, "visibility", opts.visibility);
                    }
                }
                if (opts.loop !== true && ($.queue(element)[1] === undefined || !/\.velocityQueueEntryFlag/i.test($.queue(element)[1]))) {
                    if (Data(element)) {
                        Data(element).isAnimating = false;
                        Data(element).rootPropertyValueCache = {};
                        var transformHAPropertyExists = false;
                        $.each(CSS.Lists.transforms3D, function(i, transformName) {
                            var defaultValue = /^scale/.test(transformName) ? 1 : 0, currentValue = Data(element).transformCache[transformName];
                            if (Data(element).transformCache[transformName] !== undefined && new RegExp("^\\(" + defaultValue + "[^.]").test(currentValue)) {
                                transformHAPropertyExists = true;
                                delete Data(element).transformCache[transformName];
                            }
                        });
                        if (opts.mobileHA) {
                            transformHAPropertyExists = true;
                            delete Data(element).transformCache.translate3d;
                        }
                        if (transformHAPropertyExists) {
                            CSS.flushTransformCache(element);
                        }
                        CSS.Values.removeClass(element, "velocity-animating");
                    }
                }
                if (!isStopped && opts.complete && !opts.loop && i === callLength - 1) {
                    try {
                        opts.complete.call(elements, elements);
                    } catch (error) {
                        setTimeout(function() {
                            throw error;
                        }, 1);
                    }
                }
                if (resolver && opts.loop !== true) {
                    resolver(elements);
                }
                if (Data(element) && opts.loop === true && !isStopped) {
                    $.each(Data(element).tweensContainer, function(propertyName, tweenContainer) {
                        if (/^rotate/.test(propertyName) && parseFloat(tweenContainer.endValue) === 360) {
                            tweenContainer.endValue = 0;
                            tweenContainer.startValue = 360;
                        }
                        if (/^backgroundPosition/.test(propertyName) && parseFloat(tweenContainer.endValue) === 100 && tweenContainer.unitType === "%") {
                            tweenContainer.endValue = 0;
                            tweenContainer.startValue = 100;
                        }
                    });
                    Velocity(element, "reverse", {
                        loop: true,
                        delay: opts.delay
                    });
                }
                if (opts.queue !== false) {
                    $.dequeue(element, opts.queue);
                }
            }
            Velocity.State.calls[callIndex] = false;
            for (var j = 0, callsLength = Velocity.State.calls.length; j < callsLength; j++) {
                if (Velocity.State.calls[j] !== false) {
                    remainingCallsExist = true;
                    break;
                }
            }
            if (remainingCallsExist === false) {
                Velocity.State.isTicking = false;
                delete Velocity.State.calls;
                Velocity.State.calls = [];
            }
        }
        global.Velocity = Velocity;
        if (global !== window) {
            global.fn.velocity = animate;
            global.fn.velocity.defaults = Velocity.defaults;
        }
        $.each([ "Down", "Up" ], function(i, direction) {
            Velocity.Redirects["slide" + direction] = function(element, options, elementsIndex, elementsSize, elements, promiseData) {
                var opts = $.extend({}, options), begin = opts.begin, complete = opts.complete, computedValues = {
                    height: "",
                    marginTop: "",
                    marginBottom: "",
                    paddingTop: "",
                    paddingBottom: ""
                }, inlineValues = {};
                if (opts.display === undefined) {
                    opts.display = direction === "Down" ? Velocity.CSS.Values.getDisplayType(element) === "inline" ? "inline-block" : "block" : "none";
                }
                opts.begin = function() {
                    begin && begin.call(elements, elements);
                    for (var property in computedValues) {
                        inlineValues[property] = element.style[property];
                        var propertyValue = Velocity.CSS.getPropertyValue(element, property);
                        computedValues[property] = direction === "Down" ? [ propertyValue, 0 ] : [ 0, propertyValue ];
                    }
                    inlineValues.overflow = element.style.overflow;
                    element.style.overflow = "hidden";
                };
                opts.complete = function() {
                    for (var property in inlineValues) {
                        element.style[property] = inlineValues[property];
                    }
                    complete && complete.call(elements, elements);
                    promiseData && promiseData.resolver(elements);
                };
                Velocity(element, computedValues, opts);
            };
        });
        $.each([ "In", "Out" ], function(i, direction) {
            Velocity.Redirects["fade" + direction] = function(element, options, elementsIndex, elementsSize, elements, promiseData) {
                var opts = $.extend({}, options), propertiesMap = {
                    opacity: direction === "In" ? 1 : 0
                }, originalComplete = opts.complete;
                if (elementsIndex !== elementsSize - 1) {
                    opts.complete = opts.begin = null;
                } else {
                    opts.complete = function() {
                        if (originalComplete) {
                            originalComplete.call(elements, elements);
                        }
                        promiseData && promiseData.resolver(elements);
                    };
                }
                if (opts.display === undefined) {
                    opts.display = direction === "In" ? "auto" : "none";
                }
                Velocity(this, propertiesMap, opts);
            };
        });
        return Velocity;
    }(window.jQuery || window.Zepto || window, window, document);
});

(function(factory) {
    if (typeof require === "function" && typeof exports === "object") {
        module.exports = factory();
    } else if (typeof define === "function" && define.amd) {
        define([ "velocity" ], factory);
    } else {
        factory();
    }
})(function() {
    return function(global, window, document, undefined) {
        if (!global.Velocity || !global.Velocity.Utilities) {
            window.console && console.log("Velocity UI Pack: Velocity must be loaded first. Aborting.");
            return;
        } else {
            var Velocity = global.Velocity, $ = Velocity.Utilities;
        }
        var velocityVersion = Velocity.version, requiredVersion = {
            major: 1,
            minor: 1,
            patch: 0
        };
        function greaterSemver(primary, secondary) {
            var versionInts = [];
            if (!primary || !secondary) {
                return false;
            }
            $.each([ primary, secondary ], function(i, versionObject) {
                var versionIntsComponents = [];
                $.each(versionObject, function(component, value) {
                    while (value.toString().length < 5) {
                        value = "0" + value;
                    }
                    versionIntsComponents.push(value);
                });
                versionInts.push(versionIntsComponents.join(""));
            });
            return parseFloat(versionInts[0]) > parseFloat(versionInts[1]);
        }
        if (greaterSemver(requiredVersion, velocityVersion)) {
            var abortError = "Velocity UI Pack: You need to update Velocity (jquery.velocity.js) to a newer version. Visit http://github.com/julianshapiro/velocity.";
            alert(abortError);
            throw new Error(abortError);
        }
        Velocity.RegisterEffect = Velocity.RegisterUI = function(effectName, properties) {
            function animateParentHeight(elements, direction, totalDuration, stagger) {
                var totalHeightDelta = 0, parentNode;
                $.each(elements.nodeType ? [ elements ] : elements, function(i, element) {
                    if (stagger) {
                        totalDuration += i * stagger;
                    }
                    parentNode = element.parentNode;
                    $.each([ "height", "paddingTop", "paddingBottom", "marginTop", "marginBottom" ], function(i, property) {
                        totalHeightDelta += parseFloat(Velocity.CSS.getPropertyValue(element, property));
                    });
                });
                Velocity.animate(parentNode, {
                    height: (direction === "In" ? "+" : "-") + "=" + totalHeightDelta
                }, {
                    queue: false,
                    easing: "ease-in-out",
                    duration: totalDuration * (direction === "In" ? .6 : 1)
                });
            }
            Velocity.Redirects[effectName] = function(element, redirectOptions, elementsIndex, elementsSize, elements, promiseData) {
                var finalElement = elementsIndex === elementsSize - 1;
                if (typeof properties.defaultDuration === "function") {
                    properties.defaultDuration = properties.defaultDuration.call(elements, elements);
                } else {
                    properties.defaultDuration = parseFloat(properties.defaultDuration);
                }
                for (var callIndex = 0; callIndex < properties.calls.length; callIndex++) {
                    var call = properties.calls[callIndex], propertyMap = call[0], redirectDuration = redirectOptions.duration || properties.defaultDuration || 1e3, durationPercentage = call[1], callOptions = call[2] || {}, opts = {};
                    opts.duration = redirectDuration * (durationPercentage || 1);
                    opts.queue = redirectOptions.queue || "";
                    opts.easing = callOptions.easing || "ease";
                    opts.delay = parseFloat(callOptions.delay) || 0;
                    opts._cacheValues = callOptions._cacheValues || true;
                    if (callIndex === 0) {
                        opts.delay += parseFloat(redirectOptions.delay) || 0;
                        if (elementsIndex === 0) {
                            opts.begin = function() {
                                redirectOptions.begin && redirectOptions.begin.call(elements, elements);
                                var direction = effectName.match(/(In|Out)$/);
                                if (direction && direction[0] === "In" && propertyMap.opacity !== undefined) {
                                    $.each(elements.nodeType ? [ elements ] : elements, function(i, element) {
                                        Velocity.CSS.setPropertyValue(element, "opacity", 0);
                                    });
                                }
                                if (redirectOptions.animateParentHeight && direction) {
                                    animateParentHeight(elements, direction[0], redirectDuration + opts.delay, redirectOptions.stagger);
                                }
                            };
                        }
                        if (redirectOptions.display !== null) {
                            if (redirectOptions.display !== undefined && redirectOptions.display !== "none") {
                                opts.display = redirectOptions.display;
                            } else if (/In$/.test(effectName)) {
                                var defaultDisplay = Velocity.CSS.Values.getDisplayType(element);
                                opts.display = defaultDisplay === "inline" ? "inline-block" : defaultDisplay;
                            }
                        }
                        if (redirectOptions.visibility && redirectOptions.visibility !== "hidden") {
                            opts.visibility = redirectOptions.visibility;
                        }
                    }
                    if (callIndex === properties.calls.length - 1) {
                        function injectFinalCallbacks() {
                            if ((redirectOptions.display === undefined || redirectOptions.display === "none") && /Out$/.test(effectName)) {
                                $.each(elements.nodeType ? [ elements ] : elements, function(i, element) {
                                    Velocity.CSS.setPropertyValue(element, "display", "none");
                                });
                            }
                            redirectOptions.complete && redirectOptions.complete.call(elements, elements);
                            if (promiseData) {
                                promiseData.resolver(elements || element);
                            }
                        }
                        opts.complete = function() {
                            if (properties.reset) {
                                for (var resetProperty in properties.reset) {
                                    var resetValue = properties.reset[resetProperty];
                                    if (Velocity.CSS.Hooks.registered[resetProperty] === undefined && (typeof resetValue === "string" || typeof resetValue === "number")) {
                                        properties.reset[resetProperty] = [ properties.reset[resetProperty], properties.reset[resetProperty] ];
                                    }
                                }
                                var resetOptions = {
                                    duration: 0,
                                    queue: false
                                };
                                if (finalElement) {
                                    resetOptions.complete = injectFinalCallbacks;
                                }
                                Velocity.animate(element, properties.reset, resetOptions);
                            } else if (finalElement) {
                                injectFinalCallbacks();
                            }
                        };
                        if (redirectOptions.visibility === "hidden") {
                            opts.visibility = redirectOptions.visibility;
                        }
                    }
                    Velocity.animate(element, propertyMap, opts);
                }
            };
            return Velocity;
        };
        Velocity.RegisterEffect.packagedEffects = {
            "callout.bounce": {
                defaultDuration: 550,
                calls: [ [ {
                    translateY: -30
                }, .25 ], [ {
                    translateY: 0
                }, .125 ], [ {
                    translateY: -15
                }, .125 ], [ {
                    translateY: 0
                }, .25 ] ]
            },
            "callout.shake": {
                defaultDuration: 800,
                calls: [ [ {
                    translateX: -11
                }, .125 ], [ {
                    translateX: 11
                }, .125 ], [ {
                    translateX: -11
                }, .125 ], [ {
                    translateX: 11
                }, .125 ], [ {
                    translateX: -11
                }, .125 ], [ {
                    translateX: 11
                }, .125 ], [ {
                    translateX: -11
                }, .125 ], [ {
                    translateX: 0
                }, .125 ] ]
            },
            "callout.flash": {
                defaultDuration: 1100,
                calls: [ [ {
                    opacity: [ 0, "easeInOutQuad", 1 ]
                }, .25 ], [ {
                    opacity: [ 1, "easeInOutQuad" ]
                }, .25 ], [ {
                    opacity: [ 0, "easeInOutQuad" ]
                }, .25 ], [ {
                    opacity: [ 1, "easeInOutQuad" ]
                }, .25 ] ]
            },
            "callout.pulse": {
                defaultDuration: 825,
                calls: [ [ {
                    scaleX: 1.1,
                    scaleY: 1.1
                }, .5, {
                    easing: "easeInExpo"
                } ], [ {
                    scaleX: 1,
                    scaleY: 1
                }, .5 ] ]
            },
            "callout.swing": {
                defaultDuration: 950,
                calls: [ [ {
                    rotateZ: 15
                }, .2 ], [ {
                    rotateZ: -10
                }, .2 ], [ {
                    rotateZ: 5
                }, .2 ], [ {
                    rotateZ: -5
                }, .2 ], [ {
                    rotateZ: 0
                }, .2 ] ]
            },
            "callout.tada": {
                defaultDuration: 1e3,
                calls: [ [ {
                    scaleX: .9,
                    scaleY: .9,
                    rotateZ: -3
                }, .1 ], [ {
                    scaleX: 1.1,
                    scaleY: 1.1,
                    rotateZ: 3
                }, .1 ], [ {
                    scaleX: 1.1,
                    scaleY: 1.1,
                    rotateZ: -3
                }, .1 ], [ "reverse", .125 ], [ "reverse", .125 ], [ "reverse", .125 ], [ "reverse", .125 ], [ "reverse", .125 ], [ {
                    scaleX: 1,
                    scaleY: 1,
                    rotateZ: 0
                }, .2 ] ]
            },
            "transition.fadeIn": {
                defaultDuration: 500,
                calls: [ [ {
                    opacity: [ 1, 0 ]
                } ] ]
            },
            "transition.fadeOut": {
                defaultDuration: 500,
                calls: [ [ {
                    opacity: [ 0, 1 ]
                } ] ]
            },
            "transition.flipXIn": {
                defaultDuration: 700,
                calls: [ [ {
                    opacity: [ 1, 0 ],
                    transformPerspective: [ 800, 800 ],
                    rotateY: [ 0, -55 ]
                } ] ],
                reset: {
                    transformPerspective: 0
                }
            },
            "transition.flipXOut": {
                defaultDuration: 700,
                calls: [ [ {
                    opacity: [ 0, 1 ],
                    transformPerspective: [ 800, 800 ],
                    rotateY: 55
                } ] ],
                reset: {
                    transformPerspective: 0,
                    rotateY: 0
                }
            },
            "transition.flipYIn": {
                defaultDuration: 800,
                calls: [ [ {
                    opacity: [ 1, 0 ],
                    transformPerspective: [ 800, 800 ],
                    rotateX: [ 0, -45 ]
                } ] ],
                reset: {
                    transformPerspective: 0
                }
            },
            "transition.flipYOut": {
                defaultDuration: 800,
                calls: [ [ {
                    opacity: [ 0, 1 ],
                    transformPerspective: [ 800, 800 ],
                    rotateX: 25
                } ] ],
                reset: {
                    transformPerspective: 0,
                    rotateX: 0
                }
            },
            "transition.flipBounceXIn": {
                defaultDuration: 900,
                calls: [ [ {
                    opacity: [ .725, 0 ],
                    transformPerspective: [ 400, 400 ],
                    rotateY: [ -10, 90 ]
                }, .5 ], [ {
                    opacity: .8,
                    rotateY: 10
                }, .25 ], [ {
                    opacity: 1,
                    rotateY: 0
                }, .25 ] ],
                reset: {
                    transformPerspective: 0
                }
            },
            "transition.flipBounceXOut": {
                defaultDuration: 800,
                calls: [ [ {
                    opacity: [ .9, 1 ],
                    transformPerspective: [ 400, 400 ],
                    rotateY: -10
                }, .5 ], [ {
                    opacity: 0,
                    rotateY: 90
                }, .5 ] ],
                reset: {
                    transformPerspective: 0,
                    rotateY: 0
                }
            },
            "transition.flipBounceYIn": {
                defaultDuration: 850,
                calls: [ [ {
                    opacity: [ .725, 0 ],
                    transformPerspective: [ 400, 400 ],
                    rotateX: [ -10, 90 ]
                }, .5 ], [ {
                    opacity: .8,
                    rotateX: 10
                }, .25 ], [ {
                    opacity: 1,
                    rotateX: 0
                }, .25 ] ],
                reset: {
                    transformPerspective: 0
                }
            },
            "transition.flipBounceYOut": {
                defaultDuration: 800,
                calls: [ [ {
                    opacity: [ .9, 1 ],
                    transformPerspective: [ 400, 400 ],
                    rotateX: -15
                }, .5 ], [ {
                    opacity: 0,
                    rotateX: 90
                }, .5 ] ],
                reset: {
                    transformPerspective: 0,
                    rotateX: 0
                }
            },
            "transition.swoopIn": {
                defaultDuration: 850,
                calls: [ [ {
                    opacity: [ 1, 0 ],
                    transformOriginX: [ "100%", "50%" ],
                    transformOriginY: [ "100%", "100%" ],
                    scaleX: [ 1, 0 ],
                    scaleY: [ 1, 0 ],
                    translateX: [ 0, -700 ],
                    translateZ: 0
                } ] ],
                reset: {
                    transformOriginX: "50%",
                    transformOriginY: "50%"
                }
            },
            "transition.swoopOut": {
                defaultDuration: 850,
                calls: [ [ {
                    opacity: [ 0, 1 ],
                    transformOriginX: [ "50%", "100%" ],
                    transformOriginY: [ "100%", "100%" ],
                    scaleX: 0,
                    scaleY: 0,
                    translateX: -700,
                    translateZ: 0
                } ] ],
                reset: {
                    transformOriginX: "50%",
                    transformOriginY: "50%",
                    scaleX: 1,
                    scaleY: 1,
                    translateX: 0
                }
            },
            "transition.whirlIn": {
                defaultDuration: 850,
                calls: [ [ {
                    opacity: [ 1, 0 ],
                    transformOriginX: [ "50%", "50%" ],
                    transformOriginY: [ "50%", "50%" ],
                    scaleX: [ 1, 0 ],
                    scaleY: [ 1, 0 ],
                    rotateY: [ 0, 160 ]
                }, 1, {
                    easing: "easeInOutSine"
                } ] ]
            },
            "transition.whirlOut": {
                defaultDuration: 750,
                calls: [ [ {
                    opacity: [ 0, "easeInOutQuint", 1 ],
                    transformOriginX: [ "50%", "50%" ],
                    transformOriginY: [ "50%", "50%" ],
                    scaleX: 0,
                    scaleY: 0,
                    rotateY: 160
                }, 1, {
                    easing: "swing"
                } ] ],
                reset: {
                    scaleX: 1,
                    scaleY: 1,
                    rotateY: 0
                }
            },
            "transition.shrinkIn": {
                defaultDuration: 750,
                calls: [ [ {
                    opacity: [ 1, 0 ],
                    transformOriginX: [ "50%", "50%" ],
                    transformOriginY: [ "50%", "50%" ],
                    scaleX: [ 1, 1.5 ],
                    scaleY: [ 1, 1.5 ],
                    translateZ: 0
                } ] ]
            },
            "transition.shrinkOut": {
                defaultDuration: 600,
                calls: [ [ {
                    opacity: [ 0, 1 ],
                    transformOriginX: [ "50%", "50%" ],
                    transformOriginY: [ "50%", "50%" ],
                    scaleX: 1.3,
                    scaleY: 1.3,
                    translateZ: 0
                } ] ],
                reset: {
                    scaleX: 1,
                    scaleY: 1
                }
            },
            "transition.expandIn": {
                defaultDuration: 700,
                calls: [ [ {
                    opacity: [ 1, 0 ],
                    transformOriginX: [ "50%", "50%" ],
                    transformOriginY: [ "50%", "50%" ],
                    scaleX: [ 1, .625 ],
                    scaleY: [ 1, .625 ],
                    translateZ: 0
                } ] ]
            },
            "transition.expandOut": {
                defaultDuration: 700,
                calls: [ [ {
                    opacity: [ 0, 1 ],
                    transformOriginX: [ "50%", "50%" ],
                    transformOriginY: [ "50%", "50%" ],
                    scaleX: .5,
                    scaleY: .5,
                    translateZ: 0
                } ] ],
                reset: {
                    scaleX: 1,
                    scaleY: 1
                }
            },
            "transition.bounceIn": {
                defaultDuration: 800,
                calls: [ [ {
                    opacity: [ 1, 0 ],
                    scaleX: [ 1.05, .3 ],
                    scaleY: [ 1.05, .3 ]
                }, .4 ], [ {
                    scaleX: .9,
                    scaleY: .9,
                    translateZ: 0
                }, .2 ], [ {
                    scaleX: 1,
                    scaleY: 1
                }, .5 ] ]
            },
            "transition.bounceOut": {
                defaultDuration: 800,
                calls: [ [ {
                    scaleX: .95,
                    scaleY: .95
                }, .35 ], [ {
                    scaleX: 1.1,
                    scaleY: 1.1,
                    translateZ: 0
                }, .35 ], [ {
                    opacity: [ 0, 1 ],
                    scaleX: .3,
                    scaleY: .3
                }, .3 ] ],
                reset: {
                    scaleX: 1,
                    scaleY: 1
                }
            },
            "transition.bounceUpIn": {
                defaultDuration: 800,
                calls: [ [ {
                    opacity: [ 1, 0 ],
                    translateY: [ -30, 1e3 ]
                }, .6, {
                    easing: "easeOutCirc"
                } ], [ {
                    translateY: 10
                }, .2 ], [ {
                    translateY: 0
                }, .2 ] ]
            },
            "transition.bounceUpOut": {
                defaultDuration: 1e3,
                calls: [ [ {
                    translateY: 20
                }, .2 ], [ {
                    opacity: [ 0, "easeInCirc", 1 ],
                    translateY: -1e3
                }, .8 ] ],
                reset: {
                    translateY: 0
                }
            },
            "transition.bounceDownIn": {
                defaultDuration: 800,
                calls: [ [ {
                    opacity: [ 1, 0 ],
                    translateY: [ 30, -1e3 ]
                }, .6, {
                    easing: "easeOutCirc"
                } ], [ {
                    translateY: -10
                }, .2 ], [ {
                    translateY: 0
                }, .2 ] ]
            },
            "transition.bounceDownOut": {
                defaultDuration: 1e3,
                calls: [ [ {
                    translateY: -20
                }, .2 ], [ {
                    opacity: [ 0, "easeInCirc", 1 ],
                    translateY: 1e3
                }, .8 ] ],
                reset: {
                    translateY: 0
                }
            },
            "transition.bounceLeftIn": {
                defaultDuration: 750,
                calls: [ [ {
                    opacity: [ 1, 0 ],
                    translateX: [ 30, -1250 ]
                }, .6, {
                    easing: "easeOutCirc"
                } ], [ {
                    translateX: -10
                }, .2 ], [ {
                    translateX: 0
                }, .2 ] ]
            },
            "transition.bounceLeftOut": {
                defaultDuration: 750,
                calls: [ [ {
                    translateX: 30
                }, .2 ], [ {
                    opacity: [ 0, "easeInCirc", 1 ],
                    translateX: -1250
                }, .8 ] ],
                reset: {
                    translateX: 0
                }
            },
            "transition.bounceRightIn": {
                defaultDuration: 750,
                calls: [ [ {
                    opacity: [ 1, 0 ],
                    translateX: [ -30, 1250 ]
                }, .6, {
                    easing: "easeOutCirc"
                } ], [ {
                    translateX: 10
                }, .2 ], [ {
                    translateX: 0
                }, .2 ] ]
            },
            "transition.bounceRightOut": {
                defaultDuration: 750,
                calls: [ [ {
                    translateX: -30
                }, .2 ], [ {
                    opacity: [ 0, "easeInCirc", 1 ],
                    translateX: 1250
                }, .8 ] ],
                reset: {
                    translateX: 0
                }
            },
            "transition.slideUpIn": {
                defaultDuration: 900,
                calls: [ [ {
                    opacity: [ 1, 0 ],
                    translateY: [ 0, 20 ],
                    translateZ: 0
                } ] ]
            },
            "transition.slideUpOut": {
                defaultDuration: 900,
                calls: [ [ {
                    opacity: [ 0, 1 ],
                    translateY: -20,
                    translateZ: 0
                } ] ],
                reset: {
                    translateY: 0
                }
            },
            "transition.slideDownIn": {
                defaultDuration: 900,
                calls: [ [ {
                    opacity: [ 1, 0 ],
                    translateY: [ 0, -20 ],
                    translateZ: 0
                } ] ]
            },
            "transition.slideDownOut": {
                defaultDuration: 900,
                calls: [ [ {
                    opacity: [ 0, 1 ],
                    translateY: 20,
                    translateZ: 0
                } ] ],
                reset: {
                    translateY: 0
                }
            },
            "transition.slideLeftIn": {
                defaultDuration: 1e3,
                calls: [ [ {
                    opacity: [ 1, 0 ],
                    translateX: [ 0, -20 ],
                    translateZ: 0
                } ] ]
            },
            "transition.slideLeftOut": {
                defaultDuration: 1050,
                calls: [ [ {
                    opacity: [ 0, 1 ],
                    translateX: -20,
                    translateZ: 0
                } ] ],
                reset: {
                    translateX: 0
                }
            },
            "transition.slideRightIn": {
                defaultDuration: 1e3,
                calls: [ [ {
                    opacity: [ 1, 0 ],
                    translateX: [ 0, 20 ],
                    translateZ: 0
                } ] ]
            },
            "transition.slideRightOut": {
                defaultDuration: 1050,
                calls: [ [ {
                    opacity: [ 0, 1 ],
                    translateX: 20,
                    translateZ: 0
                } ] ],
                reset: {
                    translateX: 0
                }
            },
            "transition.slideUpBigIn": {
                defaultDuration: 850,
                calls: [ [ {
                    opacity: [ 1, 0 ],
                    translateY: [ 0, 75 ],
                    translateZ: 0
                } ] ]
            },
            "transition.slideUpBigOut": {
                defaultDuration: 800,
                calls: [ [ {
                    opacity: [ 0, 1 ],
                    translateY: -75,
                    translateZ: 0
                } ] ],
                reset: {
                    translateY: 0
                }
            },
            "transition.slideDownBigIn": {
                defaultDuration: 850,
                calls: [ [ {
                    opacity: [ 1, 0 ],
                    translateY: [ 0, -75 ],
                    translateZ: 0
                } ] ]
            },
            "transition.slideDownBigOut": {
                defaultDuration: 800,
                calls: [ [ {
                    opacity: [ 0, 1 ],
                    translateY: 75,
                    translateZ: 0
                } ] ],
                reset: {
                    translateY: 0
                }
            },
            "transition.slideLeftBigIn": {
                defaultDuration: 800,
                calls: [ [ {
                    opacity: [ 1, 0 ],
                    translateX: [ 0, -75 ],
                    translateZ: 0
                } ] ]
            },
            "transition.slideLeftBigOut": {
                defaultDuration: 750,
                calls: [ [ {
                    opacity: [ 0, 1 ],
                    translateX: -75,
                    translateZ: 0
                } ] ],
                reset: {
                    translateX: 0
                }
            },
            "transition.slideRightBigIn": {
                defaultDuration: 800,
                calls: [ [ {
                    opacity: [ 1, 0 ],
                    translateX: [ 0, 75 ],
                    translateZ: 0
                } ] ]
            },
            "transition.slideRightBigOut": {
                defaultDuration: 750,
                calls: [ [ {
                    opacity: [ 0, 1 ],
                    translateX: 75,
                    translateZ: 0
                } ] ],
                reset: {
                    translateX: 0
                }
            },
            "transition.perspectiveUpIn": {
                defaultDuration: 800,
                calls: [ [ {
                    opacity: [ 1, 0 ],
                    transformPerspective: [ 800, 800 ],
                    transformOriginX: [ 0, 0 ],
                    transformOriginY: [ "100%", "100%" ],
                    rotateX: [ 0, -180 ]
                } ] ],
                reset: {
                    transformPerspective: 0,
                    transformOriginX: "50%",
                    transformOriginY: "50%"
                }
            },
            "transition.perspectiveUpOut": {
                defaultDuration: 850,
                calls: [ [ {
                    opacity: [ 0, 1 ],
                    transformPerspective: [ 800, 800 ],
                    transformOriginX: [ 0, 0 ],
                    transformOriginY: [ "100%", "100%" ],
                    rotateX: -180
                } ] ],
                reset: {
                    transformPerspective: 0,
                    transformOriginX: "50%",
                    transformOriginY: "50%",
                    rotateX: 0
                }
            },
            "transition.perspectiveDownIn": {
                defaultDuration: 800,
                calls: [ [ {
                    opacity: [ 1, 0 ],
                    transformPerspective: [ 800, 800 ],
                    transformOriginX: [ 0, 0 ],
                    transformOriginY: [ 0, 0 ],
                    rotateX: [ 0, 180 ]
                } ] ],
                reset: {
                    transformPerspective: 0,
                    transformOriginX: "50%",
                    transformOriginY: "50%"
                }
            },
            "transition.perspectiveDownOut": {
                defaultDuration: 850,
                calls: [ [ {
                    opacity: [ 0, 1 ],
                    transformPerspective: [ 800, 800 ],
                    transformOriginX: [ 0, 0 ],
                    transformOriginY: [ 0, 0 ],
                    rotateX: 180
                } ] ],
                reset: {
                    transformPerspective: 0,
                    transformOriginX: "50%",
                    transformOriginY: "50%",
                    rotateX: 0
                }
            },
            "transition.perspectiveLeftIn": {
                defaultDuration: 950,
                calls: [ [ {
                    opacity: [ 1, 0 ],
                    transformPerspective: [ 2e3, 2e3 ],
                    transformOriginX: [ 0, 0 ],
                    transformOriginY: [ 0, 0 ],
                    rotateY: [ 0, -180 ]
                } ] ],
                reset: {
                    transformPerspective: 0,
                    transformOriginX: "50%",
                    transformOriginY: "50%"
                }
            },
            "transition.perspectiveLeftOut": {
                defaultDuration: 950,
                calls: [ [ {
                    opacity: [ 0, 1 ],
                    transformPerspective: [ 2e3, 2e3 ],
                    transformOriginX: [ 0, 0 ],
                    transformOriginY: [ 0, 0 ],
                    rotateY: -180
                } ] ],
                reset: {
                    transformPerspective: 0,
                    transformOriginX: "50%",
                    transformOriginY: "50%",
                    rotateY: 0
                }
            },
            "transition.perspectiveRightIn": {
                defaultDuration: 950,
                calls: [ [ {
                    opacity: [ 1, 0 ],
                    transformPerspective: [ 2e3, 2e3 ],
                    transformOriginX: [ "100%", "100%" ],
                    transformOriginY: [ 0, 0 ],
                    rotateY: [ 0, 180 ]
                } ] ],
                reset: {
                    transformPerspective: 0,
                    transformOriginX: "50%",
                    transformOriginY: "50%"
                }
            },
            "transition.perspectiveRightOut": {
                defaultDuration: 950,
                calls: [ [ {
                    opacity: [ 0, 1 ],
                    transformPerspective: [ 2e3, 2e3 ],
                    transformOriginX: [ "100%", "100%" ],
                    transformOriginY: [ 0, 0 ],
                    rotateY: 180
                } ] ],
                reset: {
                    transformPerspective: 0,
                    transformOriginX: "50%",
                    transformOriginY: "50%",
                    rotateY: 0
                }
            }
        };
        for (var effectName in Velocity.RegisterEffect.packagedEffects) {
            Velocity.RegisterEffect(effectName, Velocity.RegisterEffect.packagedEffects[effectName]);
        }
        Velocity.RunSequence = function(originalSequence) {
            var sequence = $.extend(true, [], originalSequence);
            if (sequence.length > 1) {
                $.each(sequence.reverse(), function(i, currentCall) {
                    var nextCall = sequence[i + 1];
                    if (nextCall) {
                        var currentCallOptions = currentCall.o || currentCall.options, nextCallOptions = nextCall.o || nextCall.options;
                        var timing = currentCallOptions && currentCallOptions.sequenceQueue === false ? "begin" : "complete", callbackOriginal = nextCallOptions && nextCallOptions[timing], options = {};
                        options[timing] = function() {
                            var nextCallElements = nextCall.e || nextCall.elements;
                            var elements = nextCallElements.nodeType ? [ nextCallElements ] : nextCallElements;
                            callbackOriginal && callbackOriginal.call(elements, elements);
                            Velocity(currentCall);
                        };
                        if (nextCall.o) {
                            nextCall.o = $.extend({}, nextCallOptions, options);
                        } else {
                            nextCall.options = $.extend({}, nextCallOptions, options);
                        }
                    }
                });
                sequence.reverse();
            }
            Velocity(sequence[0]);
        };
    }(window.jQuery || window.Zepto || window, window, document);
});

$(function() {
    $("body").on("hidden.bs.popover", function(e) {
        $(e.target).data("bs.popover").inState.click = false;
    });
    $("body").tooltip({
        selector: 'a[rel="tooltip"], [data-toggle="tooltip"]',
        container: "body"
    });
    $("body").on("click", function(e) {
        $('[popover], [data-toggle="popover"]').each(function() {
            if (!$(this).is(e.target) && $(this).has(e.target).length === 0 && $(".popover").has(e.target).length === 0) {
                $(this).popover("hide");
            }
        });
    });
    $("body").on("click", ".dropdown-filter .dropdown-menu", function(e) {
        e.stopPropagation();
    });
    $(document).on("keypress.bs.collapse.data-api", "[data-toggle=collapse]", function(e) {
        if (e.which == 13 || e.which == 32) {
            var $this = $(this), href;
            var target = $this.attr("data-target") || e.preventDefault() || (href = $this.attr("href")) && href.replace(/.*(?=#[^\s]+$)/, "");
            var $target = $(target);
            var data = $target.data("bs.collapse");
            var option = data ? "toggle" : $this.data();
            var parent = $this.attr("data-parent");
            var $parent = parent && $(parent);
            if (!data || !data.transitioning) {
                if ($parent) $parent.find('[data-toggle=collapse][data-parent="' + parent + '"]').not($this).addClass("collapsed");
                $this[$target.hasClass("in") ? "addClass" : "removeClass"]("collapsed");
            }
            $target.collapse(option);
        }
    });
    $(document).on("shown.bs.tab", function(e) {
        window.setTimeout(function() {
            $(window).trigger("resize");
        }, 500);
    });
    $(document).on("shown.bs.collapse", function(e) {
        window.setTimeout(function() {
            $(window).trigger("resize");
        }, 500);
    });
    $(document).on("hidden.bs.collapse", function(e) {
        window.setTimeout(function() {
            $(window).trigger("resize");
        }, 500);
    });
    $(document).on("show.bs.popover", function(e) {
        $('[data-toggle="popover"][data-trigger="hover"]').not(e.target).popover("hide");
    });
    $(document).on("shown.bs.popover", function(e) {
        $(".popover .close").on("click", function() {
            $(e.target).popover("hide");
        });
    });
    var originalLeave = $.fn.popover.Constructor.prototype.leave;
    $.fn.popover.Constructor.prototype.leave = function(obj) {
        var self = obj instanceof this.constructor ? obj : $(obj.currentTarget)[this.type](this.getDelegateOptions()).data("bs." + this.type);
        var container, timeout;
        originalLeave.call(this, obj);
        if (self.$tip && self.$tip.length) {
            container = self.$tip;
            timeout = self.timeout;
            container.one("mouseenter", function() {
                clearTimeout(timeout);
                container.one("mouseleave", function() {
                    $.fn.popover.Constructor.prototype.leave.call(self, self);
                });
            });
        }
    };
    var addClass = $.fn.addClass;
    $.fn.addClass = function(value) {
        var orig = addClass.apply(this, arguments);
        var elem, i = 0, len = this.length;
        for (;i < len; i++) {
            elem = this[i];
            if (elem instanceof SVGElement) {
                var classes = $(elem).attr("class");
                if (classes) {
                    var index = classes.indexOf(value);
                    if (index === -1) {
                        classes = classes + " " + value;
                        $(elem).attr("class", classes);
                    }
                } else {
                    $(elem).attr("class", value);
                }
            }
        }
        return orig;
    };
    var removeClass = $.fn.removeClass;
    $.fn.removeClass = function(value) {
        var orig = removeClass.apply(this, arguments);
        var elem, i = 0, len = this.length;
        for (;i < len; i++) {
            elem = this[i];
            if (elem instanceof SVGElement) {
                var classes = $(elem).attr("class");
                if (classes) {
                    var index = classes.indexOf(value);
                    if (index !== -1) {
                        classes = classes.substring(0, index) + classes.substring(index + value.length, classes.length);
                        $(elem).attr("class", classes);
                    }
                }
            }
        }
        return orig;
    };
    var hasClass = $.fn.hasClass;
    $.fn.hasClass = function(value) {
        var orig = hasClass.apply(this, arguments);
        var elem, i = 0, len = this.length;
        for (;i < len; i++) {
            elem = this[i];
            if (elem instanceof SVGElement) {
                var classes = $(elem).attr("class");
                if (classes) {
                    if (classes.indexOf(value) === -1) {
                        return false;
                    } else {
                        return true;
                    }
                } else {
                    return false;
                }
            }
        }
        return orig;
    };
});
